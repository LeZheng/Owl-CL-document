# 1. 引言

> * 1.1 [适用范围, 目的, 和历史](#ScopePurposeAndHistory)
> * 1.2 [文档的组织结构](#OrganizationOfTheDocument)
> * 1.3 [参考的出版物](#ReferencedPublications)
> * 1.4 [定义](#Definitions)
> * 1.5 [规范性](#Conformance)
> * 1.6 [语言的扩展](#LanguageExtensions)
> * 1.7 [语言的子集](#LanguageSubsets)
> * 1.8 [弃用的语言特性](#DeprecatedLanguageFeatures)
> * 1.9 [COMMON-LISP 包中的符号](#SymbolsInTheCOMMON-LISPPackage)

## 1.1 <span id = "ScopePurposeAndHistory">适用范围, 目的, 和历史</span>

### 1.1.1 适用范围和目的

这个文档中提出的规范旨在促进 Common Lisp 程序在各种数据处理系统之间的移植性. 这是一份面向实现者和博学的程序员的语言说明书. 它既不是教程也不是一个实现指南.

### 1.1.2 历史

Lisp 是一个有悠久历史的语言家族. 早期的 Lisp 中的关键思想是 John McCarthy 在 1956 Dartmouth 人工智能夏季研究项目中开发出来的. McCarthy 的动机是去开发一个用于人工智能工作的代数列表处理语言. 早期 Lisp 方言的实现着手于 IBM 704, IBM 7090, Digital Equipment Corporation (DEC) PDP-1,  DEC PDP-6, 以及 PDP-10. 在 1960 到 1965 主要的 Lisp 方言是 Lisp 1.5. 直到20世纪70年代早期出现了两个得益于早先努力占主导地位的 Lisp 方言: MacLisp 和 Interlisp. 关于早期Lisp方言的更多信息, 见 《The Anatomy of Lisp》 或者 《Lisp 1.5 Programmer's Manual》.

MacLisp 对 Lisp 1.5 特殊变量和错误处理进行改进. MacLisp 也引入了可以接受可变数量参数的函数, 宏, 数组, 非局部动态退出, 快速计算, 第一个好的 Lisp 编译器, 还有突出的运行速度. 直到20世纪70年代末, MacLisp 被用于超过 50 个网站. 关于 Maclisp 的进一步信息, 见《Maclisp Reference Manual, Revision 0》或《The Revised Maclisp Manual》.

Interlisp 提出了很多关于 Lisp 编程环境和方法论的理念. 其中一个影响了 Common Lisp 的理念就是 Warren Teitelman 实现的循环结构, 这个启发了后面 Lisp Machines 和 MacLisp, 以及现在的 Common Lisp 的 loop 宏. 关于 Interlisp 的进一步信息, 见《Interlisp Reference Manual》.

虽然第一个 Lisp 实现是在 IBM 704 和 IBM 7090 上, 后来的工作聚焦于 DEC PDP-6 以及后来的 PDP-10 计算机, 再后来从20世纪60年代中期到70年代的大部分时间成为 Lisp 和人工智能工作的支柱的是像 Massachusetts Institute of Technology (MIT), Stanford University, 还有 Carnegie Mellon University (CMU) 这样的地方. 这个 PDP-10 计算机和它的前辈 PDP-6 计算机被设计为特别适合于Lisp因为它们有36位的字以及18位的地址. 这个结构允许一个 cons 序对存储在一个字里; 单个指令可以解出 car 和 cdr 部分. 这个 PDP-6 和 PDP-10 拥有快速强大的栈指令可以快速的进行函数调用. 但是到1973年 PDP-10 的局限也是明显的: 它支持很少数量的研究者使用Lisp, 并且这个小的 18 位地址空间 (2^18 = 262,144 字) 限制了单个程序大小. 对于地址空间问题的一个解决方案是 Lisp Machine, 一种特殊目的计算机被设计用于运行Lisp程序. 另外一种回答就是使用带有更大地址空间的通用目的计算机, 就像 DEC VAX 还有S-1 Mark IIA. 关于 S-1 Common Lisp 的更多信息, 见 "S-1 Common Lisp Implementation".

这个 Lisp machine 概念发展于20世纪60年代末期. 在20世纪70年代早期, 和 Daniel Bobrow 一起工作的 Peter Deutsch 在个人迷你计算机 Alto 上实现了一个Lisp, 使用微代码来解释一个字节码实现语言. 在那以后不久,在 MIT 的 Richard Greenblatt 开始着手一个不同的硬件和指令集的设计. 虽然作为 Lisp machine 来说 Alto 并不是完全的成功, 但是在 Xerox 开发的 D-series 机器上一个 Interlisp 的方言 Interlisp-D 变得可用. 在早期的 MIT Lisp Machines 上一个称为 Lisp Machine Lisp 的向上兼容的 MacLisp 延伸变得可用. 到了1981年, 来自于 Xerox, Lisp Machines (LMI), 和 Symbolics 的商用 Lisp Machine 出现在市场上. 关于 Lisp Machine Lisp 的更多信息, 见《Lisp Machine Manual》.

在20世纪70年代末期, Lisp Machine Lisp 开始朝向一个更完整的语言发展. 久经考验的 lambda 列表, setf, 多值, 以及像 Common Lisp 中的结构体是 Lisp Machine 组的早期编程风格试验的结果. Jonl White 还有其他人将这些特点移植到 MacLisp. 大约 1980, Scott Fahlman 和在 CMU 的其他人开始致力于一个运行在 Scientific Personal Integrated Computing Environment (SPICE) 工作站的 Lisp. 这个工程的其中一个目标就是去设计一个比 Lisp Machine Lisp 更简单的方言.

MIT 的 Macsyma 小组在20世纪70年代末期开始了一个项目, 称为 New Implementation of Lisp (NIL) for the VAX, 由 White 领导. 这个 NIL 工程的其中一个定期目标是在保留和 MacLisp 的兼容性的同时去修复一些 Lisp 的历史遗留问题. 同时, 一个 Stanford University 的研究小组以及 Richard P. Gabriel 领导的劳伦斯利物莫国家实验室开始了运行于 S-1 Mark IIA 超级计算机之上的 Lisp. S-1 Lisp 的设计, 它具有不完全的功能, 是为 Lisp 的具体实现适配先进的编译器技术的测试点. 最终这个 S-1 和 NIL 小组合作. 关于 NIL 工程的更多信息, 见 "NIL---A Perspective".

第一个朝向 Lisp 标准化的尝试是在1969年, 那时 Anthony Hearn 和 University of Utah 的 Martin Griss 定义了标准 Lisp ---是一个 Lisp 1.5 和其他方言的子集---来迁移 REDUCE, 一个符号化的代数系统. 在20世纪70年代, 这个 Utah 小组首先为标准 Lisp 实现了一个可重定向编译的优化编译器, 并且还有一个被认为是Portable Standard Lisp (PSL) 的扩展实现. 直到20世纪80年代中期, PSL 运行在十多种计算机上. 关于标准 Lisp 的更多信息, 见 "Standard LISP Report".

PSL 和 Franz Lisp ---是 Unix 机器上的类 MacLisp 方言---是第一个在多种硬件平台广泛可用的 Lisp 方言的例子.

Lisp 的其中一个最重要的发展是在20世纪70年代后半期: Scheme. Scheme, 是 Gerald J. Sussman 和 Guy L. Steele Jr 设计, 是一个简洁的 Lisp 方言, 从20世纪60年代以来这里面的设计带给 Lisp 很多编程语言语义上的理念. Sussman 是20世纪60年代末到70年代很多 Lisp 技术其他进展背后主要创新点之一. Scheme 主要的贡献是词法作用域, 词法闭包, 一阶连续性(first-class continuations), 还有简单的语法 (没有区分值 cell 和 函数 cell). 这些贡献中很多对Common Lisp的设计产生了很大影响. 关于Scheme的更多信息, 见《IEEE Standard for the Scheme Programming Language》或者 "Revised^3 Report on the Algorithmic Language Scheme".

在20世纪70年代末期,面向对象编程概念对 Lisp 产生了很大影响. 在 MIT, 来自于 Smalltalk 的思想径直进入很多广泛使用的编程系统中. Flavors, 一个带有多继承的面向对象系统, 为了 Lisp machine 社区在 MIT 被 Howard Cannon 和其他人开发出来. 在 Xerox, Smalltalk 的经验和 Knowledge Representation Language (KRL) 引导了 Lisp Object Oriented Programming System (LOOPS) 还有后来的 Common LOOPS 的发展. 关于 Smalltalk 的进一步的信息, 见《Smalltalk-80: The Language and its Implementation》. 关于 Flavors 更多信息, 见《Flavors: A Non-Hierarchical Approach to Object-Oriented Programming》.

这些系统影响了 Common Lisp Object System (CLOS) 的设计. CLOS 是为了这个标准化工作特地开发的, 并且详细记载在了 "Common Lisp Object System Specification". 然而, 在公布之后它的设计中小部分细节有了轻微的改变, 并且就像这个文档中所说, 这个文章不应该被当作一份这个对象系统语义上的官方说明.

在 1980 年 Symbolics 和 LMI 开发 Lisp Machine Lisp; stock-hardware 实现小组开发 NIL, Franz Lisp, 还有 PSL; Xerox 开发 Interlisp; 还有 CMU 的 SPICE 项目开发称之为 SpiceLisp 的类 MacLisp 方言.

在1981年四月, 在一个 DARPA 赞助的会议后, 分裂的 Lisp 社区, Symbolics, SPICE 项目, NIL 项目, 还有 S-1 Lisp 项目一起加入来定义 Common Lisp. 开始由 White 和 Gabriel 带领, 这个基层工作背后的驱动力由 Fahlman, Daniel Weinreb, David Moon, Steele, 和 Gabriel 提供. Common Lisp 被设计为一个家族语言的描述. 对于 Common Lisp 主要的影响是 Lisp Machine Lisp, MacLisp, NIL, S-1 Lisp, Spice Lisp, 还有 Scheme. 《Common Lisp: The Language》是这个设计的描述. 部分地方它的语义是有意未指定的, 因为那里感觉严格规范会限制 Common Lisp 的研究和使用.

在1986年 X3J13 被组织为一个技术小组去起草 ANSI Common Lisp 标准. 由于 Common Lisp 的接纳, 这个小组的目标与最初的设计者不同. 这些目标包括更严格的移植性标准化, 一个面向对象编程系统, 一个状态系统, 循环机制, 以及一种处理大型字符集的方式. 为了促成这个目标, 一个新的语言说明(这个文档)被开发出来.

## 1.2 <span id = "OrganizationOfTheDocument">文档的组织结构</span>

这是一份参考文档, 不是一份教程文档. 为了尽可能方便, 这个报告的顺序是原始主题在前, 构建于它们之上的在后; 然而, 线性的可读性并不是值得优先考虑的.

这个文档根据主题来拆分章节. 任何给定章节可能包含概念性内容或字典条目, 或者都有.

一个章节中的字典部分把主题相关的已定义的名字[defined name]分组后放得接近一些. 很多这样的分组可能并且不应该从分组中推断出的深层意义, 都是表面意思. 为了看到以字母顺序排列分组的已定义的名字[defined name], 可以查阅索引. 关于已定义名字[defined name]的完整列表, 见章节 1.9 (COMMON-LISP 包中的符号).

为了补偿这份文档的无序部分, 提供一份词汇表; 见章节 26 (术语). 这个词汇表通过快速访问术语的定义来提供连通性,并且一些情况下提供示例或者和另外概念的交叉引用.

关于这个文档中符号规约的内容, 见章节 1.4 (定义).

关于规范性的内容, 见章节 1.5 (规范性).

关于扩展和子集的内容, 见章节 1.6 (语言的扩展) 和章节 1.7 (语言的子集).

关于这个语言的程序[program]如何被 Lisp 读取器[Lisp reader]解析, 见章节 2 (语法).

关于这个语言的程序[program]如何被编译和执行, 见章节 3 (编译和求值).

关于数据类型的内容, 见章节 4 (类型和类). 不是所有的类型[type]和类(class)都被定义在这个章节; 很多定义在它们主题对应的章节--比如, 数值类型定义在了章节 12 (数字). 关于标准化[standardized]类型[type]的完整列表, 见 Figure 4-2.

关于常用目的控制和数据流, 见章节 5 (数据和控制流) 或章节 6 (循环).

## 1.3 <span id = "ReferencedPublications">参考的出版物</span>

* The Anatomy of Lisp, John Allen, McGraw-Hill, Inc., 1978.

* The Art of Computer Programming, Volume 3, Donald E. Knuth, Addison-Wesley Company (Reading, MA), 1973.

* The Art of the Metaobject Protocol, Kiczales et al., MIT Press (Cambridge, MA), 1991.

* "Common Lisp Object System Specification", D. Bobrow, L. DiMichiel, R.P. Gabriel, S. Keene, G. Kiczales, D. Moon, SIGPLAN Notices V23, September, 1988.

* Common Lisp: The Language, Guy L. Steele Jr., Digital Press (Burlington, MA), 1984.

* Common Lisp: The Language, Second Edition, Guy L. Steele Jr., Digital Press (Bedford, MA), 1990.

* Exceptional Situations in Lisp, Kent M. Pitman, Proceedings of the First European Conference on the Practical Application of LISP (EUROPAL '90), Churchill College, Cambridge, England, March 27-29, 1990.

* Flavors: A Non-Hierarchical Approach to Object-Oriented Programming, Howard I. Cannon, 1982.

* IEEE Standard for Binary Floating-Point Arithmetic, ANSI/IEEE Std 754-1985, Institute of Electrical and Electronics Engineers, Inc. (New York), 1985.

* IEEE Standard for the Scheme Programming Language, IEEE Std 1178-1990, Institute of Electrical and Electronic Engineers, Inc. (New York), 1991.

* Interlisp Reference Manual, Third Revision, Teitelman, Warren, et al, Xerox Palo Alto Research Center (Palo Alto, CA), 1978.

* ISO 6937/2, Information processing---Coded character sets for text communication---Part 2: Latin alphabetic and non-alphabetic graphic characters, ISO, 1983.

* Lisp 1.5 Programmer's Manual, John McCarthy, MIT Press (Cambridge, MA), August, 1962.

* Lisp Machine Manual, D.L. Weinreb and D.A. Moon, Artificial Intelligence Laboratory, MIT (Cambridge, MA), July, 1981.

* Maclisp Reference Manual, Revision 0, David A. Moon, Project MAC (Laboratory for Computer Science), MIT (Cambridge, MA), March, 1974.

* "NIL---A Perspective", JonL White, Macsyma User's Conference, 1979.

* Performance and Evaluation of Lisp Programs, Richard P. Gabriel, MIT Press (Cambridge, MA), 1985.

* "Principal Values and Branch Cuts in Complex APL", Paul Penfield Jr., APL 81 Conference Proceedings, ACM SIGAPL (San Francisco, September 1981), 248-256. Proceedings published as APL Quote Quad 12, 1 (September 1981).

* The Revised Maclisp Manual, Kent M. Pitman, Technical Report 295, Laboratory for Computer Science, MIT (Cambridge, MA), May 1983.

* "Revised^3 Report on the Algorithmic Language Scheme", Jonathan Rees and William Clinger (editors), SIGPLAN Notices V21, #12, December, 1986.

* "S-1 Common Lisp Implementation", R.A. Brooks, R.P. Gabriel, and G.L. Steele, Conference Record of the 1982 ACM Symposium on Lisp and Functional Programming, 108-113, 1982.

* Smalltalk-80: The Language and its Implementation, A. Goldberg and D. Robson, Addison-Wesley Company, 1983.

* "Standard LISP Report", J.B. Marti, A.C. Hearn, M.L. Griss, and C. Griss, SIGPLAN Notices V14, #10, October, 1979.

* Webster's Third New International Dictionary the English Language, Unabridged, Merriam Webster (Springfield, MA), 1986.

* XP: A Common Lisp Pretty Printing System, R.C. Waters, Memo 1102a, Artificial Intelligence Laboratory, MIT (Cambridge, MA), September 1989.

## 1.4 <span id = "Definitions">定义</span>

这个章节中包含了这个手册里的符号规约和术语的定义.

> * 1.4.1 [符号规约](#NotationalConventions)
> * 1.4.2 [错误术语](#ErrorTerminology)
> * 1.4.3 [本标准未正式规定的部分](#SectionsNotFormallyPartOfThisStandard)
> * 1.4.4 [解释字典条目](#InterpretingDictionaryEntries)

### 1.4.1 <span id = "NotationalConventions">符号规约</span>

下面的符号规约适用于整个文档.

> * 1.4.1.1 [字体的线索](#FontKey)
> * 1.4.1.2 [修改后的 BNF 语法](#ModifiedBNFSyntax)
> * 1.4.1.3 [特殊符号](#SpecialSymbols)
> * 1.4.1.4 [带有多种表示的对象](#ObjectsWithMultipleNotations)
> * 1.4.1.5 [标识符](#Designators)
> * 1.4.1.6 [无意义的单词](#NonsenseWords)

#### 1.4.1.1 <span id = "FontKey">字体的线索</span>(注意：这个字体在翻译中未体现出来)

在这个文档中使用字体来传递信息.

<u>*name*</u>

    表示定义在术语表中的正式的术语. 如果使用了这个字体, 那么这个术语表中定义优先于正常的英语用法.

    有时候这个术语表的术语会有下标, 就像 "whitespace[2]" (译者注: 这里的单词应该有斜体下划线). 这样的定义从多个术语表定义选择其中一个, 这里是第二个. 这个下标标记法在术语表里通常被使用于那种上下文不足以消除歧义的定义.

<u>*name*</u>

    表示在局部对当前文本引入正式术语. 这里一直有一个对应的术语表条目, 并且通常等价于使用 "name" (译者注: 这里的单词应该有斜体下划线), 但是这使得这个使用更加明显, 可以在一些情况避免读者查阅词汇表.

**name**

    表示一个在 COMMON-LISP 包里的符号. 关于大小写[case]规约的更多内容, 见章节 1.4.1.4.1 (符号案例).

name

    表示一个程序员可能用 Common Lisp 写的简单的名字[name]或代码[code]片段.

    这个字体也被用于某些标准化[standardized]的不是 COMMON-LISP 包的外部符号[external symbol]的名字, 比如关键字[keyword][1], 包[package]名[name], 还有循环关键字[loop keyword].

*name*

    表示一个形参[parameter]或者值[value]的名字.

    有些情况下也使用标记 "<<name>>" (换句话说, 同样的字体, 但是带有 "尖括号" 围绕) 来为包在里面的多个字符提供更好的目视间距. 这些 "尖括号" 是元语法, 并且实际上从不出现在程序的输入输出中.

#### 1.4.1.2 <span id = "ModifiedBNFSyntax">修改后的 BNF 语法</span>

这个规范使用了一个扩展 BNF 范式来描述 Common Lisp 宏表达式形式[macro form]和特殊表达式形式[special form]的语法. 这个章节讨论 BNF 范式的语法.

> * 1.4.1.2.1 [修改后BNF语法的拼接](#SplicingInModifiedBNFSyntax)
> * 1.4.1.2.2 [修改后BNF语法的间接引用](#IndirectionInModifiedBNFSyntax)
> * 1.4.1.2.3 [修改后BNF语法中间接定义的额外使用](#AdditionalUsesForIndirectDef)

##### 1.4.1.2.1 <span id = "SplicingInModifiedBNFSyntax">修改后BNF语法的拼接</span>

使用的主要扩展如下:

```
[[O]]
```

无论何时当一个多元素列表被拼接到一个更大的结构并且元素可以以任何顺序出现的情况下, 就会出现这个形式的表达式. 这个符号 O 表示要被拼接的多个语法元素的语法描述; 这个描述必须以这种形式

```
O1 | ... | Ol
```

其中每一个 Oi 可以是 S 形式或者 S* 形式或者 {S}1 的 形式 . 这个表达式 [[O]] 意味着这样形式的列表

```
(Oi1...Oij) 1<=j
```

被拼接到一个闭合的表达式中, 这样的情况下如果 n /=m 并且 1<=n,m<=j, 就存在 Oin/=Oim 或 Oin = Oim = Qk, 其中 1<=k <=n, Ok 是形式 Qk*. 此外, 对于每一个在结构 {Qk}1 中的 Oin, 这个元素需要出现在拼接后列表的某处.

比如说, 这个表达式

```
(x [[A | B* | C]] y)
```

意味着最多一个 A, 任意数量的 B, 以及最多一个 C 可以以任何顺序出现. 它是以下任意形式的描述:

```Lisp
(x y)
(x B A C y)
(x A B B B B B C y)
(x C B A B B B y)
```

但不是下面这些:

```Lisp
(x B B A A C C y)
(x C B C y)
```

在第一种情况下, 不管 A 还是 C 都出现的太频繁, 而第二个例子中 C 出现得太频繁.

标记法 [[O1 | O2 | ...]]+ 添加额外的限制, 表示至少有一个选项必须被使用. 比如说:

```
(x [[A | B* | C]]+ y)
```

意味着最多一个 A, 任意数量的 B, 并且最多一个 C 以任意顺序出现, 但是在任何情况下至少它们之中的一个选项要满足. 它是以下这些的描述:

```Lisp
(x B y)
(x B A C y)
(x A B B B B B C y)
(x C B A B B B y)
```

但是不是以下这些:

```Lisp
(x y)
(x B B A A C C y)
(x C B C y)
```

在第一个例子中, 没有任何条件满足; 在第二个例子中, A 和 C 都出现得太频繁; 还有在第三个示例中 C 出现得太频繁.

并且, 这个表达式:

```BNF
(x [[{A}1 | {B}1 | C]] y)
```

可以全部表示为这些并且没有其他可能 :

```Lisp
(x A B C y)
(x A C B y)
(x A B y)
(x B A C y)
(x B C A y)
(x B A y)
(x C A B y)
(x C B A y)
```

##### 1.4.1.2.2 <span id = "IndirectionInModifiedBNFSyntax">修改后BNF语法的间接引用</span>

引入一个间接引用的扩展是为了使这种语法可读性更高:

```BNF
O
```

如果 O 不是一个终止符, 它的定义的右边部分会完整地替换表达式 O. 比如, 下面的这个 BNF 表达式等价于上面那个例子:

```BNF
(x [[O]] y)

O::= A | B* | C
```

##### 1.4.1.2.3 <span id = "AdditionalUsesForIndirectDef">修改后BNF语法中间接定义的额外使用</span>

在一些情况下, 一个 BNF 辅助定义可能不会出现在这个 BNF 表达式里, 但是在其他地方是有用的. 比如说, 思考下面的定义:

```BNF
case keyform {normal-clause}* [otherwise-clause] => result*

ccase keyplace {normal-clause}* => result*

ecase keyform {normal-clause}* => result*

normal-clause::= (keys form*)

otherwise-clause::= ({otherwise | t} form*)

clause::= normal-clause | otherwise-clause
```

这里的术语 "clause" 似乎是 "废弃的(dead)" 因为它没有被使用于上面的 BNF 表达式里. 然而, 这个 BNF 的目的并不只是引导解析, 但是也定义有用的术语为了给在后面的描述性文本作参考. 像这个样子, 术语 "clause" 可能出现在后面跟着的文本中, 作为 "normal-clause 或 otherwise-clause" 的速记法.


#### 1.4.1.3 <span id = "SpecialSymbols">特殊符号</span>

这里描述的特殊符号在这个文档中为了概念上的便利, 既不是 Common Lisp 语言也不是它的运行环境的一部分.

=>

    这个表示求值. 比如说:

     (+ 4 5) =>  9

    这个意味着对表达式形式[form] (+ 4 5) 求值的结果是 9.

    如果一个表达式形式[form]返回多值[multiple values], 这些值可能通过空格, 换行或者逗号区分. 比如说:

     (truncate 7 5)
    =>  1 2
     (truncate 7 5)
    =>  1
       2
     (truncate 7 5)
    =>  1, 2

    上面三个表达式的每一个都是等价的, 表示那个 (truncate 7 5) 返回两个值: 1 和 2.

    一些符合规范的实现[conforming implementation]事实上在显示返回值之前打印箭头 (或者一些其他的指示方式), 有一些则没有.

OR=>

    记号 "OR=> " 被用于表示几个可能值的其中一个. 比如

     (char-name #\a)
    =>  NIL
    OR=>  "LOWERCASE-a"
    OR=>  "Small-A"
    OR=>  "LA01"

    表示 nil, "LOWERCASE-a", "Small-A", "LA01" 都是 (char-name #\a) 可能的结果---每一个都有相等的可能性. 除非明确指定, 它不应被认为可能值的集合已经是完整的了. 正常情况下, 上面的例子等价于

     (char-name #\a) =>  implementation-dependent

    但是它旨在提供额外的信息去说明允许实现去发散的一些方式.

NOT=>

    标记 "NOT=> " 用于表示不可能的结果. 这个可能被用于, 比如, 为了强调一种情况, 一些可预见的误解可能引导读者错误地相信这个结果是可能出现的. 比如,

    (function-lambda-expression
        (funcall #'(lambda (x) #'(lambda () x)) nil))
    =>  NIL, true, NIL
    OR=>  (LAMBDA () X), true, NIL
    NOT=>  NIL, false, NIL
    NOT=>  (LAMBDA () X), false, NIL

==

    这个表示代码等价. 比如说:

    (gcd x (gcd y z)) ==  (gcd (gcd x y) z)

    这个意味着对于任意的 x, y, z, 求值表达式 (gcd x (gcd y z)) 的结果和副作用与求值 (gcd (gcd x y) z) 的是一样的.

\>>

    Common Lisp 指定了输入和输出为非交互的流模型. 这个指定了交互式的输入输出流如何映射到非交互的模型的具体详情是具体实现定义的[implementation-defined].

    比如, 允许符合规范的实现[conforming implementation]去区分交互式输入如何中止的问题. 比如, 当最后的定界符被输入到非交互的流中, read 函数[function]中止. 在一些具体实现中, 一个交互式的对 read 的调用在最后的定界符一输入就返回, 甚至那个定界符不是换行符[newline]. 在其他实现[implementation]中, 总是需要一个最后的换行符[newline]. 在其他实现中, 可能会有一个命令去 "激活" 一个满的输入缓冲区, 而这个命令本身在程序输入流中不可见.

    这个文档的例子中, 标记 ">> " 先于交互式输入输出前. 这种方案下, 这个标记表示用户输入.

    比如, 下面的标记

    (+ 1 (print (+ (sqrt (read)) (sqrt (read)))))
    >>  9 16
    >>  7
    =>  8

    展示一个交互, 其中要被求值的是表达式形式[form] "(+ 1 (print (+ (sqrt (read)) (sqrt (read)))))", "9 16 " 是交互是输入, "7" 是交互的输出, 然后 "8" 是求值(evaluation)后产生的值[value].

    这个标记的使用是为了掩盖各个实现[implementation]之间交互式输入输出行为的微小区别.

    有时, 非交互的流模型需要换行符[newline]. 换行符[newline]如何被交互式输入是用户接口的实现定义的[implementation-defined]细节, 但是在那个例子中, 可能会被使用的不是 "<Newline>" 就是 "<NEWLINE>".

     (progn (format t "~&Who? ") (read-line))
    >>  Who? Fred, Mary, and Sally<NEWLINE>
    =>  "Fred, Mary, and Sally", false

#### 1.4.1.4 <span id = "ObjectsWithMultipleNotations">带有多种表示的对象</span>

Common Lisp 中的一些对象[object]不止一种表示的方法. 这种情况下, 选择使用哪一种是随意的, 但是表示一个 "视角(point of view)" 或 "意向感(sense of intent)" 的规约是存在的.

> * 1.4.1.4.1 [符号大小写](#CaseInSymbols)
> * 1.4.1.4.2 [数字](#Numbers)
> * 1.4.1.4.3 [点字符的使用](#DotCharacterUse)
> * 1.4.1.4.4 [NIL](#NIL)

##### 1.4.1.4.1 <span id = "CaseInSymbols">符号大小写</span>

虽然捕捉一个符号[symbol]的过程中大小写[case]是很重要的, 但是 Lisp 读取器[Lisp reader]默认在捕捉前会尝试去规范符号[symbol]; 见章节 23.1.2 (Lisp 读取器上的读取表大小写的影响). 既然如此, 符号的大小写默认是不重要的. 这个文档自始自终, 除了明确指定外, 符号[symbol]的大小写是不重要的; 也就是说, HELLO, Hello, hElLo, 还有 hello 都是表示 "HELLO" 符号的等价方法.

反斜线符号[backslash]和竖线符号[vertical-bar]被用于显式引用大小写[case]还有其他解析相关的字符方面. 即便如此, 标记法 |hello| 和 \h\e\l\l\o 是表示 "hello" 符号的等价方式, 并且明显不同[distinct]于符号 "HELLO".

符号[symbol]对应的 Common Lisp 已定义的名字[defined name]已经大写化[uppercase]了, 即便它们的名字通常以小写[lowercase]的方式出现在文档里.

##### 1.4.1.4.2 <span id = "Numbers">数字</span>

虽然 Common Lisp 为程序提供了很多方式去操纵有理数的输入和输出基数, 但是这个文档中的所有数字是十进制表示的, 除非明确指定外.

##### 1.4.1.4.3 <span id = "DotCharacterUse">点字符的使用</span>

圆点字符在表达式[expression]中单独出现, 例如

    (item1 item2 . tail)

表示那个 tail 对应一个列表结尾的对象[object]列表[list]. 比如,

    (A B C . (D E F))

表示上等价于:

    (A B C D E F)

虽然圆点[dot]是符号的一个合法成分字符, 但是没有标准化的[standardized]符号包含了圆点[dot]字符, 所以这个文档中对句子末尾符号[symbol]的引用后面的句号总是解释为一个句号而不是符号[symbol]名[name]的一部分. 比如, 这个文档中, 就像这样 "This sample sentence refers to the symbol car." 的一个句子引用了一个名字为 "CAR" 的符号(带有三个字母), 不表示4个字母的 "CAR."

##### 1.4.1.4.4 <span id = "NIL">NIL</span>

nil 有很多意思. 它是 COMMON-LISP 包中名字[name]为 "NIL" 的符号[symbol], 也是布尔值[boolean] (而且是广义布尔[generalized boolean]) false, 它是空列表[empty list], 并且它是空类型[empty type]的名字[name] (所有类型[type]的子类型[subtype]).

在 Common Lisp 中, nil 可以表示为 NIL 或者 (). 按照惯例, 这个表示的选择提供了线索去判断它扮演的角色.

| 是否求值? | 表示法 | 通常表示的作用 |
|----------|-------|-------------|
|Yes       |nil    |作为 boolean. |
|Yes       |'nil   |作为符号.      |
|Yes       |'()    |表示空列表     |
|No        |nil    |作为符号或布尔值.|
|No        |()     |作为符号.       |

Figure 1-1. NIL 的表示

仅在这个文档中, nil 有时也用 false 表示来强调它作为布尔值[boolean]的角色.

比如:

```Lisp
(print ())                          ;废止的
(defun three nil 3)                 ;废止的
'(nil nil)                          ;两个符号的列表
'(() ())                            ;空列表的列表
(defun three () 3)                  ;强调空参数列表
(append '() '()) =>  ()             ;强调空列表的使用
(not nil) =>  true                  ;强调作为布尔值 false 的使用
(get 'nil 'color)                   ;强调作为一个符号的使用
```

一个函数[function]在一些情况下被说成 "是 false" 或者 "是 true". 因为看作布尔值[boolean]时没有函数[function]对象等同于 nil 并且所有函数[function]对象[object]都表示true, 所以去说一个函数[function]是 false 是无意义的, 去说它是 true 是无聊的. 这些只是表示函数[function] "返回 false" 或着 "返回 true", 的传统方式.

#### 1.4.1.5 <span id = "Designators">标识符</span>

一个标识符[designator]是一个表示另一个对象[object]的对象[object].

在一个操作符[operator]的形参[parameter]被描述为标识符[designator]的地方, 这个操作符[operator]的描述以假定这个形参[parameter]的值是表示的对象[object]的方式编写; 这就表示, 这个形参[parameter]是表示的类型[type]. (由一个 "<\<type>> 表示符" 或者 "对于 <\<type>> 的一个标识符" 指定的这个对象[object]的具体性质可以在术语表中 "<\<type>> designator" 条目找到.)

比如, "nil" 和 "the value of \*standard-output*" 作为流标识符[stream designator]在操作上是难以区分的. 类似的, 作为字符串标识符[string designator], 符号 foo 和字符串 "FOO" 在操作上也是难以区分的.

除了额外的提示, 在这个指定的对象[object]被多次使用的情况下, 这个对象[object]是只求值一次还是被使用时每次都求值, 依赖于具体实现[implementation-dependent].

比如, mapcar 接受一个函数标识符[function designator]作为参数, 并且它的描述中写的就像它只是个函数. 事实上, 这个函数标识符[function designator]是被马上求值还是在表达式形式的内部在每次被需要的时候求值是依赖于具体实现[implementation-dependent]. 大部分情况下, 符合规范的程序[conforming program]不能检测到其中的区别, 但是也有一些不正常的情况 (尤其是那些包含自身重定义或者相互重定义的函数) 确实符合并且可以检测这个区别. 下面的程序就是一个符合规范的程序[conforming program], 但是可能有或者没有明显正确的结果, 取决于它的正确性是否依赖一个或其他的结果:

```Lisp
 (defun add-some (x)
   (defun add-some (x) (+ x 2))
   (+ x 1)) =>  ADD-SOME
 (mapcar 'add-some '(1 2 3 4))
=>  (2 3 4 5)
OR=>  (2 4 5 6)
```

在一些罕见的情况下, 这里可能有个需要在字典条目中去引用一个参数的最初标识符的对象[object]. 因为对一个参数取名会应用表示的对象, 短语 "the <\<parameter-name>> designator" 可以被用于引用那个标识符, 从它可以计算得到 <\<parameter-name>> 的值.

#### 1.4.1.6 <span id = "NonsenseWords">无意义的单词</span>

当需要一个没有前置关联语义的单词时 (比如, 在一个示例中), 在 Lisp 社区中使用 "foo", "bar", "baz", 和 "quux" 的其中一种是普遍的. 比如

```Lisp
 (defun foo (x) (+ x 1))
```

名字 foo 的使用表示 "请用你喜欢的名字替换这里" 的速记方式.

这些无意义的单词有如此的使用率, 社区的新人开始去思考这里是否有他们忽略的已绑定的语义---当然这里是没有的.

### 1.4.2 <span id = "ErrorTerminology">错误术语</span>

在这个标准中已经描述了错误可能或应该或必然出现的情况. 用于描述这种情况的词旨在有确切的含义. 以下列表是这些意义的词汇表.

安全代码(Safe code)

    这个代码[code]用设置为最高(3) 的 safety 优化来处理. safety 是代码的一个词法属性. 短语 "函数 F 应该发出一个错误(the function F should signal an error)" 意味着如果 F 在代码被最高级 safety 优化的情况下被调用, 会发出一个错误. 是 F 还是调用的代码来发出这个错误是依赖于具体实现的[implementation-dependent].

不安全代码(Unsafe code)

    这个代码是被最低安全级别处理的.

    不安全代码可能会做错误检测. 具体实现允许一直把所有代码视作安全代码.

一个错误被发出(An error is signaled)

    这个意味着在安全的和不安全的代码中都会发出一个错误. 符合规范的代码[conforming code]可以依赖安全和非安全代码中都会发出错误这一事实. 不管是安全的还是非安全的代码, 每一个具体实现需要去检测这个错误. 比如, "如果给定 unexport 一个在当前包不能访问的符号, 那么一个错误就被发出(an error is signaled if unexport is given a symbol not accessible in the current package)".

    如果没有指定明确的错误类型, 默认是 error.

一个错误应该被发出(An error should be signaled)

    这个意味着一个错误在安全的代码中发出, 并且一个错误可能在不安全的代码中发出. 符合规范的代码[conforming code]可以依赖错误会在安全代码中发出这一事实. 每一个实现至少需要在安全的代码中去检测这个错误. 当这个错误没有发出, 那么 "后果是未定义的(consequences are undefined)" (见下方). 比如, "如果任何参数都不是 number 类型, 那么 + 应该发出一个 type-error 类型的错误(+ should signal an error of type type-error if any argument is not of type number)".

应该准备去发出一个错误(Should be prepared to signal an error)

    这个类似于 "应该被发出", 但它并不意味着如果操作符[operator]的正常操作只能通过'惰性'检查成功地执行, 那么操作符[operator]就必须采取"额外的努力"来发现错误的情况. 一个实现[implementation]总是允许去发出一个错误, 但是即使在安全[safe]代码[code]里, 只在没有发出可能导致不正确的结果时需要发出这个错误. 在不安全[unsafe]代码[code]中, 后果是未定义的.

    比如, 定义 "如果 find 的第二个参数不是一个正常列表, 那么它应该准备去发出一个 type-error 类型的错误(find should be prepared to signal an error of type type-error if its second argument is not a proper list)" 不表示一定会发出一个错误. 这个

    (find 'a '(a b . c))

    表达式形式[form]必须在安全[safe]代码[code]中发出一个 type-error 类型[type]的错误, 或者返回 A. 在不安全[unsafe]代码[code]中, 后果是未定义的. 相比之下,

    (find 'd '(a b . c))

    必须在安全[safe]代码[code]中发出一个 type-error 类型的错误. 在不安全[unsafe]代码[code]中, 后果是未定义的. 同样的

    (find 'd '#1=(a b . #1#))

    在安全[safe]代码[code]中可能返回 nil (作为一个具体实现定义[implementation-defined]的扩展), 可能从来不返回, 或者发出一个 type-error 类型[type]的错误. 安全[safe]代码[code]中, 后果是未定义的.

    通常, 这个 "should be prepared to signal" 术语被用于类型检测的情况, 这个时候存在效率考虑, 使得检测与操作符[operator]的正确操作无关的错误是不切实际的.

结果是未指定的(The consequences are unspecified)

    这个意味着结果是不可预测但是无害的. 具体实现允许指定这种情况的结果. 符合规范的代码[conforming code]不能依赖这种情况的结果或影响, 并且所有的符合规范的代码[conforming code]需要把这种情况的结果和影响认为是不可预测的但是无害的. 比如, "如果给 shared-initialize 的第二个参数指定一个不对应于对象中的任何一个可访问槽的名字, 那么结果是未指定的(if the second argument to shared-initialize specifies a name that does not correspond to any slots accessible in the object, the results are unspecified)".

后果是未定义的(The consequences are undefined)

    这个意味着结果是不可预测的. 结果可能是无害的或者致命的. 没有符合规范的代码[conforming code]可能依赖这个结果或影响. 符合规范的代码[conforming code]必须把这个结果当作不可预测的. 在 "must", "must not", 或者 "may not" 词语被使用的地方, 如果没有看到规定的需求或者没有明确规定特定的结果, 就会有 "后果是未定义的".

    比如: "一旦一个名字已经被 defconstant 声明为常量, 任何进一步赋值或绑定那个变量有着未定义的后果(Once a name has been declared by defconstant to be constant, any further assignment or binding of that variable has undefined consequences)".

一个错误可能被发出(An error might be signaled)

    这个意味有着存在未定义的结果; 然而, 如果一个错误被发出, 它就是指定的类型[type]. 比如, "open 可能发出一个 file-error 类型的错误(open might signal an error of type file-error)".

返回值是未指定的(The return values are unspecified)

    这个意味着一个表达式形式[form]的返回值数量和性质没有指定. 然而, 副作用和控制转移的发生与否是指定好的.

    一个程序可以是指定好的, 即便它使用了没有指定返回值的函数. 比如, 即便函数 F 的返回值没有指定, 就像 (length (list (F))) 表达式也是指定好的因为它不依赖任何 F 返回值的特定方面.

具体实现可能去扩展来覆盖这个情况(Implementations may be extended to cover this situation)

    这个意味着这种情况[situation]存在未定义的结果; 然而, 一个符合规范的实现[conforming implementation]可以用一种更加具体的方式去对待这种情况. 比如, 一个具体实现[implementation]可能发出一个错误, 或者应该发出一个错误, 或者甚至出现一个定义好的非错误行为.

    没有符合规范的代码[conforming code]可能依赖这个情况[situation]的结果; 所有符合规范的代码[conforming code]必须把这种情况的结果当作是未定义的. 具体实现需要用文档记录如何对待这种情况.

    比如, "具体实现可以扩展来定义其他类型指定符来持有一个对应类(implementations may be extended to define other type specifiers to have a corresponding class)".

具体实现可以自由地去扩展这个语法(Implementations are free to extend the syntax)

    这意味着在这种情况下, 实现允许去为被描述的表达式形式[form]的语法定义清楚的扩展. 没有符合规范的代码[conforming code]可以依赖这个扩展. 所有具体实现[implementation]需要去用文档记录每一个这样的扩展. 所有符合规范的代码[conforming code]需要去把这个语法当作是无意义的. 标准可能禁止一些扩展而允许其他的. 比如, "没有具体实现可以自由地去扩展 defclass 的语法".

一个警告可能被发出(A warning might be issued)

    这意味着在适当上下文中 (比如, 编译的时候), 鼓励具体实现[implementation]去发出一个警告的. 然而, 一个符合规范的实现[conforming implementation]不需要发出一个警告.


### 1.4.3 <span id = "SectionsNotFormallyPartOfThisStandard">本标准未正式规定的部分</span>

这个标准的前页和书后的附属资料, 就像 "Table of Contents", "Index", "Figures", "Credits", 和 "Appendix" 不是这个标准的正规考虑的部分, 所以我们保留更新这些部分所需要的灵活性, 以便于即使在最后一刻也不需要担心修改文档的这些部分需要正式的投票. 这些条目很短并且很有用, 然而, 不推荐在这个文档的删减版本里把它们删除.

在概念性的章节里, 提供的名字以单词 "注意(Note)" 或 "注意(Notes)" 或 "例如(Example)" 或 "例如(Examples)" 开头的部分只用于说明目的, 并且不被认为是标准的一部分.

已经试着把这些章节放在父章节的末尾, 这样它们就可以被移除而不需要修改相邻章节的序号来减少文档的大小.

同样的, 字典条目中的这个 "示例(Examples)" 和 "注意(Notes)" 部分也不被认为是标准的一部分, 如有必要可以移除.

不过, 这些示例对剩下的部分提供了重要的说明和规范性检查, 这样的删减是不推荐的, 除非完全无法避免.

### 1.4.4 <span id = "InterpretingDictionaryEntries">解释字典条目</span>

每个已定义的名字[defined name]的字典条目被划分为几个部分. 除非明确表示, 每个部分由确定这个部分的标签引入. 该部分的遗漏表示这个章节是不可应用的或者没有提供什么有意思的信息.

这个章节定义了每个可能出现在字典章节的条目的意义.

> * 1.4.4.1 ["受此影响(Affected By)" 字典条目部分](#AffectedBySDE)
> * 1.4.4.2 ["参数(Arguments)" 字典条目部分](#ArgumentsSDE)
> * 1.4.4.3 ["参数和值(Arguments and Values)" 字典条目部分](#ArgumentsAndValuesSDE)
> * 1.4.4.4 ["绑定类型的影响(Binding Types Affected)" 字典条目部分](#BindingTypesAffectedSDE)
> * 1.4.4.5 ["类优先级列表(Class Precedence List)" 字典条目部分](#ClassPrecedenceListSDE)
> * 1.4.4.6 [类型标识符的字典条目](#DictionaryEntriesForTS)
> * 1.4.4.7 ["常量值(Constant Value)" 字典条目部分](#ConstantValue)
> * 1.4.4.8 ["描述(Description)" 字典条目部分](#DescriptionSDE)
> * 1.4.4.9 ["示例(Examples)" 字典条目部分](#ExamplesSDE)
> * 1.4.4.10 ["异常情况(Exceptional Situations)" 字典条目部分](#ExceptionalSituationsSED)
> * 1.4.4.11 ["初始值(Initial Value)" 字典条目部分](#InitialValueSDE)
> * 1.4.4.12 ["参数优先级顺序(Argument Precedence Order)" 字典条目部分](#ArgumentPrecedenceOrderSDE)
> * 1.4.4.13 ["方法签名(Method Signature)" 字典条目部分](#MethodSignatureSDE)
> * 1.4.4.14 ["名称(Name)" 字典条目部分](#NameSDE)
> * 1.4.4.15 ["注意(Notes)" 字典条目部分](#NotesSDE)
> * 1.4.4.16 ["发音(Pronunciation)" 字典条目部分](#PronunciationSDE)
> * 1.4.4.17 ["参见(See Also)" 字典条目部分](#SeeAlsoSDE)
> * 1.4.4.18 ["副作用(Side Effects)" 字典条目部分](#SideEffectsSDE)
> * 1.4.4.19 ["超类型(Supertypes)" 字典条目部分](#SupertypesSDE)
> * 1.4.4.20 ["语法(Syntax)" 字典条目部分](#SyntaxSDE)
> * 1.4.4.21 ["合法上下文(Valid Context)" 字典条目部分](#ValidContextSDE)
> * 1.4.4.22 ["值类型(Value Type)" 字典条目部分](#ValueTypeSDE)

#### 1.4.4.1 <span id = "AffectedBySDE">"受此影响(Affected By)" 字典条目部分</span>

对于一个操作符[operator], 就是任何可以影响这个操作符[operator]的副作用或者返回的值[value]的事物.

对于一个变量[variable], 就是任何可以影响这个变量[variable]的值[value]的事物, 这个值包括绑定或赋值给这个变量的函数[function].

#### 1.4.4.2 <span id = "ArgumentsSDE">"参数(Arguments)" 字典条目部分</span>

这个信息描述那些声明[declaration]还有不求值为表达式形式[form]并且求值也不返回值[value]的特殊表达式[expression]条目的语法信息.

#### 1.4.4.3 <span id = "ArgumentsAndValuesSDE">"参数和值(Arguments and Values)" 字典条目部分</span>

这是对操作符[operator]接收实参[argument]还有返回的值[value]的英语描述(译者注: 这里的英语对应到本译文是中文), 包括可遗漏实参[argument]的默认形参[parameter]的信息 (例如可选参数[optional parameter]和关键字参数[keyword parameter]). 对于特殊操作符[special operator]和宏[macro], 它们的实参[argument]不会被求值, 除非在它们的描述中就明确指定它们被求值.

除了显式指明以外, 如果这些类型约束被违反了, 那么结果将是未定义的.

#### 1.4.4.4 <span id = "BindingTypesAffectedSDE">"绑定类型的影响(Binding Types Affected)" 字典条目部分</span>

这个信息警告读者这个类型的绑定[binding]可能被一个声明所影响. 事实上任何这样的特定绑定[binding]是否被影响取决于其他因素. 详情见 "描述(Description)" 部分中问题的声明.

#### 1.4.4.5 <span id = "ClassPrecedenceListSDE">"类优先级列表(Class Precedence List)" 字典条目部分</span>

这个出现在类[class]的字典条目, 并且包含由 Common Lisp 定义的类[class]的一个有序列表, 这个列表一定在这个类[class]的优先级列表[class precedence list]中.

允许其他类[class] (具体实现定义的[implementation-defined]) 出现在具体实现的这个类[class]的优先级列表[class precedence list]中.

允许标准对象[standard-object]或者结构体对象[structure-object]出现在具体实现[implementation]的类优先级列表[class precedence list]中; 详情见章节 4.2.2 (类型关系).

除非在这个说明书里明确说明, 没有标准化[standardized]的类[class]出现在具体实现的类优先级列表[class precedence list]中.

根据类和类型之间的关系定义, 这部分列出来的类[class]也是这个类[class]表示的类型[type]的超类型[supertype].

#### 1.4.4.6 <span id = "DictionaryEntriesForTS">类型标识符的字典条目</span>

这个原子类型指定符[atomic type specifier]是那些 Figure 4-2 列出的已定义的名字[defined name]. 这些字典条目是 "类(Class)", "状况类型(Condition Type)", "系统类(System Class)", 或者 "类型(Type)" 种类的. 如何去把命名这些类型[type]或类[class]的符号[symbol]解释为原子类型指定符[atomic type specifier]的描述在每个字典条目的 "描述(Description)" 部分.

复合类型指定符[compound type specifiers]是那些 Figure 4-3 列出的已定义的名字[defined name]. 这样的字典条目是 "类(Class)", "系统类(System Class)", "类型(Type)", 或 "类型指定符(Type Specifier)" 类型的. 如何去把一个 car 为这样一个符号[symbol]的列表[list]解释为复合类型指定符[compound type specifiers]的描述可以在这样一个字典条目的 "复合类型指定符种类(Compound Type Specifier Kind)", "复合类型指定符语法(Compound Type Specifier Syntax)", "复合类型指定符参数(Compound Type Specifier Arguments)", 还有 "复合类型指定符描述(Compound Type Specifier Description)" 这些部分中找到.

> * 1.4.4.6.1 [ "复合类型指定符种类(Compound Type Specifier Kind)" 字典条目部分](#CTSKindSDE)
> * 1.4.4.6.2 [ "复合类型指定符语法(Compound Type Specifier Syntax)" 字典条目部分](#CTSSyntaxSDE)
> * 1.4.4.6.3 [ "复合类型指定符参数(Compound Type Specifier Arguments)" 字典条目部分](#CTSArgumentsSDE)
> * 1.4.4.6.4 [ "复合类型指定符描述(Compound Type Specifier Description)" 字典条目部分](#CTSDescriptionSDE)

##### 1.4.4.6.1 <span id = "CTSKindSDE"> "复合类型指定符种类(Compound Type Specifier Kind)" 字典条目部分</span>

一个 "abbreviating" 类型指定符[type specifier]描述了一个原则上可以枚举出这些元素[elements]但是实践上没有可操作性的一个子类型[subtype].

一个 "specializing" 类型指定符[type specifier]通过约束这个类型[type]的一个或多个成员的类型[type], 例如元素类型[element type]或复数部分类型[complex part type], 来描述一个子类型[subtype].

一个 "predicating" 类型指定符[type specifier]描述了一个只包含满足给定断言[predicate]的那些对象[object]的子类型[subtype].

一个 "combining" 类型指定符[type specifier]描述一种以组合的方式的子类型[subtype], 通过在其他类型[type]上使用组合操作符 (例如 "and", "or", 和 "not") .

##### 1.4.4.6.2 <span id = "CTSSyntaxSDE"> "复合类型指定符语法(Compound Type Specifier Syntax)" 字典条目部分</span>

这个关于一个类型[type]的信息描述了这个类型[type]的复合类型指定符[compound type specifier]的语法.

这个类型是否可以作为原子类型指定符[atomic type specifier]在这里没有说明; 见章节 1.4.4.6 (类型标识符的字典条目).

##### 1.4.4.6.3 <span id = "CTSArgumentsSDE"> "复合类型指定符参数(Compound Type Specifier Arguments)" 字典条目部分</span>

这个描述了定义在 "复合类型指定符语法(Compound Type Specifier Syntax)" 部分的结构的类型[type]信息.

##### 1.4.4.6.4 <span id = "CTSDescriptionSDE"> "复合类型指定符描述(Compound Type Specifier Description)" 字典条目部分</span>

这个描述了定义在 "复合类型指定符语法(Compound Type Specifier Syntax)" 部分的结构的意义.

#### 1.4.4.7 <span id = "ConstantValue">"常量值(Constant Value)" 字典条目部分</span>

这个描述了一个常量[constant variable]的不变的类型[type]和值[value].

#### 1.4.4.8 <span id = "DescriptionSDE">"描述(Description)" 字典条目部分</span>

这个操作符[opterator]还有它的所有目的方面的一个总结, 但是没有必要包含下面引用的所有字段("副作用(Side Effects)", "异常情况(Exceptional Situations)", 等等.)

#### 1.4.4.9 <span id = "ExamplesSDE">"示例(Examples)" 字典条目部分</span>

这个操作符[opterator]的使用示例. 这些示例不被认为是这个标准的一部分; 见章节 1.4.3 (本标准未正式规定的部分).

#### 1.4.4.10 <span id = "ExceptionalSituationsSED">"异常情况(Exceptional Situations)" 字典条目部分</span>

三种类型的信息可以出现在这里:

    被这个函数[function]检测到且正常发出来的情况.
    被这个函数[function]处理的情况.
    可能被这个函数[function]检测到的情况.

该字段既不包含传递给这个操作符[operator]作为参数或者作为动态变量由这个操作符[operator]调用的函数[function]所发出的状况, 也不包括当这个操作符[operator]是宏[macro]或特殊操作符[special operator]时, 执行这个操作符的子表达式所发出的状况.

#### 1.4.4.11 <span id = "InitialValueSDE">"初始值(Initial Value)" 字典条目部分</span>

这个信息描述了一个动态变量[dynamic variable]的初始值[value]. 因为这个变量可能会改变, 见 "值类型(Value Type)" 部分的类型限制.

#### 1.4.4.12 <span id = "ArgumentPrecedenceOrderSDE">"参数优先级顺序(Argument Precedence Order)" 字典条目部分</span>

这个信息描述了参数优先级顺序[argument precedence order]. 如果它被省略, 参数的优先级顺序[argument precedence order]就是默认的 (从左到右).

#### 1.4.4.13 <span id = "MethodSignatureSDE">"方法签名(Method Signature)" 字典条目部分</span>

这个广义函数[generic function]的描述包含了在这个标准定义在这个广义函数[generic function]上的的方法[method]描述. 一个方法签名被用于描述每一个方法[method]的形参[parameter]和形参指定符[parameter specializer]. 对于这个广义函数[generic function]定义的方法[method]必须是这个方法[method]的签名[signature]所描述形式.

F (x class) (y t) &optional z &key k

这个签名[signature]表示这个广义函数[generic function] F 的方法有两个必要参数[required parameter]: 必须是类[class] class 的广义实例[generalized instance]的 x; 还有可以是任何对象[object]的 y (换句话说, 可以类 t 的广义实例[generalized instance]). 另外, 这里有一个可选参数[optional parameter] z 和一个关键字参数[keyword parameter] k. 这个签名[signature]也表示这个 F 上的方法是一个主方法[primary method]并且没有限定符[qualifiers].

对于每个形参[parameter], 提供的实参[argument]必须是对应的广义函数描述的类型和某个方法的签名里的类型的交集 (不仅仅是这个规范里定义的方法[method], 也包括在允许定义方法[method]的地方具体实现定义的[ implementation-defined]或者用户定义的方法[method]).

#### 1.4.4.14 <span id = "NameSDE">"名称(Name)" 字典条目部分</span>

这个章节介绍字典条目. 它没有被显式标记. 它出现在一个横线的前面或后面.

在左边打印的大字体是已定义的名字[defined name]; 如果不只一个已定义的名字[defined name]要被这个条目描述, 所有这样的名字[name]都会显示出来, 通过逗号分割.

在右边打印的小的斜体的是这个字典条目是什么种类的表示. 可能的值是:

访问器(Accessor)

    这个是访问器[accessor]函数[function].

类(Class)

    这是一个类[class].

状况类型(Condition Type)

    这个是类型[type] condition 的子类型[subtype].

常量(Constant Variable)

    这是一个常量[constant variable].

声明(Declaration)

    这是一个声明标识符[declaration identifier].

函数(Function)

    这是一个函数[function].

局部函数(Local Function)

    这是一个词法上定义在宏表达式形式[macro form]的作用域里的函数[function].

局部宏(Local Macro)

    这是一个词法上定义在宏表达式形式[macro form]的作用域里的宏[macro].

宏(Macro)

    这是一个宏[macro].

重启动(Restart)

    这是一个重启动[restart].

特殊操作符(Special Operator)

    这是一个特殊操作符[special operator].

标准广义函数(Standard Generic Function)

    这是一个标准广义函数[standard generic function].

符号(Symbol)

    这是在某些特定情况下特别识别的符号[symbol], 例如宏[macro]的语法.

系统类(System Class)

    这就像一个类[class], 但是它可能表示的是内置类[built-in class]. (事实上没有类[class]必须成为内置类[built-in class].)

类型[Type]

    这是一个原子类型指定符[atomic type specifier], 并且依赖于每一个特定条目的信息, 可能会被其他类型指定符[type specifier]所接受.

类型指定符[Type Specifier]

    这是一个不是原子类型指定符[atomic type specifier]的已定义的名字[defined name], 但是可以被用于构建合法类型指定符[type specifier].

变量[Variable]

    这是一个动态变量[dynamic variable].


#### 1.4.4.15 <span id = "NotesSDE">The "注意(Notes)" 字典条目部分</span>

在其他地方没有的关于这个操作符[operator]的信息. 在其他情况中, 这个可能包含了交叉引用信息, 代码等价性, 格式上的暗示, 实现的暗示, 典型使用. 这个信息不被认为是这标准的一部分; 任何符合规范的实现[conforming implementation]和符合规范的程序[conforming program]允许忽略这个信息.

#### 1.4.4.16 <span id = "PronunciationSDE">"发音(Pronunciation)" 字典条目部分</span>

这个为已定义的名字[defined name]提供了一个推荐的发音方式, 这样人们没有在和最初的设计者们一起交流的情况下也能弄明白这个没有出现在正常英语中的单词如何发音. 这个信息是劝告性的, 不被认为是这个标准的一部分. 为了简洁性, 它只提供给带有特定于 Common Lisp 而不会出现在未删减的《Webster's Third New International Dictionary the English Language》中的名字的条目.

#### 1.4.4.17 <span id = "SeeAlsoSDE">"参见(See Also)" 字典条目部分</span>

对这个标准其他部分的引用的列表, 这些引用提供有关这个操作符[operator]信息. 这个列表不是这个标准的一部分.

#### 1.4.4.18 <span id = "SideEffectsSDE">The "副作用(Side Effects)" 字典条目部分</span>

任何因对包含该操作符[operator]的表达式形式[form]的求值而改变的东西.

#### 1.4.4.19 <span id = "SupertypesSDE">The "超类型(Supertypes)" 字典条目部分</span>

这个出现在一个类型[type]的字典条目中, 包含了一个标准化[standardized]类型[type]的列表, 它们必须是这个类型[type]的超类型[supertype].

在具体实现[implementation]中有一个对应类[class]的地方, 在类优先级列表[class precedence list]中这些类[class]的顺序和在这个章节中出现的顺序是一致的.

#### 1.4.4.20 <span id = "SyntaxSDE">"语法(Syntax)" 字典条目部分</span>

这个章节描述了如何在代码中使用已定义的名字[defined name]. 关于广义函数[generic function]的 "语法(Syntax)" 部分描述了广义函数[generic function]自身的 lambda 列表[lambda list], 而 "方法签名(Method Signatures)" 描述了已定义的方法[method]的 lambda 列表[lambda list]. 一个普通函数, 宏, 或者一个特殊操作符的 "语法(Syntax)" 描述叙述了它们的形参[parameter].

比如, 一个操作符[operator]描述可能是:

    F x y &optional z &key k

这个描述表示函数 F 有两个必要参数, x 和 y. 另外, 这里还有个可选参数 z 和一个关键字参数 k.

关于宏[macro]和特殊操作符[special operator], 语法由修改的 BNF 表示给定; 见章节 1.4.1.2 (修改后的 BNF 语法). 对于函数[function]给定一个 lambda 列表[lambda list]. 然而在两种情况下, 最外层的括号和默认值信息省略了.

> * 1.4.4.20.1 [重载操作符特殊的 "语法(Syntax)" 表示](#SpecialSyntaxNotations)
> * 1.4.4.20.2 [剩余参数的命名转化](#NamingConventions)
> * 1.4.4.20.3 [在 "语法(Syntax)" 部分要求非空剩余参数](#RequiringNonNullRestParameters)
> * 1.4.4.20.4 [在 "语法(Syntax)" 部分的返回值](#ReturnValuesInSyntaxSection)

##### 1.4.4.20.1 <span id = "SpecialSyntaxNotations">重载操作符特殊的 "语法(Syntax)" 表示</span>

如果同一个操作符带有不同数量的参数有两个描述, 那么额外的参数就被认为是可选的. 比如, 这两行:

    file-position stream => position

    file-position stream position-spec => success-p

操作上等价于:

    file-position stream &optional position-spec => result

并且不同点仅在于为每一个情况提供一个机会去为形参[parameter]和值[value]引入不同的的名字. 当操作符[operator] 使用形参[parameter]根据提供的实参[argument]数量以不同的方式被使用 (比如, 函数[function] /) 或者两种情况下返回值不同 (比如, 函数 file-position) 的方式重载时, 使用这个分开的 (多行) 表示法.

##### 1.4.4.20.2 <span id = "NamingConventions">剩余参数的命名转化</span>

在这个规范中, 如果选择的一个剩余参数[rest parameter]的名字为复数名词, 在 *parameter* 字体下的这个名字的使用引用了这个剩余参数[rest parameter]被绑定到的列表[list]. 在 *parameter* 字体下的这个名字的单数形式的使用引用了那个列表[list]的一个元素[element].

比如, 给定一个像这样的语法描述:

    F &rest arguments

可以通过名字来引用这些名为 arguments 的剩余参数[rest parameter], 或者通过 "一个 argument", "某个 argument", "每个 argument" 等等来引用其中一个.

##### 1.4.4.20.3 <span id = "RequiringNonNullRestParameters">在 "语法(Syntax)" 部分要求非空剩余参数</span>

在某些情况下, 当需要至少一个参数时, 使用剩余参数[rest parameter]将所有参数都视为单个聚合体是很有用的. 在代码[code]中可以使用各种命令式和声明性方法来表达这样的限制, 但是它们通常不会在 lambda 列表[lambda list]中显示出来. 在这个文档中为了表述目的,

    F &rest arguments+

意味着和下面的相等

    F &rest arguments

但是引入了额外的需要: 这里至少需要一个参数 argument.

##### 1.4.4.20.4 <span id = "ReturnValuesInSyntaxSection">在 "语法(Syntax)" 部分的返回值</span>

一个求值箭头 "=> " 先于要被返回的值[value]的列表. 比如:

    F a b c => x

表示这个 F 是一个操作符, 它需要三个必要参数[required parameter] (换句话说, a, b, 还有 c) 以及返回一个值[value] (就是 x). 如果不止一个值[value]被这个操作符返回, 这些值[value]的名字[name]会用逗号区分, 就像:

    F a b c => x, y, z

###### 1.4.4.20.4.1 在 "Syntax" 部分没有参数和返回值

如果允许没有实参[argument]或者没有返回的值[value], 一个特别的标记被用于使这个更显而易见. 比如,

    F <no arguments> => <no values>

表示这个 F 操作符不接受实参[argument]并且不返回值[value].

###### 1.4.4.20.4.2 在 "Syntax" 部分控制的非条件转移

一些操作符[operator]会有控制无条件转移的动作, 并且没有任何返回值. 这样的操作符[operator]通过以下方式表示:

    F a b c =>|

#### 1.4.4.21 <span id = "ValidContextSDE">"合法上下文(Valid Context)" 字典条目部分</span>

这个信息被用于例如 "声明(Declarations)" 字典条目, 用于约束这个声明可以出现的上下文.

一个给定的 "声明(Declaration)" 可能出现在一个声明[declaration] (换句话说, 一个 declare 表达式[expression]) , 一个全局声明[proclamation] (换句话说, 一个 declaim 或 proclaim 表达式形式[form]), 或者都有.

#### 1.4.4.22 <span id = "ValueTypeSDE">"值类型(Value Type)" 字典条目部分</span>

这个信息描述了一个动态变量[dynamic variable]的任何类型[type]约束条件.

除非明确指定外, 违反这个类型约束时结果是不可预测的.

## 1.5 <span id = "Conformance">规范性</span>

这个标准提出了一个符合规范的具体实现[conforming implementation]需要去实现的语法和语义 (以及它的附加文档). 另外, 它对符合规范的程序[conforming program]加了一些要求.

> * 1.5.1 [符合规范的实现](#ComformingImpl)
> * 1.5.2 [符合规范的程序](#ComformingProg)
 
### 1.5.1 <span id = "ComformingImpl">符合规范的实现</span>

一个符合规范的实现[conforming implementation]应该遵守这个章节中所述的要求.

> * 1.5.1.1 [必要的语言特性](#RequiredLanguageFeatures)
> * 1.5.1.2 [依赖具体实现的特性文档](#DocImplDepFeatures)
> * 1.5.1.3 [扩展文档](#DocExtensions)
> * 1.5.1.4 [异常情况的处理](#TreatmentExceptionalSituations)
> * 1.5.1.5 [规范性声明](#ConformanceStatement)

#### 1.5.1.1 <span id = "RequiredLanguageFeatures">必要的语言特性</span>

一个符合规范的实现[conforming implementation]需要去接受这个标准中指定的所有语言特性 (包括弃用的特性), 并带有这个标准中指定的意义.

一个符合规范的实现[conforming implementation]不需要在代码中包含替代或额外的语言元素, 以完成该标准中指定的一个语言特性. 

#### 1.5.1.2 <span id = "DocImplDepFeatures">依赖具体实现的特性文档</span>

一个符合规范的实现[conforming implementation]应该附加一个文档, 里面提供这个规范定义的语言的所有具体实现定义的[implementation-defined]方面的定义.

另外, 一个符合规范的实现[conforming implementation]鼓励 (但是不是必须) 去记录这个标准中被标注为依赖于具体实现[implementation-dependent]的条目, 尽管一些情况下这个文档可能简单地把这些条目标注为 "undefined". 

#### 1.5.1.3 <span id = "DocExtensions">扩展文档</span>

一个符合规范的实现[conforming implementation]应该附带一个文档分开叙述那些这个标准中没有但是具体实现[implementation]中有的特性, 但是加到这个语言标准中时不应导致任何的歧义和矛盾. 这样的扩展应该被描述为 "由 ANSI <\<standard number>> 指定的 Common Lisp 的扩展". 

#### 1.5.1.4 <span id = "TreatmentExceptionalSituations">异常情况的处理</span>

一个符合规范的实现[conforming implementation]应该和这个规范一致的方式去处理异常情况.

##### 1.5.1.4.1 异常情况下明显冲突的解决

如果在这个规范中不止一个片段应用于相同的情况但是以冲突的方式, 那么以最具体的方式描述这个情况的段落优先 (这个片段没有必要提供最约束的错误检测) .

###### 1.5.1.4.1.1 异常情况中的明显冲突解决示例

假设函数 foo 是操作数字的函数[function]集合 S 的一个成员. 假设一个段落阐述如果任何一个 S 中的函数[function]被给予一个 17 作为参数就会发出一个错误. 假设一个明显的冲突段落阐述如果参数为 17 则结果是未定义的. 那么第二个段落(更加针对 foo 的那个)会占主要地位, 因为这个情况的上下文描述最详细的, 即便对于参数 17 集合 S 中的其他函数需要去发出一个错误, 这个函数 foo 也不需要. 

#### 1.5.1.5 <span id = "ConformanceStatement">规范性声明</span>

一个符合规范的实现[conforming implementation]应该提供一个规范性声明作为使用这个实现的结果, 或者在附带的文档中加入这个声明. 如果这个具体实现符合这个标准的所有方面, 这个规范性声明应该为

    "<<Implementation>> 符合 ANSI <<standard number>> 的要求"

如果这个实现[implementation]符合这个标准中的一部分并非全部, 这个说明应该为

    "<<Implementation>> 符合 ANSI <<standard number>> 的要求, 除了以下例外: <<这个实现不符合的这个标准的要求的引用或完整列表>>".

### 1.5.2 <span id = "ComformingProg">符合规范的程序</span>

符合这个规范的代码应该坚持下面几条:

    符合规范的代码[conforming code]应该只使用这个标准指定的或者通过这个标准指定的扩展机制定义的语言语法和语义特性.

    符合规范的代码[conforming code]可能使用依赖实现的[implementation-dependent]特性和值, 但是不应该依赖于任何这些特征和值的特别解释, 除了那些在代码[code]的执行中发现的.

    符合规范的代码[conforming code]不应依赖未定义或者未指定情况的结果.

    符合规范的代码[conforming code]不使用这个标准禁止的任何构造.

    符合规范的代码[conforming code]不依赖于一个包含在具体实现中的扩展.

> * 1.5.2.1 [具体实现定义的语言特征的使用](#UseImplDefLangFeature)
> * 1.5.2.2 [可移植代码的字符集](#CharsetForPortCode)

#### 1.5.2.1 <span id = "UseImplDefLangFeature">具体实现定义的语言特征的使用</span>

注意, 符合规范的代码[conforming code]可能依赖一个特定的具体实现定义的[implementation-defined]特性或值. 也注意, 符合规范的代码[conforming code]和符合规范的实现[conforming implementation]的需求中不要求一个符合规范的代码[conforming code]被符合规范的实现[conforming implementation]处理时产生的结果总是相同的. 结果可能一样, 或者它们可能不同.

符合规范的代码[conforming code]可能可以运行于所有符合规范的实现[conforming implementation]中, 但是可能有具体实现定义的[implementation-defined]可允许行为导致这个代码不可移植. 比如, 下面就是一个符合规范的表达式形式[form]在不同实现会返回不同的值的示例:

```BNF
(evenp most-positive-fixnum) =>  implementation-dependent
(random) =>  implementation-dependent
(> lambda-parameters-limit 93) =>  implementation-dependent
(char-name #\A) =>  implementation-dependent
```

##### 1.5.2.1.1 读取时条件的使用

使用 #+ 和 #- 不会自动取消程序的规范性资格. 如果没有使用会使程序不规范的特性, 那么一个使用了 #+ 和 #- 的程序就是规范的. 当然, 符合规范的程序[conforming program]不一定是实际工作的程序. 下面的程序是符合规范的:

```Lisp
(defun foo ()
  #+ACME (acme:initialize-something)
  (print 'hello-there))
```

然而, 这个程序可能不会工作, 取决于特性 ACME 是否存在, 意味着名为 acme:initialize-something 的函数是否存在于这个环境中. 事实上, 在符合规范的程序[conforming program]里使用 #+ 或 #- 意味着增加一个变量 \*features* 作为这个程序的输入参数. 就像其他进入程序的数据一样, 程序员有责任去确保这个程序不做基于这个基本输入数据的无根据的假设. 

#### 1.5.2.2 <span id = "CharsetForPortCode">可移植代码的字符集</span>

可移植[portable]代码[code]只用标准字符[standard character]]编写. 

## 1.6 <span id = "LanguageExtensions">语言的扩展</span>

一个语言的扩展是指标准中已定义的名字[defined name]对应的具体实现定义的[implementation-defined]有别于标准中所描述的已记录的行为, 或者是这个标准指定为未定义, 未指定, 或通过实现可扩展的情况的已记录的后果. 比如, 如果这个标准说 "这个结果是未指定的(the results are unspecified)" , 那么一个扩展会去指定这个结果.

如果一个程序的正确行为依赖一个扩展所提供的结果, 那么只有带有同样扩展的实现会正确执行这段程序. 注意这样的程序可能是不符合规范的. 如果这个标准中说 "一个实现可以被扩展(an implementation may be extended)", 那么用了这个扩展的程序是一个符合规范的但是不可移植的程序.

假定一些扩展没有修改符合规范代码的行为也没有被这个标准显式禁止, 那么一个实现可以有这些扩展.

术语 "extension" 仅引用启动时可用的扩展. 一个具体实现可以自由地允许或禁止一个扩展的重定义.

下面的列表包含了关于特定类型扩展的具体实现指南.

额外的返回值

    一个实现必须返回这个标准指定的准确数量的返回值, 除非标准特别声明以外.

未经请求的信息

    除了这个标准里指定的外, 或者由于函数检测到状况[condition]的发出, 函数不会产生输出.

    未经请求的输出, 例如垃圾收集提醒和自动加载的预兆, 不应该直接到标准中定义的流[stream]变量的值对应的流[stream]里, 但是可以使用到 *terminal-io* 的同义流[synonym stream]间接到终端 I/O [terminal I/O] 中.

    来自函数比如 load 和 compile 的进度报告被认为是请求过的, 并且不会被这个禁令覆盖.

宏和特殊表达式的实现

    这个标准中定义的宏[macro]和特殊操作符[special operator]不能是函数[function]. 

## 1.7 <span id = "LanguageSubsets">语言的子集</span>

这个标准中描述的语言没有子集, 尽管并没有禁止子集.

对于一个被认为是子集的语言, 这个语言下合法的程序[program]一定有等价的语义并且可以被任何全语言的符合规范的实现[conforming implementation]直接运行 (没有语言外的预处理, 并且没有专门的兼容性包).

一个符合这个要求的语言应该被描述为一个 "由 ANSI <\<standard number>> 指定的 Common Lisp 的子集.''

## 1.8 <span id = "DeprecatedLanguageFeatures">弃用的语言特性</span>

废弃的语言特性是不希望出现在未来的 Common Lisp 标准中的, 但是为了符合这个标准需要被实现; 见章节 1.5.1.1 (必要的语言特性).

符合规范的程序[[conforming program]]可以使用废弃的语言特性; 然而, 避免使用它们是良好的编程风格. 在编译的时候允许编译器对这些特性的使用产生风格警告[style warning], 但是在程序执行的时候不应该有这样的警告. 

> * 1.8.1 [废弃的函数](#DeprecatedFunctions)
> * 1.8.2 [废弃的参数约定](#DeprecatedArgumentConventions)
> * 1.8.3 [废弃的变量](#DeprecatedVariables)
> * 1.8.4 [废弃的读取器语法](#DeprecatedReaderSyntax)

### 1.8.1 <span id = "DeprecatedFunctions">废弃的函数</span>

下面这块函数[function]是被废弃的.

    assoc-if-not   nsubst-if-not       require            
    count-if-not   nsubstitute-if-not  set                
    delete-if-not  position-if-not     subst-if-not       
    find-if-not    provide             substitute-if-not  
    gentemp        rassoc-if-not                          
    member-if-not  remove-if-not     

    Figure 1-2. 废弃的函数                    

### 1.8.2 <span id = "DeprecatedArgumentConventions">废弃的参数约定</span>

传递一个数字实参[argument]给 gensym 的能力已经废弃了.

这个给下面这段中的函数的 :test-not 实参[argument]已经被废弃.

    adjoin             nset-difference    search            
    assoc              nset-exclusive-or  set-difference    
    count              nsublis            set-exclusive-or  
    delete             nsubst             sublis            
    delete-duplicates  nsubstitute        subsetp           
    find               nunion             subst             
    intersection       position           substitute        
    member             rassoc             tree-equal        
    mismatch           remove             union             
    nintersection      remove-duplicates     

    Figure 1-3. 带有废弃的 :TEST-NOT 参数的函数               

在 eval-when 中名为 compile, load, 和 eval 的情况的使用被废弃了. 

### 1.8.3 <span id = "DeprecatedVariables">废弃的变量</span>

变量[variable] \*modules* 被废弃了. 

### 1.8.4 <span id = "DeprecatedReaderSyntax">废弃的读取器语法</span>

这个 #S 读取宏[reader macro]强制关键字名字到 KEYWORD 包里; 见章节 2.4.8.13 (井号S(#S)). 这个特性被废弃了; 在未来, 关键字的名字将会在它们被读入的包中被取出, 因此, 如果这是需要的, 那么实际上在关键字包中的符号[symbol]应该被使用. 

## 1.9 <span id = "SymbolsInTheCOMMON-LISPPackage">COMMON-LISP 包中的符号</span>

下面这段包括了 COMMON-LISP 包中 978 个外部符号[symbol]的完整枚举.

    &allow-other-keys            *print-miser-width*     
    &aux                         *print-pprint-dispatch*      
    &body                        *print-pretty*               
    &environment                 *print-radix*                
    &key                         *print-readably*             
    &optional                    *print-right-margin*         
    &rest                        *query-io*                   
    &whole                       *random-state*               
    *                            *read-base*                  
    **                           *read-default-float-format*  
    ***                          *read-eval*                  
    *break-on-signals*           *read-suppress*              
    *compile-file-pathname*      *readtable*                  
    *compile-file-truename*      *standard-input*             
    *compile-print*              *standard-output*            
    *compile-verbose*            *terminal-io*                
    *debug-io*                   *trace-output*               
    *debugger-hook*              +                            
    *default-pathname-defaults*  ++                           
    *error-output*               +++                          
    *features*                   -                            
    *gensym-counter*             /                            
    *load-pathname*              //                           
    *load-print*                 ///                          
    *load-truename*              /=                           
    *load-verbose*               1+                           
    *macroexpand-hook*           1-                           
    *modules*                    <                            
    *package*                    <=                           
    *print-array*                =                            
    *print-base*                 >                            
    *print-case*                 >=                           
    *print-circle*               abort                        
    *print-escape*               abs                          
    *print-gensym*               acons                        
    *print-length*               acos                         
    *print-level*                acosh                        
    *print-lines*                add-method                   

Figure 1-4. COMMON-LISP包中的符号 (1/12).

    adjoin                      atom          boundp                    
    adjust-array                base-char     break                     
    adjustable-array-p          base-string   broadcast-stream          
    allocate-instance           bignum        broadcast-stream-streams  
    alpha-char-p                bit           built-in-class            
    alphanumericp               bit-and       butlast                   
    and                         bit-andc1     byte                      
    append                      bit-andc2     byte-position             
    apply                       bit-eqv       byte-size                 
    apropos                     bit-ior       caaaar                    
    apropos-list                bit-nand      caaadr                    
    aref                        bit-nor       caaar                     
    arithmetic-error            bit-not       caadar                    
    arithmetic-error-operands   bit-orc1      caaddr                    
    arithmetic-error-operation  bit-orc2      caadr                     
    array                       bit-vector    caar                      
    array-dimension             bit-vector-p  cadaar                    
    array-dimension-limit       bit-xor       cadadr                    
    array-dimensions            block         cadar                     
    array-displacement          boole         caddar                    
    array-element-type          boole-1       cadddr                    
    array-has-fill-pointer-p    boole-2       caddr                     
    array-in-bounds-p           boole-and     cadr                      
    array-rank                  boole-andc1   call-arguments-limit      
    array-rank-limit            boole-andc2   call-method               
    array-row-major-index       boole-c1      call-next-method          
    array-total-size            boole-c2      car                       
    array-total-size-limit      boole-clr     case                      
    arrayp                      boole-eqv     catch                     
    ash                         boole-ior     ccase                     
    asin                        boole-nand    cdaaar                    
    asinh                       boole-nor     cdaadr                    
    assert                      boole-orc1    cdaar                     
    assoc                       boole-orc2    cdadar                    
    assoc-if                    boole-set     cdaddr                    
    assoc-if-not                boole-xor     cdadr                     
    atan                        boolean       cdar                      
    atanh                       both-case-p   cddaar                    

Figure 1-5. COMMON-LISP包中的符号 (2/12).

    cddadr             clear-input                  copy-tree                
    cddar              clear-output                 cos                      
    cdddar             close                        cosh                     
    cddddr             clrhash                      count                    
    cdddr              code-char                    count-if                 
    cddr               coerce                       count-if-not             
    cdr                compilation-speed            ctypecase                
    ceiling            compile                      debug                    
    cell-error         compile-file                 decf                     
    cell-error-name    compile-file-pathname        declaim                  
    cerror             compiled-function            declaration              
    change-class       compiled-function-p          declare                  
    char               compiler-macro               decode-float             
    char-code          compiler-macro-function      decode-universal-time    
    char-code-limit    complement                   defclass                 
    char-downcase      complex                      defconstant              
    char-equal         complexp                     defgeneric               
    char-greaterp      compute-applicable-methods   define-compiler-macro    
    char-int           compute-restarts             define-condition         
    char-lessp         concatenate                  define-method-combination  
    char-name          concatenated-stream          define-modify-macro      
    char-not-equal     concatenated-stream-streams  define-setf-expander     
    char-not-greaterp  cond                         define-symbol-macro      
    char-not-lessp     condition                    defmacro                 
    char-upcase        conjugate                    defmethod                
    char/=             cons                         defpackage               
    char<              consp                        defparameter             
    char<=             constantly                   defsetf                  
    char=              constantp                    defstruct                
    char>              continue                     deftype                  
    char>=             control-error                defun                    
    character          copy-alist                   defvar                   
    characterp         copy-list                    delete                   
    check-type         copy-pprint-dispatch         delete-duplicates        
    cis                copy-readtable               delete-file              
    class              copy-seq                     delete-if                
    class-name         copy-structure               delete-if-not            
    class-of           copy-symbol                  delete-package           

Figure 1-6. COMMON-LISP包中的符号 (3/12).

    denominator                    eq                   
    deposit-field                  eql                  
    describe                       equal                
    describe-object                equalp               
    destructuring-bind             error                
    digit-char                     etypecase            
    digit-char-p                   eval                 
    directory                      eval-when            
    directory-namestring           evenp                
    disassemble                    every                
    division-by-zero               exp                  
    do                             export               
    do*                            expt                 
    do-all-symbols                 extended-char        
    do-external-symbols            fboundp              
    do-symbols                     fceiling             
    documentation                  fdefinition          
    dolist                         ffloor               
    dotimes                        fifth                
    double-float                   file-author          
    double-float-epsilon           file-error           
    double-float-negative-epsilon  file-error-pathname  
    dpb                            file-length          
    dribble                        file-namestring      
    dynamic-extent                 file-position        
    ecase                          file-stream          
    echo-stream                    file-string-length   
    echo-stream-input-stream       file-write-date      
    echo-stream-output-stream      fill                 
    ed                             fill-pointer         
    eighth                         find                 
    elt                            find-all-symbols     
    encode-universal-time          find-class           
    end-of-file                    find-if              
    endp                           find-if-not          
    enough-namestring              find-method          
    ensure-directories-exist       find-package         
    ensure-generic-function        find-restart         

Figure 1-7. COMMON-LISP包中的符号 (4/12).

    find-symbol                       get-internal-run-time        
    finish-output                     get-macro-character          
    first                             get-output-stream-string     
    fixnum                            get-properties               
    flet                              get-setf-expansion           
    float                             get-universal-time           
    float-digits                      getf                         
    float-precision                   gethash                      
    float-radix                       go                           
    float-sign                        graphic-char-p               
    floating-point-inexact            handler-bind                 
    floating-point-invalid-operation  handler-case                 
    floating-point-overflow           hash-table                   
    floating-point-underflow          hash-table-count             
    floatp                            hash-table-p                 
    floor                             hash-table-rehash-size       
    fmakunbound                       hash-table-rehash-threshold  
    force-output                      hash-table-size              
    format                            hash-table-test              
    formatter                         host-namestring              
    fourth                            identity                     
    fresh-line                        if                           
    fround                            ignorable                    
    ftruncate                         ignore                       
    ftype                             ignore-errors                
    funcall                           imagpart                     
    function                          import                       
    function-keywords                 in-package                   
    function-lambda-expression        incf                         
    functionp                         initialize-instance          
    gcd                               inline                       
    generic-function                  input-stream-p               
    gensym                            inspect                      
    gentemp                           integer                      
    get                               integer-decode-float         
    get-decoded-time                  integer-length               
    get-dispatch-macro-character      integerp                     
    get-internal-real-time            interactive-stream-p         

Figure 1-8. COMMON-LISP包中的符号 (5/12).

    intern                                  lisp-implementation-type         
    internal-time-units-per-second          lisp-implementation-version      
    intersection                            list                             
    invalid-method-error                    list*                            
    invoke-debugger                         list-all-packages                
    invoke-restart                          list-length                      
    invoke-restart-interactively            listen                           
    isqrt                                   listp                            
    keyword                                 load                             
    keywordp                                load-logical-pathname-translations  
    labels                                  load-time-value                  
    lambda                                  locally                          
    lambda-list-keywords                    log                              
    lambda-parameters-limit                 logand                           
    last                                    logandc1                         
    lcm                                     logandc2                         
    ldb                                     logbitp                          
    ldb-test                                logcount                         
    ldiff                                   logeqv                           
    least-negative-double-float             logical-pathname                 
    least-negative-long-float               logical-pathname-translations    
    least-negative-normalized-double-float  logior                           
    least-negative-normalized-long-float    lognand                          
    least-negative-normalized-short-float   lognor                           
    least-negative-normalized-single-float  lognot                           
    least-negative-short-float              logorc1                          
    least-negative-single-float             logorc2                          
    least-positive-double-float             logtest                          
    least-positive-long-float               logxor                           
    least-positive-normalized-double-float  long-float                       
    least-positive-normalized-long-float    long-float-epsilon               
    least-positive-normalized-short-float   long-float-negative-epsilon      
    least-positive-normalized-single-float  long-site-name                   
    least-positive-short-float              loop                             
    least-positive-single-float             loop-finish                      
    length                                  lower-case-p                     
    let                                     machine-instance                 
    let*                                    machine-type                     

Figure 1-9. COMMON-LISP包中的符号 (6/12).

    machine-version                mask-field                  
    macro-function                 max                         
    macroexpand                    member                      
    macroexpand-1                  member-if                   
    macrolet                       member-if-not               
    make-array                     merge                       
    make-broadcast-stream          merge-pathnames             
    make-concatenated-stream       method                      
    make-condition                 method-combination          
    make-dispatch-macro-character  method-combination-error    
    make-echo-stream               method-qualifiers           
    make-hash-table                min                         
    make-instance                  minusp                      
    make-instances-obsolete        mismatch                    
    make-list                      mod                         
    make-load-form                 most-negative-double-float  
    make-load-form-saving-slots    most-negative-fixnum        
    make-method                    most-negative-long-float    
    make-package                   most-negative-short-float   
    make-pathname                  most-negative-single-float  
    make-random-state              most-positive-double-float  
    make-sequence                  most-positive-fixnum        
    make-string                    most-positive-long-float    
    make-string-input-stream       most-positive-short-float   
    make-string-output-stream      most-positive-single-float  
    make-symbol                    muffle-warning              
    make-synonym-stream            multiple-value-bind         
    make-two-way-stream            multiple-value-call         
    makunbound                     multiple-value-list         
    map                            multiple-value-prog1        
    map-into                       multiple-value-setq         
    mapc                           multiple-values-limit       
    mapcan                         name-char                   
    mapcar                         namestring                  
    mapcon                         nbutlast                    
    maphash                        nconc                       
    mapl                           next-method-p               
    maplist                        nil                         

Figure 1-10. COMMON-LISP包中的符号 (7/12).

    nintersection         package-error                  
    ninth                 package-error-package          
    no-applicable-method  package-name                   
    no-next-method        package-nicknames              
    not                   package-shadowing-symbols      
    notany                package-use-list               
    notevery              package-used-by-list           
    notinline             packagep                       
    nreconc               pairlis                        
    nreverse              parse-error                    
    nset-difference       parse-integer                  
    nset-exclusive-or     parse-namestring               
    nstring-capitalize    pathname                       
    nstring-downcase      pathname-device                
    nstring-upcase        pathname-directory             
    nsublis               pathname-host                  
    nsubst                pathname-match-p               
    nsubst-if             pathname-name                  
    nsubst-if-not         pathname-type                  
    nsubstitute           pathname-version               
    nsubstitute-if        pathnamep                      
    nsubstitute-if-not    peek-char                      
    nth                   phase                          
    nth-value             pi                             
    nthcdr                plusp                          
    null                  pop                            
    number                position                       
    numberp               position-if                    
    numerator             position-if-not                
    nunion                pprint                         
    oddp                  pprint-dispatch                
    open                  pprint-exit-if-list-exhausted  
    open-stream-p         pprint-fill                    
    optimize              pprint-indent                  
    or                    pprint-linear                  
    otherwise             pprint-logical-block           
    output-stream-p       pprint-newline                 
    package               pprint-pop                     

Figure 1-11. COMMON-LISP包中的符号 (8/12).

    pprint-tab                 read-char                   
    pprint-tabular             read-char-no-hang           
    prin1                      read-delimited-list         
    prin1-to-string            read-from-string            
    princ                      read-line                   
    princ-to-string            read-preserving-whitespace  
    print                      read-sequence               
    print-not-readable         reader-error                
    print-not-readable-object  readtable                   
    print-object               readtable-case              
    print-unreadable-object    readtablep                  
    probe-file                 real                        
    proclaim                   realp                       
    prog                       realpart                    
    prog*                      reduce                      
    prog1                      reinitialize-instance       
    prog2                      rem                         
    progn                      remf                        
    program-error              remhash                     
    progv                      remove                      
    provide                    remove-duplicates           
    psetf                      remove-if                   
    psetq                      remove-if-not               
    push                       remove-method               
    pushnew                    remprop                     
    quote                      rename-file                 
    random                     rename-package              
    random-state               replace                     
    random-state-p             require                     
    rassoc                     rest                        
    rassoc-if                  restart                     
    rassoc-if-not              restart-bind                
    ratio                      restart-case                
    rational                   restart-name                
    rationalize                return                      
    rationalp                  return-from                 
    read                       revappend                   
    read-byte                  reverse                     

Figure 1-12. COMMON-LISP包中的符号 (9/12).

    room                          simple-bit-vector                  
    rotatef                       simple-bit-vector-p                
    round                         simple-condition                   
    row-major-aref                simple-condition-format-arguments  
    rplaca                        simple-condition-format-control    
    rplacd                        simple-error                       
    safety                        simple-string                      
    satisfies                     simple-string-p                    
    sbit                          simple-type-error                  
    scale-float                   simple-vector                      
    schar                         simple-vector-p                    
    search                        simple-warning                     
    second                        sin                                
    sequence                      single-float                       
    serious-condition             single-float-epsilon               
    set                           single-float-negative-epsilon      
    set-difference                sinh                               
    set-dispatch-macro-character  sixth                              
    set-exclusive-or              sleep                              
    set-macro-character           slot-boundp                        
    set-pprint-dispatch           slot-exists-p                      
    set-syntax-from-char          slot-makunbound                    
    setf                          slot-missing                       
    setq                          slot-unbound                       
    seventh                       slot-value                         
    shadow                        software-type                      
    shadowing-import              software-version                   
    shared-initialize             some                               
    shiftf                        sort                               
    short-float                   space                              
    short-float-epsilon           special                            
    short-float-negative-epsilon  special-operator-p                 
    short-site-name               speed                              
    signal                        sqrt                               
    signed-byte                   stable-sort                        
    signum                        standard                           
    simple-array                  standard-char                      
    simple-base-string            standard-char-p                    

Figure 1-13. COMMON-LISP包中的符号 (10/12).

    standard-class             sublis                      
    standard-generic-function  subseq                      
    standard-method            subsetp                     
    standard-object            subst                       
    step                       subst-if                    
    storage-condition          subst-if-not                
    store-value                substitute                  
    stream                     substitute-if               
    stream-element-type        substitute-if-not           
    stream-error               subtypep                    
    stream-error-stream        svref                       
    stream-external-format     sxhash                      
    streamp                    symbol                      
    string                     symbol-function             
    string-capitalize          symbol-macrolet             
    string-downcase            symbol-name                 
    string-equal               symbol-package              
    string-greaterp            symbol-plist                
    string-left-trim           symbol-value                
    string-lessp               symbolp                     
    string-not-equal           synonym-stream              
    string-not-greaterp        synonym-stream-symbol       
    string-not-lessp           t                           
    string-right-trim          tagbody                     
    string-stream              tailp                       
    string-trim                tan                         
    string-upcase              tanh                        
    string/=                   tenth                       
    string<                    terpri                      
    string<=                   the                         
    string=                    third                       
    string>                    throw                       
    string>=                   time                        
    stringp                    trace                       
    structure                  translate-logical-pathname  
    structure-class            translate-pathname          
    structure-object           tree-equal                  
    style-warning              truename                    

Figure 1-14. COMMON-LISP包中的符号 (11/12).

    truncate                             values-list               
    two-way-stream                       variable                  
    two-way-stream-input-stream          vector                    
    two-way-stream-output-stream         vector-pop                
    type                                 vector-push               
    type-error                           vector-push-extend        
    type-error-datum                     vectorp                   
    type-error-expected-type             warn                      
    type-of                              warning                   
    typecase                             when                      
    typep                                wild-pathname-p           
    unbound-slot                         with-accessors            
    unbound-slot-instance                with-compilation-unit     
    unbound-variable                     with-condition-restarts   
    undefined-function                   with-hash-table-iterator  
    unexport                             with-input-from-string    
    unintern                             with-open-file            
    union                                with-open-stream          
    unless                               with-output-to-string     
    unread-char                          with-package-iterator     
    unsigned-byte                        with-simple-restart       
    untrace                              with-slots                
    unuse-package                        with-standard-io-syntax   
    unwind-protect                       write                     
    update-instance-for-different-class  write-byte                
    update-instance-for-redefined-class  write-char                
    upgraded-array-element-type          write-line                
    upgraded-complex-part-type           write-sequence            
    upper-case-p                         write-string              
    use-package                          write-to-string           
    use-value                            y-or-n-p                  
    user-homedir-pathname                yes-or-no-p               
    values                               zerop                     

Figure 1-15. COMMON-LISP包中的符号 (12/12).


# 2. 语法

> * 2.1 [字符语法](#CharacterSyntax)
> * 2.2 [读取器算法](#ReaderAlgorithm)
> * 2.3 [token 标记的解释](#InterpretationOfTokens)
> * 2.4 [标准宏字符](#StandardMacroCharacters)

## 2.1 <span id = "CharacterSyntax">字符语法</span>

Lisp 读取器[Lisp reader]从一个流[stream]中读取字符[character], 然后将其解释为一个对象[object]的打印表示, 构建这个对象[object]并且返回它.

这个章节描述的语法称之为标准语法[standard syntax]. Common Lisp 提供了对应操作, 因此可以在程序的控制下修改读取表[readtable]所表示的语法信息的各个方面; 见章节 23 (读取器). 除了明确说明的以外, 这个文档中使用的就是标准语法[standard syntax].

> * 2.1.1 [读取表](#Readtables)
> * 2.1.2 [影响 Lisp 读取器的变量](#VariablesAffectReader)
> * 2.1.3 [标准字符](#StandardCharacters)
> * 2.1.4 [字符语法类型](#CharacterSyntaxTypes)

### 2.1.1 <span id = "Readtables">读取表</span>

Lisp 读取器[Lisp reader]使用的语法信息体现在一个称之为读取表[readtable]的对象[object]中. 此外, 这个读取表[readtable]还包含字符[character]和语法类型[syntax type]之间的关联.

下一块列出了一些适用于读取表的已定义的名字[defined name].

    *readtable*                    readtable-case                
    copy-readtable                 readtablep                    
    get-dispatch-macro-character   set-dispatch-macro-character  
    get-macro-character            set-macro-character           
    make-dispatch-macro-character  set-syntax-from-char          

    Figure 2-1. 读取表已定义的名字

> * 2.1.1.1 [当前的读取表](#CurrentReadtable)
> * 2.1.1.2 [标准读取表](#StandardReadtable)
> * 2.1.1.3 [初始读取表](#InitialReadtable)

#### 2.1.1.1 <span id = "CurrentReadtable">当前的读取表</span>

可以存在一些描述不同语法的读取表[readtable], 但是在任何给定的时间内都只存在一个读取表影响着 Lisp 读取器[Lisp reader]把表达式[expression]解析为对象[object]的方式, 称之为当前读取表[current readtable]. 在一个给定的动态环境[dynamic environment]中的当前读取表[current readtable]是这个环境[environment]中的 \*readtable* 的值[value]. 为了使一个不同的读取表[readtable]成为当前的读取表[current readtable], \*readtable* 可以被赋值或绑定[bound]. 

#### 2.1.1.2 <span id = "StandardReadtable">标准读取表</span>

这个标准读取表[standard readtable]符合标准语法[standard syntax]. 如果尝试去修改标准读取表[standard readtable], 后果是未定义的. 为了实现修改或者扩展标准语法[standard syntax]的效果, 可以去创建一个标准读取表[standard readtable]的副本; 见函数[function] copy-readtable.

标准读取表[standard readtable]的读取表大小写模式[readtable case]是 :upcase. 

#### 2.1.1.3 <span id = "InitialReadtable">初始读取表</span>

初始读取表[initial readtable]是这个 Lisp 镜像[Lisp image]开始时的当前读取表[current readtable]. 在那个时候, 它符合标准语法[standard syntax]. 初始读取表[initial readtable]不同[distinct]于标准读取表[standard readtable]. 一个符合规范的程序[conforming program]去修改初始读取表[initial readtable]是允许的. 

### 2.1.2 <span id = "VariablesAffectReader">影响 Lisp 读取器的变量</span>

Lisp 读取器[Lisp reader]不止受当前读取表[current readtable]所影响, 也被很多动态变量[dynamic variable]所影响. 下面这段就列出了这些影响 Lisp 读取器[Lisp reader]行为的变量[variable].

    *package*    *read-default-float-format*  *readtable*  
    *read-base*  *read-suppress*                           

    Figure 2-2. 影响 Lisp 读取器的变量. 

### 2.1.3 <span id = "StandardCharacters">标准字符</span>

所有实现[implementation]必须支持的一个称之为 standard-char 的字符[character]字元库[repertoire]; 这个字元库[repertoire]中的成员字符[character]称之为标准字符[standard character].

这个 standard-char 字元库[repertoire]由非图形化[non-graphic]字符[character]换行[newline], 图形化[graphic]字符[character]空格[space], 还有以下 94 个图形化[graphic]字符[character]或者它们的等价体构成:

  | 图形ID       | 字形    | 描述         | 图形ID      | 字形    | 描述  |
  | :------:   | :------:| :------:  | :------:  | :------:| :------:|
  |LA01        |a      |小写 a      |LN01        |n      |小写 n      |
  |LA02        |A      |大写 A    |LN02        |N      |大写 N    |
  |LB01        |b      |小写 b      |LO01        |o      |小写 o      |
  |LB02        |B      |大写 B    |LO02        |O      |大写 O    |
  |LC01        |c      |小写 c      |LP01        |p      |小写 p      |
  |LC02        |C      |大写 C    |LP02        |P      |大写 P    |
  |LD01        |d      |小写 d      |LQ01        |q      |小写 q      |
  |LD02        |D      |大写 D    |LQ02        |Q      |大写 Q    |
  |LE01        |e      |小写 e      |LR01        |r      |小写 r      |
  |LE02        |E      |大写 E    |LR02        |R      |大写 R    |
  |LF01        |f      |小写 f      |LS01        |s      |小写 s      |
  |LF02        |F      |大写 F    |LS02        |S      |大写 S    |
  |LG01        |g      |小写 g      |LT01        |t      |小写 t      |
  |LG02        |G      |大写 G    |LT02        |T      |大写 T    |
  |LH01        |h      |小写 h      |LU01        |u      |小写 u      |
  |LH02        |H      |大写 H    |LU02        |U      |大写 U    |
  |LI01        |i      |小写 i      |LV01        |v      |小写 v      |
  |LI02        |I      |大写 I    |LV02        |V      |大写 V    |
  |LJ01        |j      |小写 j      |LW01        |w      |小写 w      |
  |LJ02        |J      |大写 J    |LW02        |W      |大写 W    |
  |LK01        |k      |小写 k      |LX01        |x      |小写 x      |
  |LK02        |K      |大写 K    |LX02        |X      |大写 X    |
  |LL01        |l      |小写 l      |LY01        |y      |小写 y      |
  |LL02        |L      |大写 L    |LY02        |Y      |大写 Y    |
  |LM01        |m      |小写 m      |LZ01        |z      |小写 z      |
  |LM02        |M      |大写 M    |LZ02        |Z      |大写 Z    |

Figure 2-3. 标准字符子表 (Part 1 of 3: 拉丁字母)

  |图形ID       |字形   |描述          |图形ID       |字形   |描述  |
  | :------:   | :------:| :------:  | :------:  | :------:| :------:|
  |ND01        |1      |digit 1      |ND06        |6      |digit 6      |
  |ND02        |2      |digit 2      |ND07        |7      |digit 7      |
  |ND03        |3      |digit 3      |ND08        |8      |digit 8      |
  |ND04        |4      |digit 4      |ND09        |9      |digit 9      |
  |ND05        |5      |digit 5      |ND10        |0      |digit 0      |

Figure 2-4. 标准字符子表 (Part 2 of 3: 数字字符)

  |图形ID       |字形   |描述                              |
  | :------:   | :------:| :------:  |
  |SP02        |!      |感叹号                         |
  |SC03        |$      |美元符号                              |
  |SP04        |"      |引号, 或双引号          |
  |SP05        |'      |撇号, 或 [单] 引号            |
  |SP06        |(      |左圆括号, 或开圆括号    |
  |SP07        |)      |右圆括号, 或闭圆括号  |
  |SP08        |,      |逗号                                    |
  |SP09        |_      |下划线, 或底部线                  |
  |SP10        |-      |连字符, 或减 [号]                  |
  |SP11        |.      |休止符, 句号, 或点                |
  |SP12        |/      |斜线, 或斜杠                        |
  |SP13        |:      |冒号                                    |
  |SP14        |;      |分号                                |
  |SP15        |?      |问号                            |
  |SA01        |+      |加 [号]                              |
  |SA03        |<      |小于 [号]                         |
  |SA04        |=      |等于 [号]                            |
  |SA05        |>      |大于 [号]                      |
  |SM01        |#      |数字符号, 或井[号]              |
  |SM02        |%      |百分 [号]                           |
  |SM03        |&      |和号                                |
  |SM04        |*      |星号, 或星                        |
  |SM05        |@      |单价记号, 或 at-号                |
  |SM06        |[      |左 [方] 括号                    |
  |SM07        |\      |反斜线号, 或反斜杠            |
  |SM08        |]      |右 [方] 括号                   |
  |SM11        |{      |左卷括号, 或左大括号        |
  |SM13        ||      |竖杠                             |
  |SM14        |}      |右卷括号, 或右大括号      |
  |SD13        |`      |沉音符, 或反引号               |
  |SD15        |^      |抑扬音符号                        |
  |SD19        |~      |波浪符号                                    |

Figure 2-5. 标准字符子表 (Part 3 of 3: 特殊字符)

这个图形ID(图形ID)在 Common Lisp 中不可用, 但是为了和 ISO 6937/2 交叉引用的目的而提供. 注意图形ID(图形ID)的第一个字母把字符分成以下几类: L---Latin, N---Numeric, S---Special.

### 2.1.4 <span id = "CharacterSyntaxTypes">字符语法类型</span>

Lisp 读取器[Lisp reader]通过根据语法类型[syntax type]解释输入文本的每一个字符[character]来构建一个对象[object]. Lisp 读取器[Lisp reader]不能接受 Lisp 打印器[Lisp printer]所生成的所有内容, 并且 Lisp 读取器[Lisp reader]包含了不能被 Lisp 打印器[Lisp printer]所使用的特性. Lisp 读取器[Lisp reader]可以用作更通用的用户编写的解析器的词法分析器.

当 Lisp 读取器[Lisp reader]被调用, 它从输入[input]流[stream]中读取单个字符并且根据这个字符[character]的语法类型[syntax type]分派它. 每个出现在输入[input]流[stream]中的字符[character]都是 Figure 2-6 中出现的语法类型[syntax type]中的一个.

    constituent  macro character  single escape  
    invalid      multiple escape  whitespace[2]  

    Figure 2-6. 可能的字符语法类型

一个字符[character]在读取表[readtable]中的语法类型[syntax type]决定了当这个读取表[readtable]是当前读取表[current readtable]时 Lisp 读取器[[Lisp reader]]如何解释这个字符. 在任何给定的时间, 每个字符都有一个确定的语法类型.

Figure 2-7 列出了每个字符[character]在标准语法[standard syntax]中的语法类型[syntax type].

  字符       | 语法类型                    | 字符       | 语法类型  
  | :------:| :------:                   | :------:  | :------:  |           
  Backspace | constituent                | 0--9      | constituent             
  Tab       | whitespace[2]              | :         | constituent             
  Newline   | whitespace[2]              | ;         | terminating macro char  
  Linefeed  | whitespace[2]              | <         | constituent             
  Page      | whitespace[2]              | =         | constituent             
  Return    | whitespace[2]              | >         | constituent             
  Space     | whitespace[2]              | ?         | constituent*            
  !         | constituent*               | @         | constituent             
  "         | terminating macro char     | A--Z      | constituent             
  \#         | non-terminating macro char | [         | constituent*            
  $         | constituent                | \         | single escape           
  %         | constituent                | ]         | constituent*            
  &         | constituent                | ^         | constituent             
  '         | terminating macro char     | _         | constituent             
  (         | terminating macro char     | `         | terminating macro char  
  )         | terminating macro char     | a--z      | constituent             
  \*         | constituent                | {         | constituent*            
  \+         | constituent                | |         | multiple escape         
  ,         | terminating macro char     | }         | constituent*            
  \-         | constituent                | ~         | constituent             
  .         | constituent                | Rubout    | constituent             
  /         | constituent                |           |

    Figure 2-7. 标准语法中的字符语法类型

用星号(*)标记的字符是最初的标记成分[constituent], 但是它们不被用于任何标准的 Common Lisp 标记中. 这些字符被明确地地保留给程序员[programmer]. ~ 不被用于 Common Lisp, 保留给实现者. $ 和 % 是字母[alphabetic[2]]字符[character], 但是不被用于任何标准 Common Lisp 已定义名字[defined name]的名字.

空白[Whitespace[2]]字符充当分隔符, 但在其他情况下被忽略. 标记成分[constituent]和转义[escape]字符[character]被累计起来, 以使其成为一个被解释为一个数字[number]或一个符号[symbol]的标记[token]. 宏字符[macro character]触发对函数[function]的调用(可能是用户提供的), 可以执行任意的解析操作. 宏字符[macro character]被分为2种, 终止[terminating]和非终止[non-terminating]的, 取决于它们是否会终结一个标记[token]. 以下是每一种语法类型[syntax type]的描述.

> * 2.1.4.1 [标记成分字符](#ConstituentCharacters)
> * 2.1.4.2 [标记成分特质](#ConstituentTraits)
> * 2.1.4.3 [非法字符](#InvalidCharacters)
> * 2.1.4.4 [宏字符](#MacroCharacters)
> * 2.1.4.5 [多转义字符](#MultipleEscapeCharacters)
> * 2.1.4.6 [单转义字符](#SingleEscapeCharacter)
> * 2.1.4.7 [空白字符](#WhitespaceCharacters)

#### 2.1.4.1 <span id = "ConstituentCharacters">标记成分字符</spans>

标记成分[constituent]字符[character]被用于标记[token]中. 一个标记[token]是一个数字[number]或符号[symbol]的表示. 字母和数字就是标记成分[constituent]字符[character]的示例.

当符号名被读取时, 其中的字母有时会被转换成大小写[case]相反的字母; 见章节 23.1.2 (Lisp 读取器上的读取表大小写的影响). 大小写[case]转换可以通过使用单转义[single escape]或多转义[multiple escape]字符抑制.

#### 2.1.4.2 <span id = "ConstituentTraits">标记成分特质</span>

每个字符[character]都有一个或多个标记成分特质[constituent trait], 它们定义了当这个字符[character]是标记成分[constituent]字符[character]时如何被 Lisp 读取器[Lisp reader]解释. 这些标记成分特质[constituent trait]是字母[alphabetic[2]], 数字, 包标记[package marker], 加号, 减号, 点, 小数点, 比率标记[ratio marker], 指数标记[exponent marker], 还有非法[invalid]. Figure 2-8 展示了标准字符[standard characters]和不完全标准[semi-standard]字符[character]的标记成分特质[constituent trait]; 没有为改变字符[character]的标记成分特质[constituent trait]提供机制. 如果当前输入基数[current input base]大于一个字符的数字值, 那么任何具有字母数字(alphadigit)标记成分特质[constituent trait]的字符[character]都是一个数字, 否则字符[character]是字母[alphabetic[2]]. 任何被单转义符[single escape]引用的字符, 不管它正常的语法, 都被当作字母[alphabetic[2]]标记成分.
                                                                                    
  标记成分字符 | 特质                    | 标记成分字符 | 特质  
  | :------:| :------:                   | :------:  | :------:  |  
  Backspace |   invalid                | {           |  alphabetic[2]
  Tab       |   invalid*               | }           |  alphabetic[2] 
  Newline   |   invalid*               | +           |  alphabetic[2], plus sign   
  Linefeed  |   invalid*               | -           |  alphabetic[2], minus sign
  Page      |   invalid*               | .           |  alphabetic[2], dot, decimal point  
  Return    |   invalid*               | /           |  alphabetic[2], ratio marker  
  Space     |   invalid*               | A, a        |  alphadigit 
  !         |   alphabetic[2]          | B, b        |  alphadigit  
  "         |   alphabetic[2]*         | C, c        |  alphadigit    
  \#         |   alphabetic[2]*         | D, d        |  alphadigit, double-float exponent marker
  $         |   alphabetic[2]          | E, e        |  alphadigit, float exponent marker 
  %         |   alphabetic[2]          | F, f        |  alphadigit, single-float exponent marker
  &         |   alphabetic[2]          | G, g        |  alphadigit  
  '         |   alphabetic[2]*         | H, h        |  alphadigit  
  (         |   alphabetic[2]*         | I, i        |  alphadigit   
  )         |   alphabetic[2]*         | J, j        |  alphadigit    
  \*         |   alphabetic[2]          | K, k        |  alphadigit 
  ,         |   alphabetic[2]*         | L, l        |  alphadigit, long-float exponent marker 
  0-9       |   alphadigit             | M, m        |  alphadigit 
  :         |   package marker         | N, n        |  alphadigit 
  ;         |   alphabetic[2]*         | O, o        |  alphadigit   
  <         |   alphabetic[2]          | P, p        |  alphadigit 
  =         |   alphabetic[2]          | Q, q        |  alphadigit   
  \>         |   alphabetic[2]          | R, r        |  alphadigit   
  ?         |   alphabetic[2]          | S, s        |  alphadigit, short-float exponent marker
  @         |   alphabetic[2]          | T, t        |  alphadigit    
  [         |   alphabetic[2]          | U, u        |  alphadigit   
  \         |   alphabetic[2]*         | V, v        |  alphadigit  
  ]         |   alphabetic[2]          | W, w        |  alphadigit  
  ^         |   alphabetic[2]          | X, x        |  alphadigit 
  _         |   alphabetic[2]          | Y, y        |  alphadigit    
  `         |   alphabetic[2]*         | Z, z        |  alphadigit   
  |         |   alphabetic[2]*         | Rubout      |  invalid    
  ~         |   alphabetic[2]          |             |
                                                                                    
Figure 2-8. 标准字符和不完全标准字符的构成成分特性

这个表中的解释方式只应用于语法类型[syntax type]为标记成分[constituent]的字符[character]. 标记了星号 (*) 的条目正常是被屏蔽[shadow[2]]的, 因为这些表示的字符[character]是空白[whitespace], 宏字符[macro character], 单转义[single escape], 或者多转义[multiple escape]语法类型[syntax type]; 只有当它们的语法类型被改变为标记成分[constituent]时, 这些标记成分特质[constituent trait]才适用于它们. 

#### 2.1.4.3 <span id = "InvalidCharacters">非法字符</span>

带有标记成分特质[constituent trait]无效[invalid]的字符[character]不能出现在标记[token]里, 除非在单转义[single escape]字符[character]的控制下. 如果一个对象[object]被读取时遇到一个无效[invalid]字符[character], 会发出一个 reader-error 类型[type]的错误. 如果一个无效[invalid]字符[character]前有一个单转义[single escape]字符[character], 它会被当作字母[alphabetic[2]]标记成分[constituent]. 

#### 2.1.4.4 <span id = "MacroCharacters">宏字符</span>

当 Lisp 读取器[Lisp reader]从输入[input]流[stream]中读入一个宏字符[macro character]时, 将对输入[input]流[stream]中的后续字符[character]进行特殊解析.

一个宏字符[macro character]有一个关联的函数[function]称之为读取器宏函数[reader macro function]实现了它专门的解析行为. 一个这样的关联可以在一个符合规范的程序[conforming program]的控制下通过使用函数[function] set-macro-character 和 set-dispatch-macro-character 来建立和修改.

遇到一个宏字符[macro character]时, 这个 Lisp 读取器[Lisp reader]会调用它的读取器宏函数[reader macro function], 它从输入[input]流[stream]中解析一个经过特殊格式化的对象. 这个函数[function]也返回解析后的对象[object], 或者它不返回值[value]表示函数[function]扫描的这些字符被忽略了 (比如, 在注释的情况下). 宏字符[macro character]的示例是反引号[backquote], 单引号[single-quote], 左圆括号[left-parenthesis], 还有右圆括号[right-parenthesis].

宏字符[macro character]要么是终止的[terminating], 要么是非终止的[non-terminating]. 终止的[terminating]和非终止的[non-terminating]宏字符[macro character]的区别在于当这些字符出现在标记[token]中间时, 会发生什么. 如果一个非终止的[non-terminating]宏字符[macro character]出现在标记[token]中, 这个非终止的[non-terminating]宏字符[macro character]关联的函数[function]不会被调用, 并且这个非终止的[non-terminating]宏字符[macro character]不终结这个标记[token]的名字; 它就好像这个宏字符[macro character]真的是一个标记成分字符一样成为这个名字的一部分. 一个终止的[terminating]宏字符[macro character]会终结任何标记[token], 并且它关联的读取器宏函数[reader macro function]会被调用, 无论这个字符[character]出现在哪里. 在标准语法[standard syntax]中唯一个非终止的[non-terminating]宏字符[macro character]是#号[sharpsign].

如果一个字符[character]是一个分派宏字符[dispatching macro character] C1, 它的读取器宏函数[reader macro function]是一个具体实现[implementation]提供的函数[function]. 这个函数[function]读取十进制数字[digit]字符[character]直到读取到一个非数字的 C2. 如果读取到任何数字[digit], 它们转化为一个对应的整数[integer]中缀的参数 P; 否则, 这个中缀参数 P 就是 nil. 这个终止的非数字 C2 是一个与分派宏字符[dispatching macro character] C1 相关联的分派表中查找到的字符 (有时被称为"子字符(sub-character)", 以强调其在分派中的从属角色) . 与子字符 C2 关联的这个读取器宏函数[[reader macro function]]调用需要三个参数: 流[stream], 子字符 C2, 还有中缀参数 P. 关于分派字符的更多信息, 见函数[function] set-dispatch-macro-character.

关于标准语法[standard syntax]中可用的宏字符[macro character]的信息, 见章节 2.4 (标准宏字符). 

#### 2.1.4.5 <span id = "MultipleEscapeCharacters">多转义字符</span>

一对多转义[multiple escape]字符[character]用于指明一个可能包含宏字符[macro character]和空白[whitespace[2]]字符[character]的闭合字符序列被认为是保持大小写[case]的字母[alphabetic[2]]字符[character]. 在序列中出现的任何单转义字符和多转义字符都必须有一个转义字符.

竖杠[vertical-bar]是标准语法[standard syntax]中的一个多转义[multiple escape]字符[character].

##### 2.1.4.5.1 多转义字符的示例

```LISP
 ;; The following examples assume the readtable case of *readtable* 
 ;; and *print-case* are both :upcase.
 (eq 'abc 'ABC) =>  true
 (eq 'abc '|ABC|) =>  true
 (eq 'abc 'a|B|c) =>  true
 (eq 'abc '|abc|) =>  false
```

#### 2.1.4.6 <span id = "SingleEscapeCharacter">单转义字符</span>

一个单转义符[single escape]被用于表明下一个字符[character]被当作字母[alphabetic[2]]字符[character]处理, 保留大小写[case], 无论它是什么字符[character]或者它由什么标记成分特质[constituent trait].

反斜杠[backslash]是标准语法[standard syntax]中一个单转义[single escape]字符[character].

##### 2.1.4.6.1 单转义字符示例

```LISP
 ;; The following examples assume the readtable case of *readtable* 
 ;; and *print-case* are both :upcase.
 (eq 'abc '\A\B\C) =>  true
 (eq 'abc 'a\Bc) =>  true
 (eq 'abc '\ABC) =>  true
 (eq 'abc '\abc) =>  false
```

#### 2.1.4.7 <span id = "WhitespaceCharacters">空白字符</span>

空白[whitespace[2]]字符[character]被用于分隔多个标记[token].

空格[space]和换行[newline]是标准语法[standard syntax]中的空白[whitespace[2]]字符[character].

##### 2.1.4.7.1 空白字符的示例

```LISP
 (length '(this-that)) =>  1
 (length '(this - that)) =>  3
 (length '(a
           b)) =>  2
 (+ 34) =>  34
 (+ 3 4) =>  7
```

## 2.2 <span id = "ReaderAlgorithm">读取器算法</span>

这个章节描述了 Lisp 读取器[Lisp reader]用来从输入[input]字符[character]流[stream]中解析对象[object]的算法规则, 包括 Lisp 读取器[Lisp reader]如何处理宏字符[macro character].

当处理标记[token]时, 读取器的基本功能是区分符号[symbol]和数字[number]的表示. 当累积到一个标记[token]时, 如果它满足 Figure 2-9 中列出的数字语法就被假定为数字[number]. 如果它不是表示一个数字[number], 但它满足潜在数字[potential number]的语法规则就会被当作潜在数字[potential number]. 如果一个有效标记[token]既不是数字[number]表示也不是一个潜在数字[potential number], 它表示一个符号[symbol].

Lisp 读取器[Lisp reader]使用的算法规则如下:

1. 如果到了文件末尾, end-of-file 处理将按照 read 中所指定的执行. 否则, 将从输入[input]流[stream]中读取到一个字符[character], x, 并且根据 x 的语法类型[syntax type]被分派到 2 至 7 中的一个步骤.

2. 如果 x 是一个无效[invalid]字符[character], 发出一个 reader-error 类型[type]的错误. 

3. 如果 x 是一个空白[whitespace[2]]字符[character], 它会被丢弃并且会再次进入步骤 1.

4. 如果 x 是一个终止的[terminating]或非终止的[non-terminating]宏字符[macro character], 那么它的关联的读取器宏函数[reader macro function]会用两个实参[argument], 输入[input]流[stream] 和 x, 来调用.

    这个读取器宏函数[reader macro function]可能从输入[input]流[stream]中读取字符[character]; 如果它这么做了, 会看到跟在那个宏字符[macro character]后的那些字符[character]. Lisp 读取器[Lisp reader]可能会从这个读取器宏函数[reader macro function]被递归调用.

    除了在这个输入[input]流[stream]以外, 这个读取器宏函数[reader macro function]一定没有任何副作用; 由于对这个 read 操作的回溯和重启, Lisp 读取器[Lisp reader]的前端 (比如, "编辑器(editor)" 和 "抹掉处理程序(rubout handler)") 可能导致在 x 只出现一次的单个表达式[expression]的读取期间这个读取器宏函数[reader macro function]被重复调用.

    这个读取器宏函数[reader macro function]可能返回零个或者一个值. 如果返回一个值, 那么这个返回的值就是这个读取操作的结果; 这个读取算法规则结束. 如果没有返回值, 然后会再次进入步骤 1.

5. 如果 x 是一个单转义[single escape]字符[character], 那么下一个字符[character] y 会被读取或者在文件末尾时发出一个 end-of-file 类型[type]的错误. y 被当作一个标记成分[constituent], 它的唯一的标记成分特质[constituent trait]是字母[alphabetic[2]]. y 被用于开始一个标记[token], 并且进入步骤 8.

6. 如果 x 是一个多转义[multiple escape]字符[character], 那么就会开始一个标记[token] (初始不包含字符[character])并且进入步骤 9.

7. 如果 x 是一个标记成分[constituent]字符[character], 它就会开始一个标记[token]. 在这个标记[token]被读取后, 它会被解释为一个 Lisp 对象[object]或者一个无效的语法. 如果这个标记[token]表示一个对象[object], 就会返回这个对象[object]作为这个读取操作的结果. 如果这个标记[token]是一个无效的语法, 就会发出一个错误. 如果 x 是一个带有大小写[case]的字符[character], 它可能会被替换为相反大小写[case]的对应字符[character], 取决于当前读取表[current readtable]的读取表[readtable case], 就像章节 23.1.2 (Lisp 读取器上的读取表大小写的影响) 阐述的一样. x 被用于开始一个标记[token], 并且进入步骤 8.

8. 此时正在累积一个标记[token], 并且已经遇到偶数个多转义[multiple escape]字符[character]. 如果到了文件的末尾, 就进入步骤 10. 否则, 一个字符[character], y, 被读入, 并且根据它的语法类型[syntax type]以下操作之一会被执行:

    * 如果 y 是一个标记成分[constituent] 或者一个非终止[non-terminating]宏字符[macro character]:

        -- 如果 y 是一个带有大小写[case]的字符[character], 它可能会被替换为相反大小写[case]的对应字符[character], 取决于当前读取表[current readtable]的读取表[readtable case], 就像章节 23.1.2 (Lisp 读取器上的读取表大小写的影响)阐述的一样.
        -- Y 被追加到正在构建的对应标记[token]中.
        -- 重复步骤 8.

    * 如果 y 是一个单转义[single escape]字符[character], 那么下一个字符[character] z 会被读取或者在文件末尾时发出一个 end-of-file 类型[type]的错误. z 被认为是一个标记成分[constituent], 它的唯一的标记成分特质[constituent trait]是字母[alphabetic[2]]. z 会被追加到正在被构建的标记[token]中, 并且重复步骤 8.

    * 如果 y 是一个多转义[multiple escape]字符[character], 就会进入步骤 9.

    * 如果 y 是一个非法[invalid]字符[character], 一个 reader-error 类型[type]的错误就会被发出.

    * 如果 y 是一个终止的[terminating]宏字符[macro character], 它会终止这个标记[token]. 首先这个字符[character] y 会被撤销读取(见 unread-char), 然后进入步骤 10.

    * 如果 y 是一个空白[whitespace[2]]字符[character], 它会终止这个标记[token]. 首先如果合适的话这个字符 y 会被撤销读取(见 read-preserving-whitespace), 然后进入步骤10.

9. 此时正在累积一个标记[token], 并且已经遇到奇数个多转义[multiple escape]字符[character]. 如果到了文件的末尾就会发出一个 end-of-file 类型[type]的错误. 否则, 一个字符[character], y, 会被读取, 并且根据它的语法类型[syntax type]以下操作之一会被执行:

    * 如果 y 是一个标记成分[constituent], 宏, 或者空白[whitespace[2]]字符[character], y 被认为是一个标记成分[constituent], 并且它唯一的标记成分特质[constituent trait]是字母[alphabetic[2]]. y 被追加到正在被构建的标记[token]中, 然后重复步骤 9.

    * 如果 y 是一个单转义[single escape]字符[character], 那么下一个字符[character] z 会被读取或者在文件末尾时发出一个 end-of-file 类型[type]的错误. z 被当作一个标记成分[constituent], 它的唯一的标记成分特质[constituent trait]是字母[alphabetic[2]]. z 被追加到正在被构建的标记[token], 并且重复步骤 9.

    * 如果 y 是一个多转义[multiple escape]字符[character], 那么进入步骤 8.

    * 如果 y 是个非法[invalid]字符[character], 会发出一个类型[type]为 reader-error 的错误.

10. 已经累积到一个完整的标记[token]. 这个标记[token]表示的对象[object]作为这个读取操作的结果返回, 如果这个标记[token]不是有效语法的就发出一个 reader-error 类型[type]的错误. 

## 2.3 <span id = "InterpretationOfTokens">token 标记的解释</span>

> * 2.3.1 [数字标记](#NumbersAsTokens)
> * 2.3.2 [从标记构建数字](#ConstructingNumbersFromTokens)
> * 2.3.3 [点对](#TheConsingDot)
> * 2.3.4 [符号标记](#SymbolsAsTokens)
> * 2.3.5 [标记的合法模式](#ValidPatternsForTokens)
> * 2.3.6 [包系统一致性规则](#PackageSystemConsistencyRules)

### 2.3.1 <span id = "NumbersAsTokens">数字标记</span>

当一个标记[token]被读取, 它被解释为一个数字[number]或符号[symbol]. 如果这个标记[token]满足下面这段指定的数字语法, 它就被解释为数字[number].

    numeric-token  ::=  integer |
              ratio   |
              float       
    integer        ::=  [sign]
              decimal-digit+
              decimal-point |
              [sign]
              digit+      
    ratio          ::=  [sign]
              {digit}+
              slash
              {digit}+    
    float          ::=  [sign]
              {decimal-digit}*
              decimal-point
              {decimal-digit}+
              [exponent]  
                        | 
              [sign]
              {decimal-digit}+
              [decimal-point
                {decimal-digit}*]
              exponent    
    exponent       ::=  exponent-marker
              [sign]
              {digit}+ 
                                          
    sign--- 一个正负号[sign].                         
    slash--- 一个斜杠[slash]
    decimal-point--- 一个点[dot].                        
    exponent-marker--- 一个指数标记[exponent marker].                        
    decimal-digit--- 一个基数[radix] 10 的数[digit].                        
    digit--- 一位当前输入基数的数[digit].                        

Figure 2-9. 数字标记的语法

#### 2.3.1.1 潜在数字作为标记

为了允许实现者和未来 Common Lisp 标准去扩展数字的语法, 定义了一个比数字语法更通用的潜在数字语法. 如果一个标记[token]满足下面的所有需求它就是一个潜在数字[potential number]:

1. 这个标记[token]完全由数字[digit], 正负号[sign], 比率标记[ratio marker], 小数点(.), 扩展字符(^ 或 _), 还有数字标记构成. 一个数字标记是一个字母. 一个字母是否会被当作数字标记取决于上下文, 但是与其他字母相邻的字母不能被视为数字标记. 指数标记[exponent marker]也是数字标记.

2. 这个标记[token]包含了至少一个数字. 根据当前输入基数[current input base], 字母可能被认为是数字, 但只在没有小数点的标记[token]中.

3. 这个标记[token]以一个数字[digit], 正负号[sign], 小数点或扩展字符开始, 但不是包标记[package marker]. 涉及一个前导包标记[package marker]后面跟着潜在数字[potential number]的语法还没有定义完善. 在一个期望适合于 read 的表达式的地方使用例如:1, :1/2, 还有 :2^3 的后果是未知的.

4. 这个标记[token]不能以一个正负号结尾.

如果一个潜在数字[potential number]有数字语法, 这个数字[number]在一个实现中是可被表示的, 会创建一个适当类型的数字[number]并且返回. 如果一个数字[number]超出了由依赖于具体实现的[implementation-dependent]数字[number]常量所设定的界限, 那么它在实现中是不能被表示的. 比如, 为浮点数[float]指定太大或太小的指数可能会使该实现中的那个数字[number]无法表示. 一个带有分母为零的比率[ratio] (比如 -35/000) 在任何实现中都是不能表示的. 当一个带有数字语法的标记[token]不能被转化为一个内置的数字[number]时, 会发出一个 reader-error 类型[type]的错误. 为一个浮点数指定太多有效数字一定不会发出一个错误; 应该生成一个截断的或者舍入的值.

如果出现字母应该被当作一个数字还是数字标记的歧义, 那么字母就被当作数字来对待.

##### 2.3.1.1.1 转义字符和潜在数字

一个潜在数字[potential number]不能包含任何转义[escape]字符[character]. 一个转义[escape]字符[character]剥夺了后面字符的所有语法特性, 迫使其严格转成字母[alphabetic[2]], 因此不适用于潜在数字[potential number]. 比如, 以下所有表示会被解释成符号[symbol], 而不是数字[number]:

     \256   25\64   1.0\E6   |100|   3\.14159   |3/4|   3\/4   5||

在每一个示例中, 移除单个转义[escape]字符[character] (或多个) 会导致标记被转成潜在数字[potential number]. 

##### 2.3.1.1.2 潜在数字示例

作为示例, 下面这一段的这些标记[token]是潜在数字[potential number], 但是它们实际上不是数字, 所以是保留的标记[token]; 一个符合规范的实现[conforming implementation]允许但不是必须去定义它们的意义.

    1b5000                       777777q                1.7J  -3/4+6.7J  12/25/83  
    27^19                        3^4/5                  6//7  3.1.2.6    ^-43^     
    3.141_592_653_589_793_238_4  -3.7+2.6i-6.17j+19.6k  

Figure 2-10. 保留标记的示例

下面这段里的这些标记[token]不是潜在数字[potential number]; 它们总是被当作符号[symbol]:

    /     /5     +  1+  1-   
    foo+  ab.cd  _  ^   ^/-  

Figure 2-11. 符号的示例

如果当前输入基数[current input base]是 16, 那么下面这段里的这些标记[token]就是潜在数字[potential number], 如果当前输入基数[current input base]是 10, 那么它们总是被当作符号[symbol].

    bad-face  25-dec-83  a/b  fad_cafe  f^  

Figure 2-12. 符号或潜在数字的示例

### 2.3.2 <span id = "ConstructingNumbersFromTokens">从标记构建数字</span>

一个实数[real]是由对应数字标记[token]直接构造的; 见 Figure 2-9.

一个复数[complex]被表示为一个 #C (或 #c) 跟着两个实数的列表[list]; 见章节 2.4.8.11 (井号C(#C)).

读取器宏[reader macro] #B, #O, #X, 和 #R 对于控制解析有理数[rational]所用的输入基数[radix]可能也是有用的; 见章节 2.4.8.7 (井号B(#B)), 章节 2.4.8.8 (井号O(#O)), 章节 2.4.8.9 (井号X(#X)), 还有章节 2.4.8.10 (井号R(#R)).

本节概述了数字[number]的完整语法.

> * 2.3.2.1 [有理数语法](#SyntaxRational)
> * 2.3.2.2 [浮点数的语法](#SyntaxFloat)
> * 2.3.2.3 [复数的语法](#SyntaxComplex)

#### 2.3.2.1 <span id = "SyntaxRational">有理数语法</span>

##### 2.3.2.1.1 一个整数的语法

整数[integer]可以写成多个数字[digit]的序列, 前面可以选择性地有一个正负号[sign], 然后还可以选择性地有一个小数点; 见 Figure 2-9. 当使用了一个小数点时, 这些数字[digit]采用的基数[radix]为 10; 当没有使用小数点时, 这个数字采取的基数就是当前输入基数[current input base].

关于整数[integer]如何被打印的信息, 见章节 22.1.3.1.1 (打印整数). 

##### 2.3.2.1.2 一个比率的语法

比率[ratio]可以写成一个可选的正负号[sign]后面跟着两个由斜杠[slash]分隔的非空数字[digit]序列; 见 Figure 2-9. 第二个序列可能不是完全由0组成的. 下一段是比率[ratio]的示例.

    2/3                 ;This is in canonical form                  
    4/6                 ;A non-canonical form for 2/3               
    -17/23              ;A ratio preceded by a sign                 
    -30517578125/32768  ;This is (-5/2)^15                          
    10/5                ;The canonical form for this is 2           
    #o-101/75           ;Octal notation for -65/61                  
    #3r120/21           ;Ternary notation for 15/7                  
    #Xbc/ad             ;Hexadecimal notation for 188/173           
    #xFADED/FACADE      ;Hexadecimal notation for 1027565/16435934  

Figure 2-13. 比率的示例

关于比率[ratio]如何被打印的信息, 见章节 22.1.3.1.2 (打印比率). 

#### 2.3.2.2 <span id = "SyntaxFloat">浮点数的语法</span>

浮点数[float]可以用十进制小数或计算机化科学记法来表示: 一个可选的正负号, 然后是一个带有内嵌小数点的非空序列, 然后是一个可选的十进制指数说明符. 如果没有指数说明符, 那么这个小数点是必须的, 并且在它后面要有个数字. 这个指数说明符由一个指数标记[exponent marker], 一个可选的正负号, 还有一个非空的数字序列组成. 如果没有指数说明符, 或者指数标记[exponent marker]用的是 e (或 E), 使用 \*read-default-float-format* 指定的格式. 见 Figure 2-9.

一个具体实现可能提供一种或多种浮点数[float]来共同构建 float 类型[type]. 字母 s, f, d, 和 l (或者它们的大写等价体) 分别显式指定 short-float, single-float, double-float, 和 long-float 类型[type]的使用.

用于扩展表示的内部格式仅依赖于指数标记[exponent marker], 而不依赖于扩展表示中的十进制数字的数量.

下面这块包含了浮点数的标记示例:

    0.0       ;Floating-point zero in default format                          
    0E0       ;As input, this is also floating-point zero in default format.  
              ;As output, this would appear as 0.0.                           
    0e0       ;As input, this is also floating-point zero in default format.  
              ;As output, this would appear as 0.0.                           
    -.0       ;As input, this might be a zero or a minus zero,                
              ; depending on whether the implementation supports              
              ; a distinct minus zero.                                        
              ;As output, 0.0 is zero and -0.0 is minus zero.                 
    0.        ;On input, the integer zero---not a floating-point number!      
              ;Whether this appears as 0 or 0. on output depends              
              ;on the value of *print-radix*.                                 
    0.0s0     ;A floating-point zero in short format                          
    0s0       ;As input, this is a floating-point zero in short format.       
              ;As output, such a zero would appear as 0.0s0                   
              ; (or as 0.0 if short-float was the default format).            
    6.02E+23  ;Avogadro's number, in default format                           
    602E+21   ;Also Avogadro's number, in default format                      

Figure 2-14. 浮点数示例

关于浮点数[float]如何打印的信息, 见章节 22.1.3.1.3 (打印浮点数). 

#### 2.3.2.3 <span id = "SyntaxComplex">复数的语法</span>

一个复数[complex]有一个笛卡尔结构, 带有一个实数部分和一个虚数部分, 其中每一个部分都是实数[real]表示. 一个复数[complex]的各个部分没有必要一定是浮点数[float]但是每个部分必须是一样的类型[type]: 都是有理数[rational], 或者都是相同的浮点数[float]子类型[subtype]. 当构建一个复数[complex]时, 如果指定的部分不是相同的类型[type], 这些部分在内部会被转换为相同的类型[type] (换句化说, 有理数[rational]部分被转化为一个浮点数[float]). 如果一个 (complex rational) 类型的对象[object]的虚部是一个值为 0 的整数[integer], 那么它在内部被转换, 并且此后被表示为一个有理数[rational].

关于进一步的信息, 见章节 2.4.8.11 (井号C(#C)) 还有章节 22.1.3.1.4 (打印复数). 

### 2.3.3 <span id = "TheConsingDot">点对</span>

如果一个标记[token]仅由点组成 (没有转义字符), 会发出一个 reader-error 类型[type]的错误, 除了在一种情况下: 如果标记[token]是一个单独的点[dot], 并且出现在点状对[dotted pair]标记允许一个点[dot]的情况中, 那么它就被接受作为这种语法的一部分, 并且不发出错误. 见章节 2.4.1 (左圆括号). 

### 2.3.4 <span id = "SymbolsAsTokens">符号标记</span>

任何不是潜在数字[potential number], 不包含包标记符[package marker], 也不是完全由点构成的标记[token]总是被解释为一个符号[symbol]. 任何是一个潜在数字[potential number]但是不符合数字语法的标记[token]作为保留标记[token]并且有着依赖于具体实现的[implementation-dependent]解释. 在所有其他情况下, 标记[token]被解释为一个符号[symbol]的名称.

下一段中有着符号[symbol]的打印表示. 为了表示的简单性, 这些示例假定当前读取表[current readtable]的读取表大小写[readtable case]是 :upcase.

    FROBBOZ         The symbol whose name is FROBBOZ.                
    frobboz         Another way to notate the same symbol.           
    fRObBoz         Yet another way to notate it.                    
    unwind-protect  A symbol with a hyphen in its name.              
    +$              The symbol named +$.                             
    1+              The symbol named 1+.                             
    +1              This is the integer 1, not a symbol.             
    pascal_style    This symbol has an underscore in its name.       
    file.rel.43     This symbol has periods in its name.             
    \(              The symbol whose name is (.                      
    \+1             The symbol whose name is +1.                     
    +\1             Also the symbol whose name is +1.                
    \frobboz        The symbol whose name is fROBBOZ.                
    3.14159265\s0   The symbol whose name is 3.14159265s0.           
    3.14159265\S0   A different symbol, whose name is 3.14159265S0.  
    3.14159265s0    A possible short float approximation to <PI>.    

Figure 2-15. 符号的打印表示示例 (Part 1 of 2)

    APL\\360            The symbol whose name is APL\360.       
    apl\\360            Also the symbol whose name is APL\360.  
    \(b^2\)\-\4*a*c     The name is (B^2) - 4*A*C.              
                        Parentheses and two spaces in it.       
    \(\b^2\)\-\4*\a*\c  The name is (b^2) - 4*a*c.              
                        Letters explicitly lowercase.           
    |"|                 The same as writing \".                 
    |(b^2) - 4*a*c|     The name is (b^2) - 4*a*c.              
    |frobboz|           The name is frobboz, not FROBBOZ.       
    |APL\360|           The name is APL360.                     
    |APL\\360|          The name is APL\360.                    
    |apl\\360|          The name is apl\360.                    
    |\|\||              Same as \|\| ---the name is ||.         
    |(B^2) - 4*A*C|     The name is (B^2) - 4*A*C.              
                        Parentheses and two spaces in it.       
    |(b^2) - 4*a*c|     The name is (b^2) - 4*a*c.              

Figure 2-16. 符号的打印表示示例 (Part 2 of 2)

在解析一个符号[symbol]的过程中, 哪些具体实现定义[implementation-defined]的属性[attribute]会从组成一个表示符号[symbol]的标记[token]的这些字符[character]中被移除, 是依赖于具体实现的[implementation-dependent].

在解析一个符号[symbol]的语法时, Lisp 读取器[Lisp reader]会在当前包[current package]中查找这个符号[symbol]的名字[name]. 这个查找可能牵涉到查找外部符号[external symbol]被当前包[current package]继承的其他包[package]. 如果找到这个名字, 返回对应的符号[symbol]. 如果没有找到这个名字 (这就表示当前包[current package]中没有这个名字的可访问[accessible]符号[symbol]), 会创建一个新的符号[symbol]并作为内部符号[internal symbol]放到当前包[current package]中. 当前包[current package]成为这个符号[symbol]的拥有者 (home 包[home package]), 并且这个符号[symbol]被捕捉到当前包[current package]. 如果这个名字后面被再一次读取到而当前的包[package]是同一个, 会找到并返回相同的符号[symbol]. 

### 2.3.5 <span id = "ValidPatternsForTokens">标记的合法模式</span>

标记的合法模式总结在下面这段.

    nnnnn              a number                                           
    xxxxx              a symbol in the current package                    
    :xxxxx             a symbol in the the KEYWORD package                
    ppppp:xxxxx        an external symbol in the ppppp package            
    ppppp::xxxxx       a (possibly internal) symbol in the ppppp package  
    :nnnnn             undefined                                          
    ppppp:nnnnn        undefined                                          
    ppppp::nnnnn       undefined                                          
    ::aaaaa            undefined                                          
    aaaaa:             undefined                                          
    aaaaa:aaaaa:aaaaa  undefined                                          

Figure 2-17. 标记的合法模式

注意, nnnnn 有数字语法, xxxxx 和 ppppp 都没有数字语法, aaaaa 有任何语法.

后面有关于包标记[package marker]的规则总结. 在每一个情况中, 都会提供一个例子阐明这个情况; 为了表达的简单性, 示例假定当前读取表[current readtable]的读取表大小写[readtable case]是 :upcase.

1. 如果这里有一个单个的包标记[package marker], 并且它出想在这个标记[token]的开始, 那么这个标记[token]被解释为包 KEYWORD 中的一个符号[symbol]. 它还将新创建的符号的 symbol-value 设置为相同的符号[symbol], 以使这个符号[symbol]可以自求值.

    比如, :bar, 读取的时候, 把 BAR 作为 KEYWORD 包的外部符号[external symbol].

2. 如果这里有一个单个的包标记[package marker], 但不是在标记[token]的开头, 这个标记[token]会被拆成2个部分. 第一个部分指定一个包[package]; 第二个部分就成为这个包中有效的外部符号[external symbol]的名字.

    比如, foo:bar, 读取的时候, 在名为 FOO 的包的外部符号[external symbol]中查找 BAR.

3. 如果这里由两个相邻的包标记[package marker], 并且不是在标记[token]的开始或结尾, 那么它们会被分为两个部分. 第一部分指定一个包[package]; 第二个部分就成为这个包[package]中的符号[symbol]的名字 (可能是一个内部符号[internal symbol]).

    比如, foo::bar, 读取的时候, 把 BAR 捕捉到名为 FOO 的包[package]中.

4. 如果这个标记[token]没有包含包标记[package marker], 并且没有潜在数字[potential number]语法, 那么这个整个标记[token]就是这个符号[symbol]的名字. 从当前包[current package]中查找这个符号[symbol].

    比如, bar, 读取的时候, 把 BAR 放到当前包[current package]中.

5. 如果在一个标记[token]中使用任何其他包标记[package marker]的模式, 那么后果是不确定的. 在符号[symbol]名中没有被这个标准所定义的所有其他包标记[package marker]的使用保留给依赖于具体实现[implementation-dependent]的使用.

比如, 假定当前读取表[current readtable]的读取表大小写[readtable case]是 :upcase, editor:buffer 引用名为 editor 的包[package]中的名为 BUFFER 的外部符号[external symbol], 不管当前包[current package]中是否有一个名为 BUFFER 的符号[symbol]. 如果没有名为 editor 的包[package], 或者包 editor 中没有名为 BUFFER 的符号[symbol], 或者 BUFFER 没有被 editor 包导出, 读取器就会发出一个可矫正的错误. 如果见到 editor::buffer, 其效果与使用 EDITOR 包作为当前包[current package]的情况下读取 buffer 完全相同. 

### 2.3.6 <span id = "PackageSystemConsistencyRules">包系统一致性规则</span>

只要 \*package* 的值[value]没有变化那么以下规则就适用于包系统:

读取-读取 一致性

    读取相同的符号[symbol]名称[name]总是会产生相同的[same]符号[symbol].

打印-读取 一致性

    一个被捕捉的[interned]符号[symbol]总是打印为一个字符序列, 当读取回来时也是相同的符号[symbol].

    关于 Lisp 打印器[Lisp printer]如何对待符号, 见章节 22.1.3.3 (打印符号).

打印-打印 一致性

    如果两个被捕捉的符号[symbol]是不同的[same], 那么它们的打印表示会是不同的字符序列.

不管任何隐式捕捉, 这些规则都是对的. 只要当前包[current package]没有改变, 不管加载文件的顺序或在什么时候输入什么符号的确切历史, 结果都是可复写的. 如果 \*package* 的值[value]被改变了然后改变回这个之前的值, 还是会保持一致性. 可以通过修改 \*package* 的值, 通过从一个错误中继续来强制改变符号[symbol]或者包[package]或者都修改, 或者调用以下函数[function]中的一个来违反这个规则: unintern, unexport, shadow, shadowing-import, 或者 unuse-package.

只有当两个已命名的符号[symbol]之间的限制被违反时, 不一致性才适用. shadow, unexport, unintern, 还有 shadowing-import 只影响作为参数传递的名字[name]相同(用 string= 判断)的符号[symbol]. 

## 2.4 <span id = "StandardMacroCharacters">标准宏字符</span>

如果读取器遇到一个宏字符[macro character], 那么它的关联读取器宏函数[reader macro function]会被调用并且可能产生一个要被返回的对象[object]. 这个函数[function]可能以任何语法读取流中宏字符[macro character]后面的那些字符[character]并且返回这个语法所表示的对象[object].

任何字符[character]都可以作为宏字符[macro character]. 一个符合规范的实现[conforming implementation]中最初定义的宏字符[macro character]包括以下这些:

> * 2.4.1 [左圆括号](#LeftParenthesis)
> * 2.4.2 [右圆括号](#RightParenthesis)
> * 2.4.3 [单引号](#SingleQuote)
> * 2.4.4 [分号](#Semicolon)
> * 2.4.5 [双引号](#DoubleQuote)
> * 2.4.6 [反引号](#Backquote)
> * 2.4.7 [逗号](#Comma)
> * 2.4.8 [井号](#Sharpsign)
> * 2.4.9 [重复读取缩写的表达式](#ReReadingAbbreviatedExpressions)
 
### 2.4.1 <span id = "LeftParenthesis">左圆括号</span>

左圆括号[left-parenthesis]开始一个列表[list]的读取. read 会被递归调用去读取后续的对象直到在这个输入流[stream]中找到一个右圆括号. 返回一个读取到的对象[object]的列表[list]. 因此

```LISP
 (a b c)
```

被读取为一个三个对象[object]的列表[list] (符号[symbol] a, b, 还有 c). 右圆括号不需要紧跟着最后一个对象[object]的打印形式后面; 空白[whitespace[2]]和注释可能在它之前.

如果在右圆括号前没有对象[object], 它就读取到一个零对象[object]的列表[list] (一个空列表[empty list]).

如果一个标记[token]只是一个点, 而前面不是紧挨着一个在某个对象[object]后被读取的转义字符, 那么这个这个点之后一定跟着又一个对象, 然后可能前后有空白[whitespace[2]]或注释, 后面跟着右圆括号:

```LISP
 (a b c . d)
```

这就意味着这个列表[list]最后一个 cons 的 cdr 部分不是 nil, 而是点之后表示的对象[object]. 上面的例子可能是下面表达式的求值结果

```LISP
 (cons 'a (cons 'b (cons 'c 'd)))
```

类似的,

```LISP
 (cons 'this-one 'that-one) =>  (this-one . that-one)
```

跟在点后面的对象也允许是一个列表[list]:

```LISP
 (a b c d . (e f . (g))) ==  (a b c d e f g)
```

关于 Lisp 打印器[Lisp printer]如何打印列表[list]和 cons 的信息, 见章节 22.1.3.5 (打印列表和 cons). 

### 2.4.2 <span id = "RightParenthesis">右圆括号</span>

除了和一个左圆括号字符结合以外, 右圆括号[right-parenthesis]是非法. 关于更多的信息, 见章节 2.2 (读取器算法). 

### 2.4.3 <span id = "SingleQuote">单引号</span>

语法: '<\<exp>>

一个单引号[single-quote]引入一个要被被"引用(quoted)"的表达式[expression]. 单引号[single-quote]后面跟着一个表达式[expression] exp 会被 Lisp 读取器[Lisp reader]当作一个缩写并且和表达式(quote exp)同等方式被解析. 见特殊操作符[special operator] quote.

#### 2.4.3.1 单引号的示例

```LISP
 'foo =>  FOO
 ''foo =>  (QUOTE FOO)
 (car ''foo) =>  QUOTE
```

### 2.4.4 <span id = "Semicolon">分号</span>

语法: ;<\<text>>

一个分号[semicolon]引入需要被忽略的字符[character], 就像注释. 分号[semicolon]和所有直到并包括下一个换行符或到文件结尾的字符都被忽略.

#### 2.4.4.1 分号的示例

```LISP
 (+ 3 ; three
    4)
=>  7  
```  

#### 2.4.4.2 关于分号样式的注释

一些文本编辑器根据开始注释的分号[semicolon]数量来对期望的缩进做出假设. 下面的样式规约是较普遍的, 尽管不是通用的.

> * 2.4.4.2.1 [单分号的使用](#UseOfSingleSemicolon)
> * 2.4.4.2.2 [两个分号的使用](#UseOfDoubleSemicolon)
> * 2.4.4.2.3 [三个分号的使用](#UseOfTripleSemicolon)
> * 2.4.4.2.4 [四个分号的使用](#UseOfQuadrupleSemicolon)
> * 2.4.4.2.5 [分号风格的示例](#ExamplesOfStyleForSemicolon)

##### 2.4.4.2.1 <span id = "UseOfSingleSemicolon">单分号的使用</span>

以一个分号[semicolon]开始的注释都对齐到右边的同一列上 (有时也被称为 "注释列(comment column)"). 这样一个注释的文本通常只应用于它出现的行. 偶尔会有两个或三个一起包含一个单句; 这有时通过用一个额外的空格 (在分号[semicolon]后) 缩进除了第一个以外的所有来表示. 

##### 2.4.4.2.2 <span id = "UseOfDoubleSemicolon">两个分号的使用</span>

以双分号[semicolon]开头的注释都和在代码[code]中处于相同位置的表达式形式[form]对齐到相同的缩进级别. 这样的注释的文本通常用来描述注释出现点的程序[program]的状态, 或者这个注释后的代码[code], 或者两者都描述了. 

##### 2.4.4.2.3 <span id = "UseOfTripleSemicolon">三个分号的使用</span>

以三个分号[semicolon]开头的注释都对齐到左边框. 通常它们是在一个定义或定义集合之前使用的, 而不是在定义中. 

##### 2.4.4.2.4 <span id = "UseOfQuadrupleSemicolon">四个分号的使用</span>

以四个个分号[semicolon]开头的注释都对齐到左边框, 并且通常包含一小段文本作为后面跟着的代码的标题, 并且可能被用于这个程序的页眉或页脚中, 该程序准备代码以作为一个硬拷贝文档呈现. 

##### 2.4.4.2.5 <span id = "ExamplesOfStyleForSemicolon">分号风格的示例</span>

```LISP
;;;; Math Utilities

;;; FIB computes the the Fibonacci function in the traditional
;;; recursive way.

(defun fib (n)
  (check-type n integer)
  ;; At this point we're sure we have an integer argument.
  ;; Now we can get down to some serious computation.
  (cond ((< n 0)
         ;; Hey, this is just supposed to be a simple example.
         ;; Did you really expect me to handle the general case?
         (error "FIB got ~D as an argument." n))
        ((< n 2) n)             ;fib[0]=0 and fib[1]=1
        ;; The cheap cases didn't work.
        ;; Nothing more to do but recurse.
        (t (+ (fib (- n 1))     ;The traditional formula
              (fib (- n 2)))))) ; is fib[n-1]+fib[n-2].
```

### 2.4.5 <span id = "DoubleQuote">双引号</span>

语法: "<\<text>>"

双引号[double-quote]被用于开始和结束一个字符串. 当遇到一个双引号[double-quote]时, 从输入[input]流[stream]中读取到的字符[character]会累积直到遇到另一个双引号[double-quote]. 如果见到一个单转义[single escape]字符[character], 这个单转义[single escape]字符[character]会被丢弃, 累积下一个字符并继续. 直到匹配的双引号为止但不包括双引号[double-quote]的那些字符[character]会被转成一个简单字符串[simple string]并返回. 这些累积字符的哪些属性[attribute]会在这个操作中被移除是依赖于具体实现的[implementation-dependent].

下一段中有双引号[double-quote]字符的示例.

```LISP
"Foo"                      ;A string with three characters in it  
""                         ;An empty string                       
"\"APL\\360?\" he cried."  ;A string with twenty characters       
"|x| = |-x|"               ;A ten-character string                
```

Figure 2-18. 双引号字符的示例

注意, 要将单转义字符或双引号[double-quote]放入字符串中, 这样的字符必须先有一个单转义字符. 还要注意, 多转义字符不需要被字符串中的单转义字符引用.

关于 Lisp 打印器[Lisp printer]如何打印字符串[string]的信息, 见章节 22.1.3.4 (打印字符串). 

### 2.4.6 <span id = "Backquote">反引号</span>

反引号[backquote]引入一个要创建的数据结构的模板. 比如, 写下

```LISP
`(cond ((numberp ,x) ,@y) (t (print ,x) ,@y))
```

粗略等价于写下

```LISP
(list 'cond 
    (cons (list 'numberp x) y) 
    (list* 't (list 'print x) y))
```

这个模板中出现逗号的地方, 这个逗号后面的表达式[expression]会被求值并产生一个对象插入到这个地方. 假定 b 的值是 3, 比如求值 `(a b ,b ,(+ b 1) b) 表示的表达式形式[form]会产生结果 (a b 3 4 b).

如果一个逗号紧跟着 @ 符号[at-sign], 这个 @ 符号[at-sign]后面的表达式形式[form]会被求值并产生一个对象[object]列表[list]. 这些对象[object]会被"接合(splice)"进这个模板. 比如, 如果 x 的值为 (a b c), 那么

```LISP
`(x ,x ,@x foo ,(cadr x) bar ,(cdr x) baz ,@(cdr x))
=>  (x (a b c) a b c foo b bar (b c) baz b c)
```

这个反引号语法可以被总结为如下.

* 对于任何不是一个列表[list]或一个普通向量[vector]的表达式[expression] basic, `basic 等同于 'basic, 也就表示, (quote basic).

* 对于任何不是以 @ 符号[at-sign]或者点[dot]开始的表达式形式 form, `,form 等同于 form. (类似的警告适用于所有在逗号[comma]之后出现的表达式形式.)

* `,@form 有着未定义的后果.

* `(x1 x2 x3 ... xn . atom) 可能被解释成

     (append [ x1] [ x2] [ x3] ... [ xn] (quote atom))

    其中方括号被用于表示一个如下的一个 xj 的转化:

    -- [form] 被解释为 (list `form), 包含一个接下来必须被进一步解释的反引号表达式形式.

    -- [,form] 被解释为 (list form).

    -- [,@form] 被解释为 form.

* \`(x1 x2 x3 ... xn) 可能被解释为相同的反引号表达式 `(x1 x2 x3 ... xn . nil), 由此将其规约到前一种情况.

* `(x1 x2 x3 ... xn . ,form) 可能被解释为

     (append [ x1] [ x2] [ x3] ... [ xn] form)

    其中的方括号表示一个如上所述的一个 xj 的转换.

* `(x1 x2 x3 ... xn . ,@form) 有着未定义的后果.

* \`#(x1 x2 x3 ... xn) 可能被解释为 (apply #'vector `(x1 x2 x3 ... xn)).

任何可能使用 ",@" 的地方, 可能使用 ",." 来表示允许在 ",." 后面的表达式形式产生的列表结构[list structure]上进行破坏性的操作 (实际上, 使用 nconc 而不是 append).

如果反引号语法是嵌套的, 那么最内层的反引号表达式形式应该首先展开. 这个也意味着如果有多个逗号出现在一行中, 最左边的一个是属于最里面的反引号[backquote].

一个具体实现[implementation]可以自由地解释一个反引号表达式形式[form] F1 为任何表达式形式[form] F2, 在求值时, 会产生一个和上面定义暗示的结果在 equal 下是相同[same]的结果, 假定替代的表达式形式[form] F2 的副作用行为也和上述给定的描述一致. 模板的构造拷贝可能也可能不和模板自身共享列表[list]的结构. 例如, 上面的定义意味着

```LISP
`((,a b) ,c ,@d)
```

会被解释为

```LISP
(append (list (append (list a) (list 'b) 'nil)) (list c) d 'nil)
```

但是它也可能被合法地解释为以下任何一种:

```LISP
(append (list (append (list a) (list 'b))) (list c) d)
(append (list (append (list a) '(b))) (list c) d)
(list* (cons a '(b)) c d)
(list* (cons a (list 'b)) c d)
(append (list (cons a '(b))) (list c) d)
(list* (cons a '(b)) c (copy-list d))
```

#### 2.4.6.1 关于反引号的注意事项

由于 Lisp 读取器[Lisp reader]解析一个涉及反引号[backquote]读取器宏[reader macro]的表达式[expressioni]的确切方式没有指定, 一个具体实现[implementation]可以自由地选择任何保留描述的语义的表示形式.

通常, 实现会选择一种便于美观打印表达式的表示形式, 这样一来 ``(pprint `(a ,b))`` 会显示 ``\`(a ,b)`` 而不是例如 ``(list 'a b)``. 然而, 这不是必须的.

没有特定理由做出一个选择或另一个的实现者可能希望引用《IEEE Standard for the Scheme Programming Language》, 它为这样的表达式确定了一种流行的表示方式, 可以为一些用户社区提供有用的兼容性. 然而这里没有任何必要条件, 要求任何符合规范的实现[conforming implementation]使用这个特定的表示. 此信息仅用于交叉引用目的.

### 2.4.7 <span id = "Comma">逗号</span>

逗号[comma]是反引号语法的一部分; 见章节 2.4.6 (反引号). 如果在上述的反引号表达式[expression]的主体之外的地方使用逗号[comma], 那么它的非法的. 

### 2.4.8 <span id = "Sharpsign">井号</span>

井号[sharpsign]是一个非终止[non-terminating]分派宏字符[dispatching macro character]. 它读取一个可选的数字序列然后再读取一个字符, 然后使用这个字符去选择一个函数[function]作为读取器宏函数[reader macro function]来运行.

标准语法[standard syntax]包括由 # 字符引入的结构. 这些结构的语法如下: 标识结构类型的字符后面跟着一些某个形式的参数. 如果这个字符是一个字母, 它的大小写[case]是不重要的; 比如 #O 和 #o 被认为是等价的.

某些 # 结构允许在 # 和字符之间出现一个无符号的十进制数.

和分派宏字符[dispatching macro character] # 关联的读取器宏[reader macro]在这个章节的后面部分有描述, 并且总结在下面这段.

  分派字符        | 目的                    | 分派字符      | 目的      
  | :------:| :------:                   | :------:  | :------:  | 
  Backspace      | signals error          | {            | undefined*             
  Tab            | signals error          | }            | undefined*             
  Newline        | signals error          | +            | read-time conditional  
  Linefeed       | signals error          | -            | read-time conditional  
  Page           | signals error          | .            | read-time evaluation   
  Return         | signals error          | /            | undefined              
  Space          | signals error          | A, a         | array                  
  !              | undefined*             | B, b         | binary rational        
  "              | undefined              | C, c         | complex number         
  \#              | reference to = label   | D, d         | undefined              
  $              | undefined              | E, e         | undefined              
  %              | undefined              | F, f         | undefined              
  &              | undefined              | G, g         | undefined              
  '              | function abbreviation  | H, h         | undefined              
  (              | simple vector          | I, i         | undefined              
  )              | signals error          | J, j         | undefined              
  \*              | bit vector             | K, k         | undefined              
  ,              | undefined              | L, l         | undefined              
  :              | uninterned symbol      | M, m         | undefined              
  ;              | undefined              | N, n         | undefined              
  <              | signals error          | O, o         | octal rational         
  =              | labels following object| P, p         | pathname               
  \>              | undefined              | Q, q         | undefined              
  ?              | undefined*             | R, r         | radix-n rational       
  @              | undefined              | S, s         | structure              
  [              | undefined*             | T, t         | undefined              
  \              | character object       | U, u         | undefined              
  ]              | undefined*             | V, v         | undefined              
  ^              | undefined              | W, w         | undefined              
  _              | undefined              | X, x         | hexadecimal rational   
  `              | undefined              | Y, y         | undefined              
  \|              | balanced comment       | Z, z         | undefined              
  ~              | undefined              | Rubout       | undefined              

Figure 2-19. 标准 # 分派宏字符语法

由星号(\*)标记的组合被显式地保留给用户. 符合规范的实现[conforming implementation]不会定义它们.

注意数字[digit]也没有出现在前面的表中. 这是因为标记 #0, #1, ..., #9 保留给另一个占相同语法空间的目的. 当一个数字[digit]跟在一个井号[sharpsign]后面, 它不会被认为是分派字符. 取而代之的是, 一个无符号整型的参数被累计起来, 并作为实参[argument]传递给数字后面字符[character]的读取器宏[reader macro]. 比如, #2A((1 2) (3 4)) 就是一个参数为 2 的 #A 的使用.

> * 2.4.8.1 [井号反斜线(#\\)](#SharpsignBackslash)
> * 2.4.8.2 [井号单引号(#')](#SharpsignSingleQuote)
> * 2.4.8.3 [井号左括号(#()](#SharpsignLeftParenthesis)
> * 2.4.8.4 [井号星号(#*)](#SharpsignAsterisk)
> * 2.4.8.5 [井号冒号(#:)](#SharpsignColon)
> * 2.4.8.6 [井号点(#.)](#SharpsignDot)
> * 2.4.8.7 [井号B(#B)](#SharpsignB)
> * 2.4.8.8 [井号O(#O)](#SharpsignO)
> * 2.4.8.9 [井号X(#X)](#SharpsignX)
> * 2.4.8.10 [井号R(#R)](#SharpsignR)
> * 2.4.8.11 [井号C(#C)](#SharpsignC)
> * 2.4.8.12 [井号A(#A)](#SharpsignA)
> * 2.4.8.13 [井号S(#S)](#SharpsignS)
> * 2.4.8.14 [井号P(#P)](#SharpsignP)
> * 2.4.8.15 [井号等号(#=)](#SharpsignEqualSign)
> * 2.4.8.16 [井号井号(##)](#SharpsignSharpsign)
> * 2.4.8.17 [井号加号(#+)](#SharpsignPlus)
> * 2.4.8.18 [井号减号(#-)](#SharpsignMinus)
> * 2.4.8.19 [井号竖线(#|)](#SharpsignVerticalBar)
> * 2.4.8.20 [井号小于号(#<)](#SharpsignLessThanSign)
> * 2.4.8.21 [井号空格(# )](#SharpsignWhitespace)
> * 2.4.8.22 [井号右括号(#))](#SharpsignRightParenthesis)

#### 2.4.8.1 <span id = "SharpsignBackslash">井号反斜线(#\\)</span>

语法: #\\<\<x>>

当这个标记[token] x 是单个字符[character]长时, 这个会被解析为字面字符[character] char. 在 #\ 后面大写[uppercase]字母和小写[lowercase]字母是区分开来的; #\A 和 #\a 表示不同的字符[character]对象[object]. 任何在 #\ 后面的单个字符[character]都会正常工作, 甚至那些对于 read 通常是非常特殊的字符, 例如左圆括号[left-parenthesis]和右圆括号[right-parenthesis].

在单字符[character]情况下, x 后面必须跟着一个非成分字符[character]. 在 #\ 被读取之后, 读取器回溯到斜线[slash]然后开始读取一个标记[token], 把最初的斜线[slash]作为单转义[single escape]字符[character] (不管它在当前读取表[current readtable]里是否为单转义字符).

当这个标记[token]不止一个字符[character]长度时, 这个 x 必须有着符号[symbol]的语法, 并且其中没有内嵌的包标记[package marker]. 在这种情况下, 这个井号[sharpsign]反斜线[backslash]标记被解析为名为 (string-upcase x) 的字符[character]; 见章节 13.1.7 (字符的名字).

关于 Lisp 打印器[Lisp printer]如何打印字符[character]对象[object]的信息, 见章节 22.1.3.2 (打印字符). 

#### 2.4.8.2 <span id = "SharpsignSingleQuote">井号单引号(#')</span>

任何前面有 #' (井号[sharpsign]后面是单引号[single-quote]) 的表达式, 就像 #'expression, 被 Lisp 读取器[Lisp reader]当作是一个缩写并且解释为表达式[expression] (function expression). 见 function. 比如,

```LISP
(apply #'+ l) ==  (apply (function +) l)
```

#### 2.4.8.3 <span id = "SharpsignLeftParenthesis">井号左括号(#()</span>

#( 和 ) 被用于表示一个简单向量[simple vector].

如果一个无符号十进制整数出现在 # 和 ( 中间, 它明确指明这个向量[vector]的长度. 如果在结束的 ) 之前的对象[object]数超过那个无符号十进制整数, 后果是未定义的. 在结束的 ) 之前提供的对象[object]数量如果小于那个无符号十进制整数大于 0 那么最后一个对象[object]被用于填充这个向量[vector]的剩余部分. 如果这个无符号十进制整数是非零的但是在结束的 ) 之前提供的对象[object]数是 0 那么结果是未定义的. 比如,

```LISP
#(a b c c c c)
#6(a b c c c c)
#6(a b c)
#6(a b c c)
```

都意味着同样的东西: 一个长度为 6 的向量, 带有 a, b, 和 4 个 c 元素[element]. 其他例子如下:

```LISP
#(a b c)               ;A vector of length 3
#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47)
                    ;A vector containing the primes below 50
#()                    ;An empty vector
```

标记 #() 表示一个空向量, 就像 #0().

关于 Lisp 打印器[Lisp printer]如何打印向量的信息, 见章节 22.1.3.4 (打印字符串), 章节 22.1.3.6 (打印位向量), 或章节 22.1.3.7 (打印其他向量). 

#### 2.4.8.4 <span id = "SharpsignAsterisk">井号星号(#*)</span>

语法: #*<\<bits>>

构造一个包含指定的位 (0's 和 1's) 的简单位向量[simple bit vector], 其中最左边的位索引为 0 并且后面的位有着递增的索引.

语法: #<\<n>>*<\<bits>>

带有一个参数 n, 那么这个要创建的向量的长度是 n. 如果位的数量少于 n 但是大于 0, 那么最后一位会被用于填充这个位向量[bit vector]的剩余部分.

标记 #* 和 #0* 每个都表示一个空的位向量[bit vector].

不管是否提供那个可选的参数 n, 星号[asterisk]后面的标记[token]会被正常的标记[token]分隔符来分割. 然而, 如果这个标记[token]不是完全由 0 和 1 组成, 或者如果提供了 n 但是位的数量却大于 n 位, 或者 n 大于 1, 但是没有提供位元素, 都会发出一个 reader-error 类型[type]的错误 (除非 \*read-suppress* 的值[value]是 true). 单转义字符[single escape]和多转义字符[multiple escape]都不允许出现在这个标记[token]里.

关于 Lisp 打印器[Lisp printer]如何打印位向量[bit vector]的信息, 见章节 22.1.3.6 (打印位向量).

##### 2.4.8.4.1 井号星号的示例

比如,

```LISP
#*101111
#6*101111
#6*101
#6*1011
```

都意味着相同的东西: 一个长度 6 的向量, 带有元素[element] 1, 0, 1, 1, 1, 和 1.

比如:

```LISP
 #*         ;An empty bit-vector
```

#### 2.4.8.5 <span id = "SharpsignColon">井号冒号(#:)</span>

语法: #:<\<symbol-name>>

\#: 引入一个名字[name]为 symbol-name 的未捕捉[uninterned]的符号[symbol]. 每次遇到这个语法, 会创建一个不同[distinct]的未拘留[uninterned]符号[symbol]. 这个 symbol-name 必须有符号[symbol]的语法并且没有包前缀[package prefix].

关于 Lisp 读取器[Lisp reader]如何打印未拘留[uninterned]符号[symbol], 见章节 22.1.3.3 (打印符号). 

#### 2.4.8.6 <span id = "SharpsignDot">井号点(#.)</span>

\#.foo 被读取为 foo 表示的对象[object]求值产生的对象[object]. 当读取到这个 #. 标记时, 求值会在 read 过程中完成. 因此这个 #. 语法执行了一个 foo 的读取时求值.

当 \*read-eval* 的值[value]是 false 时, 这个 #. 正常的影响会被抑制. 在这个情况下, 会发出一个 reader-error 类型[type]的错误.

对于一个没有适当的打印表示的对象[object], 一个计算这个对象[object]的表达式形式[form]可以使用符号 #. 来给定. 

#### 2.4.8.7 <span id = "SharpsignB">井号B(#B)</span>

\#Brational 用二进制(基数 2)读取有理数 rational. 比如,

```LISP
#B1101 ==  13 ;11012
#b101/11 ==  5/3
```

如果紧跟这个 #B 的标记没有二进制(换句话说, 基数 2)有理数[rational]的语法, 那么结果是未定义的. 

#### 2.4.8.8 <span id = "SharpsignO">井号O(#O)</span>

\#Orational 用八进制(基数 8)读取有理数 rational. 比如,

```LISP
#o37/15 ==  31/13
#o777 ==  511
#o105 ==  69 ;1058
```

如果紧跟在 #O 后的标记没有八进制(换句话说, 基数 8)有理数[rational]的语法, 结果是未定义的. 

#### 2.4.8.9 <span id = "SharpsignX">井号X(#X)</span>

\#Xrational 用十六进制(基数 16)读取有理数. 在 9 之上的数字是字母 A 到 F (小写字母 a 到 f 也是可接受的). 比如,

```LISP
#xF00 ==  3840             
#x105 ==  261 ;10516
```

如果紧跟着 #X 的标记没有十六进制(换句话说, 基数 16)有理数[rational]的语法, 那么结果是未定义的. 

#### 2.4.8.10 <span id = "SharpsignR">井号R(#R)</span>

\#nR

\#radixRrational 根据指定的进制 radix 来读取有理数 rational. 进制 radix 必须是由解释为十进制整数[integer]的数字组成; 它的值必须在 2 和 36 (包括)之间. 只有指定的进制中合法的数字可以被使用.

比如, #3r102 是另一种编写 11(十进制) 的方式, 并且 #11R32 是写 35(十进制) 的另一种方式. 对于大于 10 的进制数, 字母表中的字母依次被用于 9 之后的进制. 由于一个小数点就足够了, 不存在替代十进制数的 # 表示法.

下一段包括了 #B, #O, #X, 和 #R 的使用.

```LISP
#2r11010101  ;Another way of writing 213 decimal  
#b11010101   ;Ditto                               
#b+11010101  ;Ditto                               
#o325        ;Ditto, in octal radix               
#xD5         ;Ditto, in hexadecimal radix         
#16r+D5      ;Ditto                               
#o-300       ;Decimal -192, written in base 8     
#3r-21010    ;Same thing in base 3                
#25R-7H      ;Same thing in base 25               
#xACCEDED    ;181202413, in hexadecimal radix     
```

Figure 2-20. 进制指示符的示例

如果跟在 #nR 后的标记不满足 n 进制有理数[rational]的语法, 结果是未定义的. 

#### 2.4.8.11 <span id = "SharpsignC">井号C(#C)</span>

\#C 读取一个跟在后面的对象[object], 这个对象必须是一个长度为 2 且其中的元素[element]都是实数的列表[list]. 这两个实数分别表示一个复数[complex]的实部和虚部. 如果这两部分不是相同的数据类型, 那么它们会根据章节 12.1.1.2 (数值运算的传递性) 描述的浮点数传递的规则被转换.

\#C(real imag) 等价于 #.(complex (quote real) (quote imag)), 除了这个 #C 不会被 \*read-eval* 影响. 见函数[function] complex.

下一段中包含了 #C 的使用示例.

```LISP
#C(3.0s1 2.0s-1)  ;A complex with small float parts.                
#C(5 -3)          ;A ``Gaussian integer''                           
#C(5/3 7.0)       ;Will be converted internally to #C(1.66666 7.0)  
#C(0 1)           ;The imaginary unit; that is, i.                  
```

Figure 2-21. 复数示例

关于更多信息, 见章节 22.1.3.1.4 (打印复数) 和章节 2.3.2.3 (复数的语法). 

#### 2.4.8.12 <span id = "SharpsignA">井号A(#A)</span>

\#nA

\#nAobject 构建一个 n 维数组[array], 使用 object 作为 :initial-contents 参数的值调用 make-array.

比如, #2A((0 1 5) (foo 2 (hot dog))) 表示一个 2×3 矩阵:

    0       1       5
    foo     2       (hot dog)

相对的, #1A((0 1 5) (foo 2 (hot dog))) 表示一个长度[length] 2 的向量[vector], 其中的元素[element]是列表[list]:

    (0 1 5) (foo 2 (hot dog))

\#0A((0 1 5) (foo 2 (hot dog))) 表示一个 0 维数组[array], 其中其中仅有的元素是一个列表[list]:

    ((0 1 5) (foo 2 (hot dog)))

\#0A foo 表示一个 0 维数组[array], 其中仅有的元素是符号[symbol] foo. 这个 #1A foo 标记是非法的因为 foo 不是一个序列[sequence].

如果这个表示要被解析的数组[array]的某个容积[dimension]被发现是 0, 所有右边的容积[dimension] (也就是说, 更高的容积[dimension]) 也被认为是 0.

关于 Lisp 打印器[Lisp printer]如何打印数组[array]的信息, 见章节 22.1.3.4 (打印字符串), 章节 22.1.3.6 (打印位向量), 章节 22.1.3.7 (打印其他向量), 或者 章节 22.1.3.8 (打印其他数组). 

#### 2.4.8.13 <span id = "SharpsignS">井号S(#S)</span>

\#s(name slot1 value1 slot2 value2 ...) 表示一个结构体[structure]. 只有当 name 是一个 defstruct 已经定义的结构体[structure]类型[type]的名字并且这个结构体[structure]类型[type]有标准构造函数, 这个才是有效的. 让 cm 成为这个构造器函数的 name; 那么这个语法等价于

```LISP
#.(cm keyword1 'value1 keyword2 'value2 ...)
```

这里每一个 keywordj 都是计算下面表达式的结果

```LISP
(intern (string slotj) (find-package 'keyword))
```

其净效果是用带有指定的值的指定的槽调用构造器函数. (这个强制特性被弃用; 在未来, 关键字的名字将会取自它们被读入的包, 因此如果希望如此, 那么实际上在 KEYWORD 包中的符号[symbol]应该被使用.)

无论构造器函数返回的是什么对象[object]都会被 #S 语法返回.

关于 Lisp 打印器[Lisp printer]如何打印结构体[structure]信息, 见章节 22.1.3.12 (打印结构体). 

#### 2.4.8.14 <span id = "SharpsignP">井号P(#P)</span>

\#P 读取后面的对象[object], 它必须是一个字符串[string].

\#P<\<expression>> 等价于 #.(parse-namestring '<\<expression>>), 除了 #P 不受 \*read-eval* 影响.

关于 Lisp 打印器[Lisp printer]如何打印一个路径名[pathname]的信息, 见章节 22.1.3.11 (打印路径名). 

#### 2.4.8.15 <span id = "SharpsignEqualSign">井号等号(#=)</span>

\#n=

\#n=object 就像读取有着对象 object 作为打印表示的对象. 但是, 该对象[object]是由一个必要的无符号十进制整数 n 所标记的, 为了可以通过语法 #n# 进行引用. 这个标记的作用域是被最外面对 read 的调用所读取的表达式[expression]; 这个表达式[expression]里, 相同的标记可能不会出像第二次. 

#### 2.4.8.16 <span id = "SharpsignSharpsign">井号井号(##)</span>

\#n#

\#n#, 其中的 n 是一个必要的无符号十进制整数[integer], 提供一个对 #n= 标记的某个对象[object]的引用; 这就是说, #n# 表示一个指向和 #n= 标记的对象相同 (eq) 对象的指针. 比如, 被下面这个代码创建出来的变量 y 中的结构:

```LISP
(setq x (list 'p 'q))
(setq y (list (list 'a 'b) x 'foo x))
(rplacd (last y) (cdr y))
```

可以通过以下方式表示:

    ((a b) . #1=(#2=(p q) foo #2# . #1#))

不用这个标记, 如果 \*print-length* 设置为 10 并且 \*print-circle* 设置为 nil, 结构会被以下面方式打印:

    ((a b) (p q) foo (p q) (p q) foo (p q) (p q) foo (p q) ...)

一个 #n# 引用可能只出现在一个 #n= 标记后; 超前的引用是不允许的. 这个引用可能不会作为被标记的对象自身出现 (就是说, #n=#n#) 可能不会被写入, 因为这个 #n= 标记的对象[object]在这个情况下还没有被定义好.

#### 2.4.8.17 <span id = "SharpsignPlus">井号加号(#+)</span>

\#+ 提供一个读取时条件化机制; 语法是 #+test expression. 如果这个特性表达式[feature expression] test 成功, 那么这个文本标记表示一个打印表示是表达式 expression 的对象[object]. 如果这个特性表达式[feature expression] test 失败, 那么这个文本的标记就当作空白[whitespace[2]]对待; 这就是说, 就好象 "#+ test expression" 没有出现而只有一个空格出现在它的位置.

关于这个特性表达式[feature expression]的成功与否的详细描述, 见章节 24.1.2.1 (特性表达式).

\#+ 通过首先读取这个特性表达式[feature expression]然后如果测性表达式[feature expression]失败就会跳过这个表达式形式来操作的. 读取这个 test 时, 当前包[current package]是 KEYWORD 包. 跳过这个表达式形式是通过将 \*read-suppress* 绑定[binding]到真[true]然后调用 read 来完成的.

关于示例, 见章节 24.1.2.1.1 (特性表达式的示例). 

#### 2.4.8.18 <span id = "SharpsignMinus">井号减号(#-)</span>

\#- 就像 #+ 除了它会在那个 test 正确时跳过这个表达式 expression; 也就是说,

    #-test expression ==  #+(not test) expression

关于示例, 见章节 24.1.2.1.1 (特性表达式的示例). 

#### 2.4.8.19 <span id = "SharpsignVerticalBar">井号竖线(#|)</span>

\#|...|# 被读取器当作是一个注释. 它必须与 #| 和 |# 的其他出现保持平衡, 但是除此之外, 它可能包含任何字符.

##### 2.4.8.19.1 井号竖线的示例

下面是利用 #|...|# 标记的一些示例:

```LISP
;;; In this example, some debugging code is commented out with #|...|#
;;; Note that this kind of comment can occur in the middle of a line
;;; (because a delimiter marks where the end of the comment occurs)
;;; where a semicolon comment can only occur at the end of a line 
;;; (because it comments out the rest of the line).
 (defun add3 (n) #|(format t "~&Adding 3 to ~D." n)|# (+ n 3))

;;; The examples that follow show issues related to #| ... |# nesting.

;;; In this first example, #| and |# always occur properly paired,
;;; so nesting works naturally.
 (defun mention-fun-fact-1a ()
   (format t "CL uses ; and #|...|# in comments."))
=>  MENTION-FUN-FACT-1A
 (mention-fun-fact-1a)
>>  CL uses ; and #|...|# in comments.
=>  NIL
 #| (defun mention-fun-fact-1b ()
      (format t "CL uses ; and #|...|# in comments.")) |#
 (fboundp 'mention-fun-fact-1b) =>  NIL

;;; In this example, vertical-bar followed by sharpsign needed to appear
;;; in a string without any matching sharpsign followed by vertical-bar
;;; having preceded this.  To compensate, the programmer has included a
;;; slash separating the two characters.  In case 2a, the slash is 
;;; unnecessary but harmless, but in case 2b, the slash is critical to
;;; allowing the outer #| ... |# pair match.  If the slash were not present,
;;; the outer comment would terminate prematurely.
 (defun mention-fun-fact-2a ()
   (format t "Don't use |\# unmatched or you'll get in trouble!"))
=>  MENTION-FUN-FACT-2A
 (mention-fun-fact-2a)
>>  Don't use |# unmatched or you'll get in trouble!
=>  NIL
 #| (defun mention-fun-fact-2b ()
      (format t "Don't use |\# unmatched or you'll get in trouble!") |#
 (fboundp 'mention-fun-fact-2b) =>  NIL

;;; In this example, the programmer attacks the mismatch problem in a
;;; different way.  The sharpsign vertical bar in the comment is not needed
;;; for the correct parsing of the program normally (as in case 3a), but 
;;; becomes important to avoid premature termination of a comment when such 
;;; a program is commented out (as in case 3b).
 (defun mention-fun-fact-3a () ; #|
   (format t "Don't use |# unmatched or you'll get in trouble!"))
=>  MENTION-FUN-FACT-3A
 (mention-fun-fact-3a)
>>  Don't use |# unmatched or you'll get in trouble!
=>  NIL
 #|
 (defun mention-fun-fact-3b () ; #|
   (format t "Don't use |# unmatched or you'll get in trouble!"))
 |#
 (fboundp 'mention-fun-fact-3b) =>  NIL
```

##### 2.4.8.19.2 井号竖线风格的注意事项

一些声称理解 Lisp 语法的文本编辑器把任何 |...| 作为不能嵌套的对称对 (就像它们只是被用于标注特定符号的多转义字符的平衡对). 为了弥补这一缺陷, 一些程序员使用 #||...#||...||#...||# 而不是 #|...#|...|#...|#. 注意这个替代方式并不是一个不同的读取器宏[reader macro]; 它只是利用了额外的竖线以一种欺骗特定文本编辑器来更好地支持嵌套注释的方式出现在注释中的事实. 像这样, 一个可能的代码:

```LISP
#|| (+ #|| 3 ||# 4 5) ||# 
```

这样的代码等价于:

```LISP
#| (+ #| 3 |# 4 5) |#
```

#### 2.4.8.20 <span id = "SharpsignLessThanSign">井号小于号(#<)</span>

\#< 不是一个合法的读取器语法. Lisp 读取器[Lisp reader]在遇到 #< 时会发出一个 reader-error 类型[type]的错误. 这个语法通常被用于不能被读回的对象[object]的打印表示. 

#### 2.4.8.21 <span id = "SharpsignWhitespace">井号空格(# )</span>

\# 后面紧跟空白[whitespace[1]]不是一个合法的读取器宏. 如果 Lisp 读取器[Lisp reader]遇到 #<Newline> 或 #<Space> 读取器宏标记会发出一个 reader-error 类型[type]的错误. 

#### 2.4.8.22 <span id = "SharpsignRightParenthesis">井号右括号(#))</span>

这不是一个合法的读取器语法.

如果 Lisp 读取器[Lisp reader]遇到一个 #) 会发出一个 reader-error 类型[type]的错误. 

### 2.4.9 <span id = "ReReadingAbbreviatedExpressions">重复读取缩写的表达式</span>

注意, 当读取一个由于 "..", "...", "#" 后面跟着空白[whitespace[1]]以及 "#)" 的约束而长度或层级限制(见 \*print-level\*, \*print-length\*, 和 \*print-lines\*)而被简化的表达式[expression[2]]时, Lisp 读取器[Lisp reader]通常会发出一个 reader-error 类型[type]的错误. 


# 3. 编译和求值

> * 3.1 [求值](#Evaluation)
> * 3.2 [编译](#Compilation)
> * 3.3 [声明](#Declarations)
> * 3.4 [Lambda 列表](#LambdaLists)
> * 3.5 [函数调用中的错误检测](#ErrorChecking)
> * 3.6 [遍历规则和副作用](#TraversalRulesSideEffects)
> * 3.7 [破坏性操作](#DestructiveOperations)
> * 3.8 [求值和编译的字典条目](#EvaluationCompilationDictionary)

## 3.1 <span id = "Evaluation">求值</span>

代码[code]的执行可以通过多种方式来完成, 从对表示一个程序[program]的表达式形式[form]的直接解释到一个编译器[compiler]生成的编译代码[compiled code]的调用都可以.

求值[evaluation]是一个过程, 程序[program]通过这个过程在 Common Lisp 中执行. 求值[evaluation]机制通过 Lisp read-eval-print 循环[Lisp read-eval-print loop]的效果来隐式表现, 并且可以通过函数[function] eval, compile, compile-file 和 load 显式表现. 其中的任何一个都可能共享相同的执行策略, 或者每个都可能使用不同的执行策略.

符合规范的程序[conforming program]被 eval 和被 compile-file 处理后的行为可能不同; 见章节 3.2.2.3 (语义约束).

可以通过一个模型来理解求值, 在这个模型中, 解释器递归地遍历一个表达式形式[form], 它执行计算过程中的每一个步骤. 这个描述了 Common Lisp 程序[program]语义的模型, 被描述在章节 3.1.2 (求值模型).

> * 3.1.1 [环境的介绍](#IntroductionEnvironments)
> * 3.1.2 [求值模型](#TheEvaluationModel)
> * 3.1.3 [lambda 表达式](#LambdaExpressions)
> * 3.1.4 [闭包和词法绑定](#ClosuresLexicalBinding)
> * 3.1.5 [遮蔽](#Shadowing)
> * 3.1.6 [范围](#Extent)
> * 3.1.7 [返回值](#ReturnValues)

### 3.1.1 <span id = "IntroductionEnvironments">环境的介绍</span>

一个绑定[binding]是一个名字和它所表示的东西的关联. 绑定[binding]由特定的特殊操作符[special operators]在一个词法环境[lexical environment]或动态环境[dynamic environment]中建立.

一个环境[environment]由一个绑定[binding]集合和求值过程中使用的其他信息 (比如, 用来关联名字和意义的信息) 组成.

一个环境[environment]中的绑定[binding]用命名空间[namespace]来划分. 单独的名字在每一个环境[environment]中可以同时有超过一个关联的绑定[binding], 每一个命名空间[namespace]只能有一个关联的绑定[binding].

> * 3.1.1.1 [全局的环境](#TheGlobalEnvironment)
> * 3.1.1.2 [动态环境](#DynamicEnvironments)
> * 3.1.1.3 [词法环境](#LexicalEnvironments)
> * 3.1.1.4 [环境对象](#EnvironmentObjects)

#### 3.1.1.1 <span id = "TheGlobalEnvironment">全局的环境</span>

全局环境[global environment]是环境[environment]中包含无限作用域[indefinite scope]和无限范围[indefinite extent]的绑定[binding]的部分. 全局环境[global environment]包括以下部分:

    动态变量[dynamic variable]和常变量[constant variable]的绑定[binding].
    函数[function], 宏[macro], 特殊操作符[special operator]的绑定[binding].
    编译器宏[compiler macro]绑定[binding].
    类型[type]和类[class]名[name]绑定[binding].
    全局声明[proclamation]相关的信息. 

#### 3.1.1.2 <span id = "DynamicEnvironments">动态环境</span>

求值[evaluation]的动态环境[dynamic environment]是环境[environment]中包含了持续时间受限于建立绑定[binding]的表达式形式[form]执行期间绑定建立和解除的点的那些绑定[binding]的部分. 一个动态环境[dynamic environment]包括以下内容:

    动态变量[dynamic variable]的绑定[binding].
    活跃[active]的捕捉标签[catch tag]的信息.
    unwind-protect 建立的退出点[exit point]的信息.
    活跃的处理者[handler]和重启动[restart]的信息.

在程序[program]执行过程中, 在任何明确引用"当前动态环境(the current dynamic environment)", 或者有时只是"动态环境(the dynamic environment)"的地方, 动态环境[dynamic environment]都是可用的.

在给定的命名空间[namespace]中, 如果在动态环境[dynamic environment]中有一个与一个名称[name]相关联的绑定[binding], 或者在全局环境[global environment]中有一个与这个名称[name]相关联的绑定[binding], 那么就说这个名称[name]被绑定到这个动态环境[dynamic environment]中. 

#### 3.1.1.3 <span id = "LexicalEnvironments">词法环境</span>

在一个程序[program]中, 某个位置的求值[evaluation]的词法环境[lexical environment]是环境[environment]中包含了特定信息的部分, 这些信息有着包含这个位置的那些表达式形式[form]中的词法作用域[lexical scope]. 一个词法环境[lexical environment]包含以下内容:

    词法变量[lexical variable]和符号宏[symbol macro]的绑定[binding].
    函数[function]和宏[macro]的绑定. (这里隐含了关于局部禁用的编译器宏[compiler macro]的信息.)
    block 标记[block tag]的绑定[binding].
    go 标记[go tag]的绑定[binding].
    声明[declaration]的信息.

在一个正在被语义处理的程序中被明确引用为"当前词法环境(the current lexical environment)"或者有时只是"词法环境(the lexical environment)"的任何给定位置, 词法环境[lexical environment]都是有效的.

在给定的命名空间[namespace]中, 如果在词法环境[lexical environment]中有一个与一个名称[name]相关联的绑定[binding], 或者在全局环境[global environment]中有一个与这个名称[name]相关联的绑定[binding], 那么就说这个名称[name]被绑定到这个词法环境[lexical environment]中.

##### 3.1.1.3.1 空的词法环境

空的词法环境[null lexical environment]等价于全局环境[[global environment]].

虽然通常一个环境[environment]对象[object]的表示是依赖于具体实现的[implementation-dependent], 但是 nil 可以被用于任何需要一个环境[environment]对象[object]来表示表示空的词法环境[null lexical environment]的情况. 

#### 3.1.1.4 <span id = "EnvironmentObjects">环境对象</span>

一些操作符[operator]使用一个称为环境对象[environment object]的对象[object], 这表示对给定的词法环境[lexical environment]中的一个表达式形式[form]上执行语义分析所需的词法绑定[lexical binding]的集合. 环境对象[environment object]中的绑定[binding]集合可能是实际执行求值所需的绑定[binding]的子集; 比如, 在相应的词法环境[lexical environment]中与变量[variable]名[name]和函数名[function name]相关联的值[value]可能无法在一个环境对象[environment object]中使用.

一个环境对象[environment object]的类型[type]和性质是依赖于具体实现的[implementation-dependent]. 给宏函数[macro function]的环境参数[environment parameter]的值[value]就是环境对象[environment object]的示例.

当 nil 对象[object]被用于一个环境对象[environment object]时, 表示空的词法环境[null lexical environment]; 见章节 3.1.1.3.1 (空的词法环境). 

### 3.1.2 <span id = "TheEvaluationModel">求值模型</span>

一个 Common Lisp 系统根据词法, 动态和全局环境[environment]对表达式形式[form]进行求值. 下面章节描述的 Common Lisp 求值模型的组成部分.

#### 3.1.2.1 表达式形式求值

表达式形式[form]分为三个类别: 符号[symbol], cons 和自求值对象[self-evaluating object]. 下面的章节介绍这些类别.

> * 3.1.2.1.1 [符号表达式形式](#SymbolsForms)
> * 3.1.2.1.2 [cons 表达式形式](#ConsesForms)
> * 3.1.2.1.3 [自求值对象](#SelfEvaluatingObjects)

##### 3.1.2.1.1 <span id = "SymbolsForms">符号表达式形式</span>

如果一个表达式形式[form]是一个符号[symbol], 那么它要么是一个符号宏[symbol macro], 要么是一个变量[variable].

如果在当前的词法环境[lexical environment]中有这个符号[symbol]作为符号宏[symbol macro]的绑定[binding](见 define-symbol-macro 和 symbol-macrolet), 那么这个符号[symbol]就会命名一个符号宏[symbol macro]. 如果这个符号[symbol]是一个符号宏[symbol macro], 就会得到它的展开函数. 展开函数是一个带有两个参数的函数, 通过把这个展开函数作为第一个参数, 这个符号[symbol]作为第二个参数, 以及一个环境对象[environment object] (对应当前词法环境[lexical environment])作为第三个参数调用宏展开钩子[macroexpand hook]来调用它. 然后, 这个宏展开钩子[macroexpand hook]调用展开函数, 把这个表达式形式[form]作为第一个参数并且把环境[environment]作为它的第二个参数. 传递给宏展开钩子[macroexpand hook]的展开函数的值[value]是一个表达式形式[form]. 产生的这个表达式形式[form]会替换到原来符号[symbol]的位置.

如果一个表达式形式[form]是一个符号[symbol], 但不是符号宏[symbol macro], 那么它就是一个变量[variable]的名字[name], 并且返回这个变量[variable]的值[name]. 这里有三种变量: 词法变量[lexical variable], 动态变量[dynamic variable], 还有常变量[constant variable]. 一个变量[variable]可以存储一个对象[object]. 在一个变量[variable]上的主要操作是读取[read[1]]和写入[write[1]]它的值[value].

如果引用到一个未绑定的变量[unbound variable], 会发出一个 unbound-variable 类型[type]的错误.

非常量[non-constant variable]可以通过 setq 来赋值或者 let 来绑定[bound[3]]. 下面这段列出了可以赋值, 绑定, 和定义变量[variable]的一些已定义名字[defined name].

    boundp        let                  progv         
    defconstant   let*                 psetq         
    defparameter  makunbound           set           
    defvar        multiple-value-bind  setq          
    lambda        multiple-value-setq  symbol-value  

Figure 3-1. 可应用于变量的一些已定义的名字

下面是对每个变量种类的描述.

> * 3.1.2.1.1.1 [词法变量](#LexicalVariables)
> * 3.1.2.1.1.2 [动态变量](#DynamicVariables)
> * 3.1.2.1.1.3 [常变量](#ConstantVariables)
> * 3.1.2.1.1.4 [同时命名词法和动态变量的符号](#SymbolsNamingLDVariables)

###### 3.1.2.1.1.1 <span id = "LexicalVariables">词法变量</span>

词法变量[lexical variable]是一个只能在建立该变量[variable]的表达式形式[form]的词法作用域[lexical scope]内引用的变量[variable]; 词法变量[lexical variable]有词法作用域[lexical scope]. 每次一个表达式形式[form]创建一个变量[variable]的词法绑定, 就建立一个新的绑定[fresh binding].

在一个词法变量[lexical variable]名字[name]的绑定[binding]的作用域[scope]里, 这个名字[name]作为变量[variable]的使用被认为是对这个绑定[binding]的引用, 除了这个变量[variable]被遮蔽[shadow[2]]的地方, 通过一个建立[establish]该变量[variable]名[name]的新的[fresh]绑定[binding]的表达式形式[form], 或者通过一个表达式形式[form]将该名字[name]局部声明[declare]为 special.

一个词法变量[lexical variable]总是有一个值[value]. 这里没有可以引入一个词法变量[lexical variable]的绑定[binding]而没有给初始值[value]的操作符[operator], 也没有任何操作符[operator]可以使一个词法变量[lexical variable]解绑[unbound].

词法变量[lexical variable]的绑定[binding]可以在词法环境[lexical environment]中找到. 

###### 3.1.2.1.1.2 <span id = "DynamicVariables">动态变量</span>

如果一个变量[variable]满足下面条件的其中之一, 那么这个变量[variable]就是一个动态变量[dynamic variable]:

    它被局部声明或全局声明为 special.

    它以文本形式出现在一个为相同[same]名字[name]的变量[variable]创建一个动态绑定[dynamic binding]的表达式形式[form]中, 并且这个绑定[binding]没有被一个对相同变量[variable]名[name]创建词法绑定[lexical binding]的表达式形式[form]所遮蔽[shadow[2]].

一个动态变量[dynamic variable]可以在任何程序[program]的任何时间被引用; 对动态变量[dynamic variable]的引用没有文本限制. 在任何给定时间, 具有给定名称的所有动态变量[dynamic variable]都精确地引用一个绑定[binding], 不管是在动态环境[dynamic environment]中或全局环境[global environment]中.

一个动态变量[dynamic variable]的绑定[binding]的值[value]部分可能是空的; 在这个情况下, 就说这个动态变量[dynamic variable]没有值[value]或者被解除绑定[unbound]. 一个动态变量[dynamic variable]可以通过使用 makunbound 来解除绑定[unbound].

绑定[binding]一个动态变量[dynamic variable]的效果是创建一个新的绑定[binding], 在创建这个动态绑定[dynamic binding]的表达式形式[form]求值[evaluation]期间, 任何程序[program]中所有对该动态变量[dynamic variable]的引用都是指新创建的绑定.

动态变量[dynamic variable]可以在绑定[bind]它的表达式形式[form]的动态范围[dynamic extent]之外引用. 这种变量[variable]有时被称为"全局变量(global variable)", 但它仍然在所有方面都只是一个动态变量[dynamic variable], 它的绑定[binding]恰好存在于全局环境[global environment]中, 而不是在某些动态环境[dynamic environment]中.

除了这个规范或具体实现[implementation]中定义了初始值的变量以外的动态变量[dynamic variable]除非显式赋值, 否则就是未绑定的[unbound]. 

###### 3.1.2.1.1.3 <span id = "ConstantVariables">常变量</span>

某些变量, 称为常变量[constant variable], 被保留为"已命名常量(named constants)". 如果尝试去给它赋值, 或者给一个常变量[constant variable]创建一个绑定[binding], 后果是未定义的, 除了使用兼容的 defconstant 去重定义一个常变量[constant variable]是允许的; 见宏[macro] defconstant.

关键字[keyword], Common Lisp 或者具体实现[implementation]定义为常量的符号[symbol] (就像 nil, t, 和 pi), 还有通过 defconstant 声明为常量的符号也是常变量[constant variable]. 

###### 3.1.2.1.1.4 <span id = "SymbolsNamingLDVariables">同时命名词法和动态变量的符号</span>

同一个符号[symbol]可以命名一个词法变量[lexical variable]和动态变量[dynamic variable], 但是从来不出现在相同的词法环境[lexical environment]中.

下面的例子中, 符号 x 在不同的时间被用作词法变量[lexical variable]的名字[name]和动态变量[dynamic variable]的名字[name].

```LISP
(let ((x 1))            ;Binds a special variable X
  (declare (special x))
  (let ((x 2))          ;Binds a lexical variable X
    (+ x                ;Reads a lexical variable X
      (locally (declare (special x))
                x))))   ;Reads a special variable X
=>  3
```

##### 3.1.2.1.2 <span id = "ConsesForms">cons 表达式形式</span>

用作一个表达式形式[form]的一个 cons, 被称为为复合表达式形式[compound form].

如果这个复合表达式形式[compound form]的 car 是一个符号[symbol], 这个符号[symbol]是一个操作符[operator]的名字[name], 那么这个表达式形式[form]是一个特殊表达式形式[special form], 一个宏表达式[macro form], 或者是一个函数表达式[function form], 取决于这个操作符[operator]在当前词法环境[lexical environment]的函数[function]绑定[binding]. 如果这个操作符[operator]既不是一个特殊操作符[special operator]也不是一个宏名字[macro name], 那么它被假定为一个函数名字[function name] (即便在这里没有这样的一个函数[function]定义).

如果这个复合表达式形式[compound form]的 car 部分不是一个符号[symbol], 那么这个 car 必须是一个 lambda 表达式[lambda expression], 在这个情况下这个复合表达式形式[compound form]就是一个 lambda 表达式形式[lambda form].

一个复合表达式[compound form]如何被处理取决于它被归类为特殊表达式形式[special form], 宏表达式形式[macro form], 函数表达式形式[function form], 还是一个 lambda 表达式形式[lambda form].

> * 3.1.2.1.2.1 [特殊表达式形式](#SpecialForms)
> * 3.1.2.1.2.2 [宏表达式形式](#MacroForms)
> * 3.1.2.1.2.3 [函数表达式形式](#FunctionForms)
> * 3.1.2.1.2.4 [lambda 表达式形式](#LambdaForms)

###### 3.1.2.1.2.1 <span id = "SpecialForms">特殊表达式形式</span>

一个特殊表达式形式[special form]是一个带有特殊语法或者特殊求值规则或者两者都有的表达式形式[form], 可能控制求值环境, 控制流, 或者都控制. 一个特殊操作符[special operator]可以访问当前的词法环境[lexical environment]和当前的动态环境[dynamic environment]. 每个特殊操作符[special operator]都定义了它的那些子表达式[subexpression]的处理方式---哪些是表达式形式[form], 哪些是特殊语法, 等等.

一些特殊操作符[special operator]创建新的词法或动态环境[environment], 以便在对这个特殊表达式形式[special form]的那些子表达式形式[subform]的求值[evaluation]期间使用. 比如, block 会创建一个新的词法环境[lexical environment], 该环境与 block 表达式形式[form]的求值时的那个相同, 只是在 block 的退出点[exit point]添加了 block 名称的绑定[binding].

特殊操作符[special operator]的名字[name]的集合在 Common Lisp 中是固定的; 没有给用户提供定义特殊操作符[special operator]的方法. 下面这段列出了所有被定义为特殊操作符[special operator]的 Common Lisp 符号[symbol].

    block      let*                  return-from      
    catch      load-time-value       setq             
    eval-when  locally               symbol-macrolet  
    flet       macrolet              tagbody          
    function   multiple-value-call   the              
    go         multiple-value-prog1  throw            
    if         progn                 unwind-protect   
    labels     progv                                  
    let        quote                                  

Figure 3-2. Common Lisp 特殊操作符

###### 3.1.2.1.2.2 <span id = "MacroForms">宏表达式形式</span>

如果这个操作符[operator]命名了一个宏[macro], 它关联的宏函数[macro function]会被应用于整个表达式形式[form]并且将这个应用的结果替换原来的表达式形式[form].

具体来说, 如果对于一个符号[symbol]和一个给定的词法环境[lexical environment] macro-function 返回 true 那么在这个环境中这个符号[symbol]命名了一个宏[macro]. 这个 macro-function 返回的函数[function]是一个 2 个参数的函数[function], 称之为展开函数. 通过把这个展开函数作为第一个参数, 整个宏表达式形式[macro form]作为第二个参数, 以及一个环境对象[environment object] (对应当前词法环境[lexical environment])作为第三个参数调用宏展开钩子[macroexpand hook]来调用这个展开函数. 这个宏展开钩子[macroexpand hook]反过来调用这个展开函数, 将这个表达式形式[form]作为第一个参数并将环境对象[environment object]作为第二个参数. 这个传递给宏展开钩子[macroexpand hook]的展开函数的值[value]是一个表达式形式[form]. 返回的表达式形式[form]被求值来取代原来的表达式形式[form].

如果这个宏函数[macro function]破坏性地修改它的表达式形式[form]参数的任何部分, 那么后果是未定义的.

一个宏名字[macro name]不是一个函数标识符[function designator], 并且不能被用于例如 apply, funcall, 或者 map 这样的函数[function]的 function 参数.

一个具体实现[implementation]可以自由地将 Common Lisp 特殊操作符[special operator]实现为一个宏[macro]. 一个实现[implementation]也能自由地将任何宏[macro]操作符[operator]实现为一个特殊操作符[special operator], 但是只能在这个宏[macro]的一个等价定义被提供的情况下.

下面这段列出了一些可应用于宏[macro]的一些已定义名字[defined name].

    *macroexpand-hook*  macro-function  macroexpand-1  
    defmacro            macroexpand     macrolet       

Figure 3-3. 应用于宏的定义的名字

###### 3.1.2.1.2.3 <span id = "FunctionForms">函数表达式形式</span>

如果这个操作符[operator]是一个命名一个函数[function]的符号[symbol], 那么这个表达式形式[form]就表示一个函数表达式形式[function form], 并且这个列表的 cdr 部分包含了求值后作为参数传递给这个函数[function]的表达式形式[form].

当一个函数名字[function name]没有定义的时候, 应该会在运行时发出一个 undefined-function 类型[type]的错误; 见章节 3.2.2.3 (语义约束).

一个函数表达式形式[function form]会按如下所述被求值:

原始表达式形式[form]的 cdr 中的子表达式形式[subform]按照从左到右的顺序在词法和动态环境[environment]中被求值. 每次这样的求值[evaluation]的主值[primary value]作为参数传递给命名的函数[function]; 任何子表达式形式[subform]返回的额外的值[value]会被丢弃.

从词法环境[lexical environment]中检索操作符[operator]的函数值[functional value], 并使用指定的参数调用该函数[function].

虽然实参[argument]子表达式形式[subform]的求值[evaluation]顺序是严格的从左到右, 但是没有指定一个函数表达式形式[function form]中操作符[operator]的定义是在实参[argument]子表达式形式[subform]求值之前还是之后被查找, 或者不止一个实参[argument]子表达式形式[subform]时任意两个实参[argument]子表达式形式[subform]求值之间被查找. 比如, 下面可能返回 23 或者 24.

```LISP
(defun foo (x) (+ x 3))
(defun bar () (setf (symbol-function 'foo) #'(lambda (x) (+ x 4))))
(foo (progn (bar) 20))
```

一个函数名字[function name]的绑定[binding]可以通过几种方式的一种来建立. 一个全局环境[global environment]中的函数名[function name]的绑定[binding]可以通过 defun ,fdefinition 的 setf, symbol-function 的 setf, ensure-generic-function, defmethod (隐式的, 由于ensure-generic-function), 或者 defgeneric 来建立. 一个词法环境[lexical environment]中的函数名[function name]的绑定[binding]可以通过 flet 或者 labels 来建立.

下一段中列出了可应用于函数[function]的一些已定义的名字[defined name].

    apply                 fdefinition  mapcan               
    call-arguments-limit  flet         mapcar               
    complement            fmakunbound  mapcon               
    constantly            funcall      mapl                 
    defgeneric            function     maplist              
    defmethod             functionp    multiple-value-call  
    defun                 labels       reduce               
    fboundp               map          symbol-function      

Figure 3-4. 一些已定义的函数相关的名字 

###### 3.1.2.1.2.4 <span id = "LambdaForms">lambda 表达式形式</span>

一个 lambda 表达式形式[lambda form]类似于函数表达式[function form], 除了函数名[function name]被一个 lambda 表达式[lambda expression]替换.

一个 lambda 表达式形式[lambda form]等价于在给定的那些实参[argument]上使用一个 lambda 表达式[lambda expression]的词法闭包[lexical closure]的 funcall 调用. (在实践中, 比起已声明为 inline 的任意命名函数, 一些编译器更有可能为  lambda 表达式形式[lambda form]生成内联代码.)

关于更多信息, 见章节 3.1.3 (lambda 表达式). 

##### 3.1.2.1.3 <span id = "SelfEvaluatingObjects">自求值对象</span>

一个既不是一个符号[symbol]也不是一个 cons 的表达式形式[form]被定义为一个自求值对象[self-evaluating object]. 对这样的对象[object]进行求值, 会产生[yield]相同的[same]对象[object]来作为结果.

某些特定的符号[symbol]和 cons 偶尔也可能是"自求值", 但只是作为关于符号[symbol]和 cons 求值[evaluation]的一个更普遍的规则集合的特例; 这样的对象[object]不被认为是自求值对象[self-evaluating object].

如果字面[literal]对象[object] (包括自求值对象[self-evaluating object])被破坏性的修改, 结果是无法定义的.

###### 3.1.2.1.3.1 自求值对象的示例

数字[number], 路径名[pathname], 还有数组[array]都是自求值对象[self-evaluating object]的示例.

```LISP
3 =>  3
#c(2/3 5/8) =>  #C(2/3 5/8)
#p"S:[BILL]OTHELLO.TXT" =>  #P"S:[BILL]OTHELLO.TXT"
#(a b c) =>  #(A B C)
"fred smith" =>  "fred smith"
```

### 3.1.3 <span id = "LambdaExpressions">lambda 表达式</span>

在 lambda 表达式[lambda expression]中, 主体部分在一个词法环境[lexical environment]中求值, 这个词法环境[lexical environment]是通过添加 lambda 列表[lambda list]中的每个形参[parameter]和来自实参[argument]的对应值[value]的绑定[binding]到当前词法环境[environment]中来构成的.

有关如何基于 lambda 列表[lambda list]建立绑定[binding]的进一步讨论, 见章节 3.4 (Lambda 列表).

一个 lambda 表达式[lambda expression]的主体是一个隐式 progn [implicit progn]; 它返回的值会被这个 lambda 表达式[lambda expression]返回. 

### 3.1.4 <span id = "ClosuresLexicalBinding">闭包和词法绑定</span>

一个词法闭包[lexical closure]是一个函数[function], 它可以引用和更改由包含函数定义的绑定[binding]表达式形式[form]所建立的词法绑定[lexical binding]的值.

细想这段 x 没有声明为 special 的代码:

```LISP
(defun two-funs (x)
  (list (function (lambda () x))
        (function (lambda (y) (setq x y)))))
(setq funs (two-funs 6))
(funcall (car funs)) =>  6
(funcall (cadr funs) 43) =>  43
(funcall (car funs)) =>  43
```

这个 function 的特殊表达式形式[special form]将一个 lambda 表达式[lambda expression]强制转换为闭包[closure], 当对这个特殊表达式形式[special form]进行求值时, 事实上这个词法环境[lexical environment]与这个 lambda 表达式[lambda expression]一起被捕获到这个闭包[closure]中.

这个 two-funs 函数返回一个两函数[function]的列表[list], 它们中的每一个都引用了函数 two-funs 被调用时在入口创建的变量 x 的绑定[binding]. 这个变量有初始值 6, 但是 setq 可以修改这个绑定[binding]. 为第一个 lambda 表达式[lambda expression]创建的词法闭包[lexical closure]在创建这个闭包[closure]时不会"快照(snapshot)" x 的值[value] 6;而是捕捉了 x 的绑定. 第二个函数[function]可以被用于修改相同的(被捕获的)绑定[binding]中的值[value] (在示例中改为 43), 并且这个修改后的变量绑定接下来影响了第一个函数[function]的返回值.

在同一组绑定中, 一个 lambda 表达式[lambda expression]的闭包[closure]可能不止一次地产生的情况下, 产生的多个闭包[closure]可能或可能不相同[identical], 由具体实现来决定. 也就是说, 两个行为无法区分的函数[function]可能或可能不相同[identical]. 行为上可区分的两个函数[function]是截然不同的[distinct]. 示例:

```LISP
(let ((x 5) (funs '()))
  (dotimes (j 10)                          
    (push #'(lambda (z)                        
              (if (null z) (setq x 0) (+ x z)))
          funs))
  funs)
```

上面表达式形式[form]的结果是是一个十个闭包[closure]的列表[list]. 每一个都只需要 x 的绑定[binding]. 每个情况下都是相同的绑定[binding], 但是这十个闭包[closure]对象[object]可能或可能不相同[identical]. 另一方面, 下面这个表达式形式[form]的结果

```LISP
(let ((funs '()))     
  (dotimes (j 10)
    (let ((x 5))
      (push (function (lambda (z)
                      (if (null z) (setq x 0) (+ x z))))
            funs)))
funs)
```

也是十个闭包[closure]的列表[list]. 然而, 在这个情况下没有两个闭包[closure]对象[object]是相同的[identical]因为每一个闭包[closure]都封闭了一个不同的 x 的绑定[binding], 并且由于 setq 的使用这些绑定[binding]可以从行为上区分.

下面这个表达式形式[form]的结果

```LISP
(let ((funs '()))
  (dotimes (j 10)
    (let ((x 5))
      (push (function (lambda (z) (+ x z)))
          funs)))
  funs)
```

是一个可能或可能不相同[identical]的十个闭包[closure]对象[object]的列表[list]. 每一个闭包[closure]都涉及一个不同的 x 的绑定[binding], 但是这些绑定[binding]是不能区分的, 因为它们的值是相同的[same]且不可变 (这里没有在 x 上进行 setq 操作). 一个编译器可以在内部把这个表达式形式[form]转换成下面这种

```LISP
(let ((funs '()))
  (dotimes (j 10)
    (push (function (lambda (z) (+ 5 z)))
          funs))
funs)
```

其中的闭包[closure]可能是一样的.

一个闭包[closure]没有封闭任何变量绑定也是可能的. 在这个代码片段中

```LISP
(mapcar (function (lambda (x) (+ x 2))) y)
```

函数 (lambda (x) (+ x 2)) 没有包含任何外部对象的引用. 在这个情况下, 对于所有的 function 表达式形式[form]的求值, 可能返回相同的闭包[closure]. 

### 3.1.5 <span id = "Shadowing">遮蔽</span>

如果用相同的名字[name] N 建立[establish]词法绑定[lexical binding]的两个表达式形式[form]在文本上是嵌套的, 那么内部表达式形式[form]对 N 的引用会引用到内部表达式形式[form]建立的绑定[binding]; 这个内部 N 的绑定[binding]会遮蔽[shadow]外部 N 的绑定[binding]. 内部表达式形式[form]外面但是外部那个的里面对 N 的引用会引用到外部表达式形式[form]建立的绑定[binding]上. 比如:

```LISP
(defun test (x z)
  (let ((z (* x 2)))
    (print z))
  z)
```

由 let 创建的这个变量 z 的绑定[binding]遮蔽了函数 test 的形参[parameter]绑定. 在 print 表达式形式[form]中对变量 z 的引用会引用 let 绑定的. 在函数 test 的最后对 z 的引用会引用到名为 z 的形参[parameter]上.

具有词法作用域的构造就像在每次执行时为每个对象[object]生成新的名称一样. 因此, 动态遮蔽不会发生. 比如:

```LISP
(defun contorted-example (f g x)
  (if (= x 0)
      (funcall f)
      (block here
        (+ 5 (contorted-example g
                                #'(lambda () (return-from here 4))
                                (- x 1))))))
```

细想 (contorted-example nil nil 2) 这个调用. 这个产生 4. 在执行过程中, 这个有三个对 contorted-example 的调用, 带有 2 个 block 交错:

```LISP
(contorted-example nil nil 2)
  (block here1 ...)
    (contorted-example nil #'(lambda () (return-from here1 4)) 1)
      (block here2 ...)
        (contorted-example #'(lambda () (return-from here1 4))
                          #'(lambda () (return-from here2 4))
                          0)
            (funcall f)
                  where f =>  #'(lambda () (return-from here1 4))
                (return-from here1 4)
```

在执行 funcall 的时候, 有两个未偿还的 block 退出点[exit point], 每个都明显命名为 here. 这个被作为 funcall 操作的结果执行的 return-from 表达式形式[form]引用外面的未偿还的退出点[exit point] (here1), 不是内部的那个(here2). 它指的是在 function (这里通过 #' 语法缩写了)执行时文本上可见的退出点[exit point], 这个 function 导致了实际被 funcall 调用的函数[function]对象[object]的创建.

如果在这个例子中, 一个人打算把 (funcall f) 改为 (funcall g), 那么调用 (contorted-example nil nil 2) 的值会是 9. 这个值会改变是因为 funcall 会导致 (return-from here2 4) 的执行, 从而导致一个从内部的退出点[exit point] (here2)的返回. 当这个发生时, 值 4 会被中间的 contorted-example 调用返回, 5 被加到它上面成了 9, 并且这个值会被外部 block 和外部 contorted-example 调用返回. 重点是, 返回的退出点[exit point]的选择与它是最内部或最外层无关; 而是, 它取决于在执行 function 时和 lambda 表达式[lambda expression]一起打包的词法环境[lexical environment]. 

### 3.1.6 <span id = "Extent">范围</span>

这个 contorted-example 可以工作仅因为在退出点[exit point]的范围[extent]内调用了由 f 命名的函数[function]. 一旦这个执行的控制流离开了这个 block, 这个退出点[exit point]就会被废除. 比如:

```LISP
(defun invalid-example ()
  (let ((y (block here #'(lambda (z) (return-from here z)))))
    (if (numberp y) y (funcall y 5))))
```

您可能期望调用 (invalid-example) 根据以下不正确的推理生成 5: let 把 y 绑定到 block 的值; 这个值是一个由 lambda 表达式[lambda expression]产生的函数. 因为 y 不是一个数字, 所以它被在值 5 上被调用. 这个 return-from 应该从名为 here 的退出点[exit point]返回这个值, 从而再一次退出 block 并且把值 5 给 y, 成为一个数字, 然后把这个值作为调用 invalid-example 的结果返回.

这个论证失败仅因为退出点[exit point]有动态范围[dynamic extent]. 这个论证直到 return-from 的执行还是正确的. 这个 return-from 的执行应该会发出一个 control-error 类型[type]的错误, 然而, 不是因为它不能引用到那个退出点[exit point]而发出, 而是因为它正确地引用到那个退出点[exit point]而那个退出点[exit point]已经被废弃.

一个根据名字对动态退出点[exit point]绑定的引用, 如 catch 标记[catch tag], 引用的是最近已建立的还没有被废弃的该名称的绑定[binding]. 比如:

```LISP
(defun fun1 (x)
  (catch 'trap (+ 3 (fun2 x))))
(defun fun2 (y)
  (catch 'trap (* 5 (fun3 y))))
(defun fun3 (z)
  (throw 'trap z))
```

细想这个调用 (fun1 7). 结果是 10. 在那个 throw 被执行的时候, 这里有两个未偿还的带有名字 trap 的捕捉者(catcher): 一个在程序 fun1 中建立, 并且另外一个在程序 fun2 中建立. 后面那个更接近, 所以这个值 7 是从 fun2 的 catch 中被返回. 从 fun3 中来看, 在 fun2 中的那个 catch 遮蔽了在 fun1 中的那个. fun2 被定义为

```LISP
(defun fun2 (y)
  (catch 'snare (* 5 (fun3 y))))
```

那么两个退出点[exit point]会有不同的名字[name], 因此 fun1 的那个不会被遮蔽. 这个结果会是 7. 

### 3.1.7 <span id = "ReturnValues">返回值</span>

通常调用函数[function]的结果是一个单独的对象[object]. 然而, 有时候, 一个函数可以很方便地计算多个对象[object]并返回它们.

为了从一个表达式形式[form]接受一个以上的返回值, 几个特殊表达式形式[special form]或宏[macro]中的一个必须被用于请求那些值. 如果一个表达式形式[form]产生了多值[multiple value]但是没有以这种方式接收, 那么第一个返回值会被给到调用者并且其他的会被丢弃; 如果这个表达式形式[form]产生零个值, 那么调用者会收到一个 nil 作为值.

下面这段列出了接收多值[multiple value]的操作符[operator]. 这些操作符[operator]可以被用于指定一个或多个表达式形式[form]去求值[evaluate]以及指定这些表达式形式[form]返回的那些值[value]放置到哪里.

    multiple-value-bind  multiple-value-prog1  return-from  
    multiple-value-call  multiple-value-setq   throw        
    multiple-value-list  return                             

Figure 3-5. 一些可应用于接收多值的操作符

函数[function] values 可以被用于产生多值[multiple values[2]]. (values) 返回 0 个值; (values form) 返回 form 返回的主值[primary value]; (values form1 form2) 返回两个值, form1 的主值[primary value]和 form2 的主值[primary value]; 以此类推.

见 multiple-values-limit 和 values-list. 

## 3.2 <span id = "Compilation">编译</span>

> * 3.2.1 [编译器术语](#CompilerTerminology)
> * 3.2.2 [编译语义](#CompilationSemantics)
> * 3.2.3 [文件编译](#FileCompilation)
> * 3.2.4 [编译后文件中的字面化对象](#LiteralObjectsInCompiledFiles)
> * 3.2.5 [编译器中的异常情况](#ExceptionalSituationsCompiler)

### 3.2.1 <span id = "CompilerTerminology">编译器术语</span>

以下术语被用于这个章节.

编译器[compiler]是一个将代码转换为一个具体实现相关的[implementation-dependent]可以被有效地表示和执行的形式的工具. 术语编译器[compiler]指的是 compile 和 compile-file 这两个函数[function].

术语编译后的代码[compiled code]指的是表示编译后程序的对象[object], 例如加载一个编译后文件[compiled file]时被 compile 或者 load 构造的对象[object].

术语隐式编译[implicit compilation]指的是在求值[evaluation]期间执行的编译[compilation].

术语字面化[literal]对象[object]指的是一个引用的对象[object]或者一个自求值对象[self-evaluating object]或者一个这样的对象的底层结构对象[object]. 一个常变量[constant variable]自身不是一个字面化[literal]对象[object].

术语合并[coalesce]按如下定义. 假定 A 和 B 是源代码[source code]中的两个字面化[literal]常量[constant], 并且 A' 和 B' 是编译后代码[compiled code]中对应的对象[object]. 如果 A' 和 B' 是 eql 但是 A 和 B 不是 eql, 那么就说 A 和 B 被编译器所合并.

术语最小编译[minimal compilation]指的是编译器必须在编译期[compile time]执行的动作. 这些动作声明在章节 3.2.2 (编译语义).

动词处理[process]指的是执行最小编译[minimal compilation], 确定一个表达式形式[form]的求值时间, 并可能求值该表达式形式[form] (如果需要的话).

术语进一步编译[further compilation]指的是超出最小编译[minimal compilation]的依赖于具体实现的[ implementation-dependent]的编译. 这就意味着, 处理并不意味着完整编译. 块编译和机器特定指令的生成是进一步编译的示例. 进一步编译允许发生在运行时[run time].

区分与编译相关的 4 个不同的环境[environment]: 启动环境[startup environment], 编译环境[compilation environment], 求值环境[evaluation environment], 还有运行时环境[run-time environment].

启动环境[startup environment]是编译器被调用的那个 Lisp 镜像[Lisp image]的环境[environment].

编译环境[compilation environment]由编译器维护, 并用于保存编译器内部使用的定义和声明. 只有正确编译所需的定义部分才会被保存. 编译环境[compilation environment]用作编译器调用的宏展开函数的环境[environment]实参[argument]. 在编译环境[compilation environment]中可用的定义是否可以用于启动环境[startup environment]或求值环境[evaluation environment]中所启动的求值[evaluation]中, 这是未知的.

求值环境[evaluation environment]是一个运行时环境[run-time environment], 在这个环境中, 由 eval-when 指定的要被求值的代码和宏展开会被求值. 由编译器[compiler]发起的所有求值都在求值环境[evaluation environment]中进行.

运行时环境[run-time environment]是被编译后的的程序将被执行的环境[environment].

编译环境[compilation environment]从求值环境[evaluation environment]继承而来, 并且编译环境[compilation environment]和求值环境[evaluation environment]可能是相同的[identical]. 这个求值环境[evaluation environment]从启动环境[startup environment]中继承而来, 并且这个启动环境[startup environment]和求值环境[evaluation environment]可能是一样的[identical].

术语编译期[compile time]指的是编译器处理源代码[source code]的那段时间. 在编译期[compile time], 只有编译环境[compilation environment]和求值环境[evaluation environment]可用.

术语编译期定义[compile-time definition]指的是编译环境[compilation environment]中的定义. 比如, 编译一个文件时, 一个函数如果声明为 inline, 那么它的定义可能被保留在编译环境[compilation environment]中. 这个定义可能在求值环境[evaluation environment]中不可用.

术语运行时[run time]指的是加载器加载编译后的代码或编译后的代码被执行的那段时间. 在运行时, 只有运行时环境[run-time environment]可用.

术语运行时定义[run-time definition]指的是运行时环境[run-time environment]中的一个定义.

术语运行时编译器[run-time compiler]指的是 compile 函数[function]或者隐式编译[implicit compilation], 对于它们来说编译和运行时环境[environment]是在同一个 Lisp 镜像[Lisp image]中. 注意当运行时编译器[[run-time compiler]]被使用时, 运行时环境[run-time environment]和启动环境[startup environment]是一样的. 

### 3.2.2 <span id = "CompilationSemantics">编译语义</span>

从概念上讲, 编译是一个遍历代码, 使用在编译环境[compilation environment]中提供的信息(如全局声明和宏[macro]定义)来执行特定的语法和语义分析, 并生成等价的, 可能更有效的代码的过程.

> * 3.2.2.1 [编译器宏](#CompilerMacros)
> * 3.2.2.2 [最小化编译](#MinimalCompilation)
> * 3.2.2.3 [语义约束](#SemanticConstraints)

#### 3.2.2.1 <span id = "CompilerMacros">编译器宏</span>

编译器宏[compiler macro]可以定义给一个名字[name], 这个名字[name]同时命名一个函数[function]或宏[macro]. 这也就是说, 一个函数名[function name]可能同时命名函数[function]和编译器宏[compiler macro].

如果 compiler-macro-function 对于出现在词法环境[lexical environment]中的一个函数名[function name]返回 true, 这个函数名[function name]命名一个编译器宏[compiler macro]. 为这个函数名[function name]创建一个词法绑定[lexical binding]不止创建一个局部函数[function]或宏[macro]定义, 并且也遮蔽[shadows[2]]了这个编译器宏[compiler macro].

这个 compiler-macro-function 返回的函数[function]是一个两个参数的函数[function], 称为展开函数(expansion function). 为了展开一个编译器宏[compiler macro], 通过用这个展开函数作为第一个参数, 整个编译器宏表达式形式[form]作为第二个参数, 当前编译环境(或者如果这个表达式形式[form]被 compile-file 以外的其他处理过, 那么就是当前的词法环境[environment])作为第三个参数来调用宏展开钩子[macroexpand hook]进而调用这个展开函数. 宏展开钩子[macroexpand hook]反过来将这个表达式形式[form]作为第一个参数而环境[environment]作为第二个参数来调用这个展开函数. 展开函数的返回值, 由宏展开钩子函数传递, 可能是相同的[same]表达式形式[form], 或者是另一种表达式形式[form], 由执行展开的代码[code]决定, 被用于替换到原始表达式形式[form].

    *macroexpand-hook*  compiler-macro-function  define-compiler-macro  

Figure 3-6. 应用于编译器宏的定义的名字

##### 3.2.2.1.1 编译器宏的目的

这个编译器宏[compiler macro]机制的目的是允许选择性的源代码转换为编译器的优化建议. 当一种复合表达式形式[compound form]被处理(例如被编译器), 如果这个操作符[operator]命名了一个编译器宏[compiler macro], 那么这个编译器宏函数[compiler macro function]可能在这个表达式形式[form]上被调用, 而产生的展开进行递归处理优先于在原始表达式形式[form]上根据它作为函数表达式形式[function form]或宏表达式形式[macro form]的解释执行常规处理.

一个编译器宏函数[compiler macro function], 就像一个宏函数[macro function], 是一个两个实参[argument]的函数[function]: 整个调用的表达式形式[form]和那个环境[environment]. 不像一个普通的宏函数[macro function], 一个编译器宏函数[compiler macro function]可以通过只返回与原始表达式形式[form]相同的值来拒绝提供展开式. 如果编译器宏函数[compiler macro function]破坏性地修改的它的表达式形式[form]参数的任何部分, 那么后果是未定义的.

传递给编译器宏函数[compiler macro function]的表达式形式[form]可以是一个 car 部分为一个函数名的列表[list]或者一个 car 部分是 funcall 并且 cadr 部分是一个列表 (function name) 的列表; 注意, 这会影响编译器宏函数[compiler macro function]对表达式形式参数的解构. define-compiler-macro 会为两种可能的格式的参数正确解构做准备.

当 compile-file 选择展开一个是编译器宏[compiler macro]表达式形式[form]的顶层表达式形式[top level form]时, 那么展开式出于 eval-when 处理的目的也被当作顶层表达式形式[top level form]来处理; 见章节 3.2.3.1 (顶层表达式形式的处理). 

##### 3.2.2.1.2 编译器宏的命名

编译器宏[compiler macro]可以被定义为命名了函数[function]和宏[macro]的函数名[function name].

编译器宏[compiler macro]定义是严格的全局定义. 没有提供 macrolet 定义局部宏[macro]的方式来定义局部编译器宏[compiler macro]. 一个函数名字的词法绑定会遮蔽任何和这个名字关联的编译器宏[compiler macro], 还有和这个名字关联的全局的函数[function]和宏[macro]定义.

注意, 编译器宏定义的存在不会影响访问函数定义(比如, fboundp)或宏定义(比如, macroexpand)的函数返回的值. 编译器宏是全局的, 并且函数 compiler-macro-function 足以解决它们与其他词法和全局定义之间的交互作用. 

##### 3.2.2.1.3 编译器宏被使用的时机

一个函数[function]或宏[macro]的编译器宏[compiler macro]定义的存在表明, 编译器应该使用编译器宏[compiler macro]的展开, 而不是原来的函数表达式形式[function form]或宏表达式形式[macro form]. 然而, 任何语言处理器(编译器, 求值器, 或者其他的 code walker)都不需要实际调用编译器宏函数[compiler macro function], 或者如果调用编译器宏函数[compiler macro function]也不使用产生的展开.

当编译器[compiler]在处理时遇到一个对编译器宏[compiler macro]名称[name]调用的表达式形式[form] (这个没有被声明为 notinline)时, 编译器[compiler]可能会展开编译器宏[compiler macro], 并可能使用展开式代替原始表达式形式[form].

当 eval 在处理时遇到一个对编译器宏[compiler macro]名称[name]调用的表达式形式[form] (这个没有被声明为 notinline)时, eval 可能会展开编译器宏[compiler macro], 并可能使用展开式代替原始表达式形式[form].

这里有两个编译器宏[compiler macro]定义一定不能被任何语言处理器所使用的情况:

    与编译器宏关联的全局函数名称绑定被那个函数名的词法绑定所遮蔽.

    函数名已被全局声明或局部声明为 notinline, 而调用表达式形式出现在声明的作用域内.

在其他情况下, 编译器宏[compiler macro]是否被展开或使用是未知的.

###### 3.2.2.1.3.1 关于编译器宏实现的注意事项

如上所述, 虽然从技术上允许 eval 在和编译器[compiler]相同的情况下去处理编译器宏[compiler macro], 但是这在解释型具体实现[interpreted implementation]中并不一定是个好主意.

编译器宏[compiler macro]的存在是为了用编译时速度换取运行时速度的目的. 编写编译器宏[compiler macro]的程序员倾向于假设编译器宏[compiler macro]比正常函数[function]和宏[macro]花费更多的时间进而来生成用于运行时的最佳的代码. 由于 eval 在解释型具体实现[interpreted implementation]中可能多次执行相同表达式形式的语义分析, 因此具体实现[implementation]在每次这样的求值[evaluation]中选择调用编译器宏[compiler macro]可能会很低效.

然而, 关于在这些情况下应该做什么的决定留给每个具体实现[implementation]. 

#### 3.2.2.2 <span id = "MinimalCompilation">最小化编译</span>

最小化编译[minimal compilation]根据如下定义:

    在编译时, 正在编译的源代码[source code]中出现的所有编译器宏[compiler macro]调用都被展开; 它们不会在运行时展开.

    正在编译的源代码中出现的所有宏[macro]和符号宏[symbol macro]调用都在编译时进行展开, 这样它们就不会在运行时再次被展开. macrolet 和 symbol-macrolet 实际上被替换为与它们的主体相对应的表达式, 在这里, 对宏[macro]的调用被它们的展开式所取代.

    在被 compile 处理的源代码[source code]中一个 load-time-value 表达式形式[form]的第一个实参[argument]在编译期[compile time]被求值; 在被 compile-file 处理的源代码[source code]中, 编译器安排它在加载时[load time]被求值. 不论发生何种情况, 这个求值[evaluation]的结果会被记住并且在执行时[execution time]被用于后面 load-time-value 表达式形式[form]的值. 

#### 3.2.2.3 <span id = "SemanticConstraints">语义约束</span>

所有符合规范的程序[conforming program]必须遵守以下约束, 这些被设计用于减少编译和解释的程序的可观测差异:

  * 任何被引用的宏[macro]的定义必须出现在编译环境[compilation environment]中. 任何以一个不是命名该编译环境[compilation environment]中定义的特殊操作符[special operator]或宏[macro]的符号[symbol]开始的列表[list]表达式形式[form]会被编译器当作一个函数调用.

  * 动态变量[dynamic variable]的 special 公告必须在编译环境[compilation environment]中做出. 在编译环境[compilation environment]中没有 special 声明或公告的任何绑定[binding]都被编译器视为词法绑定[lexical binding].

  * 在编译环境[compilation environment]中定义和声明为 inline 的函数的定义在运行时必须是相同的.

  * 在一个名为 F 的函数[function]中, 这个编译器可能 (但不是必须) 假定一个对名为 F 的函数的明显递归调用指向 F 的相同定义, 除非这个函数已经被声明为 notinline. 在函数[function] F 执行时, 重定义这样一个递归定义函数[function] F 的后果是没有定义的.

  * 在一个文件中对一个定义在相同文件中的已命名函数的调用指的就是那个函数, 除非该函数被声明为 notinline. 如果函数在运行时被单独重定义或者在一个相同文件里多次定义, 那么后果是未指定的.

  * 所有在编译时声明 ftype 的函数的参数语法和返回值数量必须在运行时保持不变.

  * 在编译环境[compilation environment]中定义的常变量[constant variable]在运行时必须具有相似[similar]的值. 源代码[source code]中对一个常变量[constant variable]的引用等价于对一个常变量[constant variable]值[value]的字面化[literal]对象[object]的引用.

  * 用 deftype 或者 defstruct 在编译环境[compilation environment]中所做的类型定义必须在运行时保持相同的定义. 由 defclass 在编译环境[compilation environment]中定义的类必须在运行时被定义有着相同的超类[superclasse]和元类[metaclass].

    这个也就意味着类型指定符[type specifier]的子类型[subtype]/超类型[supertype]关系必须在编译期[compile time]和运行期[run time]保持不变.

  * 在编译环境[environment]中出现的类型声明必须准确地描述在运行时的对应值; 否则, 后果就是未定义的. 在编译时, 允许一个未知类型[type]出现在一个声明中, 但是在这种情况下可能会发出一个警告.

  * 除了上面显式列出的情况外, 在求值环境[evaluation environment]中定义的一个函数[function]允许在运行时具有不同的定义或不同的签名, 并且运行时定义生效.

不应该使用额外的关于运行时环境[environment]与启动、求值和编译环境[environment]之间一致性的任何假设来编写符合规范的程序[conforming programs].

除非另行注明, 当一个编译期定义和运行时不同, 会在运行时出现以下情况的一种:

  * 发出一个 error 类型[type]的错误
  * 那个编译器定义生效
  * 那个运行时定义生效

如果编译器[compiler]处理一个在编译时没有定义操作符[operator]的函数表达式形式[function form], 那么编译时就不会发出错误. 

### 3.2.3 <span id = "FileCompilation">文件编译</span>

函数[function] compile-file 对一个文件中的表达式形式[form]根据章节 3.2.2 (编译语义) 中的规则执行编译, 并且产生一个可以通过 load 被载入的输出文件.

通常情况下, 在 compile-file 编译的文件中出现的顶层表达式形式[top level form]只在加载编译后文件时才进行求值, 而不是在编译文件时进行求值. 但是, 通常情况下, 文件中的某些表达式需要在编译时进行求值, 以便能够正确地读取和编译文件的其余部分.

这个 eval-when 特殊表达式[special form]可以被用于控制一个顶层表达式形式[top level form]是否在编译时, 加载时, 或者两个时机都求值. 用 eval-when 指定这三种情况的任何几个都是可以的, 通过符号 :compile-toplevel, :load-toplevel, 还有 :execute 来表示. 对于顶层的 eval-when 表达式形式, :compile-toplevel 表示编译器必须在编译期求值这个主体部分, 而 :load-toplevel 表示这个编译器必须安排在加载时求值这个主体. 关于非顶层的 eval-when 表达式, :execute 表示这个主体必须在运行时环境[environment]被执行.

这种表达式形式[form]的行为可以从 compile-file 如何处理一个要被编译的文件中的表达式形式的模型的方面来更精确地理解. 这个有两种处理模式, 称之为 "not-compile-time" 还有 "compile-time-too".

文件中的连续表达式形式被 compile-file 读取并且在 not-compile-time 模式下被处理; 在这个模式下, compile-file 安排表达式形式只在加载时被求值而不是在编译时. 当 compile-file 在 compile-time-too 模式下时, 表达式形式在加载和编译时都求值.

#### 3.2.3.1 顶层表达式形式的处理

在文件编译器中对顶层表达式形式[top level form]的处理定义如下:

* 如果这个表达式形式[form]是一个编译器宏表达式形式[compiler macro form] (没有被一个 notinline 声明[declaration]所禁用), 具体实现[implementation]可能也可能不选择计算该表达式形式[form]的编译器宏展开式[compiler macro expansion], 并且执行那个展开式, 可能也可能不会选择在相同的处理模式(compile-time-too 或 not-compile-time)下将结果作为顶层表达式形式[top level form]进行处理. 如果它拒绝获取或使用展开式, 它必须处理原始的表达式[form].

* 如果这个表达式形式是一个宏表达式形式[macro form], 它的宏展开会在相同的处理模式下(compile-time-too 或 not-compile-time)按照顶层表达式形式[top level form]被计算并处理.

* 如果表达式形式是一个 progn 表达式形式, 它的主体表达式形式[form]中的每一个会被依次当作顶层表达式形式[top level form]在相同的处理模式下处理.

* 如果这个表达式形式是一个 locally, macrolet, 或者 symbol-macrolet, 那么 compile-file 建立适当的绑定并实际上用这些绑定在相同的处理模式下按照顶层表达式形式[top level form]处理主体表达式形式. (注意, 这意味着被处理的顶层表达式形式的词法环境[environment]没有必要是空词法环境[null lexical environment].)

* 如果表达式形式是一个 eval-when 表达式形式, 它会根据下面这段被处理.

    CT | LT | E | Mode | Action | New Mode
    - | :-: | -: | - | - | -
    Yes | Yes | --- | --- |  Process |  compile-time-too 
    No |  Yes | Yes | CTT |  Process |  compile-time-too  
    No  | Yes | Yes | NCT |  Process |  not-compile-time  
    No  | Yes | No |  --- |  Process |  not-compile-time  
    Yes | No |  --- | --- |  Evaluate | ---               
    No |  No |  Yes | CTT |  Evaluate | ---               
    No |  No |  Yes | NCT |  Discard |  ---               
    No |  No |  No |  --- |  Discard |  ---               

    Figure 3-7. EVAL-WHEN 处理

    列 CT 表示 :compile-toplevel 是否被指定. 列 LT 表示 :load-toplevel 是否被指定. 列 E 表示 :execute 是否被指定. 列 Mode 表示处理模式; 一个代字号 (---) 表示处理模式是不相关的.

    这个 Action 列指明三种动作中的一种:

    Process: 在指定模式下按照顶层表达式形式[top level form]处理主体.

    Evaluate: 在编译器的动态执行上下文中对主体进行求值, 使用求值环境[evaluation environment]作为全局环境以及 eval-when 出现的词法环境[lexical environment].

    Discard: 忽略这个表达式形式[form].

    这个 New Mode 列表示新的处理模式. 一个代字符 (---) 表示编译器保留当前模式.

* 否则, 这个表达式形式就是一个不是这些特殊情况之一的顶层表达式形式[top level form]. 在 compile-time-too 模式下, 这个编译器首先在求值环境[environment]中对表达式形式进行求值, 然后对其进行最低限度的编译. 在 not-compile-time 模式下, 表达式形式[form]只是简单地最低限度地编译了. 所有子表达式形式[subform]被当作非顶层表达式形式[non-top-level form]. 

    注意, 顶层表达式形式[top level form]是按照在文件中显示的顺序处理的, 并且编译器读取的每个顶层表达式形式[top level form]都在读取下一个之前进行处理. 然而, 只要 Common Lisp 的语义被保留, 不是顶层表达式形式[top level form]的子表达式[subform]的处理(包括宏展开的)顺序还有进一步编译的顺序是未指定的.

eval-when 表达式形式[form]导致的编译期求值仅限顶层. 对于非顶层表达式形式[non-top-level form] :compile-toplevel 和 :load-toplevel 情况声明都会被忽略. 对于非顶层表达式形式[non-top-level form], 一个指定了 :execute 情况的 eval-when 被当作一个包括 eval-when 表达式形式[form]的主体部分的隐式 progn[implicit progn]; 否则, 在主体中的表达式形式[form]就被忽略.

##### 3.2.3.1.1 定义宏的处理

出现在一个要被 compile-file 处理的文件中的那些定义宏[macro] (就像 defmacro 或者 defvar), 通常会有编译期副作用, 影响同一个文件[file]中后续表达式形式[form]的编译. 解释这些副作用是如何发生的一个很方便的模型是, 定义宏被展开为一个或多个 eval-when 表达式形式[form], 然后导致编译期副作用发生的这些调用会出现在一个 (eval-when (:compile-toplevel) ...) 表达式形式[form]的主体部分.

编译期的副作用可能会导致对定义的信息的存储方式不同于以"正常"方式处理定义宏时的方式 (要么是解释, 要么是加载已编译的文件).

具体来说, 在编译期由定义宏[macro]所存储的信息可能或可能无法用于解释器 (不管是编译时或是编译后), 或者是后续对编译器[compiler]的调用中. 比如, 下面这段代码是不可移植的因为它假定在对于解释器可用的地方编译器[compiler]也存储了 foo 宏定义:

```LISP
(defmacro foo (x) `(car ,x))
(eval-when (:execute :compile-toplevel :load-toplevel)
  (print (foo '(a b c))))
```

一种完成相同工作的可移植的方式是把宏定义包含在 eval-when 表达式形式[form]里, 就像:

```LISP
(eval-when (:execute :compile-toplevel :load-toplevel)
  (defmacro foo (x) `(car ,x))
  (print (foo '(a b c))))
```

下面这段列出了使得定义可以在编译时和运行时环境[environment]都可用的宏. 既没有指定在编译环境[compilation environment]中可用的定义是否在求值环境[environment]中可用, 也没有指定它们在后续编译单元中或者在编译器的后续调用中是否可用. 与 eval-when 一样, 这些编译期副作用只发生在定义宏出现在顶层时.

    declaim                define-modify-macro   defsetf    
    defclass               define-setf-expander  defstruct  
    defconstant            defmacro              deftype    
    define-compiler-macro  defpackage            defvar     
    define-condition       defparameter                     

Figure 3-8. 影响编译期环境的定义宏

##### 3.2.3.1.2 对宏和编译器宏的限制

除了在显式声明之外, 在 Common Lisp 标准中定义的宏都不会产生导致这个宏表达式形式[macro form]的任何子表达式形式[subform]被当作顶层表达式形式[top level form]来处理的展开式. 如果一个具体实现[implementation]还提供了一个 Common Lisp 宏[macro]的特殊操作符[special operator]定义, 那么这个特殊操作符[special operator]定义在这方面必须是语义上等价的.

编译器宏[compiler macro]展开式也必须具有与它们所取代的表达式形式[form]相同的顶层求值语义. 这对符合规范的实现[conforming implementation]和符合规范的程序[conforming program]都需要去关注的. 

### 3.2.4 <span id = "LiteralObjectsInCompiledFiles">编译后文件中的字面化对象</span>

函数 eval 和 compile 需要去确保引用的字面化[literal]对象[object]在产生的解释后或编译后的代码对象和源代码[source code]中的对应对象[object]是相同的[same]. 从另一方面说, compile-file 必须产生一个编译后的文件[compiled file], 它被 load 加载时, 构建源代码[source code]中定义的对象并且产生指向它们的引用.

在 compile-file 的情况下, 编译后的文件[compiled file]被 load 加载所构建的对象[object]不能被认为与编译时构造的对象[object]相同[same], 因为编译后的文件[compiled file]可能被加载到不同的 Lisp 镜像[Lisp image]中, 而不是它编译时所在的那个. 这个部分定义了相似性[similarity]的概念, 它将求值环境[evaluation environment]中的对象[object]与运行时环境[run-time environment]中的相应对象[object]关联起来.

在这个章节中描述的字面化[literal]对象[object]上的约束只能应用于 compile-file; eval 和 compile 不会拷贝或合并常量.

> * 3.2.4.1 [可外部化的对象](#ExternalizableObjects)
> * 3.2.4.2 [字面化对象的相似性](#SimilarityLiteralObjects)
> * 3.2.4.3 [相似性规则的扩展](#ExtensionsSimilarityRules)
> * 3.2.4.4 [外部化对象的附加约束](#ACEO)

#### 3.2.4.1 <span id = "ExternalizableObjects">可外部化的对象</span>

事实上文件编译器[file compiler]在编译后的文件[compiled file]中外部地表示字面化[literal]对象[object]并且在文件[file]被加载时重构这些对象[object]的适合的等价对象, 这也意味着就需要去约束被文件编译器[file compiler]处理的代码[code]中的可以被用作字面化[literal]对象[object]的那些对象[object]的特性.

一个可以被用作要被文件编译器[file compiler]处理的代码[code]中的字面化[literal]对象[object]的对象[object]被称为可外部化对象[externalizable object].

如果两个对象[object]满足一个二元概念等价断言(下面定义的), 我们就定义它们是相似的[similar], 这个断言不依赖于 Lisp 镜像[Lisp image], 所以两个在不同 Lisp 镜像[Lisp image]中的对象[object]可以在这个断言下理解为等价的. 更进一步, 通过检查这个概念性断言的定义, 程序员可以预测一个对象[object]的哪些方面确实被文件[file]编译[compilation]保留了.

文件编译器[file compiler]必须与加载器[loader]合作, 以确保可外部化的对象[externalizable object]作为一个字面化[literal]对象[object]处理的每个情况中, 加载器[loader]会构造一个类似的[similar]对象[object].

新的概念术语"相似[similar]"就是为了可外部化对象[externalizable object]的对象[object]集合而定义, 这样一来当编译后的文件[compiled file]被加载时, 一个和文件编译器[file compiler]操作时存在的原始对象[object]相似的对象[object]会被构建. 

#### 3.2.4.2 <span id = "SimilarityLiteralObjects">字面化对象的相似性</span>

##### 3.2.4.2.1 聚合对象的相似性

在已定义相似性[similarity]之外的类型[type]中, 一些被当作是聚合对象. 对于这些类型, 相似性[similarity]是递归定义的. 我们说这些类型的对象有着确定的"基本特性(basic qualities)"并且为了满足相似性[similarity]关系, 两个对象[object]的对应特性的值也必须是相似的.

##### 3.2.4.2.2 相似性的定义

两个对象[object] S (在源代码[source code]中) 和 C (在编译后的代码[compiled code]中) 仅当它们同时都是这里列出的类型[type] (或者具体实现[implementation]定义的)之一并且它们都满足该类型[type]的相似性[similarity]的所有额外需求, 那么它们就被定义为相似的[similar].

number

    两个数字[number] S 和 C 如果它们是相同的类型[type]并且表示相同的数学上的值, 那么它们就是相似的[similar].

character

    如果两个简单[simple]字符[character] S 和 C 有相似的[similar]字符码[code]属性[attribute], 那么它们就是相似的[similar].

    具体实现[implementation]假定额外的, 具体实现定义的[implementation-defined]属性[attribute]必须定义非简单[non-simple]字符[character]是否可以被当作相似的[similar]并且如何被当作相似的[similar].

symbol

    如果两个显而易见的未捕捉[apparently uninterned]符号[sumbol] S 和 C 的名字[name]是相似的[similar], 那么它们就是相似的[similar].

    如果两个被捕捉的[interned]符号 S 和 C 名字[name]是相似的[similar]并且编译时 S 可以在当前包[current package]是访问的而加载时 C 可以在当前包[current package]也是可访问的, 或者 C 在 S home 包[home package]的相似的[similar]包[package]中是可访问, 那么它们就是相似的[similar].

    (注意, 符号[symbol]的相似性[similarity]不依赖于当前的读取表[current readtable], 也不依赖函数[function] read 如何来解析符号[symbol]名称[name]中的字符[character].)

package

    如果两个包[package] S 和 C 的名字[name]是相似的[similar], 那么它们就是相似的[similar].

    注意, 虽然一个包[package]对象[object]是一个可外部化的对象[externalizable object], 但是当代码将其作为一个字面化[literal]对象[object]引用时, 程序员有责任确保相应的包[package]已经存在. 加载器[loader]就像是通过使用该名称[name]作为实参[argument]调用的 find-package 来查找相应的包[package]对象[object]. 如果加载时包[package]不存在, 则加载器[loader]会发出一个错误.

random-state

    如果两个随机状态[random state] S 和 C 中, 假定每种情况下 limit 实参[argument]等价, 当给定作为函数[function] random 的 random-state 实参[argument]时, S 总是产生和 C 的拷贝[copy[5]]相同的伪随机数序列, 那么它们就是相似的[similar].

    (注意, 因为 C 已经被文件编译器[file compiler]处理过了, 它不能被直接用于 random 的实参[argument]因为 random 会有副作用.)

cons

    两个 cons S 和 C 如果它们的 car 和 cdr 部分分别都是相似的[similar], 那么它们就是相似的[similar].

array

    如果两个一维的数组[array] S 和 C 的长度[length]以及实际数组元素类型[actual array element type]还有每一个对应可用的[active]元素[element]也是相似的[similar], 那么它们就是相似的[similar].

    两个一维[rank]以外的数组 S 和 C 如果它们的维度[rank]是相似的[similar], 每一个对应维度的规模[dimension[1]]也是相似的[similar], 每一个对应实际数组元素类型[actual array element type]也是相似的[similar], 并且每一个对应的元素[element]也是相似的[similar], 那么它们就是相似的[similar].

    另外, 如果 S 是一个简单数组[simple array], 那么 C 也必须是一个简单数组[ simple array]. 如果 S 是一个带有一个填充指针[fill pointer]或者实际可调整[actually adjustable]的偏移数组[displaced array], 那么 C 被允许缺乏任何或所有这些特性.

hash-table

    如果两个哈希表[hash table] S 和 C 满足下面三条需求, 那么它们就是相似的[similar]:

        它们都有相同的 test 部分(比如, 它们都是 eql 哈希表[hash table]).

        两个哈希表[hash table]的键之间存在唯一的一对一匹配, 这样一来对应的键就是相似的[similar].

        对于所有的键, 与两个对应键关联的值是相似的[similar].

    如果在 S 和 C 中的键之间不止一个一对一对应, 结果是未指定的. 一个符合规范的程序[conforming program]不能使用像 S 这个的表作为可外部化常量.

pathname

    如果两个路径名[pathname] S 和 C 对应的所有路径名[pathname]成分是相似的[similar], 那么它们就是相似的[similar].

function

    函数[function]不是可外部化对象[externalizable object].

structure-object 和 standard-object

    对于结构体[structure]和标准对象[standard object]不存在相似性[similarity]的通用概念. 然而, 一个符合规范的程序[conforming program]允许去为这个程序[program]所定义的 structure-object 或 standard-object 的子类[subclass] K 定义一个 make-load-form 方法[method]. 这样一个方法[method]的效果就是定义当源代码[source code]中类型[type] K 的对象[object] S 和编译后的代码[compiled code]中类型[type] K 的对象[object] C 是通过对 S 调用 make-load-form 的代码[code]构造出来的时, S 和 C 就是相似的[similar]. 

#### 3.2.4.3 <span id = "ExtensionsSimilarityRules">相似性规则的扩展</span>

在上面给定的相似性定义下, 一些对象[object], 例如流[stream], 读取表还有方法不是可外部化的对象[externalizable object]. 这就是说, 这些对象[object]可能不能像要被文件编译器[file compiler]处理的代码[code]中的字面化[literal]对象[object]那样可移植地出现.

一个具体实现[implementation]允许去扩展相似性规则, 这样一来其他种类的对象[object]对于这个具体实现[implementation]也是可外部化对象[externalizable object].

如果对于某个类型的对象[object], 相似性[similarity]既没有被这个说明文档也没有被具体实现[implementation]所定义, 那么文件编译器[file compiler]在遇到这样一个对象[object]作为字面化[literal]常量[constant]时会发出一个错误. 

#### 3.2.4.4 <span id = "ACEO">外部化对象的附加约束</span>

如果在文件编译器[file compiler]处理的单个文件源代码中出现的两个字面化[literal]对象[object]是相同的[identical], 那么编译后的代码[compiled code]中相应的对象[object]也必须是相同的[identical]. 除了符号[symbol]和包[package], 文件编译器[file compiler]处理的代码中的任何两个字面化[literal]对象[object]仅当它们是相似的[similar]时候可以被合并[coalesce]; 如果它们两个都是符号[symbol]或者包[package], 它们可能只有在它们是相同的[identical]时候才会被合并[coalesced].

包含循环引用的对象[object]可以是可外部化对象[externalizable object]. 文件编译器[file compiler]需要在一个文件[file]中保存子结构的相等性(eqlness). 保留相等性(eqlness)意味着在源代码[source code]中相同的[same]子对象在相应的编译后代码[compiled code]中必须是相同的[same].

另外, 下面是文件编译器[file compiler]对字面化[literal]对象[object]处理上的约束:

  **array**: 如果在源代码中的一个数组[array]是一个简单数组[simple array], 那么在编译后代码中的对应数组[array]也是一个简单数组[simple array]. 如果一个数组在源代码中是偏移的, 带有一个填充指针[fill pointer]或者一个实际可调整的[actually adjustable], 那么编译后代码中的对应数组[array]可能缺少任何或者所有这些特性. 如果一个源代码中的数组[array]有一个填充指针, 那么编译后的代码中对应的数组[array]可能只是填充指针所暗示的大小.

  **packages**: 加载器需要去找到对应包[package]对象[object], 就像通过用这个包名为参数调用 find-package 一样. 如果加载的时候这个名字对应的包[package]不存在, 那么就会发出一个 package-error 类型[type]的错误.

  **random-state**: 一个不变的随机状态[random state]对象不能用作函数[function] random 的状态参数, 因为 random 会修改这个数据结构.

  **structure, standard-object**: 如果存在类型[type]适合的 make-load-form 方法那么 structure-object 和 standard-object 类型[type]的对象[object]也可能出现在编译后的常量中.

      文件编译器[file compiler]在任何被引用作为字面化[literal]对象[object]的对象[object]上调用 make-load-form, 如果这个对象[object]是 standard-object, structure-object, condition, 或者任何依赖于具体实现的[implementation-dependent]其他类[class]集合(可能是空的)的任何一个的广义实例[generalized instance]的话. 对于单独文件[file]中任何给定的对象[object]文件编译器[file compiler]只会调用一次 make-load-form.

  **symbol**: 为了保证那些编译后的文件[compiled file]能够正确加载, 用户必须确保这些文件[file]中引用的包[package]在编译时和加载时被一致地定义. 符合规范的程序[conforming program]必须满足以下要求:

          1.当文件[file]中的顶层表达式形式[top level form]被 compile-file 处理时的当前包[current package]必须和编译后文件[compiled file]中对应顶层表达式形式[top level form]被 load 执行时的当前包相同[current package]. 特别地:

              a. 任何在一个文件[file]中修改当前包[current package]的顶层表达式形式[top level form]都必须在编译时和加载时将其更改为同一名称[name]的包[package].

              b. 如果在这个文件[file]中的第一个非原子[non-atomic]顶层表达式形式[top level form]不是一个 in-package 的表达式形式[form], 那么调用 load 时的当前包[current package]必须与 compile-file 被调用时的当前包[current package]有着相同名称[name].

          2.在编译期一个顶层表达式形式[top level form]被处理期间, 对于词法上出现在这个顶层表达式形式[top level form]中并且在当前包[current package]中是可访问的[accessible]而 home 包[home package]是另一个包[package]的所有符号[symbol], 在加载时当前包[current package]以及和编译时 home 包[home package]有着相同名字[name]的包[package]中也必须存在一个可访问的[accessible]相同名字[name]的符号[symbol].

          3.对于编译后的文件[compiled file]中出现的所有在编译时是它们 home 包[home package]的外部符号[external symbol]的符号[symbol], 在加载时相同名字[name]的这个包[package]里也必须存在名字[name]相同的外部符号[external symbol].

      如果其中任何一个条件都不成立, 那么加载器[loader]查找受影响的符号[symbol]的包[package]就是未指定的. 具体实现[implementation]允许去发出一个错误或者定义这个行为. 

### 3.2.5 <span id = "ExceptionalSituationsCompiler">编译器中的异常情况</span>

compile 和 compile-file 允许去发出错误和警告, 包括由于处理编译期的 (eval-when (:compile-toplevel) ...) 表达式形式的处理, 宏展开, 还有编译器自身发出的状况(condition)引起的错误.

编译在没有干预就不能处理的情况下, error 类型[type]的状况[condition]可能由编译器发出.

除了这个标准指定的必须或者可能发出 warning 类型[type]的状况[condition]的情况外, 在编译器可以确定结果未定义或者一个运行时错误会发出情况下也可能发出警告. 以下是这种情况的示例: 违反类型声明, 对 defconstant 定义的常量的值进行赋值或修改, 用错误数量的参数或者残缺的关键字列表调用内置的 Lisp 函数, 还有使用不可识别的声明标识符.

编译器允许以 style-warning 类型[type]的状况去提出一个关于编程风格问题的警告. 以下是这个情况的示例: 使用不同的参数列表重定义一个函数, 用错误数量的参数调用一个函数, 没有对一个没有引用到的局部变量声明 ignore, 还有引用一个声明为 ignore 的变量.

compile 和 compile-file 都允许(但不是必须)去为一个 error 类型[type]的状况[condition]建立[establish]一个处理者[handler]. 比如, 它们可能会发出一个警告, 并且从某个依赖于具体实现的[implementation-dependent]点重启编译来让这个编译在没有手动干预的情况下进行下去.

compile 和 compile-file 都返回 3 个值, 前两个表示被编译的源代码中是否包含错误以及是否提出风格警告.

一些警告可能会被推迟到编译结束的时候. 见 with-compilation-unit. 

## 3.3 <span id = "Declarations">声明</span>

声明[Declaration]提供了一种指定像求值器或者编译器这样的程序处理器使用的信息的方式.

局部声明[local declaration]可以通过 declare 嵌入到可执行的代码中. 全局声明[global declaration], 或者公告[proclamation], 可以通过 proclaim 或者 declaim 来建立.

这个 the 特殊表达式形式[special form]提供了一种简写标记来创建一个关于给定表达式形式[form]的值[type]的类型[type]的局部声明[local declaration].

如果一个程序违反了声明[declaration]和公告[proclamation], 结果是没有定义的.

> * 3.3.1 [最低的声明处理需求](#MDPR)
> * 3.3.2 [声明指定符](#DeclarationSpecifiers)
> * 3.3.3 [声明标识符](#DeclarationIdentifiers)
> * 3.3.4 [声明的作用域](#DeclarationScope)

### 3.3.1 <span id = "MDPR">最低的声明处理需求</span>

通常, 一个具体实现[implementation]可以自由地忽视除了 declaration, notinline, safety 还有 special 以外的声明指定符[declaration specifier].

一个 declaration 声明[declaration]必须抑制关于不识别这个种类的声明[declaration]的警告. 如果一个实现[implementation]不产生关于不识别声明的警告, 它可以安全地忽视了这个声明[declaration].

一个 notinline 声明[declaration]必须被任何支持内联函数或者编译器宏[compiler macro]的具体实现[implementation]所识别进而废弃那些机制. 一个不使用内联函数或者编译器宏[compiler macro]的具体实现[implementation]可能会安全地忽略这个声明[declaration].

一个 safety 声明[declaration]必须总是被识别, 它会提高当前的安全等级. 一个始终进行像 safety 是高的一样处理代码的实现, 可以安全地忽略这个声明.

一个 special 声明[declaration]必须被所有实现[implementation]所处理. 

### 3.3.2 <span id = "DeclarationSpecifiers">声明指定符</span>

一个声明指定符[declaration specifier]是一个表达式[expression], 它可以出现在 declare 表达式或者一个 declaim 表达式形式的顶层, 或者作为给 proclaim 的参数. 它是一个的列表[list], 其中 car 部分为声明标识符[declaration identifier], cdr 部分为根据特定于这个声明标识符[declaration identifier]的规则解释的数据.

### 3.3.3 <span id = "DeclarationIdentifiers">声明标识符</span>

下面这段展示了这个标准定义的所有的声明标识符[declaration identifier].

    declaration     ignore     special  
    dynamic-extent  inline     type     
    ftype           notinline           
    ignorable       optimize            

Figure 3-9. Common Lisp 声明标识符

一个具体实现可以自由地去支持其他(依赖于具体实现的[implementation-defined])声明标识符[declaration identifier]. 如果一个声明标识符[declaration identifier]没有在上面定义, 也没有被具体实现[implementation]所定义, 不是一个类型[type]名字[name], 也没有在 declaration 全局公告[proclamation]中声明, 那么可能会发出一个警告.

#### 3.3.3.1 类型声明的简写标记

类型指定符[type specifier]可以用作声明标识符[declaration identifier]. (type-specifier var\*) 可以当作 (type type-specifier var\*) 的简写. 

### 3.3.4 <span id = "DeclarationScope">声明的作用域</span>

声明[declaration]可以被分成两种类型: 一些适用于变量[variable]或函数[function]的绑定[binding]; 一些则不适用于绑定[binding].

一个出现在绑定表达式形式[form]的头部并且适用于这个表达式形式[form]创建的变量[variable]或函数[function]的绑定[binding]的声明[declaration]称之为绑定声明[bound declaration]; 这个声明[declaration]会影响这个声明[declaration]的作用域[scope]内的该绑定[binding]和任何该绑定的引用.

不是绑定声明[bound declaration]的声明[declaration]称为自由声明[free declarations].

在表达式形式[form] F1 中的一个自由声明[free declarations], 它应用于由某个表达式形式[from] F2 所建立的一个名字[name] N 的绑定[binding], 其中 F1 是 F2 的一个子表达式形式[subform], 那么它只影响 N 在 F1 中的引用; 它不应用于其他在 F1 以外的对 N 的引用, 也不影响 F2 中 N 的绑定[binding]被建立[establish]的方式.

不应用于绑定[binding]的声明[declaration]只能以自由声明[free declarations]的形式出现.

一个绑定声明[bound declaration]的作用域[scope]和它应用的绑定[binding]的词法作用域[lexical scope]相同; 对于特殊变量[special variable], 这意味拥有这个绑定[binding]会拥有的作用域[scope]使得它成为一个词法绑定[lexical binding].<!--TODO 不理解-->

除非明确声明, 一个自由声明[free declaration]的作用域[scope]只包括它出现在头部的表达式形式[form]的主体子表达式形式[subform], 不包括其他的子表达式形式[subform]. 自由声明[free declaration]的作用域[scope]不包括包含这些声明[declaration]的表达式形式[form]所建立的绑定[binding]的初始化表达式形式[initialization form].

一些循环表达式形式[iteration form]包含步进(step), 终止条件(end-test), 或者结果(result)子表达式形式[subform], 这些子表达式形式[subform]也被包含在循环表达式形式[iteration form]中出现的那些声明[declaration]的作用域[scope]内. 具体地说, 涉及的循环表达式形式[iteration form]和子表达式形式[subform]是:

    do, do*: step-forms, end-test-form, and result-forms.
    dolist, dotimes: result-form
    do-all-symbols, do-external-symbols, do-symbols: result-form

#### 3.3.4.1 声明作用域的示例

下面是一个示例, 说明了绑定声明[bound declaration]的作用域[scope].

```LISP
(let ((x 1))                ;[1] 1st occurrence of x
  (declare (special x))     ;[2] 2nd occurrence of x
  (let ((x 2))              ;[3] 3rd occurrence of x
    (let ((old-x x)         ;[4] 4th occurrence of x
          (x 3))            ;[5] 5th occurrence of x
      (declare (special x)) ;[6] 6th occurrence of x
      (list old-x x))))     ;[7] 7th occurrence of x
=>  (2 3)
```

由于 x 在第二行的 special 声明[declaration], 第一个出现的 x 建立[establish]一个 x 的动态绑定[dynamic binding]. 第三个出现的 x 建立[establish]一个 x 的词法绑定[lexical binding] (因为在对应的 let 表达式形式[form]里没有 special 声明[declaration]). 第四个出现的 x 是一个引用第三行建立[establish]的 x 的词法绑定[lexical binding]. 因为在第六行的这个 x 的 special 声明[declaration], 第五个出现的 x 为 let 表达式形式[form]的 body 部分建立一个 x 的动态绑定[dynamic binding]. 第四行的 x 引用没有被第六行的 special 声明[declaration]影响因为这个引用不是在第五行变量[variable] x 的"潜在的词法作用域(would-be lexical scope)"内. 第七行 x 的引用是第五行建立[establish]的 x 的动态绑定[dynamic binding]的一个引用.

这里是另一个示例, 用来介绍自由声明[free declaration]的作用域[scope]. 如下:

```LISP
(lambda (&optional (x (foo 1))) ;[1]
  (declare (notinline foo))     ;[2]
  (foo x))                      ;[3]
```

第一行对 foo 的调用[call]可能会被编译为内联的, 即便第三行对 foo 的调用一定不会的情况下. 这是因为第二行对 foo 的 notinline 声明[declaration]只适用于第三行的主体部分. 为了抑制两个调用[call]的内联, 一种方式是这么写:

```LISP
(locally (declare (notinline foo)) ;[1]
  (lambda (&optional (x (foo 1)))  ;[2]
    (foo x)))                      ;[3]
```

或者, 换种方式:

```LISP
(lambda (&optional                               ;[1]
          (x (locally (declare (notinline foo))  ;[2]
                (foo 1))))                       ;[3]
  (declare (notinline foo))                      ;[4]
  (foo x))                                       ;[5]
```

最后, 这里有一个循环表达式形式[iteration form]中声明[declaration]的作用域[scope]的示例.

```LISP
(let ((x  1))                     ;[1]
  (declare (special x))           ;[2]
    (let ((x 2))                  ;[3]
      (dotimes (i x x)            ;[4]
        (declare (special x)))))  ;[5]
=>  1
```

在这个例子, 第四行的第一个 x 引用是指第三行建立的 x 的词法绑定[lexical binding]. 然而, 出现在第四行的第二个 x 位于第五行的自由声明[declaration]的作用域[scope]内 (因为这个是 dotimes 的结果表达式形式(result-form)) 并且因此引用 x 的动态绑定[dynamic binding]. 

## 3.4 <span id = "LambdaLists">Lambda 列表</span>

一个 lambda 列表[lambda list]是一个列表[list], 它指明了形参[parameter]集合(有时也称为 lambda 变量[lambda variable])和一个用于接收和这些形参[parameter]有关的值[value]的协议.

这里有几种 lambda 列表[lambda list]的类型.

  |    上下文               |                       lambda 列表的种类   |
  |   -   | - |
  |defun 表达式形式[form]             |普通 lambds 列表[ordinary lambda list] |
  |defmacro 表达式形式[form]          |宏 lambda 列表[macro lambda list]    |
  |lambda 表达式[lambda expression]  |普通 lambds 列表[ordinary lambda list]  |
  |flet 局部函数[function]定义        |普通 lambds 列表[ordinary lambda list]  |
  |labels 局部函数[function]定义      |普通 lambds 列表[ordinary lambda list]  |
  |handler-case 子句说明             |普通 lambds 列表[ordinary lambda list]  |
  |restart-case 子句说明             |普通 lambds 列表[ordinary lambda list]  |
  |macrolet 局部宏[macro]定义         |宏 lambda 列表[macro lambda list]    |
  |define-method-combination        |普通 lambds 列表[ordinary lambda list]  |
  |define-method-combination :arguments 选项  |define-method-combination 参数 lambda 列表[define-method-combination arguments lambda list]  |
  |defstruct :constructor 选项       |boa lambda 列表[boa lambda list]     |
  |defgeneric 表达式形式[form]        |广义函数 lambda 列表[generic function lambda list]   |
  |defgeneric 方法[method]子句       |特化 lambda 列表[specialized lambda list]   |
  |defmethod 表达式形式[form]         |特化 lambda 列表[specialized lambda list]  |
  |defsetf 表达式形式[form]           |defsetf lambda 列表[defsetf lambda list]       |
  |define-setf-expander 表达式形式[form] |宏 lambda 列表[macro lambda list]               |
  |deftype 表达式形式[form]           |deftype lambda 列表[deftype lambda list]     |
  |destructuring-bind 表达式形式[form] |解构 lambda 列表[destructuring lambda list]   |
  |define-compiler-macro 表达式形式[form] |宏 lambda 列表[macro lambda list]            |
  |define-modify-macro 表达式形式[form]  |define-modify-macro lambda 列表[define-modify-macro lambda list]  |

Figure 3-10. 要使用的lambda列表的种类

下面这段列出了可应用于 lambda 列表[lambda list]的已定义的名字[defined name].

    lambda-list-keywords  lambda-parameters-limit    

Figure 3-11. 可应用于 lambda 列表的已定义的名字

> * 3.4.1 [普通 lambda 列表](#OrdinaryLambdaLists)
> * 3.4.2 [广义函数 lambda 列表](#GenericFunctionLambdaLists)
> * 3.4.3 [特化的 lambda 列表](#SpecializedLambdaLists)
> * 3.4.4 [宏 lambda 列表](#MacroLambdaLists)
> * 3.4.5 [解构 lambda 列表](#DestructuringLambdaLists)
> * 3.4.6 [Boa Lambda 列表](#BoaLambdaLists)
> * 3.4.7 [Defsetf Lambda 列表](#DefsetfLambdaLists)
> * 3.4.8 [Deftype Lambda 列表](#DeftypeLambdaLists)
> * 3.4.9 [Define-modify-macro Lambda 列表](#DefineMMLambdaLists)
> * 3.4.10 [Define-method-combination 参数 Lambda 列表](#DefineMCArgumentsLambdaLists)
> * 3.4.11 [文档字符串和声明的语法交互](#SIDSD)

### 3.4.1 <span id = "OrdinaryLambdaLists">普通 lambda 列表</span>

一个普通 lambda 列表[ordinary lambda list]被用于描述一个实参[argument]集合如何被普通函数[functioni]所接收. 下面是使用普通 lambda 列表[ordinary lambda list]的已定义的名字[defined name]:

    define-method-combination  handler-case  restart-case  
    defun                      labels                      
    flet                       lambda                      

Figure 3-12. 使用普通 lambda 列表的标准操作

一个普通 lambda 列表[ordinary lambda list]可以包含下面这段展示的 lambda 列表关键字[lambda list keyword].

    &allow-other-keys  &key       &rest  
    &aux               &optional         

Figure 3-13. 被普通 lambda 列表使用的 lambda 关键字列表

一个 lambda 列表[lambda list]中的每一个元素[element]是一个参数指定符或者一个 lambda 列表关键字[lambda list keyword]. 具体实现可以自由地提供额外的 lambda 列表关键字[lambda list keyword]. 关于一个实现中使用的 lambda 列表关键字[lambda list keyword], 见 lambda-list-keywords.

普通 lambda 列表[ordinary lambda list]的语法如下:

    lambda-list::= (var* 
                    [&optional {var | (var [init-form [supplied-p-parameter]])}*] 
                    [&rest var] 
                    [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* [&allow-other-keys]] 
                    [&aux {var | (var [init-form])}*]) 

一个 var 或 supplied-p-parameter 必须是一个符号[symbol], 并且不是常变量[constant variable]的名字.

一个 init-form 可以是任何表达式形式[form]. 无论何时为任何参数指定符求值任何 init-form, 那个表达式形式[form]可能引用这个 init-form 出现指定符左边的任何参数变量, 包括任何 supplied-p-parameter 变量, 并且可能依赖于没有其他参数变量已经被绑定的事实(包括它自己的参数变量) .

一个 keyword-name 可以是任何符号[symbol], 但是按照惯例通常是一个关键字[keyword[1]]; 所有标准化[standardized]的函数[function]都遵守这个惯例.

一个普通 lambda 列表[ordinary lambda list]有5个部分, 其中的任何部分或者全部可以是空的. 关于不匹配参数处理的信息, 见章节 3.5 (函数调用中的错误检测).

> * 3.4.1.1 [必要参数的指定符](#SpecifiersRequiredParameters)
> * 3.4.1.2 [可选参数的指定符](#SpecifiersOptionalParameters)
> * 3.4.1.3 [剩余参数的指定符](#SpecifierRestParameter)
> * 3.4.1.4 [关键字参数的指定符](#SpecifiersKeywordParameters)
> * 3.4.1.5 [&aux 变量的指定符](#SpecifiersAuxVariables)
> * 3.4.1.6 [普通 lambda 列表[ordinary lambda list]的示例](#ExamplesOrdinaryLambdaLists)

#### 3.4.1.1 <span id = "SpecifiersRequiredParameters">必要参数的指定符</span>

这些指的是直到第一个 lambda 列表关键字[lambda list keyword]为止的那些参数指定符; 如果这里没有 lambda 列表关键字[lambda list keyword], 那么所有指定符都是必要参数. 每一个必要参数被参数变量 var 指定. var 被绑定为一个词法变量, 除非它被声明为 special.

如果这里有 n 个必要参数 (n 可能是 0), 这里至少必须传递 n 个实参, 并且必要参数绑定给前 n 个传递的实参; 见章节 3.5 (函数调用中的错误检测). 其他参数保留给后面的剩余参数.

#### 3.4.1.2 <span id = "SpecifiersOptionalParameters">可选参数的指定符</span>

如果出现 &optional, 可选参数指定符就是那些跟在 &optional 后面直到下一个 lambda 列表关键字[lambda list keyword]或者直到列表结束的那些指定符. 如果指定了可选参数, 那么每一个都按如下处理. 如果存在未处理的参数, 则参数变量 var 将绑定到下一个的剩余参数, 就像必要参数一样. 如果没有参数剩下, 不管怎样, 那么 init-form 被求值, 并且那个参数变量被绑定给产生的值(如果没有 init-form 出现在参数指定符中就绑定为 nil). 如果另一个变量名 supplied-p-parameter 出现在这个指定符中, 如果有一个参数可用它会被绑定为 true, 如果没有参数剩余它会被绑定为 false (因此 init-form 需要被求值). supplied-p-parameter 不是绑定一个参数而是一个值, 它表示是否为相应的 var 提供了一个对应的参数. 

#### 3.4.1.3 <span id = "SpecifierRestParameter">剩余参数的指定符</span>

&rest, 如果出现, 后面必须跟着单独的剩余参数[rest parameter]指定符, 而那个指定符后面必须跟着另一个 lambda 列表关键字[lambda list keyword]或者 lambda 列表[lambda list]的末尾. 在所有可选参数被处理后, 这里可能由也可能没有一个剩余参数[rest parameter]. 如果这里有一个剩余参数[rest parameter], 它给绑定给一个所有还没有被处理(as-yet-unprocessed)参数的列表[list]. 如果没有未处理参数剩下, 这个剩余参数[rest parameter]绑定给空列表[empty list]. 如果这里没有剩余参数[rest parameter]和关键字参数[keyword parameter], 那么如果有任何未处理参数剩余就会发出一个错误; 见章节 3.5 (函数调用中的错误检测). 允许剩余参数[rest parameter]的值去和给 apply 的最后一个参数共享结构, 但不是必需. 

#### 3.4.1.4 <span id = "SpecifiersKeywordParameters">关键字参数的指定符</span>

如果出现 &key , 所有直到下一个 lambda 列表关键字[lambda list keyword]或者列表[list]末尾的指定符都是关键字参数指定符. 当关键字参数被处理, 同样被处理的参数会被做到一个列表[list]中作为剩余参数[rest parameter]. 允许同时指定 &rest 和 &key. 在这个情况下剩下的参数被同时用于这两种目的; 这就是说, 所有剩下的参数被做到剩余参数[rest parameter]的列表[list]中, 也被当作 &key 参数被处理. 如果指定了 &key, 必须有偶数个参数; 见章节 3.5.1.6 (奇数数量的关键字参数). 这些参数被当作对(pair), 每一对中的第一个参数被解释为一个名字而第二个作为对应的值. 每个对中的第一个对象[object]必须是一个符号[symbol]; 见章节 3.5.1.5 (非法的关键字参数). 这个关键字参数指定符后面可能可选地跟着 lambda 列表关键字[lambda list keyword] &allow-other-keys.

在每一个关键字参数指定符中参数变量必须是一个名字 var. 如果这个 var 单独出现或者在一个 (var init-form) 组合中, 当匹配实参[argument]到形参[parameter]时, 使用的关键字名字是一个 KEYWORD 包中名字[name]和 var 相同[same] (在 string= 下)的符号[symbol]. 如果使用了这个 ((keyword-name var) init-form) 表示法, 那么用于匹配实参[argument]到形参[parameter]的关键字名字是 keyword-name, 它可能是任何包[package]中的符号[symbol] (当然, 如果它不是 KEYWORD 包中的符号[symbol], 它没有必要自求值, 所以当调用这个函数时必须额外关心来确保正常的求值一直产生这个关键字名字). 因此

```LISP
(defun foo (&key radix (type 'integer)) ...)
```

与下面这个意义相同

```LISP
(defun foo (&key ((:radix radix)) ((:type type) 'integer)) ...)
```

关键字参数指定符和所有参数指定符一样, 实际上从左到右进行处理. 对于每一个关键字参数指定符, 如果这里有一个名字匹配这个指定符的名字的实参对 (这就是说, 名字之间是 eq 的), 那么这个指定符的参数变量绑定为这个实参对的第二项(值部分). 如果不止一个这样的参数对匹配, 会使用最左边的实参对. 如果不存在这样的实参对, 那么这个指定符的对应 init-form 被求值并且这个参数变量绑定为那个值 (如果没有指定 init-form , 那就绑定为 nil). supplied-p-parameter 和 &optional 参数一样的处理方式: 如果这里有匹配的实参对它被绑定为 true, 否则就是 false.

除非关键字参数检测被抑制, 一个实参对必须和一个参数指定符名字匹配; 见章节 3.5.1.4 (不识别的关键字参数).

如果关键字参数检测被抑制, 那么允许一个实参对没有匹配的参数指定符, 并且这个实参对会被忽略, 但是如果提供了剩余参数[rest parameter], 这样的一个参数是可以通过剩余参数[rest parameter]访问的. 这些机制的目的是去允许在多个 lambda 表达式[lambda expression]之间共享参数列表并且允许调用者和被调用的 lambda 表达式[lambda expression]去指定这样的共享是可能发生的.

注意如果 &key 出现了, 一个 :allow-other-keys 的关键字参数总是是允许的---不管关联的值是 true 或者 false. 然而, 如果这个值是 false, 其他不匹配的关键字是不接受的 (除非使用了 &allow-other-keys).

此外, 如果接收的参数列表指定了一个会被 :allow-other-keys 标记的普通参数, 那么 :allow-other-keys 同时有它的特殊情况意义(标识是否允许附加的关键字)和它的正常意义(数据流入到提及的函数中).

##### 3.4.1.4.1 抑制关键字参数检测

如果一个函数[function]的 lambda 列表[lambda list]中指定了 &allow-other-keys, 对这个函数[function]的调用中关键字[keyword[2]]实参[argument]检测会被抑制.

如果在一个函数[function]的调用中 :allow-other-keys 参数[argument]是 true, 在这个调用中关键字[keyword[2]]实参[argument]检测是被抑制的.

这个 :allow-other-keys 实参[argument]在所有涉及关键字[keyword[2]]实参[argument]的地方都是允许的, 即便当它关联的值[value]是 false 时.

###### 3.4.1.4.1.1 抑制关键字参数检测的示例

```LISP
;;; The caller can supply :ALLOW-OTHER-KEYS T to suppress checking.
((lambda (&key x) x) :x 1 :y 2 :allow-other-keys t) =>  1
;;; The callee can use &ALLOW-OTHER-KEYS to suppress checking.
((lambda (&key x &allow-other-keys) x) :x 1 :y 2) =>  1
;;; :ALLOW-OTHER-KEYS NIL is always permitted.
((lambda (&key) t) :allow-other-keys nil) =>  T
;;; As with other keyword arguments, only the left-most pair
;;; named :ALLOW-OTHER-KEYS has any effect.
((lambda (&key x) x) 
:x 1 :y 2 :allow-other-keys t :allow-other-keys nil)
=>  1
;;; Only the left-most pair named :ALLOW-OTHER-KEYS has any effect,
;;; so in safe code this signals a PROGRAM-ERROR (and might enter the
;;; debugger).  In unsafe code, the consequences are undefined.
((lambda (&key x) x)                   ;This call is not valid
:x 1 :y 2 :allow-other-keys nil :allow-other-keys t)
```

#### 3.4.1.5 <span id = "SpecifiersAuxVariables">&aux 变量的指定符</span>

这些不是真的参数. 如果出现这个 lambda 列表关键字[lambda list keyword] &aux, 所有在它后面的指定符都是辅助变量指定符. 在所有参数指定符被处理后, 这些辅助变量指定符(那些跟在 &aux 后面的)从左到右被处理. 对于其中的每一个, init-form 被求值并且 var 被绑定为那个值 (如果没有 init-form 就绑定为 nil). &aux 变量处理类似于 let* 处理.

```LISP
(lambda (x y &aux (a (car x)) (b 2) c) (list x y a b c))
  ==  (lambda (x y) (let* ((a (car x)) (b 2) c) (list x y a b c)))
```

#### 3.4.1.6 <span id = "ExamplesOrdinaryLambdaLists">普通 lambda 列表的示例</span>

这里是可选参数[optional parameter]和剩余参数[rest parameter]的例子:

```LISP
;;; The caller can supply :ALLOW-OTHER-KEYS T to suppress checking.
 ((lambda (&key x) x) :x 1 :y 2 :allow-other-keys t) =>  1
;;; The callee can use &ALLOW-OTHER-KEYS to suppress checking.
 ((lambda (&key x &allow-other-keys) x) :x 1 :y 2) =>  1
;;; :ALLOW-OTHER-KEYS NIL is always permitted.
 ((lambda (&key) t) :allow-other-keys nil) =>  T
;;; As with other keyword arguments, only the left-most pair
;;; named :ALLOW-OTHER-KEYS has any effect.
 ((lambda (&key x) x) 
  :x 1 :y 2 :allow-other-keys t :allow-other-keys nil)
=>  1
;;; Only the left-most pair named :ALLOW-OTHER-KEYS has any effect,
;;; so in safe code this signals a PROGRAM-ERROR (and might enter the
;;; debugger).  In unsafe code, the consequences are undefined.
 ((lambda (&key x) x)                   ;This call is not valid
  :x 1 :y 2 :allow-other-keys nil :allow-other-keys t)
```

这里是关键字参数[keyword parameter]的例子:

```LISP
((lambda (a b &key c d) (list a b c d)) 1 2) =>  (1 2 NIL NIL)
((lambda (a b &key c d) (list a b c d)) 1 2 :c 6) =>  (1 2 6 NIL)
((lambda (a b &key c d) (list a b c d)) 1 2 :d 8) =>  (1 2 NIL 8)
((lambda (a b &key c d) (list a b c d)) 1 2 :c 6 :d 8) =>  (1 2 6 8)
((lambda (a b &key c d) (list a b c d)) 1 2 :d 8 :c 6) =>  (1 2 6 8)
((lambda (a b &key c d) (list a b c d)) :a 1 :d 8 :c 6) =>  (:a 1 6 8)
((lambda (a b &key c d) (list a b c d)) :a :b :c :d) =>  (:a :b :d NIL)
((lambda (a b &key ((:sea c)) d) (list a b c d)) 1 2 :sea 6) =>  (1 2 6 NIL)
((lambda (a b &key ((c c)) d) (list a b c d)) 1 2 'c 6) =>  (1 2 6 NIL)
```

这里是同时启用可选参数[optional parameter]和剩余参数[rest parameter]还有关键字参数[keyword parameter]的示例:

```LISP
((lambda (a &optional (b 3) &rest x &key c (d a))
  (list a b c d x)) 1)   
=>  (1 3 NIL 1 ()) 
((lambda (a &optional (b 3) &rest x &key c (d a))
  (list a b c d x)) 1 2)
=>  (1 2 NIL 1 ())
((lambda (a &optional (b 3) &rest x &key c (d a))
  (list a b c d x)) :c 7)
=>  (:c 7 NIL :c ())
((lambda (a &optional (b 3) &rest x &key c (d a))
  (list a b c d x)) 1 6 :c 7)
=>  (1 6 7 1 (:c 7))
((lambda (a &optional (b 3) &rest x &key c (d a))
  (list a b c d x)) 1 6 :d 8)
=>  (1 6 NIL 8 (:d 8))
((lambda (a &optional (b 3) &rest x &key c (d a))
  (list a b c d x)) 1 6 :d 8 :c 9 :d 10)
=>  (1 6 9 8 (:d 8 :c 9 :d 10))
```

作为 &allow-other-keys 和 :allow-other-keys 使用的示例, 细想一个函数[function], 它接受它自身的两个已命名的参数, 并接受附加的命名参数, 以将其传递给 make-array:

```LISP
(defun array-of-strings (str dims &rest named-pairs
                        &key (start 0) end &allow-other-keys)
  (apply #'make-array dims
        :initial-element (subseq str start end)
        :allow-other-keys t
        named-pairs))
```

这个函数[function]需要一个字符串[string]和一个维度信息并且返回一个指定维度的数组[array], 它的每一个元素都是指定的字符串[string]. 然而, :start 和 :end 命名的参数可能被用于指定给定字符串[string]中应该使用的子字符串. 另外, 在这个 lambda 列表[lambda list]中出现的 &allow-other-keys 表示调用者可能提供额外的已命名参数; 这个剩余参数[rest parameter]提供对它们的访问. 这些额外已命名的参数被传递给 make-array. 这个 make-array 函数[function]正常不允许使用已命名参数 :start 和 :end, 并且如果这样的已命名参数提供给 make-array 应该会发出一个错误. 然而, 对 make-array 的调用中已命名参数 :allow-other-keys 以及一个 true 值的出现导致任何额外的已命名参数, 包括 :start 和 :end, 是可接受的并且被忽略掉. 

### 3.4.2 <span id = "GenericFunctionLambdaLists">广义函数 lambda 列表</span>

一个广义函数 lambda 列表[generic function lambda list]被用于描述被一个广义函数[generic function]接受的实参列表的整体形状. 个别方法[method]签名[signature]可能为有效方法[effective method]的 lambda 列表[lambda list]提供额外的关键字参数[keyword parameter].

一个广义函数 lambda 列表[generic function lambda list]被 defgeneric 所使用.

一个广义函数 lambda 列表[generic function lambda list]有着以下语法:

    lambda-list::= (var* 
                    [&optional {var | (var)}*] 
                    [&rest var] 
                    [&key {var | ({var | (keyword-name var)})}* [&allow-other-keys]]) 

一个广义函数 lambda 列表[generic function lambda list]可以包含下面这段展示的 lambda 列表关键字[lambda list keyword].

    &allow-other-keys  &optional    
    &key               &rest        

Figure 3-14. 广义函数 lambda 列表使用的 lambda 列表关键字

一个广义函数 lambda 列表[generic function lambda list]在以下方面有别于普通 lambda 列表[ordinary lambda list]:

必要参数

    0个或多个必要参数[required parameter]必须被指定.

可选参数和关键字参数

    可选参数[optional parameter]和关键字参数[keyword parameter]可能没有默认的初始值表达式也没有使用 supplied-p 参数.

&aux 的使用

    &aux 的使用是不允许的. 

### 3.4.3 <span id = "SpecializedLambdaLists">特化的 lambda 列表</span>

一个特化的 lambda 列表[specialized lambda list]被用于为一个特定的签名[signature]特化[specialize]一个方法[method]并且去描述匹配这个签名[signature]的那些实参[argument]如何被这个方法[method]接收. 下一段中已定义的名字[defined name]以某种方式使用特化的 lambda 列表[specialized lambda list]; 关于其中的每一个怎样处理的信息见字典条目.

    defmethod  defgeneric    

Figure 3-15. 使用特化的 lambda 列表的标准化操作符

一个特化的 lambda 列表[specialized lambda list]可以包含下面这段中展示的 lambda 列表关键字[lambda list keyword].

    &allow-other-keys  &key       &rest  
    &aux               &optional         

Figure 3-16. 特化 lambda 列表使用的 lambda 列表关键字

一个特化的 lambda 列表[specialized lambda list]是语法上等价于一个普通 lambda 列表[ordinary lambda list]除了每一个必要参数[required parameter]可能可选地和一个该形参[parameter]被特化[specialize]的类[class]或者一个对象[object]关联.

    lambda-list::= ({var | (var [specializer])}* 
                    [&optional {var | (var [init-form [supplied-p-parameter]])}*] 
                    [&rest var] 
                    [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* [&allow-other-keys]] 
                    [&aux {var | (var [init-form])}*]) 

### 3.4.4 <span id = "MacroLambdaLists">宏 lambda 列表</span>

一个宏 lambda 列表[macro lambda list]被用于描述下面这段中的这些操作符[operator]定义的宏[macro].

    define-compiler-macro  defmacro  macrolet  
    define-setf-expander                       

Figure 3-17. 使用宏 lambda 列表[macro lambda list]的操作符

在一个环境参数[environment parameter]可能只出现一次(在描述的任何位置)的附加限制下, 一个宏 lambda 列表[macro lambda list]有以下语法:

    reqvars::= var* 

    optvars::= [&optional {var | (var [init-form [supplied-p-parameter]])}*] 

    restvar::= [{&rest | &body} var] 

    keyvars::= [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* 
                [&allow-other-keys]] 

    auxvars::= [&aux {var | (var [init-form])}*] 

    envvar::= [&environment var] 

    wholevar::= [&whole var] 

    lambda-list::= (wholevar envvar  reqvars envvar  optvars envvar 
                    restvar envvar  keyvars envvar  auxvars envvar) | 
                  (wholevar envvar  reqvars envvar  optvars envvar .  var) 

    pattern::= (wholevar reqvars optvars restvar keyvars auxvars) | 
              (wholevar reqvars optvars . var) 

一个宏 lambda 列表[macro lambda list]可以包含下面这段展示的 lambda 列表关键字[lambda list keyword].

    &allow-other-keys  &environment  &rest   
    &aux               &key          &whole  
    &body              &optional             

Figure 3-18. 宏 lambda 列表[macro lambda list]使用的lambda列表参数

可选参数[optional parameter] (通过 &optional 引入) 和关键字参数[keyword parameter] (通过 &key 引入) 可以在一个宏 lambda 列表[macro lambda list]中被提供, 就像在普通 lambda 列表[ordinary lambda list]中一样. 两个中的每一个都可能包含默认初始化表达式形式和 supplied-p 参数[supplied-p parameter].

&body 在函数中和 &rest 一样, 但是它可以被用于通知特定的输出格式化和编辑函数: 这个表达式形式[form]的剩余部分被当作一个主体(body), 并且应该相应地缩进. 在任何特定的级别 &body 或者 &rest 只有一个可以被使用; 见章节 3.4.4.1 (lambda 列表的解构). &body 可以出现在一个宏 lambda 列表[macro lambda list]的任何级别; 关于详细情况, 见章节 3.4.4.1 (lambda 列表的解构).

&whole 后面跟着一个绑定为整个宏调用表达式形式的单独变量; 这是这个宏函数[macro function]作为第一个参数收到的值. 如果出现 &whole 和一个跟在后面的变量, 它们必须出现在 lambda 列表的最前面, 在任何其他参数或者 lambda 列表关键字[lambda list keyword]之前. &whole 可以出现在一个宏 lambda 列表[macro lambda list]的任何级别. 在内部级别, 这个 &whole 变量绑定为参数的对应部分, 正如 &rest, 但是不像 &rest, 其他参数也是允许的. 这个 &whole 的使用不影响指定参数的匹配.

&environment 后面跟着一个绑定为一个环境[environment]的单独变量, 这个环境表示这个宏调用被解释时所处的当前词法环境[lexical environment]. 这个环境[environment]应该和 macro-function, get-setf-expansion, compiler-macro-function, 还有 macroexpand (比如) 在计算宏展开式一起使用, 来确保这个编译环境[compilation environment]中建立的任何词法绑定[lexical binding]或定义被考虑进去. &environment 只能出现在宏 lambda 列表[macro lambda list]的顶层, 并且只能出现一次, 但是可以出现在这个列表的任何位置; 这个 &environment 和 &whole 形参[parameter]在这个 lambda 列表[lambda list]的任何其他变量[variable]之前被绑定[bound], 不管 &environment 出现在这个 lambda 列表[lambda list]的什么地方. 绑定为环境参数[environment parameter]的对象[object]具有动态范围[dynamic extent].

解构允许一个宏 lambda 列表[macro lambda list]去表达宏调用语法的结构. 如果没有出现 lambda 列表关键字[lambda list keyword], 那么这个宏 lambda 列表[macro lambda list]是在叶子中包含参数名称的树[tree]. 匹配模式和宏表达式形式[macro form]必须具有兼容的树结构[tree structure]; 这就是说, 它们的树结构[tree structure]必须是等价的, 或者它只能在匹配模式的某些叶节点与宏表达式形式[macro form]的非原子[non-atomic]对象[object]匹配时有所不同. 关于这种求值情况[situation]下的错误检测的信息, 见章节 3.5.1.7 (解构不匹配).

一个解构 lambda 列表[lambda list] (不管在顶层还是嵌入的)可以是点对的(dotted), 以一个参数名结束. 这种情况被视为结束列表的参数名称出现在 &rest 前面.

只有在和 (... &rest var) 或 (... . var) 匹配时, 允许一个宏表达式形式[macro form] (或者是一个宏表达式形式[macro form]的子表达式[subexpression])是一个点对列表. 宏[macro]需要去识别和处理这种情况.

#### 3.4.4.1 lambda 列表的解构

在一个宏 lambda 列表[macro lambda list]中参数名字可以出现的任何地方, 以及普通 lambda 列表[ordinary lambda list]语法中(在章节 3.4.1 (普通 lambda 列表) 描述的)不允许一个列表[list]的地方, 一个解构 lambda 列表[destructuring lambda list]可以出现来替换这个参数名字. 在这样做时, 会与形参匹配的实参被当作一个(可能是点对的)列表[list], 作为一个参数列表, 用作满足内嵌的 lambda 列表[lambda list]中的参数的实参列表. 这就被认为是解构(destructuring).

解构是将一个复合对象[object]分解为它的组件部分的过程, 使用一种简短的声明式语法, 而不是用原始的组件访问函数书写出来. 每一个组件部分绑定给一个变量.

一个解构操作需要一个将要解构的对象[object], 一个指定要提取哪些组件的匹配模式, 以及那些值为那些组件的变量的名称.

##### 3.4.4.1.1 lambda 列表的数据导向解构

在数据导向的解构中, 匹配模式是一个要被分解的类型[type]的简单对象[object]. 无论在哪里提取组件, 在匹配模式中对应地方都会出现一个符号[symbol]; 这个符号[symbol]是变量的名称, 这个变量的值就是那个组件.

###### 3.4.4.1.1.1 lambda 列表的数据导向解构示例

一个匹配模式示例是

```LISP
(a b c)
```

它解构了一个三个元素的列表. 这个变量 a 被赋值为第一个元素, b 给赋值为第二个, 等等. 一个更加复杂的例子是

```LISP
((first . rest) . more)
```

语法简单性和扩展到 lambda 列表导向解构的能力是数据导向解构的重要特性. 

##### 3.4.4.1.2 lambda 列表的 lambda 列表导向解构

树[tree]的数据导向解构的一个延伸是 lambda 列表导向的解构. 这是从三元素的解构模式

```LISP
(first second third)
```

以及下面这个三参数的 lambda 列表的类比中得出的

```LISP
(first second third)
```

如果没有 lambda 列表关键字[lambda list keyword]出现在匹配模式中, 那么 lambda 列表导向的解构和数据导向的结构是相同的. 在这个包含 lambda 列表关键字[lambda list keyword]的匹配模式中的任何列表(不管是一个子列表或是整个匹配模式本身)就会被特别地解释. 这个列表中第一个 lambda 列表关键字[lambda list keyword]左边的那些元素被当作解构匹配模式处理, 像平常一样, 但是列表中剩下的元素被当作函数的 lambda 列表[lambda list]一样处理, 除了在通常需要一个变量的情况下, 允许使用任意的解构匹配模式. 注意, 在不确定的情况下, lambda 列表[lambda list]语法优于解构语法. 因此, 在 &optional 之后, 是一个列表, 它的元素是一个解构匹配模式和一个默认值表达式形式的列表.

每个 lambda 列表关键字[lambda list keyword]在 lambda 列表导向的解构匹配模式中的具体行为如下:

&optional

    每一个后面的元素是一个变量或者一个解构匹配模式, 一个默认值表达式形式和一个 supplied-p 变量的列表. 这个默认值和 supplied-p 可以被省略. 如果这个被解构的列表提前结束, 而它没有一个元素来匹配这个解构匹配模式或子模式, 那么这个默认表达式形式会求值并解构. 如果这个默认表达式形式被使用了, 那么 supplied-p 变量会收到值 nil, 否则就是 t.

&rest, &body

    下一个元素是一个匹配这个列表剩余部分的解构匹配模式. &body 和 &rest 一样但是声明所匹配的是构成表达式形式[form]主体的表达式形式列表. 这下一个元素必须是最后一个除非后面跟着一个 lambda 列表关键字[lambda list keyword].

&aux

    其余的元素根本不是解构匹配模式, 而是辅助变量绑定.

&whole

    下一个元素是一个匹配一个宏里的整个表达式形式的解构匹配模式, 或者内部层级的整个子表达式[subexpression].

&key

    后面跟着的元素是以下其中之一

    一个变量[variable],

    或者一个变量, 一个可选的初始化表达式形式, 和一个可选的 supplied-p 变量的列表.

    或者一个关键字和一个解构匹配模式的列表, 一个可选初始化表达式形式, 和一个可选 supplied-p 变量的列表.

    被解构的列表的其余部分被认为是交替的关键字和值, 并且被适当地分开.

&allow-other-keys

    根据它自身理解. 

### 3.4.5 <span id = "DestructuringLambdaLists">解构lambda列表</span>

一个解构 lambda 列表[destructuring lambda list]被 destructuring-bind 使用.

解构 lambda 列表[destructuring lambda list]与宏 lambda 列表[macro lambda list]密切相关; 见章节 3.4.4 (宏 lambda 列表). 除了 &environment 之外, 一个解构 lambda 列表[destructuring lambda list]可以包含所有其他用于宏 lambda 列表[macro lambda list]的 lambda 列表关键字[lambda list keyword], 并且支持相同方式下的解构. 在宏 lambda 列表[macro lambda list]中嵌套的内部 lambda 列表[lambda list]具有解构 lambda 列表[destructuring lambda list]的语法.

一个解构 lambda 列表[destructuring lambda list]具有以下语法:

    reqvars::= var* 

    optvars::= [&optional {var | (var [init-form [supplied-p-parameter]])}*] 

    restvar::= [{&rest | &body} var] 

    keyvars::= [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* 
                [&allow-other-keys]] 

    auxvars::= [&aux {var | (var [init-form])}*] 

    envvar::= [&environment var] 

    wholevar::= [&whole var] 

    lambda-list::= (wholevar reqvars optvars restvar keyvars auxvars) | 
                  (wholevar reqvars optvars . var) 

### 3.4.6 <span id = "BoaLambdaLists">Boa Lambda 列表</span>

一个 boa lambda 列表[boa lambda list]是一个语法上像普通 lambda 列表[ordinary lambda list]的 lambda 列表[lambda list], 但是这个是 "根据参数顺序" 风格处理.

一个 boa lambda 列表[boa lambda list]只被 defstruct 表达式形式[form]使用, 在显式指定构造器函数[function]的 lambda 列表[lambda list]的时候 (有时称之为 "boa 构造器(boa constructor)").

在 boa lambda 列表[boa lambda list]中的这些 &optional, &rest, &aux, &key, 还有 &allow-other-keys lambda 列表关键字[lambda list keyword]是被识别的. 这些 lambda 列表关键字[lambda list keyword]的使用方式有别于在普通 lambda 列表[ordinary lambda list]中.

细想这个示例, 它描述了解构(destruct)如何处理它的 :constructor.

```LISP
(:constructor create-foo
        (a &optional b (c 'sea) &rest d &aux e (f 'eff)))
```

这个定义了 create-foo 去作为一个或多个参数的构造器. 第一个参数被用于初始化 a 槽. 第二个参数用于初始化 b 槽. 如果这里没有第二个参数, 那么 defstruct 主体中给定的默认值(如果给了的话)被使用. 第三个参数被用于初始化 c 槽. 如果这里没有任何第三个参数, 那么符号 sea 就会被使用. 任何跟在第三个参数后面的参数被收集到一个列表[list]中然后被用于初始化 d 槽. 如果这里只有三个或更少的参数, 那么 d 槽的内容就是 nil. e 槽没有被初始化; 它的初始化值是具体实现定义的[implementation-defined]. 最后, f 槽被初始化去包含符号 eff. &key 和 &allow-other-keys 参数默认类似于 &optional 参数: 如果在这个 lambda 列表[lambda list]中没有提供默认值, 那么使用 defstruct 主体中给定的默认值(如果给了的话). 举例说:

```LISP
(defstruct (foo (:constructor CREATE-FOO (a &optional b (c 'sea)
                                            &key (d 2)
                                            &aux e (f 'eff))))
  (a 1) (b 2) (c 3) (d 4) (e 5) (f 6))

(create-foo 10) =>  #S(FOO A 10 B 2 C SEA D 2 E implemention-dependent F EFF)
(create-foo 10 'bee 'see :d 'dee) 
=>  #S(FOO A 10 B BEE C SEE D DEE E implemention-dependent F EFF)
```

如果指定了这个表达式形式 ((key var) [default [svar]]) 的关键字参数, 这个槽[slot]的名字[name]和 var 匹配(不是 key).

仔细选择在 b 和 e 情况下采取的行动, 来允许用户指定所有可能的行为. 这个 &aux 变量被用于完全重写主体中给定的默认的初值.

如果没有给一个 aux 变量[aux variable]提供默认值, 那么如果在槽被显式赋值前尝试去读取对应槽[slot]的值的话, 结果是未定义的. 如果这样一个槽[slot]指定了一个 :type 选项, 这种被抑制的初始化并不意味着类型不匹配的情况; 声明的类型只有在槽最终赋值时才需要应用.

在这个定义下, 可以写成下面这样:

```LISP
(create-foo 1 2)
```

而不是

```LISP
(make-foo :a 1 :b 2)
```

并且 create-foo 提供了和 make-foo 不同的默认值.

不对应于槽名但只提供在随后的初始化计算中使用的值的附加参数是允许的. 比如, 在这个定义中

```LISP
(defstruct (frob (:constructor create-frob
                (a &key (b 3 have-b) (c-token 'c) 
                        (c (list c-token (if have-b 7 2))))))
        a b c)
```

这个 c-token 参数只是给 c 槽的初始化提供一个值. 与可选参数[optional parameter]和关键字参数[keyword parameter]相关的这些 supplied-p 参数[supplied-p parameter]也可以使用这种方式. 

### 3.4.7 <span id = "DefsetfLambdaLists">Defsetf Lambda 列表</span>

一个 defsetf lambda 列表[defsetf lambda list]被 defsetf 所使用.

一个 defsetf lambda 列表[defsetf lambda list]遵循以下语法:

```LISP
lambda-list::= (var* 
                [&optional {var | (var [init-form [supplied-p-parameter]])}*] 
                [&rest var] 
                [&key {var | ({var | (keyword-name var)} [init-form [supplied-p-parameter]])}* [&allow-other-keys]] 
                [&environment var] 
```

一个 defsetf lambda 列表[defsetf lambda list]可以包含下面这段展示的这些 lambda 列表关键字[lambda list keyword].

    &allow-other-keys  &key       &rest  
    &environment       &optional         

Figure 3-19. Defsetf Lambda 列表使用的 lambda 列表关键字

一个 defsetf lambda 列表[defsetf lambda list]和普通 lambda 列表[ordinary lambda list]的区别仅在于它不允许使用 &aux, 并且它允许使用引入环境参数[environment parameter]的 &environment. 

### 3.4.8 <span id = "DeftypeLambdaLists">Deftype Lambda 列表</span>

一个 deftype lambda 列表[deftype lambda list]被 deftype 所使用.

一个 deftype lambda 列表[deftype lambda list]有着像宏 lambda 列表[macro lambda list]相同的语法, 并且因此可以包含和宏 lambda 列表[macro lambda list]相同的 lambda 列表关键字[lambda list keyword].

一个 deftype lambda 列表[deftype lambda list]和宏 lambda 列表[macro lambda list]的区别仅在于如果没有给一个可选参数[optional parameter]和关键字参数[keyword parameter]提供初始化表达式形式 init-from, 那么这个形参[parametaer]的默认值[value]就是符号[symbol] * (而不是 nil). 

### 3.4.9 <span id = "DefineMMLambdaLists">Define-modify-macro Lambda 列表</span>

一个 define-modify-macro lambda 列表[deftype lambda list]被 define-modify-macro 所使用.

一个 define-modify-macro lambda 列表[deftype lambda list]可以包含下面这段展示的 lambda 列表关键字[lambda list keyword].

    &optional  &rest  

Figure 3-20. Define-modify-macro Lambda 列表使用的 lambda 列表关键字

Define-modify-macro lambda 列表[deftype lambda list]类似于普通 lambda 列表[ordinary lambda list], 但是不支持关键字参数. define-modify-macro 不需要去匹配关键字, 并且一个剩余参数[rest parameter]就足够了. aux 变量[aux variable]也不支持, 因为 define-modify-macro 没有主体表达式来引用这些绑定[binding]. 见宏 define-modify-macro. 

### 3.4.10 <span id = "DefineMCArgumentsLambdaLists">Define-method-combination 参数 Lambda 列表</span>

一个 define-method-combination 参数 lambda 列表[define-method-combination arguments lambda list]被 define-method-combination 的 :arguments 选项所使用.

一个 define-method-combination 参数 lambda 列表[define-method-combination arguments lambda list]可以包含下面这段中展示的 lambda 列表关键字[lambda list keyword].

    &allow-other-keys  &key       &rest   
    &aux               &optional  &whole  

Figure 3-21. Define-method-combination 参数 Lambda 列表使用的 lambda 列表关键字

define-method-combination 参数 lambda 列表[define-method-combination arguments lambda list]类似于普通 lambda 列表[ordinary lambda list], 但是也允许使用 &whole. 

### 3.4.11 <span id = "SIDSD">文档字符串和声明的语法交互</span>

在许多情况下, 文档字符串[documentation string]可以出现在一系列表达式形式之前的一系列 declare 表达式[expression]中.

在这个情况下, 如果字符串[string] S 出现在允许文档字符串[documentation string]的地方并且后面既没有 declare 表达式[expression]或一个表达式形式[form]那么 S 就被认为是一种表达式形式[form]; 否则, S 被当作一个文档字符串[documentation string]. 如果出现不止一个文档字符串[documentation string]那么结果是未定义的. 

## 3.5 <span id = "ErrorChecking">函数调用中的错误检测</span>

### 3.5.1 参数匹配检测

> * 3.5.1.1 [安全和非安全调用](#SafeUnsafeCalls)
> * 3.5.1.2 [参数太少](#TooFewArguments)
> * 3.5.1.3 [参数太多](#TooManyArguments)
> * 3.5.1.4 [不识别的关键字参数](#UnrecognizedKeywordArguments)
> * 3.5.1.5 [非法的关键字参数](#InvalidKeywordArguments)
> * 3.5.1.6 [奇数数量的关键字参数](#OddNumberKeywordArguments)
> * 3.5.1.7 [解构不匹配](#DestructuringMismatch)
> * 3.5.1.8 [调用下一个方法时的错误](#ErrorsWhenCallingNextMethod)

#### 3.5.1.1 <span id = "SafeUnsafeCalls">安全和非安全调用</span>

如果下面中的每一个都是安全[safe]代码[code]或者系统代码[system code] (除了由程序员代码[programmer code]的宏展开[macro expansion]所产生的系统代码[system code]之外)那么这个调用[call]就是安全调用[safe call] :

* 这个调用[call].
* 要被调用的函数[function]的定义.
* 函数性求值[functional evaluation]的点

以下特殊情况需要一些细化:

* 如果被调用的函数[function]是一个广义函数[generic function], 如果下面列出的所有部分都是安全[safe]代码[code]或者系统代码[system code]那么它就被认为是安全的[safe]:

        -- 它的定义 (如果它被显式定义的话).
        -- 所有可应用[applicable]方法[method]的方法[method]定义.
        -- 它的方法组合[method combination]的定义.

* 对于表达式形式 (coerce x 'function), 其中 x 是一个 lambda 表达式[lambda expression], 当 coerce 执行时, 全局环境中优化质量[optimize quality] safety 的值应用于产生的函数[function].

* 对于一个函数[function] ensure-generic-function 的调用, 在作为 :environment 参数[argument]传递的环境[environment]对象[object]中优化质量[optimize quality] safety 的值应用于产生的广义函数[generic function].

* 对于一个用 lambda 表达式[lambda expression]作为实参[argument]的 compile 的调用, 在 compile 被调用时全局环境[global environment]中优化质量[optimize quality] safety 的值应用于编译后的函数[compiled function].

* 对于一个单参数的 compile 调用, 如果函数[function]的原始定义是安全的[safe], 那么产生的编译后的函数[compiled function]也必须是安全的[safe].

* 一个通过 call-next-method 的对方法[method]的调用[call]中, 如果下面的每一个都被认为是安全[safe]代码[code]或者系统代码[system code], 那么这个调用一定被认为是安全的[safe]:

    -- 这个广义函数[generic function]的定义 (如果它被显式定义的话).
    -- 所有可应用[applicable]方法[method]的方法[method]定义.
    -- 方法组合[method combination]的定义.
    -- 方法[method]定义表达式形式[defining form]主体部分的入口点, 即建立 call-next-method 绑定[binding]的地方.
    -- 名字 call-next-method 函数性求值[functional evaluation]的点.

一个不安全调用[unsafe call]就是一个不是安全调用[safe call]的调用[call].

非正式的意图是, 如果已经采取了所有合理的步骤来确保调用[call]是安全的[safe], 即使在涉及到系统代码[system code]的情况下, 程序员[programmer]也可以依赖于一个调用[call]是安全的[safe]. 比如, 如果一个程序员[programmer]从安全[safe]代码[code]中调用 mapcar 并且提供了一个被编译为安全的[safe]函数[function], 那么这个具体实现[implementation]也需要去确保这个 mapcar 是一个安全调用[safe call].

##### 3.5.1.1.1 安全调用的错误检测时间

如果在安全调用[safe call]中发出一个错误, 这个发出[signal]的准确的点是依赖于具体实现的[implementation-dependent]. 具体来说, 它可能在编译时或运行时发出, 如果在运行时发出, 它可能在执行这个调用[call]时, 或之前, 或之后发出. 然而它总是在这个被调用函数[function]的主体执行之前. 

#### 3.5.1.2 <span id = "TooFewArguments">参数太少</span>

不允许对一个函数[function]提供过少的实参[argument]. 过少的参数意味着实参[argument]少于这个函数必要参数[required parameter]的数量.

如果这个求值情况[situation]发生在一个安全调用[safe call]中, 一定会发出一个 program-error 类型[type]的错误; 如果在一个不安全的调用[unsafe call]中这个求值情况[situation]有着未定义的后果. 

#### 3.5.1.3 <span id = "TooManyArguments">参数太多</span>

不允许对一个函数[function]提供过多的实参[argument]. 太多的参数意味实参[argument]多于这个函数必要参数[required parameter]加上可选参数[optional parameter]的数量; 然而, 如果这个函数[function]使用 &rest 或者 &key, 它不可能接受过多参数.

如果这个求值情况[situation]发生在一个安全调用[safe call]中, 一定会发出一个 program-error 类型[type]的错误; 如果在一个不安全的调用[unsafe call]中这个求值情况[situation]有着未定义的后果. 

#### 3.5.1.4 <span id = "UnrecognizedKeywordArguments">不识别的关键字参数</span>

不允许向一个函数[function]提供一个名字不被识别的关键字参数, 除非就像章节 3.4.1.4.1 (抑制关键字参数检测) 描述的那样抑制关键字参数检测.

如果这个求值情况[situation]发生在一个安全调用[safe call]中, 一定会发出一个 program-error 类型[type]的错误; 如果在一个不安全的调用[unsafe call]中这个求值情况[situation]有着未定义的后果. 

#### 3.5.1.5 <span id = "InvalidKeywordArguments">非法的关键字参数</span>

不允许使用一个不是符号[symbol]的名字来给函数提供关键字参数.

如果这个求值情况[situation]发生在一个安全调用[safe call]中, 一定会发出一个 program-error 类型[type]的错误, 除非就像章节 3.4.1.4.1 (抑制关键字参数检测) 描述的那样抑制关键字参数检测; 如果在一个不安全的调用[unsafe call]中这个求值情况[situation]有着未定义的后果. 

#### 3.5.1.6 <span id = "OddNumberKeywordArguments">奇数数量的关键字参数</span>

一定不能提供奇数数量的实参[argument]给关键字参数[keyword parameter].

如果这个求值情况[situation]发生在一个安全调用[safe call]中, 一定会发出一个 program-error 类型[type]的错误, 除非就像章节 3.4.1.4.1 (抑制关键字参数检测) 描述的那样抑制关键字参数检测; 如果在一个不安全的调用[unsafe call]中这个求值情况[situation]有着未定义的后果. 

#### 3.5.1.7 <span id = "DestructuringMismatch">解构不匹配</span>

当匹配一个解构 lambda 列表[destructuring lambda list]和一个表达式形式[form]时, 这个解构匹配模式和表达式形式[form]必须有着兼容的树结构[tree structur], 像章节 3.4.4 (宏 lambda 列表) 描述的那样.

否则, 如果这个求值情况[situation]发生在一个安全调用[safe call]中, 一定会发出一个 program-error 类型[type]的错误; 如果在一个不安全的调用[unsafe call]中这个求值情况[situation]有着未定义的后果.

#### 3.5.1.8 <span id = "ErrorsWhenCallingNextMethod">调用下一个方法时的错误(Errors When Calling a Next Method)</span>

如果用实参[argument]调用 call-next-method, 用于 call-next-method 的变更后的参数集合的可应用[applicable]方法[method]的有序集合必须与这个广义函数[generic function]的原始实参[argument]的可应用[applicable]方法[method]有序集合相同, 否则应该会发出一个错误.

对于应用于新的那些参数的方法集合和应用于原始参数的方法集合之间的比较, 其中相同特化符的方法之间的次序差别是不敏感的.

如果使用指定了不同的可应用方法的有序集的实参[argument]来调用 call-next-method , 并且没有可用的下一个方法[next method], 那么对不同方法的测试和相关错误的发出(存在的话)的将优先于调用 no-next-method. 

## 3.6 <span id = "TraversalRulesSideEffects">遍历规则和副作用</span>

当在一个对象遍历[object-traversing]操作期间执行的代码[code]以一种可能影响正在进行的遍历操作的方式修改对象[object]时, 其后果是未定义的. 具体来说, 应用以下规则.

列表遍历(List traversal)

    对于列表[list]遍历操作, 列表[list]中的 cdr 链是不允许被破坏性修改的.

数组遍历(Array traversal)

    对于数组[array]遍历操作, 不允许对数组[array]进行调整, 并且填充指针不允许被修改, 如果有的话.

哈希表遍历(Hash-table traversal)

    对于哈希表[hash table]遍历操作, 新元素可能不会被添加或删除, 除了当前散列键对应的元素可以被更改或删除的话.

包遍历(Package traversal)

    对于包[package]遍历操作 (比如, do-symbols), 新的符号[symbol]不能从被遍历的包[package]或者它使用的任何包[package]中被捕捉[interned]或者解除捕捉[uninterned], 除了当前的符号[symbol]可以从被遍历的包[package]中被解除捕捉[uninterned].

## 3.7 <span id = "DestructiveOperations">破坏性操作</span>

### 3.7.1 字面化对象的修改

如果字面化[literal]对象[object]被破坏性地修改那么后果是未定义的. 出于这个目的, 以下操作被认为是破坏性的[destructive]:

random-state

    使用它作为函数[function] random 的一个参数[argument].

cons

    修改 cons 的 car 或者 cdr 部分, 或者对一个 cons 的 car 或者 cdr 部分的对象[object]执行破坏性[destructive]操作.

array

    将一个新值存储到数组[array]的某个元素中, 或者对已经是这样一个元素[element]的对象[object]执行破坏性[destructive]操作.

    改变数组[array]的填充指针[fill pointer], 规模[dimension]或位移 (不管这个数组[array]是否为实际上可调整的[actually adjustable]).

    在另一个数组[array]上执行破坏性[destructive]操作, 它被转移到这个数组或者和这个数组[array]共享内容.

hash-table

    对任何键[key]做破坏性[destructive]操作.

    为任何键[key]存储一个新的值[value[4]], 或者在这样一个值[value]的任何对象上执行破坏性[destructive]操作.

    从这个哈希表[hash table]中添加或删除元素.

structure-object

    存储一个新的值到任何槽中, 或者对一些槽的值对象[object]执行破坏性[destructive]操作.

standard-object

    存储一个新的值到任何槽中, 或者对一些槽的值对象[object]执行破坏性[destructive]操作.

    改变这个对象[object]的类 (比如, 使用函数[function] change-class).

readtable

    更改读写表大小写[readtable case].

    修改这个读取表中任何字符的语法类型.

    修改与读取表[readtable]中任何字符[character]关联的读取器宏函数[reader macro function], 或修改在读取表[readtable]被定义为分派宏字符[dispatching macro character]的字符[character]关联的读取器宏函数[reader macro function].

stream

    在流[stream]上执行 I/O 操作, 或者关闭这个流[stream].

所有其他标准化类型

    [这个范围包括, 比如, character, condition, function, method-combination, method, number, package, pathname, restart, 还有 symbol.]

    在这些类型[type]的对象[object]上没有标准化[standardized]破坏性[destructive]操作. 

### 3.7.2 破坏性操作期间的控制转移

如果将控制从破坏性[destructive]的操作中转移出来(比如, 由于一个错误), 就会被修改对象的状态是依赖于具体实现的[implementation-dependent].

#### 3.7.2.1 破坏性操作期间的控制转移的示例

下面的示例演示了许多方法中的一部分, 在这些方法下这个修改的依赖于具体实现的[implementation-dependent]本质得以展现.

```LISP
(let ((a (list 2 1 4 3 7 6 'five)))
  (ignore-errors (sort a #'<))
  a)
=>  (1 2 3 4 6 7 FIVE)
OR=>  (2 1 4 3 7 6 FIVE)
OR=>  (2)

(prog foo ((a (list 1 2 3 4 5 6 7 8 9 10)))
  (sort a #'(lambda (x y) (if (zerop (random 5)) (return-from foo a) (> x y)))))
=>  (1 2 3 4 5 6 7 8 9 10)
OR=>  (3 4 5 6 2 7 8 9 10 1)
OR=>  (1 2 4 3)
```

## 3.8 <span id = "EvaluationCompilationDictionary">求值和编译的字典条目</span>

 * [符号 LAMBDA](#SymbolLAMBDA)
 * [宏 LAMBDA](#MacroLAMBDA)
 * [函数 COMPILE](#FunctionCOMPILE)
 * [函数 EVAL](#FunctionEVAL)
 * [特殊操作符 EVAL-WHEN](#SpecialOperatorEVALWHEN)
 * [特殊操作符 LOAD-TIME-VALUE](#SpecialOperatorLOADTIMEVALUE)
 * [特殊操作符 QUOTE](#SpecialOperatorQUOTE)
 * [访问器 COMPILER-MACRO-FUNCTION](#AccessorCOMPILERMACROFUNCTION)
 * [宏 DEFINE-COMPILER-MACRO](#MacroDEFINECOMPILERMACRO)
 * [宏 DEFMACRO](#MacroDEFMACRO)
 * [访问器 MACRO-FUNCTION](#AccessorMACROFUNCTION)
 * [函数 MACROEXPAND, MACROEXPAND-1](#FunctionMACROEXPANDMACROEXPAND1)
 * [宏 DEFINE-SYMBOL-MACRO](#MacroDEFINESYMBOLMACRO)
 * [特殊操作符 SYMBOL-MACROLET](#SpecialOperatorSYMBOLMACROLET)
 * [变量 *MACROEXPAND-HOOK*](#VariableMACROEXPANDHOOK)
 * [函数 PROCLAIM](#FunctionPROCLAIM)
 * [宏 DECLAIM](#MacroDECLAIM)
 * [符号 DECLARE](#SymbolDECLARE)
 * [声明 IGNORE, IGNORABLE](#DeclarationIGNOREIGNORABLE)
 * [声明 DYNAMIC-EXTENT](#DeclarationDYNAMICEXTENT)
 * [声明 TYPE](#DeclarationTYPE)
 * [声明 INLINE, NOTINLINE](#DeclarationINLINENOTINLINE)
 * [声明 FTYPE](#DeclarationFTYPE)
 * [声明 DECLARATION](#DeclarationDECLARATION)
 * [声明 OPTIMIZE](#DeclarationOPTIMIZE)
 * [声明 SPECIAL](#DeclarationSPECIAL)
 * [特殊操作符 LOCALLY](#SpecialOperatorLOCALLY)
 * [特殊操作符 THE](#SpecialOperatorTHE)
 * [函数 SPECIAL-OPERATOR-P](#FunctionSPECIALOPERATORP)
 * [函数 CONSTANTP](#FunctionCONSTANTP)


### <span id = "SymbolLAMBDA">符号 LAMBDA</span>

* 语法(Syntax):

        lambda lambda-list [[declaration* | documentation]] form*

* 参数(Arguments):

        lambda-list---一个普通 lambda 列表[ordinary lambda list].
        declaration---一个 declare 表达式[expression]; 不求值.
        documentation---一个字符串[string]; 没有被求值的.
        form---一个表达式形式[form].

* 描述(Description):

        lambda 表达式[lambda expression]是一种列表[list], 可以被用于替代特定上下文中的一个函数名[function name], 通过直接描述其行为而不是间接地引用一个已建立函数[function]的名称来表示一个函数[function].

        documentation 作为文档字符串[documentation string]被附加到所表示的函数 function (如果有实际创建的话).

* 参见(See Also):

        function, documentation, 章节 3.1.3 (lambda 表达式), 章节 3.1.2.1.2.4 (lambda 表达式形式), 章节 3.4.11 (文档字符串和声明的语法交互)

* 注意(Notes):

        这个 lambda 表达式形式[lambda form]

    ```LISP
    ((lambda lambda-list . body) . arguments)
    ```

        语义上等价于函数表达式[function form]

    ```LISP
    (funcall #'(lambda lambda-list . body) . arguments)
    ```

### <span id = "MacroLAMBDA">宏 LAMBDA</span>

* 语法(Syntax):

        lambda lambda-list [[declaration* | documentation]] form* => function

* 参数和值(Arguments and Values):

        lambda-list---一个普通 lambda 表达式[ordinary lambda list].
        declaration---一个 declare 表达式[expression]; 不求值.
        documentation---一个字符串[string]; 不求值.
        form---一个表达式形式[form].
        function---一个函数[function].

* 描述(Description):

        为一个涉及一个 lambda 表达式[lambda expression]的 function 特殊表达式形式[special form]提供一个简写表示, 例如:

        (lambda lambda-list [[declaration* | documentation]] form*)
        ==  (function (lambda lambda-list [[declaration* | documentation]] form*))
        ==  #'(lambda lambda-list [[declaration* | documentation]] form*)

* 示例(Examples):

    ```LISP
    (funcall (lambda (x) (+ x 3)) 4) =>  7
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        lambda (symbol)

* 注意(Notes):

        这个宏可以这样实现:

    ```LISP
    (defmacro lambda (&whole form &rest bvl-decls-and-body)
    (declare (ignore bvl-decls-and-body))
    `#',form)
    ```

### <span id = "FunctionCOMPILE">函数 COMPILE</span>

* 语法(Syntax):

        compile name &optional definition => function, warnings-p, failure-p

* 参数和值(Arguments and Values):

        name---一个函数名字[function name], 或者 nil.
        definition---一个 lambda 表达式[lambda expression]或者一个函数[function]. 如果 name 命名一个函数[function]那么默认就是这个名字 name 的函数定义, 或者如果 name 命名一个宏[macro]那么默认就是这个名字 name 的宏函数[macro function]. 当 name 是 nil 时如果没有提供这个定义 definition 那么后果是未定义的.
        function---这个函数名 function-name, 或者一个编译后的函数[compiled function].
        warnings-p---一个广义 boolean[generalized boolean].
        failure-p---一个广义 boolean[generalized boolean].

* 描述(Description):

        编译一个解释的函数[interpreted function].

        compile 从定义 definition 中产生一个编译后的函数[compiled function]. 如果定义 definition 是一个 lambda 表达式[lambda expression], 它被强制转为一个函数[function]. 如果这个定义 definition 已经是一个编译后的函数[compiled function], compile 会产生那个函数自身(换句话说, 是一个恒等(identity)操作)或者一个等价的函数.

        如果这个名字 name 是 nil, 产生的编译后的函数[compiled function]作为主值[primary value]直接返回. 如果给定一个非 nil[non-nil]的名字 name, 那么产生的编译后的函数[compiled function]替换这个名字 name 对应的已存在的函数[function]定义并且作为主值[primary value]返回这个名字 name; 如果名字 name 是一个命名一个宏[macro]的符号[symbol], 它的宏函数[macro function]会被更新并且名字 name 作为主值[primary value]返回.

        在 compile 函数处理的代码中出现的字面化[literal]对象[object]既没有被复制也没有被合并[coalesce]. 从 compile 的执行中产生的代码引用和源代码中对应对象[object] eql 的对象[object].

        compile 允许但不是必须去为 error 类型[type]的状况[condition]建立[establish]处理者[handler]. 比如, 处理者[handler]可能会发出警告, 并从某个依赖于具体实现的[implementation-dependent]点重新启动编译, 以便在无需人工干预的情况下进行编译.

        第二个返回值[secondary value], warnings-p, 如果编译器没有检测到 error 或者 warning 类型[type]的状况[condition]那么就是 false, 否则就是 true.

        第三个返回值[tertiary value], failure-p, 如果编译器没有检测到 error 或者 warning(除了 style-warning) 类型[type]的状况[condition]那么就是 false, 否则就是 true.

* 示例(Examples):

    ```LISP
    (defun foo () "bar") =>  FOO
    (compiled-function-p #'foo) =>  implementation-dependent
    (compile 'foo) =>  FOO 
    (compiled-function-p #'foo) =>  true
    (setf (symbol-function 'foo)
        (compile nil '(lambda () "replaced"))) =>  #<Compiled-Function>
    (foo) =>  "replaced"
    ```

* 受此影响(Affected By):

        *error-output*, *macroexpand-hook*.

        宏定义和全局声明(proclamation)的存在.

* 异常情况(Exceptional Situations):

        如果包围在要编译的函数上的词法环境[lexical environment]包含除了宏[macros], 符号宏[symbol macros]或声明[declaration]之外的任何绑定[binding], 则其结果是未定义的.

        关于在编译过程中的错误检测信息, 见章节 3.2.5 (编译器中的异常情况).

* 参见(See Also):

        compile-file

* 注意(Notes): None. 

### <span id = "FunctionEVAL">函数 EVAL</span>

* 语法(Syntax):

        eval form => result*

* 参数和值(Arguments and Values):

        form---一个表达式形式[form].
        results---表达式形式 form 的求值[evaluation]产生[yield]的值[value].

* 描述(Description):

        在当前动态环境[dynamic environment]和空词法环境[null lexical environment]下求值表达式形式 form.

        eval 是一个求值器的用户接口.

        这个求值器展开宏调用就像通过使用 macroexpand-1 一样.

        出现在被 eval 处理的代码中的常量既不会被复制也不会被合并. 从 eval 的执行产生的代码引用的对象[object]和源代码中对应的对象[object]是 eql 的.

* 示例(Examples):

    ```LISP
    (setq form '(1+ a) a 999) =>  999
    (eval form) =>  1000
    (eval 'form) =>  (1+ A)
    (let ((a '(this would break if eval used local value))) (eval form))
    =>  1000
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        macroexpand-1, 章节 3.1.2 (求值模型)

* 注意(Notes):

        为了获得一个符号[symbol]的当前动态值, 使用 symbol-value 等价于(而且通常更可取的)使用 eval.

        注意, eval 表达式形式[form]需要对其实参[argument]进行两个级别的求值[evaluation]. 第一, 表达式形式 form 通过常规的参数求值机制来求值[evaluation], 就像任何调用[call]一样. 从这个普通的实参[argument]求值[evaluation]得出的对象[object]成为表达式形式 form 形参[parameter]的值[value], 然后作为 eval 表达式形式[form]的一部分进行求值[evaluate]. 比如:

    ```LISP
    (eval (list 'cdr (car '((quote (a . b)) c)))) =>  b
    ```

        这个实参[argument]表达式形式[form] (list 'cdr (car '((quote (a . b)) c))) 以正常方式求值来产生实参 (cdr (quote (a . b))); 然后 eval 求值它的实参[argument], (cdr (quote (a . b))), 产生 b. 因为一个单独求值[evaluation]已经发生在任何函数表达式形式[function form]中的任何实参[argument]表达式形式[form]中, 所以有时称 eval 执行 "一个额外级别的求值".

### <span id = "SpecialOperatorEVALWHEN">特殊操作符 EVAL-WHEN</span>

* 语法(Syntax):

        eval-when (situation*) form* => result*

* 参数和值(Arguments and Values):

        situation---这些 :compile-toplevel, :load-toplevel, :execute, compile, load, 或 eval 符号[symbol]中的一个. 这里 eval, compile, 和 load 被废弃了.
        forms---一个隐式 progn [implicit progn].
        results---如果这些表达式形式[form]被执行, 这个就是它们的值, 如果没有就是 nil.

* 描述(Description):

        一个 eval-when 表达式形式的主体被当作一个隐式 progn [implicit progn]处理, 但是只有在列出的那些求值情况 situation 下.

        这里求值情况 :compile-toplevel (或 compile) 还有 :load-toplevel (或 load) 的使用控制着当 eval-when 作为顶层表达式形式[top level form]出现在被 compile-file 处理的代码中时是否会发生求值[evaluation]以及何时发生求值[evaluation].

        这里求值情况 :execute (或者 eval) 的使用控制着其他 eval-when 表达式形式[form]是否发生求值; 这就是说, 那些不是顶层表达式形式[top level form]的, 或者那些在被 eval 或 compile 处理的代码中的. 如果这个 :execute 求值情况在这样一个表达式形式[form]中被指定, 那么其中的主体表达式形式作为一个隐式 progn [implicit progn]处理; 否则, 这个 eval-when 表达式形式[form]返回 nil.

        eval-when 通常作为顶层表达式形式[top level form]出现, 但是对于它作为非顶层表达式形式[non-top-level form]出现在也是有意义的. 然而, 这个描述在章节 3.2 (编译) 的编译时副作用只发生在当 eval-when 作为顶层表达式形式[top level form]出现的时候.

* 示例(Examples):

        eval-when 使用的一个示例是, 为了当编译器使用用户定义的读取器宏[reader macro]时可以正确地读取文件, 它有必要写成

    ```LISP
    (eval-when (:compile-toplevel :load-toplevel :execute)
      (set-macro-character #\$ #'(lambda (stream char)
                                      (declare (ignore char))
                                      (list 'dollar (read stream))))) =>  T
    ```

        这个导致对 set-macro-character 的调用在编译器的执行环境中被执行, 从而修改它的读取器语法表.

    ```LISP
    ;;;     The EVAL-WHEN in this case is not at toplevel, so only the :EXECUTE
    ;;;     keyword is considered. At compile time, this has no effect.
    ;;;     At load time (if the LET is at toplevel), or at execution time
    ;;;     (if the LET is embedded in some other form which does not execute
    ;;;     until later) this sets (SYMBOL-FUNCTION 'FOO1) to a function which
    ;;;     returns 1.
    (let ((x 1))
      (eval-when (:execute :load-toplevel :compile-toplevel)
        (setf (symbol-function 'foo1) #'(lambda () x))))

    ;;;     If this expression occurs at the toplevel of a file to be compiled,
    ;;;     it has BOTH a compile time AND a load-time effect of setting
    ;;;     (SYMBOL-FUNCTION 'FOO2) to a function which returns 2.
    (eval-when (:execute :load-toplevel :compile-toplevel)
      (let ((x 2))
        (eval-when (:execute :load-toplevel :compile-toplevel)
          (setf (symbol-function 'foo2) #'(lambda () x)))))

    ;;;     If this expression occurs at the toplevel of a file to be compiled,
    ;;;     it has BOTH a compile time AND a load-time effect of setting the
    ;;;     function cell of FOO3 to a function which returns 3.
    (eval-when (:execute :load-toplevel :compile-toplevel)
      (setf (symbol-function 'foo3) #'(lambda () 3)))
    
    ;;; #4: This always does nothing. It simply returns NIL.
    (eval-when (:compile-toplevel)
      (eval-when (:compile-toplevel) 
        (print 'foo4)))

    ;;;     If this form occurs at toplevel of a file to be compiled, FOO5 is
    ;;;     printed at compile time. If this form occurs in a non-top-level
    ;;;     position, nothing is printed at compile time. Regardless of context,
    ;;;     nothing is ever printed at load time or execution time.
    (eval-when (:compile-toplevel) 
      (eval-when (:execute)
        (print 'foo5)))
    
    ;;;     If this form occurs at toplevel of a file to be compiled, FOO6 is
    ;;;     printed at compile time.  If this form occurs in a non-top-level
    ;;;     position, nothing is printed at compile time. Regardless of context,
    ;;;     nothing is ever printed at load time or execution time.
    (eval-when (:execute :load-toplevel)
      (eval-when (:compile-toplevel)
        (print 'foo6)))
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        compile-file, 章节 3.2 (编译)

* 注意(Notes):

        以下效果是 eval-when 的定义的逻辑结果:

        * 一个单独的 eval-when 表达式执行主体代码不超过一次.

        * 应该编写用于顶层表达式形式[top level form]中的宏[macro], 以便处理在宏展开中的那些表达式形式[form]的副作用. 这个宏展开器(macro-expander)自身不应该执行这些副作用.

            比如:

            错误的:

    ```LISP
    (defmacro foo ()
      (really-foo)
      `(really-foo))
    ```

            正确的:

    ```LISP
    (defmacro foo ()
      `(eval-when (:compile-toplevel :execute :load-toplevel) (really-foo)))
    ```

            遵守这个约定意味着这样的宏[macro]在作为非顶层表达式形式[non-top-level form]出现在时直观地表现.

        * 在一个 eval-when 周围放置一个变量的绑定确实会捕获这个绑定, 因为 compile-time-too 模式不会发生 (换句话说, 引入一个变量绑定意味着 eval-when 不是一个顶层表达式形式[top level form]). 比如,

    ```LISP
    (let ((x 3))
    (eval-when (:execute :load-toplevel :compile-toplevel) (print x)))
    ```

            在执行的时候(换句话说, 加载时)打印 3, 而在编译时不会打印任何东西. 这很重要, 因此 defun 和 defmacro 的展开可以根据 eval-when 来完成并且可以正确地捕获词法环境[lexical environment].

    ```LISP
    (defun bar (x) (defun foo () (+ x 3)))
    ```

            可能被展开成

    ```LISP            
    (defun bar (x) 
      (progn (eval-when (:compile-toplevel) 
                (compiler::notice-function-definition 'foo '(x)))
              (eval-when (:execute :load-toplevel)
                (setf (symbol-function 'foo) #'(lambda () (+ x 3))))))
    ```

            当这个 bar 的定义不是一个顶层表达式形式[top level form]时, 它会被上面的规则当成和下面的这个相同

    ```LISP
    (defun bar (x) 
    (setf (symbol-function 'foo) #'(lambda () (+ x 3))))
    ```

### <span id = "SpecialOperatorLOADTIMEVALUE">特殊操作符 LOAD-TIME-VALUE</span>

* 语法(Syntax):

        load-time-value form &optional read-only-p => object

* 参数和值(Arguments and Values):

        form---一个表达式形式[form]; 按照以下描述的被求值.
        read-only-p---一个 boolean; 不求值.
        object---从求值表达式形式 form 返回的主值[primary value].

* 描述(Description):

        load-time-value 为表达式形式 form 直到这个表达式在运行时环境中才求值提供一个延时求值的机制; 见章节 3.2 (编译).

        read-only-p 指定这个结果是否可以被认为是常量对象[constant object]. 如果是 t, 结果就是一个只读的量, 如果适用于具体实现[implementation], 它可以被拷贝到只读空间 并且/或 和来自其他程序[program]的相似的[similar]常量对象[constant object]进行合并. 如果是 nil (默认的), 结果一定既不被复制, 也不能被合并; 它一定被认为是潜在可修改的数据.

        如果一个 load-time-value 表达式被 compile-file 处理, 这个编译器在这个表达式形式 form 上执行它正常的语义处理 (就像宏展开和转为机器码), 但是安排这个表达式形式 form 的执行发生在加载时的一个空词法环境[null lexical environment]中, 这个求值的结果在运行时被当作是一个字面化[literal]对象[object]. 确保这个表达式形式 form 的求值只有在文件[file]加载时才会发生, 但是对该文件中顶层表达式形式[top level form]的求值的求值顺序是由依赖实现的[implementation-dependent].

        如果一个 load-time-value 表达式出现在被 compile 编译的函数中, 这个表达式形式 form 在编译时的一个空词法环境[null lexical environment]中被求值. 这个编译时求值的结果被当作是编译后代码中的字面化[literal]对象[object].

        如果一个 load-time-value 表达式被 eval 处理, 表达式形式 form 在一个空词法环境[null lexical environment]中被求值, 并且返回一个值. 隐式编译(或部分编译)由 由 eval 处理表达式的具体实现可能只求值表达式形式 form 一次, 在这个编译被执行的时候.

        如果相同的[same]列表[list] (load-time-value form) 被求值或编译超过一次, 这个表达式形式 form 被只求值一次或者超过一次是依赖于具体实现的[implementation-dependent]. 当一个表达式被求值或编译共享子结构时, 当相同的[same]表达式形式[form]被 eval 或 compile 多次处理时, 都可能发生这种情况. 由于一个 load-time-value 表达式可以在不止一个地方被引用并且可以被 eval 求值超过一次, 因此每一次执行返回新的对象还是返回和其他执行一样的对象[object]是依赖于具体实现的[implementation-dependent]. 当对产生的对象[object]进行破坏性修改时, 用户必须谨慎使用.

        如果两个在 equal 下是相同的[same]但是不相等[identical]列表 (load-time-value form) 被求值或编译, 它们的值总是来自于对表达式形式 form 的不同的求值. 它们的那些值[value]可能不会被合并除非 read-only-p 是 t.

* 示例(Examples):

    ```LISP
    ;;; The function INCR1 always returns the same value, even in different images.
    ;;; The function INCR2 always returns the same value in a given image, 
    ;;; but the value it returns might vary from image to image.
    (defun incr1 (x) (+ x #.(random 17)))
    (defun incr2 (x) (+ x (load-time-value (random 17))))

    ;;; The function FOO1-REF references the nth element of the first of 
    ;;; the *FOO-ARRAYS* that is available at load time.  It is permissible for
    ;;; that array to be modified (e.g., by SET-FOO1-REF); FOO1-REF will see the
    ;;; updated values.
    (defvar *foo-arrays* (list (make-array 7) (make-array 8)))
    (defun foo1-ref (n) (aref (load-time-value (first *my-arrays*) nil) n))
    (defun set-foo1-ref (n val) 
    (setf (aref (load-time-value (first *my-arrays*) nil) n) val))

    ;;; The function BAR1-REF references the nth element of the first of 
    ;;; the *BAR-ARRAYS* that is available at load time.  The programmer has
    ;;; promised that the array will be treated as read-only, so the system 
    ;;; can copy or coalesce the array.
    (defvar *bar-arrays* (list (make-array 7) (make-array 8)))
    (defun bar1-ref (n) (aref (load-time-value (first *my-arrays*) t) n))

    ;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced
    ;;; even though NIL was specified, because the object was already read-only
    ;;; when it was written as a literal vector rather than created by a constructor.
    ;;; User programs must treat the vector v as read-only.
    (defun baz-ref (n)
    (let ((v (load-time-value #(A B C) nil)))
        (values (svref v n) v)))

    ;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced
    ;;; even though NIL was specified in the outer situation because T was specified
    ;;; in the inner situation.  User programs must treat the vector v as read-only.
    (defun baz-ref (n)
    (let ((v (load-time-value (load-time-value (vector 1 2 3) t) nil)))
        (values (svref v n) v)))
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        compile-file, compile, eval, 章节 3.2.2.2 (最小化编译), 章节 3.2 (编译)

* 注意(Notes):

        load-time-value 必须出现在一个"用于[evaluation]"位置中的引用结构的外面. 在出现需要在被引用结构中使用 load-time-value 的情况下, 反引号[backquote]读取器宏[reader macro]可能会被调用; 见章节 2.4.6 (反引号).

        如果一个对象已经是只读的, 为 read-only-p 指定为 nil 不是强制一个对象成为可修改的方法. 这只是一种方式来说明, 对于一个可修改的对象, 这个操作不是为了使这个对象变得只读. 

### <span id = "SpecialOperatorQUOTE">特殊操作符 QUOTE</span>

* 语法(Syntax):

        quote object => object

* 参数和值(Arguments and Values):

        object---一个对象[object]; 不求值.

* 描述(Description):

        这个 quote 特殊操作符[special operator]只是返回对象 object.

        如果那些字面化[literal]对象[object] (包括被引用对象[quoted object])被破坏性修改那么结果是未定义的.

* 示例(Examples):

    ```LISP
    (setq a 1) =>  1
    (quote (setq a 3)) =>  (SETQ A 3)
    a =>  1
    'a =>  A
    ''a =>  (QUOTE A) 
    '''a =>  (QUOTE (QUOTE A))
    (setq a 43) =>  43
    (list a (cons a 3)) =>  (43 (43 . 3))
    (list (quote a) (quote (cons a 3))) =>  (A (CONS A 3)) 
    1 =>  1
    '1 =>  1
    "foo" =>  "foo"
    '"foo" =>  "foo"
    (car '(a b)) =>  A
    '(car '(a b)) =>  (CAR (QUOTE (A B)))
    #(car '(a b)) =>  #(CAR (QUOTE (A B)))
    '#(car '(a b)) =>  #(CAR (QUOTE (A B)))
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        章节 3.1 (求值), 章节 2.4.3 (单引号), 章节 3.2.1 (编译器术语)

* 注意(Notes):

        这个 'object 文本表示法和 (quote object) 是等价的; 见章节 3.2.1 (编译器术语).

        一些称之为自求值对象[self-evaluating object]的对象[object]不需要被 quote 引用. 然而, 符号[symbol]和列表[list]用来表示程序的一部分, 因此如果没有 quote, 程序中的常量数据就无法使用. 由于 quote 抑制了这些对象[object]的求值[evaluation], 它们变成了数据而不是程序. 

### <span id = "AccessorCOMPILERMACROFUNCTION">访问器 COMPILER-MACRO-FUNCTION</span>

* 语法(Syntax):

        compiler-macro-function name &optional environment => function

        (setf (compiler-macro-function name &optional environment) new-function)

* 参数和值(Arguments and Values):

        name---一个函数名字[function name].
        environment---一个环境[environment]对象[object].
        function, new-function---一个编译器宏函数[compiler macro function], 或者 nil.

* 描述(Description):

        在环境 environment 中访问[access]名为 name 的编译器宏函数[compiler macro function], 如果有的话.

        一个 nil 值表示名为 name 的编译器宏函数[compiler macro function]的缺失.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        在一个 compiler-macro-function 的 setf 使用中, 如果环境 environment 是非 nil[non-nil]那么结果是未定义的.

* 参见(See Also):

        define-compiler-macro, 章节 3.2.2.1 (编译器宏)

* 注意(Notes): None. 

### <span id = "MacroDEFINECOMPILERMACRO">宏 DEFINE-COMPILER-MACRO</span>

* 语法(Syntax):

        define-compiler-macro name lambda-list [[declaration* | documentation]] form*
        => name

* 参数和值(Arguments and Values):

        name---一个函数名字[function name].
        lambda-list---一个宏 lambda 列表[macro lambda list].
        declaration---一个 declare 表达式[expression]; 不求值.
        documentation---一个字符串[string]; 不求值.
        form---一个表达式形式[form].

* 描述(Description):

        这是一个定义编译器宏函数[compiler macro function]的普通机制. 它的定义方式和 defmacro 一样; 仅有的区别是:

            * 这个 name 可以是一个命名了任何函数[function]或宏[macro]的函数名字[function name].

            * 展开器函数作为 name 的编译器宏函数[compiler macro function]被安装, 而不是作为一个宏函数[macro function].

            * 这个 &whole 参数绑定为传递给这个编译器宏函数[compiler macro function]的 form 参数. 剩余的 lambda-list 参数被指定为好像一个表达式形式包含了在 car 中的函数名和在 cdr 中的那些实际参数, 但是如果实际表达式形式的 car 部分是一个符号 funcall, 那么参数的解构实际上通过使用它的 cddr 来执行.

            * 这个 documentation 作为一个文档字符串被关联到名字 name (作为 compiler-macro 种类) 和这个编译器宏函数[compiler macro function].

            * 不像一个普通的宏[macro], 编译器宏[compiler macro]可以仅仅通过返回与原始那个(可以通过使用 &whole 获取到的) 相同的[same]表达式形式来拒绝提供展开式.

* 示例(Examples):

    ```LISP
    (defun square (x) (expt x 2)) =>  SQUARE
    (define-compiler-macro square (&whole form arg)
      (if (atom arg)
          `(expt ,arg 2)
          (case (car arg)
            (square (if (= (length arg) 2)
                        `(expt ,(nth 1 arg) 4)
                        form))
            (expt   (if (= (length arg) 3)
                        (if (numberp (nth 2 arg))
                            `(expt ,(nth 1 arg) ,(* 2 (nth 2 arg)))
                            `(expt ,(nth 1 arg) (* 2 ,(nth 2 arg))))
                        form))
            (otherwise `(expt ,arg 2))))) =>  SQUARE
    (square (square 3)) =>  81
    (macroexpand '(square x)) =>  (SQUARE X), false
    (funcall (compiler-macro-function 'square) '(square x) nil)
    =>  (EXPT X 2)
    (funcall (compiler-macro-function 'square) '(square (square x)) nil)
    =>  (EXPT X 4)
    (funcall (compiler-macro-function 'square) '(funcall #'square x) nil)
    =>  (EXPT X 2)

    (defun distance-positional (x1 y1 x2 y2)
      (sqrt (+ (expt (- x2 x1) 2) (expt (- y2 y1) 2))))
    =>  DISTANCE-POSITIONAL
    (defun distance (&key (x1 0) (y1 0) (x2 x1) (y2 y1))
      (distance-positional x1 y1 x2 y2))
    =>  DISTANCE
    (define-compiler-macro distance (&whole form
                                      &rest key-value-pairs
                                      &key (x1 0  x1-p)
                                          (y1 0  y1-p)
                                          (x2 x1 x2-p)
                                          (y2 y1 y2-p)
                                      &allow-other-keys
                                      &environment env)
      (flet ((key (n) (nth (* n 2) key-value-pairs))
              (arg (n) (nth (1+ (* n 2)) key-value-pairs))
              (simplep (x)
                (let ((expanded-x (macroexpand x env)))
                  (or (constantp expanded-x env)
                      (symbolp expanded-x)))))
        (let ((n (/ (length key-value-pairs) 2)))
          (multiple-value-bind (x1s y1s x2s y2s others)
              (loop for (key) on key-value-pairs by #'cddr
                    count (eq key ':x1) into x1s
                    count (eq key ':y1) into y1s
                    count (eq key ':x2) into x2s
                    count (eq key ':y1) into y2s
                    count (not (member key '(:x1 :x2 :y1 :y2)))
                      into others
                    finally (return (values x1s y1s x2s y2s others)))
            (cond ((and (= n 4)
                        (eq (key 0) :x1)
                        (eq (key 1) :y1)
                        (eq (key 2) :x2)
                        (eq (key 3) :y2))
                    `(distance-positional ,x1 ,y1 ,x2 ,y2))
                  ((and (if x1-p (and (= x1s 1) (simplep x1)) t)
                        (if y1-p (and (= y1s 1) (simplep y1)) t)
                        (if x2-p (and (= x2s 1) (simplep x2)) t)
                        (if y2-p (and (= y2s 1) (simplep y2)) t)
                        (zerop others))
                    `(distance-positional ,x1 ,y1 ,x2 ,y2))
                  ((and (< x1s 2) (< y1s 2) (< x2s 2) (< y2s 2)
                        (zerop others))
                    (let ((temps (loop repeat n collect (gensym))))
                      `(let ,(loop for i below n
                                  collect (list (nth i temps) (arg i)))
                        (distance
                          ,@(loop for i below n
                                  append (list (key i) (nth i temps)))))))
                  (t form))))))
    =>  DISTANCE
    (dolist (form
              '((distance :x1 (setq x 7) :x2 (decf x) :y1 (decf x) :y2 (decf x))
                (distance :x1 (setq x 7) :y1 (decf x) :x2 (decf x) :y2 (decf x))
                (distance :x1 (setq x 7) :y1 (incf x))
                (distance :x1 (setq x 7) :y1 (incf x) :x1 (incf x))
                (distance :x1 a1 :y1 b1 :x2 a2 :y2 b2)
                (distance :x1 a1 :x2 a2 :y1 b1 :y2 b2)
                (distance :x1 a1 :y1 b1 :z1 c1 :x2 a2 :y2 b2 :z2 c2)))
      (print (funcall (compiler-macro-function 'distance) form nil)))
    >>  (LET ((#:G6558 (SETQ X 7))
    >>        (#:G6559 (DECF X))
    >>        (#:G6560 (DECF X))
    >>        (#:G6561 (DECF X)))
    >>    (DISTANCE :X1 #:G6558 :X2 #:G6559 :Y1 #:G6560 :Y2 #:G6561)) 
    >>  (DISTANCE-POSITIONAL (SETQ X 7) (DECF X) (DECF X) (DECF X)) 
    >>  (LET ((#:G6567 (SETQ X 7))
    >>        (#:G6568 (INCF X)))
    >>    (DISTANCE :X1 #:G6567 :Y1 #:G6568)) 
    >>  (DISTANCE :X1 (SETQ X 7) :Y1 (INCF X) :X1 (INCF X)) 
    >>  (DISTANCE-POSITIONAL A1 B1 A2 B2) 
    >>  (DISTANCE-POSITIONAL A1 B1 A2 B2) 
    >>  (DISTANCE :X1 A1 :Y1 B1 :Z1 C1 :X2 A2 :Y2 B2 :Z2 C2) 
    =>  NIL
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        compiler-macro-function, defmacro, documentation, 章节 3.4.11 (文档字符串和声明的语法交互)

* 注意(Notes):

        为一个 COMMON-LISP 包中的函数写一个编译器宏[compiler macro]的定义的结果是未定义的; 很有可能在某些实现[implementation]中, 这样的尝试会覆盖相同或同等重要的定义. 一般来说, 建议程序员只编写自己维护的函数[function]的编译器宏[compiler macro]的定义--为其他地方维护的函数编写一个编译器宏[compiler macro]的定义通常被认为违背了模块化和数据抽象的传统规则. 

### <span id = "MacroDEFMACRO">宏 DEFMACRO</span>

* 语法(Syntax):

        defmacro name lambda-list [[declaration* | documentation]] form*
        => name

* 参数和值(Arguments and Values):

        name---一个符号[symbol]. 
        lambda-list---一个宏 lambda 列表[macro lambda list].
        declaration---一个 declare 表达式[expression]; 不求值.
        documentation---一个字符串[string]; 不求值.
        form---一个表达式形式[form].

* 描述(Description):

        通过关联一个宏函数[macro function]到全局环境中的这个名字 name 来把 name 定义为一个宏[macro]. 这个宏函数[macro function]被定义在 defmacro 表达式形式[form]出现的相同的词法环境[lexical environment]中.

        在 lambda-list 里的参数变量被绑定为这个宏调用的解构的部分里.

        这个展开函数接受两个参数, 一个表达式形式[form]和一个环境[environment]. 这个展开函数返回一个表达式形式[form]. 这个展开函数的主体是由这些表达式形式 form 指定的. 这些表达式形式 form 按顺序被执行. 最后一个表达式形式 form 执行的值作为这个宏[macro]的展开返回. 这个展开函数的主体表达式形式 form (但不是那个 lambda-list) 被隐式地闭合在一个名字为 name 的块[block]中.

        这个 lambda-list 符合 3.4.4 章节(宏 lambda 列表)所描述的要求.

        这个 documentation 作为文档字符串[documentation string]被关联到 name(作为 function 种类) 和这个宏函数[macro function]上.

        defmacro 可以被用于重定义一个宏[macro]或者用一个宏[macro]定义替换一个函数[functioni]定义.

        返回的表达式形式[form]的递归展开必须终止, 其中包括作为返回的其他表达式形式[form]的子表达式形式[subform]的宏的展开.

        如果完全宏展开一个表达式形式[form]的结果包含除了在字面化[literal]对象[object]里以外的任何环状[circular]列表[list]结构[structure], 结果是未定义的.

        如果一个 defmacro 表达式形式[form]作为顶层表达式形式[top level form]出现, 编译器[compiler]必须在编译时把宏[macro]定义存储起来, 这样一来在这个文件中稍后出现的这个宏就可以被正确地展开. 如果这个宏在这个要被被编译的文件[file]中被引用到, 用户必须确保这个宏[macro]的主体可以在编译时被求值.

* 示例(Examples):

    ```LISP
    (defmacro mac1 (a b) "Mac1 multiplies and adds" 
                `(+ ,a (* ,b 3))) =>  MAC1 
    (mac1 4 5) =>  19 
    (documentation 'mac1 'function) =>  "Mac1 multiplies and adds" 
    (defmacro mac2 (&optional (a 2 b) (c 3 d) &rest x) `'(,a ,b ,c ,d ,x)) =>  MAC2 
    (mac2 6) =>  (6 T 3 NIL NIL) 
    (mac2 6 3 8) =>  (6 T 3 T (8)) 
    (defmacro mac3 (&whole r a &optional (b 3) &rest x &key c (d a))
        `'(,r ,a ,b ,c ,d ,x)) =>  MAC3 
    (mac3 1 6 :d 8 :c 9 :d 10) =>  ((MAC3 1 6 :D 8 :C 9 :D 10) 1 6 9 8 (:D 8 :C 9 :D 10)) 
    ```

        只有在普通 lambda 列表[ordinary lambda list]语法允许一个参数名而不是列表[list]的情况下才允许使用内嵌的解构 lambda 列表[destructuring lambda list]的这个规则被用来防止歧义. 比如, 下面的是非法的:

    ```LISP
    (defmacro loser (x &optional (a b &rest c) &rest z)
      ...)
    ```

        因为普通 lambda 列表[ordinary lambda list]语法不允许一个列表[list]跟在 &optional 后面; 这个列表[list] (a b &rest c) 会被解释为描述一个名字为 a 的可选参数, 它的默认值是表达式形式 b, 带有一个命名为 &rest 的 supplied-p 参数(不合法), 还有一个列表中的无关符号 c (也是不合法的). 一种几乎正确的方式来表达是

    ```LISP
    (defmacro loser (x &optional ((a b &rest c)) &rest z)
      ...)
    ```

        额外的括号集消除了歧义. 然而, 这个定义现在是不正确的因为一个像 (loser (car pool)) 这样的宏调用不会提供任何参数表达式形式给 lambda 列表 (a b &rest c), 因此, 与 lambda 列表[lambda list]相匹配的默认值是 nil, 因为没有指定显式的默认值. 这个结果是未定义的, 因为空列表 nil 没有表达式形式[form]来满足参数 a 和 b. 完全正确的定义应该是

    ```LISP
    (defmacro loser (x &optional ((a b &rest c) '(nil nil)) &rest z)
      ...)
    ```

        或者

    ```LISP
    (defmacro loser (x &optional ((&optional a b &rest c)) &rest z)
      ...)
    ```

        这些略有不同: 第一个要求如果宏调用显式指定了 a, 那么它也必须显式地指定 b, 而第二个则没有这个要求. 比如,

    ```LISP
    (loser (car pool) ((+ x 1)))
    ```

        这对于第二个定义是个合法的调用但是对于第一个则不是.

    ```LISP
    (defmacro dm1a (&whole x) `',x)
    (macroexpand '(dm1a))  =>  (QUOTE (DM1A))
    (macroexpand '(dm1a a)) is an error.
    
    (defmacro dm1b (&whole x a &optional b) `'(,x ,a ,b))
    (macroexpand '(dm1b))  is an error.
    (macroexpand '(dm1b q))  =>  (QUOTE ((DM1B Q) Q NIL))
    (macroexpand '(dm1b q r)) =>  (QUOTE ((DM1B Q R) Q R))
    (macroexpand '(dm1b q r s)) is an error.

    (defmacro dm2a (&whole form a b) `'(form ,form a ,a b ,b))
    (macroexpand '(dm2a x y)) =>  (QUOTE (FORM (DM2A X Y) A X B Y))
    (dm2a x y) =>  (FORM (DM2A X Y) A X B Y)

    (defmacro dm2b (&whole form a (&whole b (c . d) &optional (e 5)) 
                    &body f &environment env)
      ``(,',form ,,a ,',b ,',(macroexpand c env) ,',d ,',e ,',f))
    ;Note that because backquote is involved, implementations may differ
    ;slightly in the nature (though not the functionality) of the expansion.
    (macroexpand '(dm2b x1 (((incf x2) x3 x4)) x5 x6))
    =>  (LIST* '(DM2B X1 (((INCF X2) X3 X4))
                      X5 X6)
                X1
                '((((INCF X2) X3 X4)) (SETQ X2 (+ X2 1)) (X3 X4) 5 (X5 X6))),
        T
    (let ((x1 5))
      (macrolet ((segundo (x) `(cadr ,x)))
        (dm2b x1 (((segundo x2) x3 x4)) x5 x6)))
    =>  ((DM2B X1 (((SEGUNDO X2) X3 X4)) X5 X6)
          5 (((SEGUNDO X2) X3 X4)) (CADR X2) (X3 X4) 5 (X5 X6))
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        define-compiler-macro, destructuring-bind, documentation, macroexpand, *macroexpand-hook*, macrolet, macro-function, 章节 3.1 (求值), 章节 3.2 (编译), 章节 3.4.11 (文档字符串和声明的语法交互)

* 注意(Notes): None. 

### <span id = "AccessorMACROFUNCTION">访问器 MACRO-FUNCTION</span>

* 语法(Syntax):

        macro-function symbol &optional environment => function

        (setf (macro-function symbol &optional environment) new-function)

* 参数和值(Arguments and Values):

        symbol---一个符号[symbol].
        environment---一个环境[environment]对象[object].
        function---一个宏函数[macro function]或者 nil.
        new-function---一个宏函数[macro function].

* 描述(Description):

        确定符号 symbol 在指定的环境 environment 中是否有一个函数定义作为一个宏.

        如果是这样, 则返回宏展开函数, 是一个两参数的函数. 如果符号 symbol 在这个词法环境 environment 中没有函数定义, 或者它的定义不是一个宏[macro], macro-function 返回 nil.

        对于符号 symbol, macro-function 和 special-operator-p 都返回 true 是有可能的. 宏定义必须可被那些只理解那些标准 Common Lisp 特殊表达式形式[special form]的程序所使用.

* 示例(Examples):

    ```LISP
    (defmacro macfun (x) '(macro-function 'macfun)) =>  MACFUN 
    (not (macro-function 'macfun)) =>  false 

    (macrolet ((foo (&environment env)
                  (if (macro-function 'bar env)
                      ''yes
                      ''no)))
        (list (foo)
              (macrolet ((bar () :beep))
                (foo))))
    
    =>  (NO YES)
    ```

* 受此影响(Affected By):

        (setf macro-function), defmacro, and macrolet.

* 异常情况(Exceptional Situations):

        在一个 macro-function 的 setf 的使用中如果环境 environment 是非 nil 的[non-nil], 那么结果是未定义的.

* 参见(See Also):

        defmacro, 章节 3.1 (求值)

* 注意(Notes):

        setf 可以和 macro-function 一起使用来设置一个宏[macro]为一个符号的全局函数定义:

    ```LISP
    (setf (macro-function symbol) fn)
    ```

        设置的值必须是一个函数, 该函数接受两个参数, 整个宏调用和一个环境[environment], 并计算该调用的展开. 执行这个操作会导致符号 symbol 只有这个宏定义作为全局函数定义; 任何之前的定义, 不管是宏[macro]还是函数[function], 都会丢失. 

### <span id = "FunctionMACROEXPANDMACROEXPAND1">函数 MACROEXPAND, MACROEXPAND-1</span>

* 语法(Syntax):

        macroexpand form &optional env => expansion, expanded-p

        macroexpand-1 form &optional env => expansion, expanded-p

* 参数和值(Arguments and Values):

        form---一个表达式形式[form].
        env---一个环境[environment]对象[object]. 默认是 nil.
        expansion---一个表达式形式[form].
        expanded-p---一个广义 boolean[generalized boolean].

* 描述(Description):

        macroexpand 和 macroexpand-1 把宏[macro]展开.

        如果表达式形式 form 是一个宏表达式形式[macro form], 那么 macroexpand-1 只展开宏表达式形式[macro form]调用一次.

        macroexpand 重复地展开表达式形式 form 直到它不再是一个宏表达式形式[macro form]. 事实上, macroexpand 重复调用 macroexpand-1 直到返回的第二个值[secondary value]是 nil.

        如果表达式形式 form 是一个宏表达式形式[macro form], 那么展开式 expansion 就是一个宏展开式[macro expansion]并且 expanded-p 是 true. 否则, 这个展开式 expansion 就是给定的表达式形式 form 并且 expanded-p 是 false.

        宏展开是按照以下方式进行的. 一旦 macroexpand-1 确定表达式形式 from 是一个宏表达式形式[macro form], 它就会获得一个用于这个宏[macro]或符号宏[symbol macro]的合适的展开函数[function]. 这个 *macroexpand-hook* 的值强制转为一个函数[function]并且作为一个三个参数的函数[function]被调用: 展开函数[function], 这个 form, 还有这个 env. 从这个调用返回的值[value]被认为是这个表达式形式 form 的展开.

        除了全局环境中的宏[macro]定义之外, 在 env 中由 macrolet 或 symbol-macrolet 所建立的任何局部宏定义都被考虑到. 如果只提供了表达式形式 form 作为一个参数, 那么环境实际上就是 null, 那么只有通过 defmacro 建立的全局宏定义才会被考虑进去. 宏[macro]定义被局部函数[function]定义所遮蔽.

* 示例(Examples):

    ```LISP
    (defmacro alpha (x y) `(beta ,x ,y)) =>  ALPHA
    (defmacro beta (x y) `(gamma ,x ,y)) =>  BETA
    (defmacro delta (x y) `(gamma ,x ,y)) =>  EPSILON
    (defmacro expand (form &environment env)
      (multiple-value-bind (expansion expanded-p)
          (macroexpand form env)
        `(values ',expansion ',expanded-p))) =>  EXPAND
    (defmacro expand-1 (form &environment env)
      (multiple-value-bind (expansion expanded-p)
          (macroexpand-1 form env)
        `(values ',expansion ',expanded-p))) =>  EXPAND-1

    ;; Simple examples involving just the global environment
    (macroexpand-1 '(alpha a b)) =>  (BETA A B), true
    (expand-1 (alpha a b)) =>  (BETA A B), true
    (macroexpand '(alpha a b)) =>  (GAMMA A B), true
    (expand (alpha a b)) =>  (GAMMA A B), true
    (macroexpand-1 'not-a-macro) =>  NOT-A-MACRO, false
    (expand-1 not-a-macro) =>  NOT-A-MACRO, false
    (macroexpand '(not-a-macro a b)) =>  (NOT-A-MACRO A B), false
    (expand (not-a-macro a b)) =>  (NOT-A-MACRO A B), false

    ;; Examples involving lexical environments
    (macrolet ((alpha (x y) `(delta ,x ,y)))
      (macroexpand-1 '(alpha a b))) =>  (BETA A B), true
    (macrolet ((alpha (x y) `(delta ,x ,y)))
      (expand-1 (alpha a b))) =>  (DELTA A B), true
    (macrolet ((alpha (x y) `(delta ,x ,y)))
      (macroexpand '(alpha a b))) =>  (GAMMA A B), true
    (macrolet ((alpha (x y) `(delta ,x ,y)))
      (expand (alpha a b))) =>  (GAMMA A B), true
    (macrolet ((beta (x y) `(epsilon ,x ,y)))
      (expand (alpha a b))) =>  (EPSILON A B), true
    (let ((x (list 1 2 3)))
      (symbol-macrolet ((a (first x)))
        (expand a))) =>  (FIRST X), true
    (let ((x (list 1 2 3)))
      (symbol-macrolet ((a (first x)))
        (macroexpand 'a))) =>  A, false
    (symbol-macrolet ((b (alpha x y)))
      (expand-1 b)) =>  (ALPHA X Y), true
    (symbol-macrolet ((b (alpha x y)))
      (expand b)) =>  (GAMMA X Y), true
    (symbol-macrolet ((b (alpha x y))
                      (a b))
      (expand-1 a)) =>  B, true
    (symbol-macrolet ((b (alpha x y))
                      (a b))
      (expand a)) =>  (GAMMA X Y), true

    ;; Examples of shadowing behavior
    (flet ((beta (x y) (+ x y)))
      (expand (alpha a b))) =>  (BETA A B), true
    (macrolet ((alpha (x y) `(delta ,x ,y)))
      (flet ((alpha (x y) (+ x y)))
        (expand (alpha a b)))) =>  (ALPHA A B), false
    (let ((x (list 1 2 3)))
      (symbol-macrolet ((a (first x)))
        (let ((a x))
          (expand a)))) =>  A, false
    ```

* 受此影响(Affected By):

        defmacro, setf of macro-function, macrolet, symbol-macrolet

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        *macroexpand-hook*, defmacro, setf of macro-function, macrolet, symbol-macrolet, 章节 3.1 (求值)

* 注意(Notes):

        无论是 macroexpand 还是 macroexpand-1 都没有做任何显式的尝试去展开那些是 form 的子表达式形式[subform]或 expansion 的子表达式形式[subform]的宏表达式[macro form]. 然而, 由于这个宏函数[macro function]的语义或实现, 这样的展开可能隐式发生. 

### <span id = "MacroDEFINESYMBOLMACRO">宏 DEFINE-SYMBOL-MACRO</span>

* 语法(Syntax):

        define-symbol-macro symbol expansion
        => symbol

* 参数和值(Arguments and Values):

        symbol---一个符号[symbol].
        expansion---一个表达式形式[form].

* 描述(Description):

        为全局地影响所表示符号 symbol 的宏展开[macro expansion]提供了一种机制.

        为由符号 symbol 命名的符号宏[symbol macro]全局地建立一个展开函数. 对于符号宏[symbol macro]来说, 展开函数[function]的唯一确保属性是当它被应用到表达式形式[form]和环境[environment]时它会返回正确的展开式. (具体来说, 这个展开在概念上是存储在展开函数, 环境[environment], 还是两者都存储了, 这是依赖于实现的[implementation-dependent].)

        每个对符号 symbol 的全局引用(换句话说, 没有被同一个符号所命名的变量[variable]或符号宏[symbol macro]的绑定[binding]所遮蔽[shadow[2]])都是通过常规的宏展开过程来展开的; 见章节 3.1.2.1.1 (符号表达式形式). 符号宏[symbol macro]的展开在与符号宏[symbol macro]引用所在相同的词法环境[lexical environment]中受到进一步的宏展开[macro expansion], 与普通宏[macro]类似.

        如果在这个定义的作用域内为符号 symbol 做一个 special 声明, 后果是未定义的 (换句话说, 当它没有被一个由相同符号[symbol]命名的变量[variable]或符号宏[symbol macro]的绑定[binding]所遮蔽[shadow[2]]时).

        任何在这个定义的作用域中使用 setq 来设置符号 symbol 的值都被当作 setf. 符号 symbol 的 psetq 被当作是 psetf, 并且 multiple-value-setq 被当作是 values 的 setf.

        一个符号宏[symbol macro]的绑定[binding]可以被 let 或 symbol-macrolet 所遮蔽[shadow[2]].

* 示例(Examples):

    ```LISP
    (defvar *things* (list 'alpha 'beta 'gamma)) =>  *THINGS*

    (define-symbol-macro thing1 (first *things*)) =>  THING1
    (define-symbol-macro thing2 (second *things*)) =>  THING2
    (define-symbol-macro thing3 (third *things*)) =>  THING3

    thing1 =>  ALPHA
    (setq thing1 'ONE) =>  ONE
    *things* =>  (ONE BETA GAMMA)
    (multiple-value-setq (thing2 thing3) (values 'two 'three)) =>  TWO
    thing3 =>  THREE
    *things* =>  (ONE TWO THREE)

    (list thing2 (let ((thing2 2)) thing2)) =>  (TWO 2)
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果符号 symbol 已经被定义为一个全局变量[global variable], 那么就会发出一个 program-error 类型[type]的错误.

* 参见(See Also):

        symbol-macrolet, macroexpand

* 注意(Notes): None. 

### <span id = "SpecialOperatorSYMBOLMACROLET">特殊操作符 SYMBOL-MACROLET</span>

* 语法(Syntax):

        symbol-macrolet ((symbol expansion)*) declaration* form*
        => result*

* 参数和值(Arguments and Values):

        symbol---一个符号[symbol].
        expansion---一个表达式形式[form].
        declaration---一个 declare 表达式[expressioni]; 不求值.
        forms---一个隐式 progn[implicit progn].
        results---那些表达式形式 forms 返回的那些值[value].

* 描述(Description):

        symbol-macrolet 为影响符号[symbol]的宏展开[macro expansion]环境提供一种机制.

        symbol-macrolet 为由那些符号中的每一个符号 symbol 命名的符号宏[symbol macro]词法上建立展开函数. 对于一个符号宏[symbol macro]来说, 展开函数[function]的唯一保证属性是当它被应用到表达式形式[form]和环境[environment]时它会返回正确的展开式. (具体来说, 它在概念上是存储在展开函数, 环境[environment], 还是两者都存储了, 这是依赖于具体实现的[implementation-dependent].)

        在 symbol-macrolet 词法作用域[scope]内, 作为一个变量的对 symbol 的每个引用都被常规的宏展开过程所展开; 见章节 3.1.2.1.1 (符号表达式形式). 一个符号宏的展开式在这个符号宏调用相同的词法环境中受到进一步的宏展开, 与普通宏[macro]类似.

        允许和 let 相同的那些声明 declarations, 除了一个例外: 如果一个 special 声明命名了要被 symbol-macrolet 定义的这些符号中的一个, 那么 symbol-macrolet 会发出一个错误.

        当 symbol-macrolet 表达式形式中的那些表达式形式 forms 被展开, 任何使用 setq 来设置这些指定变量的其中一个的值被当作是 setf 一样. 一个被定义为一个符号宏的符号的 psetq 被当作它是一个 psetf, 并且 multiple-value-setq 被当作是 values 的 setf.

        这个 symbol-macrolet 的使用可以被 let 遮蔽. 换句话说, symbol-macrolet 只是替代了包在那些表达式形式 forms 周围的符号 symbol 的词法绑定的作用域[scope]中的 symbol 的出现.

* 示例(Examples):

    ```LISP
    ;;; The following is equivalent to
    ;;;   (list 'foo (let ((x 'bar)) x)),
    ;;; not
    ;;;   (list 'foo (let (('foo 'bar)) 'foo))
    (symbol-macrolet ((x 'foo))
      (list x (let ((x 'bar)) x))) 
    =>  (foo bar)
    NOT=>  (foo foo) 
    
    (symbol-macrolet ((x '(foo x)))
      (list x))
    =>  ((FOO X))
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果试图绑定一个已经被定义为全局变量[global variable]的符号[symbol], 会发出一个 program-error 类型[type]的错误.

        如果声明 declaration 中包含一个对 symbol-macrolet 绑定那些符号[symbol]中的一个的 special 声明, 那么会发出一个 program-error 类型[type]的错误.

* 参见(See Also):

        with-slots, macroexpand

* 注意(Notes):

        这个特殊表达式形式 symbol-macrolet 是用于实现 with-slots 的基础机制.

        如果一个 symbol-macrolet 表达式形式[form]是一个顶层表达式形式[top level form], 那么这些表达式形式 forms 也被当作顶层表达式形式[top level form]处理. 见章节 3.2.3 (文件编译). 

### <span id = "VariableMACROEXPANDHOOK">变量 \*MACROEXPAND-HOOK\*</span>

* 值类型(Value Type):

        一个三参数[argument]的函数[function]的标识符[designator]: 一个宏函数[macro function], 一个宏表达式形式[macro form], 和一个环境[environment]对象[object].

* 初始值(Initial Value):

        一个等价于函数[function] funcall 的函数的标识符[designator], 但是可能有额外的依赖于具体实现的[implementation-dependent]副作用.

* 描述(Description):

        被 macroexpand-1 用作展开接口钩子来控制宏展开[macro expansion]过程. 当一个宏表达式形式[macro form]要被展开时, 这个函数[function]会被调用, 并传递三个参数: 这个宏函数[macro function], 宏表达式形式[macro form], 这个要被展开的宏表达式形式[macro form]所在的环境[environment]. 这个环境[environment]对象[object]具有动态范围[dynamic extent]; 如果环境[environment]对象[object]在宏展开函数的动态范围[dynamic extent]之外被引用, 则其后果是未定义的.

* 示例(Examples):

    ```LISP
    (defun hook (expander form env)
        (format t "Now expanding: ~S~%" form)
        (funcall expander form env)) =>  HOOK 
    (defmacro machook (x y) `(/ (+ ,x ,y) 2)) =>  MACHOOK 
    (macroexpand '(machook 1 2)) =>  (/ (+ 1 2) 2), true 
    (let ((*macroexpand-hook* #'hook)) (macroexpand '(machook 1 2)))
    >>  Now expanding (MACHOOK 1 2) 
    =>  (/ (+ 1 2) 2), true
    ```

* 受此影响(Affected By): None.

* 参见(See Also):

        macroexpand, macroexpand-1, funcall, 章节 3.1 (求值)

* 注意(Notes):

        选择初始值的净效果是仅调用宏函数[macro function], 将宏表达式形式[macro form]和环境[environment]作为它的两个参数.

        用户或用户程序可以给这个变量[variable]赋值[assign]来定制或跟踪宏展开[macro expansion]机制. 注意, 但是, 这个变量[variable]是一个全局资源, 可能由多个程序[program]共享; 因此, 如果两个程序依赖于它们在这个变量的设置上的正确性, 那么这些程序[program]可能无法在相同的 Lisp 镜像[Lisp image]中运行. 由于这个原因, 通常最好将其用途限制在调试情况下.

        把自己的函数设置到 *macroexpand-hook* 的用户应该考虑把这个钩子的之前的值保存起来, 并且从他们自己的函数里调用这个值.

### <span id = "FunctionPROCLAIM">函数 PROCLAIM</span>

* 语法(Syntax):

        proclaim declaration-specifier => implementation-dependent

* 参数和值(Arguments and Values):

        declaration-specifier---一个声明指定符[declaration specifier].

* 描述(Description):

        在全局环境[global environment]中建立[establish] declaration-specifier 指定的声明[declaration].

        这样一个声明, 有时也称之为全局声明[global declaration]或公告[proclamation], 除非被局部遮蔽[shadow], 否则总是有效的.

        在 declaration-specifier 中, 变量[variable]和函数[function]的名称[name]分别引用动态变量[dynamic variable]和全局函数[function]定义.

        下一个图显示了可用于 proclaim 的声明标识符[declaration identifier]列表.

            declaration  inline     optimize  type  
            ftype        notinline  special         

            Figure 3-22. 全局声明标识符

        一个具体实现也可以自由地支持其他(具体实现定义的[implementation-defined])声明标识符[declaration identifier].

* 示例(Examples):

    ```LISP
    (defun declare-variable-types-globally (type vars)
      (proclaim `(type ,type ,@vars))
      type)

    ;; Once this form is executed, the dynamic variable *TOLERANCE*
    ;; must always contain a float.
    (declare-variable-types-globally 'float '(*tolerance*))
    =>  FLOAT
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        declaim, declare, 章节 3.2 (编译)

* 注意(Notes):

    虽然 proclaim 表达式形式[form]的执行有着可能影响编译的效果, 但是编译器不会尝试识别和特别地处理 proclaim 表达式形式[form]. 像下面这样的公告[proclamation], 即便是一个顶层表达式形式[top level form], 直到它被执行之前不会有任何效果:

    ```LISP
    (proclaim '(special *x*))
    ```

    如果需要编译时的副作用, eval-when 可能会有用. 比如:

    ```LISP
    (eval-when (:execute :compile-toplevel :load-toplevel)
      (proclaim '(special *x*)))
    ```

    然而, 在大多数这样的情况下, 使用 declaim 来实现这一目的更好.

    因为 proclaim 表达式形式[form]是普通的函数形式[function form], 所以宏表达式形式[macro form]可以展开到它们. 

### <span id = "MacroDECLAIM">宏 DECLAIM</span>

* 语法(Syntax):

        declaim declaration-specifier* => implementation-dependent

* 参数和值(Arguments and Values):

        declaration-specifier---一个声明指定符[declaration specifier]; 不求值.

* 描述(Description):

        建立一个由 declaration-specifiers 指定的声明[declaration].

        如果这个宏的使用以顶层表达式形式[top level form]出现在文件编译器[file compiler]处理的文件[file]中, 这些公告[proclamations]也在编译时进行. 与其他定义宏一样, 在编译完文件后, 编译时的副作用是否存在仍然是未知的.

* 示例(Examples):

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        declare, proclaim

* 注意(Notes): None. 

### <span id = "SymbolDECLARE">符号 DECLARE</span>

* 语法(Syntax):

        declare declaration-specifier*

* 参数(Arguments):

        declaration-specifier---一个声明指定符[declaration specifier]; 不求值.

* 描述(Description):

        一个 declare 表达式[expression], 有时也称之为一个声明[declaration], 只能出现在某些表达式形式[form]的主体部分的开头; 那也就是说, 它的前面只可能是其他 declare 表达式[expression], 或者如果上下文允许前面还可能有文档字符串[documentation string].

        一个 declare 表达式可以出现在一个 lambda 表达式[lambda expression]中或者下面这段列出的任何表达式形式[form]中.

            defgeneric                 do-external-symbols   prog                      
            define-compiler-macro      do-symbols            prog*                     
            define-method-combination  dolist                restart-case              
            define-setf-expander       dotimes               symbol-macrolet           
            defmacro                   flet                  with-accessors            
            defmethod                  handler-case          with-hash-table-iterator  
            defsetf                    labels                with-input-from-string    
            deftype                    let                   with-open-file            
            defun                      let*                  with-open-stream          
            destructuring-bind         locally               with-output-to-string     
            do                         macrolet              with-package-iterator     
            do*                        multiple-value-bind   with-slots                
            do-all-symbols             pprint-logical-block                            

        Figure 3-23. 声明可以出现的标准表达式形式

        一个 declare 表达式[expression]只能出现在这些表达式形式[form]的语法所指定的位置. 尝试去求值一个 declare 表达式[expression]的后果是未定义的. 在这些表达式[expression]出现的情况下, 会为它们的存在进行显式检查, 并且它们从来没有真正被求值过; 正是因为这个原因它们被称之为 "declare 表达式[expression]" 而不是 "declare 表达式形式[form]".

        macro 表达式形式[macro form]不能被展开成声明; declare 表达式[expression]必须作为它们所引用的表达式形式[form]的实际的子表达式[subexpression]出现.

        下一段展示了可以被用于 declare 的声明标识符[declaration identifier]的列表.

            dynamic-extent  ignore     optimize  
            ftype           inline     special   
            ignorable       notinline  type      

            Figure 3-24. 局部声明标识符

        一个具体实现也可以自由地支持其他(具体实现定义的[implementation-defined])声明标识符[declaration identifier].

* 示例(Examples):

    ```LISP
    (defun nonsense (k x z)
      (foo z x)                     ;First call to foo
      (let ((j (foo k x))           ;Second call to foo
            (x (* k k)))
        (declare (inline foo) (special x z))
        (foo x j z)))               ;Third call to foo
    ```

        在这个例子里, 这个 inline 声明只应用于第三个 foo 调用, 不是第一个和第二个.这个 x 的 special 声明导致 let 为 x 创建了一个动态绑定[binding], 并且导致 let 主体中对 x 的引用是一个动态引用. 在对 foo 的第二个调用中的 x 的引用是一个对 nonsense 第二个参数的局部引用. 在第一个 foo 调用中对 x 的引用也是一个局部引用, 不是一个 special 的. 这个 z 的 special 声明导致第三个 foo 调用中的 z 引用是一个动态引用; 它不引用 nonsense 中名为 z 的参数, 因为这个参数绑定[binding]没有被声明为 special. (这个 z 的 special 声明不是出现在 defun 的主体部分, 而是在一个内部的表达式形式[form]中, 因此不影响形参[parameter]的绑定[binding].)

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        试着把 declare 表达式[expression]当作一个表达式形式[form]来求值后果是不可预料的.

* 参见(See Also):

        proclaim, 章节 4.2.3 (类型指定符), declaration, dynamic-extent, ftype, ignorable, ignore, inline, notinline, optimize, type

* 注意(Notes): None. 

### <span id = "DeclarationIGNOREIGNORABLE">声明 IGNORE, IGNORABLE</span>

* 语法(Syntax):

        (ignore {var | (function fn)}*)

        (ignorable {var | (function fn)}*)

* 参数(Arguments):

        var---一个变量[variable]名字[name].
        fn---一个函数[function]名字[name].

* 合法上下文(Valid Context):

        声明[declaration]

* 绑定类型的影响(Binding Types Affected):

        变量[variable], 函数[function]

* 描述(Description):

        这个 ignore 和 ignorable 声明指向多个 var 的变量[variable]绑定[binding]还有多个 fns 的函数[function]绑定[binding]的值[for-value]引用[reference].

        一个 ignore 声明[declaration]指出对那些表示的绑定[binding]的值[for-value]引用[reference]不会发生在这个声明[declaration]的作用域里. 在这样一个声明[declaration]的作用域[scope]里, 编译器针对任何 var 或 fn 的值[for-value]引用[reference], 或者一个任意 var 的 special 声明[declaration]的出现去发出一个警告是可取的.

        一个 ignorable 声明[declaration]指出对那些表示的绑定[binding]的值[for-value]引用[reference]可能或可能不会出现在这个声明[declaration]的作用域里. 在这样一个声明[declaration]的作用域[scope]里, 编译器针对任何 var 或 fn 的值[for-value]引用[reference], 或者一个任意 var 的 special 声明[declaration]的出现或缺失去发出一个警告是可取的.

        当不在一个 ignore 或 ignorable 声明[declaration]的作用域[scope]时, 对于任何既没有值[for-value]引用[reference]也没有 special 声明[declaration]的 var, 或者没有值[for-value]引用[reference]的 fn, 编译器去发出一个警告是可取的.

        任何关于一个 "used" 或者 "unused" 绑定[binding]的警告必须是 style-warning 类型[type]的, 并且不影响程序的语义.

        由 with-open-file, with-open-stream, with-input-from-string, 和 with-output-to-string 建立的流变量[stream variable], 还有所有循环变量[iteration variable], 根据定义总是是 "used" 的. 对于这样一个变量[variable] v 使用 (declare (ignore v)), 有着未指明的结果.

* 参见(See Also):

        declare 

### <span id = "DeclarationDYNAMICEXTENT">声明 DYNAMIC-EXTENT</span>

* 语法(Syntax):

        (dynamic-extent [[var* | (function fn)*]])

* 参数(Arguments):

        var---一个变量[variable]名字[name].
        fn---一个函数[variable]名字[name].

* 合法上下文(Valid Context):

        声明[declaration]

* 绑定类型的影响(Binding Types Affected):

        变量[variable], 函数[function]

* 描述(Description):

        在某个包含的表达式形式 F 中, 这个声明为每一个 vari 断言 (不需要被 F 绑定), 并且为 vari 呈现的每一个值[value] vij 断言, 还有当 vij 成为 vari 的值的任何时候为 vij 的其他不可访问部分[otherwise inaccessible part]的对象[object] xijk 断言, 在 F 的执行终止后, xijk 要么是不可访问的(如果 F 为 vari 建立一个绑定[binding]), 要么是 vari 的当前值的一个其他不可访问部分[otherwise inaccessible part] (如果 F 没有为 vari 建立一个绑定[binding]). 每个 fni 都有相同的关系, 除了这些在函数[function]命名空间[namespace]中的绑定. 

        允许编译器以任何适合于具体实现[implementation]并且不与 Common Lisp 的语义冲突的方式使用该信息.

        dynamic-extent 声明可以是自由声明[free declaration]或绑定声明[bound declaration].

        在 dynamic-extent 声明中命名的这些 vars 和 fns 一定不能引用符号宏[symbol macro]或宏[macro]绑定.

* 示例(Examples):

        由于初始值的栈上分配需要在对象[object]的创建时知道对象[object]可以是栈上分配的[stack-allocated], 对于没有词法上显而易见的初始值的变量[variable], 对变量进行 dynamic-extent 声明[declaration]通常是不太有用的. 比如, 这可能是很有用的:

    ```LISP
    (defun f ()
      (let ((x (list 1 2 3)))
        (declare (dynamic-extent x))
            ...))
    ```

        这将允许那些希望这样做的编译器来栈上分配[stack allocate]由局部变量 x 所持有的列表. 写成下面这样是允许的, 但在实践中可能没有那么有用:

    ```LISP
    (defun g (x) (declare (dynamic-extent x)) ...)
    (defun f () (g (list 1 2 3)))
    ```

        大部分编译器不会在 f 中去栈上分配[stack allocate]给 g 的实参[argument], 因为对于编译器来说, 从 f 中假设关于 g 的事实是违背模块化的. 只有当 g 的定义不兼容地改变时, 愿意重编译 f 的一个具体实现可以合理地栈上分配[stack allocate]这个在 f 中给 g 的列表[list]参数.

        这里有另一个例子:

    ```LISP
    (declaim (inline g))
    (defun g (x) (declare (dynamic-extent x)) ...)
    (defun f () (g (list 1 2 3)))
    
    (defun f ()
      (flet ((g (x) (declare (dynamic-extent x)) ...))
        (g (list 1 2 3))))
    ```

        在上面的例子里, 一些编译器可能会确定优化是可以的, 而另一些可能不会.

        这个的一个变体是 "栈上分配剩余列表(stack allocated rest list)", 可以通过下面来实现 (在支持这个优化的实现中):

    ```LISP
    (defun f (&rest x)
      (declare (dynamic-extent x))
      ...)
    ```

        注意, 虽然 x 的初始值不明确, 但是 f 函数负责将列表 x 从传递的参数中装配起来, 因此在支持这些的实现中可以通过编译器对 f 函数进行优化, 以构建一个栈上分配[stack-allocated]的列表, 而不是使用堆上分配的列表.

        在下面的示例中,

    ```LISP
    (let ((x (list 'a1 'b1 'c1))
          (y (cons 'a2 (cons 'b2 (cons 'c2 nil)))))
      (declare (dynamic-extent x y))
      ...)
    ```

        这个 x 的其他不可访问部分[otherwise inaccessible part]是三个 cons, 而 y 的其他不可访问部分[otherwise inaccessible part]是另外三个 cons. 符号 a1, b1, c1, a2, b2, c2, 或者 nil 中没有是 x 或 y 的其他不可访问部分[otherwise inaccessible part], 因为每一个都被捕捉[interned]因此可以通过它被捕捉[interned]到的包[package] (或者多个包[package])是可访问的[accessible]. 然而, 如果使用了一个新分配的未捕捉[uninterned]的符号[symbol], 那么它将是包含它的列表[list]的其他不可访问部分[otherwise inaccessible part].

    ```LISP
    ;; In this example, the implementation is permitted to stack allocate
    ;; the list that is bound to X.
    (let ((x (list 1 2 3)))
      (declare (dynamic-extent x))
      (print x)
      :done)
    >>  (1 2 3)
    =>  :DONE
    
    ;; In this example, the list to be bound to L can be stack-allocated.
    (defun zap (x y z)
      (do ((l (list x y z) (cdr l)))
          ((null l))
        (declare (dynamic-extent l))
        (prin1 (car l)))) =>  ZAP
    (zap 1 2 3)
    >>  123
    =>  NIL

    ;; Some implementations might open-code LIST-ALL-PACKAGES in a way
    ;; that permits using stack allocation of the list to be bound to L.
    (do ((l (list-all-packages) (cdr l)))
        ((null l))
      (declare (dynamic-extent l))
      (let ((name (package-name (car l))))
        (when (string-search "COMMON-LISP" name) (print name))))
    >>  "COMMON-LISP"
    >>  "COMMON-LISP-USER"
    =>  NIL

    ;; Some implementations might have the ability to stack allocate 
    ;; rest lists.  A declaration such as the following should be a cue
    ;; to such implementations that stack-allocation of the rest list
    ;; would be desirable.
    (defun add (&rest x)
      (declare (dynamic-extent x))
      (apply #'+ x)) =>  ADD
    (add 1 2 3) =>  6

    (defun zap (n m)
      ;; Computes (RANDOM (+ M 1)) at relative speed of roughly O(N).
      ;; It may be slow, but with a good compiler at least it
      ;; doesn't waste much heap storage.  :-}
      (let ((a (make-array n)))
        (declare (dynamic-extent a))
        (dotimes (i n) 
          (declare (dynamic-extent i))
          (setf (aref a i) (random (+ i 1))))
        (aref a m))) =>  ZAP
    (< (zap 5 3) 3) =>  true
    ```

        下面的是错误的, 因为 x 的值在它的范围[extent]外被使用:

    ```LISP
    (length (list (let ((x (list 1 2 3)))  ; Invalid
                    (declare (dynamic-extent x))
                    x)))

    (progn (let ((x (list 1 2 3)))  ; Invalid
              (declare (dynamic-extent x))
              x)
            nil)
    ```

* 参见(See Also):

        declare

* 注意(Notes):

        最常见的优化是对由 vars 命名的那些对象[object]的初始值进行栈上分配[stack allocate].

        一个实现允许完全可以忽略这个声明. 

### <span id = "DeclarationTYPE">声明 TYPE</span>

* 语法(Syntax):

        (type typespec var*)

        (typespec var*)

* 参数(Arguments):

        typespec---一个类型指定符[type specifier].
        var---一个变量[variable]名字[name].

* 合法上下文(Valid Context):

        声明[declaration]或者公告[proclamation]

* 绑定类型的影响(Binding Types Affected):

        变量[variable]

* 描述(Description):

        只影响变量绑定[binding], 并指出那些变量 vars 只具有指定的类型指定符 typespec 的值. 具体来说, 通过 setq 给变量赋的值, 以及那些变量 vars 的初始值必须是指定的类型指定符 typespec. type 声明从来不应用于函数绑定[binding] (见 ftype).

        一个由 symbol-macrolet 定义的符号[symbol]的类型声明等价于在该符号的展开式周围包一个 the 表达式, 尽管这个符号[symbol]的宏展开[macro expansion]实际上并没有受到影响.

        一个类型声明的意义等价于修改声明作用域里的每一个变量 (var) 的引用为 (the typespec var), 修改声明作用域里的每一个赋值给变量 (new-value) 的表达式为 (the typespec new-value), 以及在进入声明作用域的时候执行 (the typespec var).

        一个类型[type]声明在所有声明中都是合法的. 对类型声明的解释如下:

        1. 在这个声明的作用域内对这个声明变量的任何引用执行期间, 如果声明的变量的值不是声明的类型[type], 后果是未定义的.
        2. 在这个声明的作用域内对这个声明变量的任何 setq 的执行期间, 如果被赋给声明变量的新值不属于声明的类型[type], 那么后果将是未定义的.
        3. 当进入声明的作用域时, 如果声明的变量的值不是声明的类型[type], 那么后果将是未定义的.

        一个类型[type]声明只影响它的作用域内的变量引用.

        如果嵌套类型[type]声明引用相同的变量, 那么该变量的值必须是那些声明类型[type]的交集的成员.

        如果对于一个动态变量这里有一个局部 type 声明, 并且对于相同的变量这里也有一个全局的类型[type]公告, 那么在这个局部声明的作用域中的那个变量的值必须是两种声明类型[type]的交集.

        type 声明可以是自由声明[free declaration]或绑定声明[bound declaration].

        一个符号[symbol]既不能是类型[type]的名称, 也不能是声明的名称. 一个符号[symbol]已经被声明为一个声明的名字时, 定义这个符号[symbol]为类[class], 结构体[structure], 状况[condition], 或类型[type]的名字[name]时, 如果这个符号已经被声明为一个声明的名字, 或反过来, 都会发出一个错误.

        在一个 array 类型声明的词法作用域[lexical scope]中, 所有对数组[array]元素[element]的引用都被假定为满足表达数组元素类型[expressed array element type] (与提升数组元素类型[upgraded array element type]相反). 编译器可以认为在 array 类型声明的范围内的代码就好像数组[array]元素[element]的每个访问[access]都被合适的 the 表达式形式包围一样.

* 示例(Examples):

    ```LISP
    (defun f (x y)
      (declare (type fixnum x y))
      (let ((z (+ x y)))
        (declare (type fixnum z))
        z)) =>  F
    (f 1 2) =>  3
    ;; The previous definition of F is equivalent to
    (defun f (x y)
      ;; This declaration is a shorthand form of the TYPE declaration
      (declare (fixnum x y))
      ;; To declare the type of a return value, it's not necessary to
      ;; create a named variable.  A THE special form can be used instead.
      (the fixnum (+ x y))) =>  F
    (f 1 2) =>  3

    (defvar *one-array* (make-array 10 :element-type '(signed-byte 5)))
    (defvar *another-array* (make-array 10 :element-type '(signed-byte 8)))
      
    (defun frob (an-array)
      (declare (type (array (signed-byte 5) 1) an-array))
      (setf (aref an-array 1) 31)
      (setf (aref an-array 2) 127)
      (setf (aref an-array 3) (* 2 (aref an-array 3)))
      (let ((foo 0))
        (declare (type (signed-byte 5) foo))
        (setf foo (aref an-array 0))))
      
    (frob *one-array*)
    (frob *another-array*)
    ```

        上面的 frob 定义等价于:

    ```LISP
    (defun frob (an-array)
      (setf (the (signed-byte 5) (aref an-array 1)) 31)
      (setf (the (signed-byte 5) (aref an-array 2)) 127)
      (setf (the (signed-byte 5) (aref an-array 3))
            (* 2 (the (signed-byte 5) (aref an-array 3))))
      (let ((foo 0))
        (declare (type (signed-byte 5) foo))
        (setf foo (the (signed-byte 5) (aref an-array 0)))))
    ```

        给定一个实现,其中 fixnums 是29位, 但是 fixnum 数组[array]被升级到有符号的32位数组[array], 下面可以用所有的 fixnum 运算来编译:

    ```LISP
    (defun bump-counters (counters)
      (declare (type (array fixnum *) bump-counters))
      (dotimes (i (length counters))
        (incf (aref counters i))))
    ```

* 参见(See Also):

        declare, declaim, proclaim

* 注意(Notes):

        (typespec var*) 是 (type typespec var*) 的一个缩写.

        对于一个函数的参数的 type 声明并不一定意味着结果的类型. 下面的函数不允许使用依赖于具体实现的[implementation-dependent] 仅限 fixnum 的算法来编译:

    ```LISP
    (defun f (x y) (declare (fixnum x y)) (+ x y))
    ```

        为说明原因, 细想 (f most-positive-fixnum 1). Common Lisp 定义这个 F 必须返回一个 bignum, 而不是发出一个错误或产生一个数学上不正确的结果. 如果你有特殊的知识, "fixnum overflow" 情况就不会出现, 您可以在 fixnum 范围内声明结果值, 使一些编译器可以使用更有效的算法:

    ```LISP
    (defun f (x y)
      (declare (fixnum x y))
      (the fixnum (+ x y)))
    ```

        但是, 请注意, 在三个参数的情况下, 由于隐式中间值增长太大的可能性, 下面的内容不会导致使用依赖于具体实现的[implementation-dependent]仅限 fixnum 的算法:

    ```LISP
    (defun f (x y)
      (declare (fixnum x y z))
      (the fixnum (+ x y z)))
    ```

        为说明原因, 细想 (f most-positive-fixnum 1 -1). 尽管参数和结果都是 fixnums, 但一个中间值不是 fixnum. 如果在提供它的实现中选择依赖于具体实现的[implementation-dependent]仅限 fixnum 的算法是很重要的, 那么考虑编写这样的代码:

    ```LISP
    (defun f (x y)
      (declare (fixnum x y z))
      (the fixnum (+ (the fixnum (+ x y)) z)))
    ```

### <span id = "DeclarationINLINENOTINLINE">声明 INLINE, NOTINLINE</span>

* 语法(Syntax):

        (inline function-name*)

        (notinline function-name*)

* 参数(Arguments):

        function-name---一个函数名字[function name].

* 合法上下文(Valid Context):

        声明[declaration]或公告[proclamation]

* 绑定类型的影响(Binding Types Affected):

        函数[function]

* 描述(Description):

        inline 指出期望编译器去为 function-name 命名的函数产生内联调用; 这就是说, 指定的函数名  function-name  的代码应该集成到调用例程中, 内联出现并替换程序调用. 一个编译器可以自由地忽略这个声明. inline 声明从不应用于变量绑定[binding].

        如果其中一个提及的函数有着词法上明显的局部定义 (例如通过 flet 或 labels), 那么这个声明应用于这个局部定义而不是那个全局函数定义.

        虽然没有符合规范的实现[conforming implementation]被要求去执行用户定义函数的内联展开, 但那些具体实现[implementation]尝试去识别以下范例:

        为了定义一个默认不是 inline 的函数[function] f, 但是 (declare (inline f)) 会使 f 成为局部内联的, 合适的定义顺序是:

    ```LISP
    (declaim (inline f))
    (defun f ...)
    (declaim (notinline f))
    ```

        在 defun 表达式形式[form]前面的这个 inline 公告确保编译器[compiler]有机会保存内联展开所必需的信息, 并且跟在 defun 表达式形式[form]后面的这个 notinline 公告防止 f 在任何地方被内联展开.

        notinline 指出这个由 function-name 命名的函数不需要被内联编译. 一个编译器可以自由地忽略这个声明; 对这个指定的函数的调用必须被实现为非内联子程序调用.

        如果其中一个提及的函数有着词法上明显的局部定义 (例如通过 flet 或 labels), 那么这个声明应用于这个局部定义而不是那个全局函数定义.

        在 function-name 的编译器宏[compiler macro]定义存在的情况下, 一个 notinline 声明阻止了编译器宏[compiler macro]的使用. 可以使用 inline 声明来鼓励使用编译器宏[compiler macro]定义. inline 和 notinline 声明在 function-name 的词法可见定义是一个宏[macro]定义时是没有效果的.

        inline 和 notinline 声明可以是自由声明[free declaration]或绑定声明[bound declaration]. 出现在一个 flet 或 labels 表达式形式[form]的主体前的 inline 和 notinline 函数声明是绑定声明[bound declaration]. 在其他上下文中的这些声明是自由声明[free declaration].

* 示例(Examples):

    ```LISP
    ;; The globally defined function DISPATCH should be open-coded,
    ;; if the implementation supports inlining, unless a NOTINLINE 
    ;; declaration overrides this effect.
    (declaim (inline dispatch))
    (defun dispatch (x) (funcall (get (car x) 'dispatch) x))
    ;; Here is an example where inlining would be encouraged.
    (defun top-level-1 () (dispatch (read-command)))
    ;; Here is an example where inlining would be prohibited.
    (defun top-level-2 ()
      (declare (notinline dispatch))
      (dispatch (read-command)))
    ;; Here is an example where inlining would be prohibited.
    (declaim (notinline dispatch))
    (defun top-level-3 () (dispatch (read-command)))
    ;; Here is an example where inlining would be encouraged.
    (defun top-level-4 () 
      (declare (inline dispatch))
      (dispatch (read-command)))
    ```

* 参见(See Also):

        declare, declaim, proclaim 

### <span id = "DeclarationFTYPE">声明 FTYPE</span>

* 语法(Syntax):

        (ftype type function-name*)

* 参数(Arguments):

        function-name---一个函数名字[function name].
        type---一个类型指定符[type specifier].

* 合法上下文(Valid Context):

        声明[declaration]或公告[proclamation]

* 绑定类型的影响(Binding Types Affected):

        函数[function]

* 描述(Description):

        指出由那些函数名 function-names 命名的函数是 type 函数类型. 比如:

    ```LISP
    (declare (ftype (function (integer list) t) ith)
            (ftype (function (number) float) sine cosine))
    ```

        如果其中一个提及的函数有着词法上明显的局部定义 (例如通过 flet 或 labels), 那么这个声明应用于这个局部定义而不是那个全局函数定义. ftype 声明从不应用于变量绑定[binding] (见 type).

        这个 function-names 的词法上明显绑定不能是宏[macro]定义. (这是因为 ftype 声明每个函数名[function name]的函数定义是一个 function 的特定子类型, 而宏[macro]不表示函数[function].)

        ftype 声明可以是自由声明[free declaration]或绑定声明[bound declaration]. 出现在一个 flet 或 labels 表达式形式[form]的主体前的 ftype 函数声明是绑定声明[bound declaration]. 在其他上下文中的这些声明是自由声明[free declaration].

* 参见(See Also):

        declare, declaim, proclaim 

### <span id = "DeclarationDECLARATION">声明 DECLARATION</span>

* 语法(Syntax):

        (declaration name*)

* 参数(Arguments):

        name---一个符号[symbol].

* 绑定类型的影响(Binding Types Affected): None.

* 合法上下文(Valid Context):

        仅限公告[proclamation]

* 描述(Description):

        建议编译器, 每个名字 name 都是有效的, 但可能是非标准的声明名. 这样做的目的是告诉一个编译器不要发出用于另一个编译器或其他程序处理器的声明的警告.

* 示例(Examples):

    ```LISP
    (declaim (declaration author target-language target-machine))
    (declaim (target-language ada))
    (declaim (target-machine IBM-650))
    (defun strangep (x)
      (declare (author "Harry Tweeker"))
      (member x '(strange weird odd peculiar)))
    ```

* 参见(See Also):

        declaim, proclaim 

### <span id = "DeclarationOPTIMIZE">声明 OPTIMIZE</span>

* 语法(Syntax):

        (optimize {quality | (quality value)}*)

* 参数(Arguments):

        quality---一个优化质量[optimize quality].
        value--- 0, 1, 2, 或 3 这些整数[integer]的其中之一.

* 合法上下文(Valid Context):

        声明[declaration]或公告[proclamation]

* 绑定类型的影响(Binding Types Affected): None.

* 描述(Description):

        建议编译器应该根据指定的相应值 value 注意每个质量 quality. 每一个质量 quality 都必须是一种名为优化质量[optimize quality]的符号[symbol]; 标准优化质量[optimize quality]的名称和含义在下一段中展示.

            名称                意义
            compilation-speed  编译处理的速度
            debug              易于调试
            safety             运行时(run-time)错误检查
            space              代码大小和运行时(run-time)空间
            speed              对象代码的速度           

            Figure 3-25. 优化质量

        这里可能有其他的, 具体实现定义的[implementation-defined]优化质量[optimize quality].

        一个 0 的值 value 意味着对应的质量 quality 是完全不重要的, 而这个 3 表示极其重要的; 1 和 2 是中间的值, 这里 1 是中立的值. (quality 3) 可以缩写成 quality.

        注意有着优化 (safety 3), 或者只是 safety 的代码[code], 称为安全代码[safe code].

        如果质量 quality 以出现不止一种并且不同的[different]值, 那么后果是不可预料的.

* 示例(Examples):

    ```LISP
    (defun often-used-subroutine (x y)
      (declare (optimize (safety 2)))
      (error-check x y)
      (hairy-setup x)
      (do ((i 0 (+ i 1))
            (z x (cdr z)))
          ((null z))
        ;; This inner loop really needs to burn.
        (declare (optimize speed))
        (declare (fixnum i))
        ))
    ```

* 参见(See Also):

        declare, declaim, proclaim, 章节 3.3.4 (声明的作用域)

* 注意(Notes):

        一个 optimize 声明从不适用于一个变量[variable]或一个函数[function]绑定[binding]. 一个 optimize 声明只能是自由声明[free declaration]. 关于更多信息, 见章节 3.3.4 (声明的作用域). 

### <span id = "DeclarationSPECIAL">声明 SPECIAL</span>

* 语法(Syntax):

        (special var*)

* 参数(Arguments):

        var---一个符号[symbol].

* 合法上下文(Valid Context):

        声明[declaration]或公告[proclamation]

* 绑定类型的影响(Binding Types Affected):

        变量[variable]

* 描述(Description):

        指定所有 var 命名的都是动态的. 这个指定符影响变量绑定[binding]和引用. 所有受影响的变量绑定[binding]都成为动态绑定[binding], 并且影响指向当前的动态绑定的变量引用. 比如:

    ```LISP
    (defun hack (thing *mod*)    ;The binding of the parameter
      (declare (special *mod*))  ; *mod* is visible to hack1,
      (hack1 (car thing)))       ; but not that of thing.
    (defun hack1 (arg)
      (declare (special *mod*))  ;Declare references to *mod*
                                  ;within hack1 to be special.
      (if (atom arg) *mod*
          (cons (hack1 (car arg)) (hack1 (cdr arg)))))
    ```

        一个 special 声明不影响一个变量 var 的内部绑定; 内部绑定[binding]隐式地遮蔽一个 special 声明, 并且必须显式地重新声明为 special. special 声明从不应用于函数绑定[binding].

        special 声明可以是同时影响绑定和引用的绑定声明[bound declaration], 或只影响引用的自由声明[free declaration], 取决于声明是否被关联到一个变量绑定.

        当使用一个公告[proclamation]时, 一个 special 声明指定符[declaration specifier]应用于所有的绑定[binding]以及所有提到的变量的引用. 比如, 在

        (declaim (special x))

        后面有一个这样的函数定义

        (defun example (x) ...)

        这个参数 x 被绑定为一个动态变量而不是一个词法变量.

* 示例(Examples):

    ```LISP
    (defun declare-eg (y)                 ;this y is special
      (declare (special y))
      (let ((y t))                         ;this y is lexical
            (list y
                  (locally (declare (special y)) y)))) ;this y refers to the
                                                      ;special binding of y
    =>  DECLARE-EG 
    (declare-eg nil) =>  (T NIL) 

    (setf (symbol-value 'x) 6)
    (defun foo (x)                         ;a lexical binding of x
      (print x)
      (let ((x (1+ x)))                    ;a special binding of x
        (declare (special x))              ;and a lexical reference
        (bar))
      (1+ x))
    (defun bar () 
      (print (locally (declare (special x))
              x)))
    (foo 10) 
    >>  10
    >>  11
    =>  11

    (setf (symbol-value 'x) 6)
    (defun bar (x y)            ;[1] 1st occurrence of x
      (let ((old-x x)           ;[2] 2nd occurrence of x -- same as 1st occurrence
            (x y))              ;[3] 3rd occurrence of x
        (declare (special x))
        (list old-x x)))
    (bar 'first 'second) =>  (FIRST SECOND)

    (defun few (x &optional (y *foo*))
      (declare (special *foo*))
      ...)
    ```

        这个例子第一行对 *foo* 的引用不是 special 即便在第二行有一个 special 声明.

    ```LISP
    (declaim (special prosp)) =>  implementation-dependent
    (setq prosp 1 reg 1) =>  1
    (let ((prosp 2) (reg 2))         ;the binding of prosp is special
        (set 'prosp 3) (set 'reg 3)   ;due to the preceding proclamation,
        (list prosp reg))             ;whereas the variable reg is lexical
    =>  (3 2)
    (list prosp reg) =>  (1 3)

    (declaim (special x))          ;x is always special.
    (defun example (x y)                                 
      (declare (special y))
      (let ((y 3) (x (* x 2)))
        (print (+ y (locally (declare (special y)) y)))
        (let ((y 4)) (declare (special y)) (foo x)))) =>  EXAMPLE
    ```

        在上面的扭曲代码中, 最外层和最内层的 y 的绑定[binding]是动态的, 但是中间绑定是词法的. 给 + 的两个参数是不一样的, 一个是一个值, 3, 是词法变量 y 的, 而另一个是名为 y 的动态变量的值 (巧合的是, 它的一个绑定在词法上围绕在它外层). 然而, 由于这个 x 总是是 special 的公告, 所有 x 的绑定和 x 的引用都是动态的.

* 参见(See Also):

        defparameter, defvar 

### <span id = "SpecialOperatorLOCALLY">特殊操作符 LOCALLY</span>

* 语法(Syntax):

        locally declaration* form* => result*

* 参数和值(Arguments and Values):

        Declaration---一个 declare 表达式[expression]; 不求值.
        forms---一个隐式的 progn[implicit progn].
        results---这些表达式形式[form]的值[value].

* 描述(Description):

        在这些给定声明 declarations 有效的一个词法环境[lexical environment]中, 依次对这些表达式形式  form 主体进行求值.

* 示例(Examples):

    ```LISP
    (defun sample-function (y)  ;this y is regarded as special
      (declare (special y))                                
      (let ((y t))              ;this y is regarded as lexical
        (list y
              (locally (declare (special y))
                ;; this next y is regarded as special
                y))))
    =>  SAMPLE-FUNCTION
    (sample-function nil) =>  (T NIL) 
    (setq x '(1 2 3) y '(4 . 5)) =>  (4 . 5)

    ;;; The following declarations are not notably useful in specific.
    ;;; They just offer a sample of valid declaration syntax using LOCALLY.
    (locally (declare (inline floor) (notinline car cdr))
              (declare (optimize space))
        (floor (car x) (cdr y))) =>  0, 1

    ;;; This example shows a definition of a function that has a particular set
    ;;; of OPTIMIZE settings made locally to that definition.
    (locally (declare (optimize (safety 3) (space 3) (speed 0)))
      (defun frob (w x y &optional (z (foo x y)))
        (mumble x y z w)))
    =>  FROB

    ;;; This is like the previous example, except that the optimize settings
    ;;; remain in effect for subsequent definitions in the same compilation unit.
    (declaim (optimize (safety 3) (space 3) (speed 0)))
    (defun frob (w x y &optional (z (foo x y)))
      (mumble x y z w))
    =>  FROB
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        declare

* 注意(Notes):

        locally 可以和 special 声明一起使用来影响变量[variable]的引用, 而不是绑定[binding].

        如果一个 locally 表达式形式[form]是一个顶层表达式形式[top level form], 这个主体表达式形式[form]也被当作顶层表达式形式[top level form]处理. 见章节 3.2.3 (文件编译). 

### <span id = "SpecialOperatorTHE">特殊操作符 THE</span>

* 语法(Syntax):

        the value-type form => result*

* 参数和值(Arguments and Values):

        value-type---一个类型指定符[type specifier]; 不求值.
        form---一个表达式形式[form]; 求值.
        results---从表达式形式 form 的求值[evaluation]得出的值[value]. 这些值[value]必须符合 value-type 所提供的类型[type]; 见下文.

* 描述(Description):

        the 指出了表达式形式 form 返回的值[values[1a]]是 value-type 表示的类型[type]. 如果任意结果 result 不是声明的类型, 后果是未定义的.

        假设 type 声明的那些值[value]确实是那些类型[type], 允许表达式形式 form 产生[yield]不同于 value-type 指定的数量的值. 出于检查它们的类型[type]的目的, 缺少的值被当作 nil.

        不考虑 value-type 声明的值[value]的数量, 这个 the 特殊表达式形式[special form]返回到值[value]的数量和表达式形式 form 返回的值[value]的数量一样.

* 示例(Examples):

    ```LISP
    (the symbol (car (list (gensym)))) =>  #:G9876
    (the fixnum (+ 5 7)) =>  12
    (the (values) (truncate 3.2 2)) =>  1, 1.2
    (the integer (truncate 3.2 2)) =>  1, 1.2
    (the (values integer) (truncate 3.2 2)) =>  1, 1.2
    (the (values integer float) (truncate 3.2 2))   =>  1, 1.2
    (the (values integer float symbol) (truncate 3.2 2)) =>  1, 1.2
    (the (values integer float symbol t null list) 
          (truncate 3.2 2)) =>  1, 1.2
    (let ((i 100))
        (declare (fixnum i))
        (the fixnum (1+ i))) =>  101
    (let* ((x (list 'a 'b 'c))
            (y 5))
        (setf (the fixnum (car x)) y)
        x) =>  (5 B C)
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果表达式形式 form 产生[yield]的值[value]不是由 value-type 指定的类型[type], 那么后果是没有定义的.

* 参见(See Also):

        values

* 注意(Notes):

        values 类型指定符可以用来表示多值[multiple values]的类型:

    ```LISP
    (the (values integer integer) (floor x y))
    (the (values string t)
        (gethash the-key the-string-table))
    ```

        setf 可以和 the 类型声明一起使用. 在这种情况下, 这个声明被转换为指定新值的表达式形式. 然后分析产生的 setf 表达式形式[form]. 

### <span id = "FunctionSPECIALOPERATORP">函数 SPECIAL-OPERATOR-P</span>

* 语法(Syntax):

        special-operator-p symbol => generalized-boolean

* 参数和值(Arguments and Values):

        symbol---一个符号[symbol].
        generalized-boolean---一个广义 boolean[generalized boolean].

* 描述(Description):

        如果符号 symbol 是一个特殊操作符[special operator]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (special-operator-p 'if) =>  true
    (special-operator-p 'car) =>  false
    (special-operator-p 'one) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果它的参数不是一个符号[symbol]应该发出一个 type-error 错误.

* 参见(See Also): None.

* 注意(Notes):

        从历史观点上说, 这个函数被称为 special-form-p. 这个名字最终被声明为用词不当并且修改, 因为它是对特殊操作符[special operator]返回 true, 而不是特殊表达式形式[special form]. 

### <span id = "FunctionCONSTANTP">函数 CONSTANTP</span>

* 语法(Syntax):

        constantp form &optional environment => generalized-boolean

* 参数和值(Arguments and Values):

        form---一个表达式形式[form].
        environment---一个环境[environment]对象[object]. 默认是 nil.
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果表达式形式 form 可以被这个具体实现[implementation]确定为在指定的环境 environment 中的一个常量形式[constant form], 则返回 true; 否则, 它返回 false 表示这个表达式形式[form]不是一个常量形式[constant form]或者它不能确定表达式形式[form]是否为一个常量形式[constant form].

        下面这些种类的表达式形式[form]被当作常量形式[constant form]:

        * 自求值对象[self-evaluating object] (像数字[number], 字符[character], 以及各种类型的数组[array]) 总是被当作常量形式[constant form]并且一定被 constantp 识别.

        * 常变量[constant variable], 例如关键字, 被 Common Lisp 定义作为常量的符号 (像 nil, t, 还有 pi), 还有在指定的环境 environment 中, 被用户使用 defconstant 声明为常量的符号总是被认为是常量形式[constant form], 并且一定被 constantp 所识别.

        * quote 表达式形式[form]总是被当作常量并且一定被 constantp 所识别.

        * 一个实现[implementation]允许, 但不是必须去检测额外的常量形式[constant form]. 如果确实如此, 那么使用环境 environment 中信息也是允许的, 但不是必需的. 对于 constantp 可能或可能不会返回 true 的常量形式[constant form]的例子是: (sqrt pi), (+ 3 2), (length '(a b c)), 还有 (let ((x 7)) (zerop x)).

        如果一个实现[implementation]选择使用环境 environment 信息, 可以使用诸如展开宏[macro]或执行函数内联之类的操作, 但不是必须; 然而, 展开编译器宏[compiler macro]是不允许的.

* 示例(Examples):

    ```LISP
    (constantp 1) =>  true
    (constantp 'temp) =>  false
    (constantp ''temp)) =>  true
    (defconstant this-is-a-constant 'never-changing) =>  THIS-IS-A-CONSTANT 
    (constantp 'this-is-a-constant) =>  true
    (constantp "temp") =>  true
    (setq a 6) =>  6 
    (constantp a) =>  true
    (constantp '(sin pi)) =>  implementation-dependent
    (constantp '(car '(x))) =>  implementation-dependent
    (constantp '(eql x x)) =>  implementation-dependent
    (constantp '(typep x 'nil)) =>  implementation-dependent
    (constantp '(typep x 't)) =>  implementation-dependent
    (constantp '(values this-is-a-constant)) =>  implementation-dependent
    (constantp '(values 'x 'y)) =>  implementation-dependent
    (constantp '(let ((a '(a b c))) (+ (length a) 6))) =>  implementation-dependent
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        全局环境的状态 (比如, 那些已经被声明为常变量[constant variable]的名字[name]的符号[symbol]).

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        defconstant

* 注意(Notes): None. 


# 4. 类型和类

> * 4.1 [引言](#Introduction)
> * 4.2 [类型](#Types)
> * 4.3 [类](#Classes)
> * 4.4 [类型和类的字典](#TheTypesClassesDictionary)

## 4.1 <span id="Introduction">引言</span>

一个类型[type]是一个对象[object] (可能是无数)集合. 一个对象[object]可以属于超过一个类型[type]. 类型[type]从不显式地被 Common Lisp 表示为对象[object]. 相反, 它们是通过使用类型指定符[type specifier]间接引用的, 类型指定符是表示类型[type]的对象[object].

新的类型[type]可以使用 deftype, defstruct, defclass, 以及 define-condition 来定义.

函数[function] typep 作为一个集合成员资格测试, 被用于确定一个给定的对象[object]是否为给定的类型[type]. 函数 subtypep 作为一个子集测试, 被用于确定一个给定的类型[type]是否为另一个给定类型[type]的子类型[subtype]. 函数 type-of 返回一个给定对象[object]所属的具体类型[type], 即便这个对象[object]也属于一个或多个其他类型[type]. (比如, 每一个对象[object]都是类型[type] t, 但是 type-of 总是返回一个比 t 更具体的类型[type]的类型指定符[type specifier].)

对象[object]拥有类型[type], 而不是变量[variable]. 通常, 任何变量[variable]可以持有任何对象[object]作为它的值[value]. 可以通过显式类型声明[type declaration]来声明一个变量[variable]只能获取指定的类型[type]的值. 类型[type]被安排在一个有向的非循环图中, 除了等价的存在<!--TODO 不理解-->.

可以通过 declare, proclaim, declaim, 或 the 来做出和类型[type]相关的声明[declaration]. 关于声明[declaration]的更多信息, 见章节 3.3 (声明).

对象系统的基本对象[object]之一是类[class]. 一个类[class]确定其他被称之为它的实例[instance]的对象[object]集的结构和行为. 每一个对象[object]都是一个类[class]的直接实例[direct instance]. 一个对象[object]的类[class]确定可以在这个对象[object]上进行的操作集合. 关于更多信息, 见章节 4.3 (类).

可以写出具有特化[specialized]于函数实参[argument]对象[object]的类的行为的函数[function]. 关于更多信息, 见章节 7.6 (广义函数和方法).

一个对象[object]的类[class]的类[class]称为它的元类[metaclass]. 关于元类[metaclass]的更多信息, 见章节 7.4 (元对象). 

## 4.2 <span id="Types">类型</span>

> * 4.2.1 [数据类型定义](#DataTypeDefinition)
> * 4.2.2 [类型关系](#TypeRelationships)
> * 4.2.3 [类型指定符](#TypeSpecifiers)

### 4.2.1 <span id="DataTypeDefinition">数据类型定义</span>

关于类型使用的信息所在章节在 Figure 4-1 中指定. Figure 4-7 列出了和对象系统特别相关的类[class]. Figure 9-1 列出了已定义的状况[condition]类型[type].

  章节                     | 数据类型                          
  -------------------------|------------------------              
  章节 4.3 (类)             | 对象系统类型
  章节 7.5 (槽)             | 对象系统类型
  章节 7 (对象)             | 对象系统类型
  章节 7.6 (广义函数和方法)   | 对象系统类型
  章节 9.1 (状况系统概念)     | 状况系统类型
  章节 4 (类型和类)          | 各种类型
  章节 2 (语法)              | 所有类型---读取和打印语法
  章节 22.1 (Lisp 打印器)    | 所有类型---打印语法
  章节 3.2 (编译)            | 所有类型---编译问题

Figure 4-1. 数据类型信息的交叉引用

### 4.2.2 <span id="TypeRelationships">类型关系</span>

* 类型[type] cons, symbol, array, number, character, hash-table, function, readtable, package, pathname, stream, random-state, condition, restart, 还有任何由 defstruct, define-condition, 或 defclass 创建的单个类型是成对[pairwise]互斥[disjoint]的, 除了在 defclass 或 define-condition 中或者 destruct 的 :include 选项指定超类[superclasse]来显式建立的类型关系以外.

* 任何由 defstruct 创建的两个类型[type]是互斥[disjoint]的, 除非由于 defstruct 的 :include 选项, 一个是另一个的超类型[supertype].

* 任何两个由 defclass 或 define-condition 创建的不同[distinct]的类[class]是互斥[disjoint]的, 除非它们有一个共同的子类[subclass]或者一个类是另一个的子类[subclass].

* 可以扩展一个实现来添加指定类型[type]之间的其他子类型[subtype]关系, 只要它们不违反这里指定的类型关系和类互斥性的需求. 一个实现可能为任何指定的类型[type]定义额外的子类型[subtype]或超类型[supertype], 只要不违反互斥性的要求并且每一个额外的类型[type]是类型[type] t 的子类型[subtype]也是类型[type] nil 的超类型[supertype].

    任凭具体实现自行处理, 无论是 standard-object 还是 structure-object, 都可能出现在一个没有指定 standard-object 或 structure-object 的系统类[system class]的优先级列表中. 如果确实如此, 它必须在类[class] t 之前并且跟在所有标准化[standardized]类[class]后面.

### 4.2.3 <span id="TypeSpecifiers">类型指定符</span>

类型指定符[type specifier]可以是符号[symbol], 类[class]或列表[list]. Figure 4-2 列出了标准[standardized]原子类型指定符[atomic type specifier]的那些符号[symbol], 并且 Figure 4-3 列出了标准[standardized]复合类型指定符[compound type specifier]的那些名字[name]. 关于语法信息, 见对应类型指定符[type specifier]的字典条目. 可以通过 defclass, define-condition, defstruct, 或 deftype 来定义新的类型指定符[type specifier].

    arithmetic-error                  function            simple-condition        
    array                             generic-function    simple-error            
    atom                              hash-table          simple-string           
    base-char                         integer             simple-type-error       
    base-string                       keyword             simple-vector           
    bignum                            list                simple-warning          
    bit                               logical-pathname    single-float            
    bit-vector                        long-float          standard-char           
    broadcast-stream                  method              standard-class          
    built-in-class                    method-combination  standard-generic-function
    cell-error                        nil                 standard-method         
    character                         null                standard-object         
    class                             number              storage-condition       
    compiled-function                 package             stream                  
    complex                           package-error       stream-error            
    concatenated-stream               parse-error         string                  
    condition                         pathname            string-stream           
    cons                              print-not-readable  structure-class         
    control-error                     program-error       structure-object        
    division-by-zero                  random-state        style-warning           
    double-float                      ratio               symbol                  
    echo-stream                       rational            synonym-stream          
    end-of-file                       reader-error        t                       
    error                             readtable           two-way-stream          
    extended-char                     real                type-error              
    file-error                        restart             unbound-slot            
    file-stream                       sequence            unbound-variable        
    fixnum                            serious-condition   undefined-function      
    float                             short-float         unsigned-byte           
    floating-point-inexact            signed-byte         vector                  
    floating-point-invalid-operation  simple-array        warning                 
    floating-point-overflow           simple-base-string                          
    floating-point-underflow          simple-bit-vector                              

Figure 4-2. 标准化原子类型指定符

如果一个类型指定符[type specifier]是一个列表[list], 这个列表[list]的 car 部分是一个符号[symbol], 并且这个列表[list]的剩余部分附属类型[type]信息. 这样一个类型指定符称为复合类型指定符[compound type specifier]. 除显式声明外, 附属项可以是未指明的. 这个未指明的辅助项通过编写 * 来表示. 比如, 为了完全地指定一个向量[vector], 元素的类型[type]和这个向量[vector]的长度都必须存在.

```LISP
(vector double-float 100)
```

下面这个留着长度未指定:

```LISP
(vector double-float *)
```

下面这个留着元素类型未指定:

```LISP
(vector * 100)
```

假设这两种类型指定符[type specifier]是相同的除了第一个有一个 * 而第二个有一个更明确的指定. 那么第二个表示的是第一个表示的类型[type]的子类型[subtype].

如果一个列表[list]的末尾有一个或超过一个未指定项, 这些项可以被丢弃. 如果丢弃所有出现的 * 导致一个单元素[singleton]列表[list], 那么圆括号也可以被丢弃 (这个列表可以被它的 car 的符号[symbol]所替代). 比如, (vector double-float *) 可以被简写为 (vector double-float), 而 (vector * *) 可以被简写为 (vector) 然后是 vector.

    and           long-float    simple-base-string  
    array         member        simple-bit-vector   
    base-string   mod           simple-string       
    bit-vector    not           simple-vector       
    complex       or            single-float        
    cons          rational      string              
    double-float  real          unsigned-byte       
    eql           satisfies     values              
    float         short-float   vector              
    function      signed-byte                       
    integer       simple-array                      

Figure 4-3. 标准复合类型指定符的名字

下面这段展示了可以被用于复合类型指定符[compound type specifier]名字但是不能被用于原子类型指定符[atomic type specifier]的那些已定义的名字[defined name].

    and     mod  satisfies  
    eql     not  values     
    member  or              

Figure 4-4. 标准仅限复合类型指定符的名字

新的类型指定符可以通过两种方式出现.

* 通过使用 defstruct 不带 :type 指定符来定义一个结构体或者使用 defclass 或 define-condition 来定义一个类[class]自动导致结构体或类的名字成为一个新的类型指定符[type specifier]符号[symbol].
* 可以使用 deftype 来定义派生类型指定符[derived type specifier], 它表现地像其他类型指定符[type specifier]的'缩写(abbreviation)'一样.

一个类[class]对象[object]可以被用作一个类型指定符[type specifier]. 当使用这种方式的时候, 它表示这个类[class]的所有成员的集合.

下面这段展示了一些类型[type]和声明[declarations]相关的已定义的名字[defined name].

    coerce            defstruct  subtypep  
    declaim           deftype    the       
    declare           ftype      type      
    defclass          locally    type-of   
    define-condition  proclaim   typep     

Figure 4-5. 类型和声明相关的已定义的名字.

下面这段展示了所有是类型指定符[type specifier]名字[name]的已定义名字[defined name], 不管是原子类型指定符[atomic type specifier]或者复合类型指定符[compound type specifier]; 这个列表是 Figure 4-2 和 Figure 4-3 列表的结合.

    and                               function            simple-array            
    arithmetic-error                  generic-function    simple-base-string      
    array                             hash-table          simple-bit-vector       
    atom                              integer             simple-condition        
    base-char                         keyword             simple-error            
    base-string                       list                simple-string           
    bignum                            logical-pathname    simple-type-error       
    bit                               long-float          simple-vector           
    bit-vector                        member              simple-warning          
    broadcast-stream                  method              single-float            
    built-in-class                    method-combination  standard-char           
    cell-error                        mod                 standard-class          
    character                         nil                 standard-generic-function  
    class                             not                 standard-method         
    compiled-function                 null                standard-object         
    complex                           number              storage-condition       
    concatenated-stream               or                  stream                  
    condition                         package             stream-error            
    cons                              package-error       string                  
    control-error                     parse-error         string-stream           
    division-by-zero                  pathname            structure-class         
    double-float                      print-not-readable  structure-object        
    echo-stream                       program-error       style-warning           
    end-of-file                       random-state        symbol                  
    eql                               ratio               synonym-stream          
    error                             rational            t                       
    extended-char                     reader-error        two-way-stream          
    file-error                        readtable           type-error              
    file-stream                       real                unbound-slot            
    fixnum                            restart             unbound-variable        
    float                             satisfies           undefined-function      
    floating-point-inexact            sequence            unsigned-byte           
    floating-point-invalid-operation  serious-condition   values                  
    floating-point-overflow           short-float         vector                  
    floating-point-underflow          signed-byte         warning                    

Figure 4-6. 标准类型指定符的名字

## 4.3 <span id="Classes">类</span>

尽管对象系统来描述所有的标准化[standardized]类[class] (包括, 例如, number, hash-table, 和 symbol) 足够通用, 但下面这段包含了与理解对象系统相关的类[class]的列表.

    built-in-class    method-combination         standard-object   
    class             standard-class             structure-class   
    generic-function  standard-generic-function  structure-object  
    method            standard-method                              

Figure 4-7. 对象系统类

> * 4.3.1 [类的介绍](#IntroductionToClasses)
> * 4.3.2 [定义类](#DefiningClasses)
> * 4.3.3 [创建类的实例](#CreatingInstancesClasses)
> * 4.3.4 [继承](#Inheritance)
> * 4.3.5 [确定类优先级列表](#DeterminingClassPrecedenceList)
> * 4.3.6 [重定义类](#RedefiningClasses)
> * 4.3.7 [整合类和类型](#IntegratingTypesClasses)

### 4.3.1 <span id="IntroductionToClasses">类的介绍</span>

一个类[class]是一个决定其他被称之为它的实例[instance]的那些对象[object]集合的结构和行为的对象[object].

一个类[class]可以从其他类[class]中继承结构和行为. 一个出于继承其他类[class]的目的而在定义中引用它们的类[class]就称这个类是那些类[class]的子类[subclass]. 为了继承而指定的类[class]称为继承类[class]的超类[superclass].

一个类[class]可以有一个名字[name]. 函数[function] class-name 接受一个类[class]对象[object]并且返回它的名字[name]. 一个匿名类[class]的名字[name]是 nil. 一个符号[symbol]可以命名[name]一个类[class]. 函数[function] find-class 接受一个符号[symbol]并且返回这个符号[symbol]命名的类[class]. 如果一个名字[name]是一个符号[symbol]并且如果一个类[class]的这个名字[name]命名这个类[class], 那么这个类有一个专有名字[proper name]. 这就是说, 如果 S= (class-name C) 并且 C= (find-class S) 那么一个类[class] C 有一个专有名字[proper name]. 注意, (find-class S1) = (find-class S2) 并且 S1/=S2 是可能的. 如果 C= (find-class S), 我们就说 C 是名为 S 的类[class].

如果一个类[class] C2 在它的定义中显式指定 C1 作为超类[superclass]那么类[class] C1 就是类[class] C2 的一个直接超类[direct superclass]. 在这个情况下 C2 是 C1 的一个直接子类[direct subclass]. 如果 1 <= i < n 并且存在一系列的类[class] C2,...,Cn-1 而 Ci+1 是 Ci 的直接超类[direct superclass]那么类[class] Cn 是类[class] C1 的一个超类[superclass]. 一个类[class]不能被当作是它自身的超类[superclass]或子类[subclass]. 这也就是说, 如果 C1 是 C2 的一个超类[superclass], 那么 C1 /=C2. 由某个给定的类[class] C 及其所有超类[superclass]组成的类集合被称为 "C 及其超类".

每一个类[class]有一个类优先级列表[class precedence list], 它是给定类[class]及其超类[superclass]的集合的总序列. 这个总序列被表示为一个从最具体到最不具体的列表. 这个类优先级列表[class precedence list]被用于多种用途. 一般来说, 更具体的类[class]可以遮蔽[shadow[1]]从不具体的类中继承而来的特性. 方法[method]选择和组合过程使用类优先级列表[class precedence list]以从最具体到最不具体的顺序类对方法排序.

当一个类[class]被定义时, 定义表达式形式中提及到的直接超类[direct superclass]的顺序是很重要的. 每一个类[class]有一个局部优先级序列[local precedence order], 这是一个由该类[class]和跟在后面的直接超类[direct superclass]组成的列表[list], 按照定义表达式形式[form]中所提到的顺序.

类优先级列表[class precedence list]总是与列表中的每个类[class]的局部优先级序列[local precedence order]一致. 每个局部优先级序列[local precedence order]中的类都以相同的顺序出现在类优先级列表中. 如果局部优先级序列[local precedence order]和其他每个是不一致的, 就不能构建类优先级列表[class precedence list], 并且发出一个错误. 类优先级列表和它的运算在章节 4.3.5 (确定类优先级列表) 中讨论.

类[class]被组织成一个有向的无环图. 这里有两个显著的类[class], 名为 t 和 standard-object. 名为 t 的类[class]没有超类[superclass]. 它是除了它自身以外所有类[class]的超类[superclass]. 类[class] standard-object 是类[class] standard-class 的一个实例[instance]并且是每一个除了它自身以外类 standard-class 实例[instance]的超类[superclass].

这里由一个从对象系统类[class]空间到类型[type]空间的映射. 很多在这个文档中指定的标准类型[type]都有一个对应的有着和这个类型[type]相同名字[name]的类[class]. 一些类型[type]没有对应的类[class]. 类型[type]和类[class]系统的集成在章节 4.3.7 (整合类和类型) 中讨论.

类[class]由自身也是类[class]的实例[instance]的对象[object]来表示. 一个对象[object]的类[class]的类[class]被称为该对象[object]的元类[metaclass]. 当不可能出现错误解释时, 元类[metaclass]这个术语被用来引用一个有着自身也是类[class]的实例[instance]的类[class]. 元类[metaclass]确定作为它的实例[instance]的类[class]的继承形式, 以及那些类[class]的实例[instance]的表示形式. 这个对象系统提供一个默认的元类[metaclass], standard-class, 适用于大部分程序.

除另有指定外, 在这个标准中提及的所有类[class]都是类[class] standard-class 的实例[instance], 所有广义函数[generic function]都是类[class] standard-generic-function 的实例[instance], 并且所有方法[method]都是类[class] standard-method 的实例[instance]. 

#### 4.3.1.1 标准的元类

对象系统提供了许多预定义的元类[metaclass]. 这些包括类[class] standard-class, built-in-class, 还有 structure-class:

* 类[class] standard-class 是 defclass 定义的类[class]的默认类[class].

* 类[class] built-in-class 是这样的类[class]: 它的实例[instance]是具有限制能力的特殊实现的类[class]. 任何对应于标准类型[type]的类[class]可能是 built-in-class 的一个实例[instance]. 预定义的类型[type]指定符需要有着 Figure 4-8 中列出的对应类[class]. 这些类[class]中的每一个是否被实现为一个内置类[built-in class]是依赖于具体实现的[implementation-dependent].

* 所有通过 defstruct 定义的类[class]都是类[class] structure-class 的实例[instance]. 

### 4.3.2 <span id="DefiningClasses">定义类</span>

宏 defclass 被用于定义一个新命名的类[class].

一个类[class]的定义包括:

* 这个新类[class]的名字[name]. 对于新定义的类[class], 这个名字[name]是一个专有名字[proper name].

* 这个新定义的类[class]的直接超类列表[superclasses].

* 一个槽指定符[slot specifier]的集合. 每一个槽指定符[slot specifier]包括槽[slot]的名字[name]和 0 个或多个的槽[slot]选项. 一个槽[slot]选项只适用于单个槽[slot]. 如果一个类[class]定义包含两个相同名字[name]的槽指定符[slot specifier], 会发出一个错误.

* 一个类[class]选项的集合. 每个类[class]选项都属于整个类[class].

    defclass 表达式形式的槽[slot]选项和类[class]选项机制被用于:

    * 为给定的槽[slot]提供默认的初始值表达式形式[form].

    * 请求自动生成广义函数[generic function]的方法[method]，用于读取或写入槽[slot].

    * 控制一个给定的槽[slot]是否共享于这个类[class]的所有实例[instance]或者这个类[class]的每个实例[instance]是否有它自己的槽[slot].

    * 提供初始化参数和初始化参数默认值, 用于实例[instance]的创建.

    * 指定元类[metaclass]而不是默认的. 这个 :metaclass 选项保留给未来使用; 一个实现可以扩展去使用 :metaclass 选项.

    * 指定存储在槽[slot]中的期望的类型[type].

    * 指定槽[slot]的文档字符串[documentation string]. 

### 4.3.3 <span id="CreatingInstancesClasses">创建类的实例</span>

广义函数 make-instance 创建并返回一个类[class]的一个新的实例[instance]. 这个对象系统提供多种机制用于指明一个新的实例[instance]如何被初始化. 比如, 可以在新创建的实例[instance]中通过给 make-instance 提供参数或提供默认的初始化值来指定槽[slot]的初始值. 进一步的初始化活动可以通过为初始化协议中的广义函数[generic function]编写方法[method]来执行. 完全的初始化协议在章节 7.1 (对象创建和初始化) 中描述. 

### 4.3.4 <span id="Inheritance">继承</span>

一个类[class]可以从它的超类[superclass]中继承方法[method], 槽[slot], 还有一些 defclass 选项. 其他部分描述了方法[method]的继承, 槽[slot]和槽[slot]选项的继承以及类[class]选项的继承.

#### 4.3.4.1 继承的示例

```LISP
(defclass C1 () 
    ((S1 :initform 5.4 :type number) 
    (S2 :allocation :class)))

(defclass C2 (C1) 
    ((S1 :initform 5 :type integer)
    (S2 :allocation :instance)
    (S3 :accessor C2-S3)))
```

类 C1 的实例[instance]有一个名为 S1 的局部槽[local slot], 它的默认初始值是 5.4 并且它的值[number]应该始终为一个数字[number]. 类 C1 也有一个名为 S2 的共享槽[shared slot].

在 C2 的实例[instance]中有一个名为 S1 的局部槽[local slot]. S1 的默认初始值为 5. S1 的值应该总是为类型 (and integer number). 在 C2 的实例[instance]中也有名为 S2 和 S3 的局部槽[local slot]. 类 C2 有一个 C2-S3 方法[method]来读取槽 S3 的值; 也有一个 (setf C2-S3) 方法[method]来写入 S3 的值. 

#### 4.3.4.2 类选项的继承

这个 :default-initargs 类选项被继承. 一个类[class]的默认初始化参数集合是这个类[class]和它的超类[superclass]的 :default-initargs 类选项中提供的初始化参数的并集. 当给一个给定的初始化参数提供了不止一个默认初始值表达式形式[form]时, 使用的默认初始值表达式形式[form]是由类优先级列表[class precedence list]中最具体的类[class]提供的.

如果一个给定的 :default-initargs 类选项不止一次指定相同名字[name]的初始化参数, 会发出一个 program-error 类型[type]的错误. 

### 4.3.5 <span id="DeterminingClassPrecedenceList">确定类优先级列表</span>

一个类的 defclass 表达式形式提供这个类[class]和它的直接超类[superclass]的总序列. 这个序列称之为局部优先级序列[local precedence order]. 它是一个这个类[class]和它的直接超类[superclass]的有序列表. 类 C 的类优先级列表[class precedence list]是一个 C 和它的超类的总序列, 由 C 和它的超类[superclass]的每一个局部优先级序列[local precedence order]构成.

一个类[class]在它的直接超类[superclass]前面, 并且一个直接超类[superclass]先于那些在 defclass 表达式形式中的超类[superclass]列表中在它右边的其他直接超类[superclass]. 对于每一个类 C, 定义

    RC={(C,C1),(C1,C2),...,(Cn-1,Cn)}

其中 C1,...,Cn 是 C 的直接超类[superclass], 以 defclass 表达式形式提及的顺序. 这些有序对生成类 C 和它的直接超类[superclass]的总序列.

让 SC 是 C 和它的超类[superclass]的集合. 让 R 为

    R=Uc<ELEMENT-OF>SCRc

这个集合 R 可能会也可能不会生成一个部分列表, 取决于 Rc, c<ELEMENT-OF>SC, 是否是一致的; 假定它们是一致的, R 产生一个部分列表. 当这个 Rc 不是一致的时, 就说 R 是非一致的.

为了计算 C 的类优先级列表[class precedence list], 根据 R 产生的部分序列对 SC 的元素进行拓扑排序. 当这个拓扑排序必须从两个或更多类[class]的集合中选择一个类[class]时, 其中没有一个类的前面有关于 R 的其他类[class], 选择的类是确定的, 如下面所述.

如果 R 不是一致的, 会发出一个错误.

#### 4.3.5.1 拓扑排序 (未校对)
<!-- TODO 未校对 -->
拓扑排序是根据 R 中的元素通过在 SC 中找到一个 C 类来进行的, 这样就不会有其他元素先于这个元素. 这个类 C 被放在结果的最前面. 从 SC 中移除 C, 并且从 R 中移除所有表达式形式 (C,D) 对, D<ELEMENT-OF>SC. 重复这个过程, 在结果的末尾添加前面没有任何类的类. 当找不到前面没有类的元素时停止.

如果 SC 不是空并且这个过程已经停止, 那么集合 R 是不一致的. 如果在有限类[class]集合中的每个类[class]都前置另一个类, 那么 R 就包含一个循环. 这就是说, 这里有一个 Ci 先于 Ci+1 的链 C1,...,Cn , 1 <= i < n, 而 Cn 先于 C1.

有时候这里有多个来自 SC 并且前面没有类的类[class]. 在这个情况下选择有着直接子类[subclass]位于计算到目前为止的类优先级列表[class precedence list]的最右边的那个. (如果这里没有这样一个候选的类[class], R 不产生一个部分序列---这个 Rc, c<ELEMENT-OF>SC, 是不一致的.)

用更精确的术语, 让 {N1,...,Nm}, m>=2, 为来自于 SC 的前面没有类的类[class]. 让 (C1...Cn), n>=1, 为目前为止已构建的类优先级列表[class precedence list]. C1 是最具体的类[class], 而 Cn 最不具体的. 让 1 <= j <= n 成为最大一个数这样一来这里存在 i 其中 1 <= i <= m 并且 Ni 是 Cj 的一个直接超类[superclass]; Ni 被放到下一个.

这个从一组没有前导类的类[class]集合中选择的规则的效果是, 一个简单的超类[superclass]链中的类[class]在类优先级列表[class precedence list]中是相邻的, 并且每个相对独立的子图中的类[class]在类优先级列表[class precedence list]中是相邻的. 例如, 让 T1 和 T2 成为子图, 其唯一公共的元素是类 J. 假设没有 J 的超类出现在 T1 或 T2 中, 并且这个 J 存在于 T1 和 T2 的每个类的超类链中. 让 C1 是 T1 底部; 并且让 C2 是 T2 的底部. 假设这个顺序下 C 是一个直接超类是按照那个顺序 C1 和 C2 的类[class], 那么 C 的类优先级列表[class precedence list]以 C 开始后面跟着 T1 的所有类[class]除了 J. 后面是 T2 的所有类[class]. 类[class] J 和它的超类[superclass]出现在最后. 

#### 4.3.5.2 确定类优先级列表的示例

这个实例确定一个类 pie 的类优先级列表[class precedence list]. 定义下面这些类[class]:

```LISP
(defclass pie (apple cinnamon) ())

(defclass apple (fruit) ())

(defclass cinnamon (spice) ())

(defclass fruit (food) ())

(defclass spice (food) ())

(defclass food () ())
```

集合 Spie = {pie, apple, cinnamon, fruit, spice, food, standard-object, t}. 集合 R = {(pie, apple), (apple, cinnamon), (apple, fruit), (cinnamon, spice),
(fruit, food), (spice, food), (food, standard-object), (standard-object, t)}.

类 pie 的前面什么都没有, 所以它是第一个; 目前为止结果是 (pie). 从 S 中移除 pie 并且从 R 中移除提及到 pie 的对(pair)来得到 S = {apple, cinnamon, fruit, spice, food, standard-object, t} 还有 R = {(apple, cinnamon), (apple, fruit), (cinnamon, spice),
(fruit, food), (spice, food), (food, standard-object), (standard-object, t)}.

类 apple 前面没有任何东西, 所以它是下一个; 结果是 (pie apple). 移除 apple 和相关的对得到 S = {cinnamon, fruit, spice, food, standard-object, t} 以及 R = {(cinnamon, spice), (fruit, food), (spice, food), (food, standard-object),
(standard-object, t)}.

类 cinnamon 和 fruit 前面什么都没有, 所以目前为止有着类优先级列表[class precedence list]中最右边的直接子类[subclass]的那一个是下一个. 类 apple 是 fruit 的直接子类[subclass], 而类 pie 是一个 cinnamon 的直接子类[subclass]. 因为类优先级列表[class precedence list]中 apple 出现 pie 的右边, fruit 是下一个, 目前的结果是 (pie apple fruit). S = {cinnamon, spice, food, standard-object, t}; R = {(cinnamon, spice), (spice, food),(food, standard-object), (standard-object, t)}.

类 cinnamon 是下一个, 目前结果为 (pie apple fruit cinnamon). 这时 S = {spice, food, standard-object, t}; R = {(spice, food), (food, standard-object), (standard-object, t)}.

类 spice, food, standard-object, 还有 t 按这个顺序添加, 然后类优先级列表[class precedence list]为 (pie apple fruit cinnamon spice food standard-object t).

编写一组不能被排序的类[class]定义是可能的. 比如:

```LISP
(defclass new-class (fruit apple) ())

(defclass apple (fruit) ())
```

类 fruit 必须先于 apple 因为必须保留超类[superclass]的局部顺序. 类 apple 必须先于 fruit 因为一个类必须先于它自己的超类[superclass]. 当这个情况发生时, 会发出一个错误, 就像在这里系统尝试去计算 new-class 的类优先级列表[class precedence list]时发生的那样.

以下可能是一组相互冲突的定义:

```LISP
(defclass pie (apple cinnamon) ())

(defclass pastry (cinnamon apple) ())

(defclass apple () ())

(defclass cinnamon () ())
```

这个 pie 的类优先级列表[class precedence list]是 (pie apple cinnamon standard-object t).

这个 pastry 的类优先级列表[class precedence list]是 (pastry cinnamon apple standard-object t).

在 pie 的超类[superclass]的顺序中 apple 先于 cinnamon 不是问题, 但是在 pastry 中则有问题. 然而, 去构建一个同时有 pie 和 pastry 作为超类[superclass]的新的类[class]是不可能的. 

### 4.3.6 <span id="RedefiningClasses">重定义类</span>

作为一个 standard-class 的直接实例[direct instance]的类[class]可以被重定义, 但只有当重定义的新类[class]也是 standard-class 类的直接实例[direct instance]的情况下. 重定义一个类[class]会修改已存在的类[class]对象[object]来反映这个新的类[class]的定义; 它不会为这个类[class]创建一个新的类[class]对象[object]. 任何由旧的 defclass 表达式形式指定的 :reader, :writer, 或 :accessor 选项所创建的方法[method]对象[object]会从对应广义函数[generic function]中被移除. 由这个新的 defclass 表达式形式指定的那些方法[method]会被添加进去.

当这个类 C 被重定义时, 修改会传递到它的实例[instance]以及它的任何子类[subclass]的实例[instance]. 更新这样一个实例[instance]发生的时间依赖于具体实现[implementation-dependent], 但是不会晚于下一次这个实例[instance]的槽[slot]被读取或写入. 更新一个实例[instance]不会改变由函数[function] eq 定义的它的等价性. 更新的过程可能改变这个特别实例[instance]的槽[slot], 但是不会创建一个新实例[instance]. 更新一个实例是否消耗存储是依赖于具体实现的[implementation-dependent].

注意, 重定义一个类[class]可能导致槽[slot]被添加或删除. 如果一个类[class]被重定义, 以一种改变实例[instance]中可访问[accessible]的局部槽[local slot]的集合的方式, 那么实例[instance]就会被更新. 如果一个类[class]被重定义, 以一种没有改变实例[instance]中可访问[accessible]的局部槽[local slot]的集合的方式, 实例[instance]是否被更新是依赖于具体实现的[implementation-dependent].

在旧的类[class]和新的类[class]中都指定为共享的槽[slot]的值会被保留. 如果这样一个共享槽[shared slot]在旧的类[class]中没绑定, 它在新的类[class]里也是没有绑定的. 在旧的类[class]中是局部的而在新的类[class]中是共享的槽[slot]会被初始化. 新添加的共享槽[shared slot]会被初始化.

每一个新添加的共享槽[shared slot]会被设置为新类[class]的 defclass 表达式形式[form]中指定的这个槽的被捕获的初始化表达式形式[captured initialization form]的求值结果. 如果这里没有初始化表达式形式[initialization form], 这个槽[slot]就是未绑定的.

如果一个类[class]被重定义, 以一种改变实例[instance]中可访问[accessible]的局部槽[local slot]的集合的方式, 那么就会发生一个更新这个类[class]的实例[instance]的两步式步骤就会发生. 这个过程可能通过调用广义函数 make-instances-obsolete 来明确开始. 这个两步式的过程可以发生在一些实现的其他情况中. 例如, 在一些实现中如果槽[slot]在存储中的顺序被改变, 这个两步式过程也会被触发.

第一步通过添加新的局部槽[local slot]和丢弃这个类[class]的新版本中没定义的局部槽[local slot]来修改这个实例[instance]的结构. 第二部来初始化新添加的局部槽[local slot]并且执行任何其他的用户定义的动作. 这两个步骤在下面两个章节中会进一步说明.

> * 4.3.6.1 [修改实例的结构](#ModifyingStructureInstances)
> * 4.3.6.2 [初始化新添加的局部槽](#InitializingSlots)
> * 4.3.6.3 [定制类的重定义](#CustomizingClassRedefinition)

#### 4.3.6.1 <span id="ModifyingStructureInstances">修改实例的结构</span>

第一步修改重定义类[class]的实例[instance]的结构来使之符合新的类[class]定义. 在新的类[class]定义中增加的局部槽[local slot]而在旧的类[class]定义中既没有指定为局部的也不是共享的槽会被添加, 并且在新的类[class]定义中既不是局部也不是共享的而在旧的类[instance]定义中指定为局部的槽会被丢弃. 这些新添加和丢弃的槽[slot]的名字作为参数传递给下一章节所描述的 update-instance-for-redefined-class.

旧的和新的类[class]中都指定的局部槽[local slot]的值会被保留. 如果这样一个局部槽[local slot]是未绑定的, 它就保留为未绑定的.

在旧的类[class]中是共享的而在新的类[class]中指定为局部的槽[slot]的值会保留. 如果这样一个共享槽[shared slot]是未绑定的, 那么这个局部槽[local slot]也是为绑定的. 

#### 4.3.6.2 <span id="InitializingSlots">初始化新添加的局部槽</span>

第二步初始化新添加的那些局部槽[local slot]并且执行任何其他用户定义的动作. 这个步骤被广义函数 update-instance-for-redefined-class 实现, 这个函数在第一个修改实例[instance]结构的步骤完成后被调用.

广义函数 update-instance-for-redefined-class 需要 4 个必要参数: 在经历过第一个步骤之后要被更新的实例[instance], 被添加的局部槽[local slot]的名称列表, 被丢弃的局部槽[local slot]的名称列表, 还有一个包含被丢弃的并且有值的槽[slot]的名字和槽[slot]的值的属性列表. 被丢弃的槽[slot]中包括旧类[class]中是局部的而新类[class]中是共享的槽[slot].

广义函数 update-instance-for-redefined-class 也接受任意数量的初始化参数. 当它被系统调用来更新一个类[class]已经被重定义的实例[instance]时, 不会提供初始化参数.

这里有一个系统提供的关于 update-instance-for-redefined-class 主方法[method], 它的实例参数的参数指定符[parameter specializer]是一个 standard-object 类[class]. 首先这个方法[method]检测初始化参数的有效性, 如果一个提供的参数没有被合法声明就会发出一个错误. (关于更多信息, 见章节 7.1.2 (声明初始化参数的有效性).) 然后它调用广义函数 shared-initialize 并传入以下参数: 这个实例[instance], 新添加槽[slot]的名称[name]列表, 还有它收到的初始化参数. 

#### 4.3.6.3 <span id="CustomizingClassRedefinition">定制类的重定义</span>

这个 update-instance-for-redefined-class 的方法[method]可能被定义用来指定当一个实例[instance]被更新时采取的动作. 如果只定义了 update-instance-for-redefined-class 的 after 方法[after method], 那么它们将在系统提供的的初始化主方法[method]之后运行, 因此不会影响 update-instance-for-redefined-class 的默认行为. 被系统调用时由于没有传递初始化参数给 update-instance-for-redefined-class, 被 update-instance-for-redefined-class 的 before 方法[before method]填充的槽的初始化表达式形式[initialization form]不会被 shared-initialize 求值.

这个 shared-initialize 的方法[method]可能被定义用来定制类[class]的重定义行为. 关于更多信息, 见章节 7.1.5 (Shared-Initialize). 

### 4.3.7 <span id="IntegratingTypesClasses">整合类和类型</span>

对象系统映射类[class]的空间到类型[type]的空间. 每个有着特有的的名字的类[class]都有一个对应相同名字[name]的类型[type].

每个类的专有名字[proper name]是一个有效的类型指定符[type specifier]. 另外, 每个类[class]对象[object]是一个有效的类型指定符[type specifier]. 所以表达式 (typep object class) 在 object 的类[class]是 class 本身或者 class 的子类[subclass]情况下返回 true. 如果 class1 是 class2 的一个子类[subclass]或者它们是相同的类[class], 那么表达式 (subtypep class1 class2) 的求值返回多值 true 和 true; 否则它返回多值 false 和 true. 如果 I 是某个名为 S 的类[class] C 的实例[instance]并且 C 是 standard-class 的实例[instance], 那么如果 S 是 C 的专有名字[proper name], 那么表达式 (type-of I) 的求值返回 S; 否则, 它返回 C.

由于类[class]的名字和类[class]对象[object]都是类型指定符[type specifier], 它们可能被用于特殊表达式形式 the 以及类型声明中.

很多但不是全部预定义的类型指定符[type specifier]都有和类型[type]有着相同专有名字[proper name]的类[class]. 这些类型指定符[type specifier]列在 Figure 4-8. 比如, 类型[type] array 有一个对应的名为 array 的类. 例如 (vector double-float 100) 这样的列表作为类型指定符[type specifier]没有一个对应的类[class]. 操作符[operator] deftype 不会创建任何类[class].

对应于预定义类型指定符[type specifier]的每个类[class]可以通过以下三种方式实现, 由每个具体实现决定. 它可以是一个标准类[standard class], 一个结构体类[structure class], 或者一个系统类[system class].

一个内置类[built-in class]是一个广义实例[generalized instance]具有限制功能和特殊表示的类. 尝试使用 defclass 去定义 built-in-class 的子类[subclasse]会发出一个错误. 调用 make-instance 去创建一个内置类[built-in class]的广义实例[generalized instance]会发出一个错误. 对一个内置类[built-in class]的广义实例[generalized instance]调用 slot-value 会发出一个错误. 重定义一个内置类[built-in class]或使用 change-class 去改变一个内置类内置类[built-in class]对象[object]的类[class]或把一个对象[object]的类[class]改为内置类[built-in class]都会发出一个错误. 然而, 内置类[built-in class]可以被用作方法[method]的参数指定符[parameter specializer].

可以通过检查元类[metaclass]来确定一个类[class]是否为内置类[built-in class]. 一个标准类[standard class]是类[class] standard-class 的一个实例[instance], 一个内置类[built-in class]是类[class] built-in-class 的实例[instance], 并且一个结构体类[structure class]是类[class] structure-class 的实例[instance].

每一个用 defstruct 创建的没有使用 :type 选项的结构体[structure]类型[type]都有一个对应的类[class]. 这个类[class]是一个类[class] structure-class 的广义实例[generalized instance]. 这个 defstruct 的 :include 选项会创建一个对应被包含的结构体[structure]类型[type]的类[class]的直接子类[subclass].

槽[slot]是否被牵涉到在这个规范定义的类[class]的实例[instance]上的这个规范定义的函数[function]的操作中是依赖于具体实现的[implementation-dependent], 除非这个槽[slot]被这个规范显式定义.

如果在一个特定的具体实现[inplementation]中的这个规范定义的一个类[class]有着没有在这个规范中定义的槽[slot], 这些槽[slot]的名称不能是该规范中定义的包[package]的外部符号[external symbol], 也不能是 CL-USER 包中可访问的[accessible].

指定许多标准类型指定符[type specifier]有相应的类[class]的目的是使用户能够编写对这些类型进行区别对待的方法[method]. 方法[method]选择要求可以为每个类确定一个类优先级列表[class precedence list].

类型指定符[type specifier]之间的层次关系通过与这些类型[type]对应的类[class]之间的关系来反映.

Figure 4-8 列出了预定义类型指定符[type specifier]对应的类[class]的集合.

    arithmetic-error                  generic-function    simple-error          
    array                             hash-table          simple-type-error       
    bit-vector                        integer             simple-warning          
    broadcast-stream                  list                standard-class          
    built-in-class                    logical-pathname    standard-generic-function  
    cell-error                        method              standard-method         
    character                         method-combination  standard-object         
    class                             null                storage-condition       
    complex                           number              stream                  
    concatenated-stream               package             stream-error            
    condition                         package-error       string                  
    cons                              parse-error         string-stream           
    control-error                     pathname            structure-class         
    division-by-zero                  print-not-readable  structure-object        
    echo-stream                       program-error       style-warning           
    end-of-file                       random-state        symbol                  
    error                             ratio               synonym-stream          
    file-error                        rational            t                       
    file-stream                       reader-error        two-way-stream          
    float                             readtable           type-error              
    floating-point-inexact            real                unbound-slot            
    floating-point-invalid-operation  restart             unbound-variable        
    floating-point-overflow           sequence            undefined-function      
    floating-point-underflow          serious-condition   vector                  
    function                          simple-condition    warning                 

Figure 4-8. 对应预定义类型指定符的类

在这些类的条目中指定的类优先级列表[class precedence list]信息就是对象系统所需要的那些.

可以扩展单独的具体实现来定义其他类型指定符来拥有相应的类[class]. 单个具体实现可以扩展去添加其他子类[subclass]关系, 并将其他元素[element]添加到类优先级列表[class precedence list]中, 只要它们不违反该标准所指定的类型关系和互斥性需求. 一个已定义的没有指定直接超类[superclass]的标准类[class]保证和这个表中的所有类都是互斥的, 除了名为 t 的类. 

## 4.4 <span id="TheTypesClassesDictionary">类型和类的字典</span>

> * [类型 NIL](#TypeNIL)
> * [类型 BOOLEAN](#TypeBOOLEAN)
> * [系统类 FUNCTION](#SystemClassFUNCTION)
> * [类型 COMPILED-FUNCTION](#TypeCOMPILEDFUNCTION)
> * [系统类 GENERIC-FUNCTION](#SystemClassGENERICFUNCTION)
> * [系统类 STANDARD-GENERIC-FUNCTION](#SystemClassSTANDARDGENERICFUNCTION)
> * [系统类 CLASS](#SystemClassCLASS)
> * [系统类 BUILT-IN-CLASS](#SystemClassBUILTINCLASS)
> * [系统类 STRUCTURE-CLASS](#SystemClassSTRUCTURECLASS)
> * [系统类 STANDARD-CLASS](#SystemClassSTANDARDCLASS)
> * [系统类 METHOD](#SystemClassMETHOD)
> * [系统类 STANDARD-METHOD](#SystemClassSTANDARDMETHOD)
> * [类 STRUCTURE-OBJECT](#ClassSTRUCTUREOBJECT)
> * [类 STANDARD-OBJECT](#ClassSTANDARDOBJECT)
> * [系统类 METHOD-COMBINATION](#SystemClassMETHODCOMBINATION)
> * [系统类 T](#SystemClassT)
> * [类型指定符 SATISFIES](#TypeSpecifierSATISFIES)
> * [类型指定符 MEMBER](#TypeSpecifierMEMBER)
> * [类型指定符 NOT](#TypeSpecifierNOT)
> * [类型指定符 AND](#TypeSpecifierAND)
> * [类型指定符 OR](#TypeSpecifierOR)
> * [类型指定符 VALUES](#TypeSpecifierVALUES)
> * [类型指定符 EQL](#TypeSpecifierEQL)
> * [函数 COERCE](#FunctionCOERCE)
> * [宏 DEFTYPE](#MacroDEFTYPE)
> * [函数 SUBTYPEP](#FunctionSUBTYPEP)
> * [函数 TYPE-OF](#FunctionTYPEOF)
> * [函数 TYPEP](#FunctionTYPEP)
> * [状况类型 TYPE-ERROR](#ConditionTypeTYPEERROR)
> * [函数 TYPE-ERROR-DATUM, TYPE-ERROR-EXPECTED-TYPE](#FunctionTEDTEET)
> * [状况类型 SIMPLE-TYPE-ERROR](#ConditionTypeSIMPLETYPEERROR)

### <span id="TypeNIL">类型 NIL</span>

* 超类型(Supertypes):

        所有类型[type]

* 描述(Description):

        类型[type] nil 不含任何对象[object]所以也被称为空类型[empty type]. 类型[type] nil 是所有类型[type]的子类型[subtype]. 没有 nil 类型[type]的对象[object].

* 注意(Notes):

        包含对象[object] nil 的类型[type]是 null, 不是类型[type] nil. 

### <span id="TypeBOOLEAN">类型 BOOLEAN</span>

* 超类型(Supertypes):

        boolean, symbol, t

* 描述(Description):

        类型[type] boolean 包含符号[symbol] t 和 nil, 它们分别表示 true 和 false.

* 参见(See Also):

        t (常变量), nil (常变量), if, not, complement

* 注意(Notes):

        条件操作, 比如 if, 允许广义 boolean [generalized boolean]的使用, 不只是 boolean; 任何非 nil [non-nil]的值, 不只是 t, 对于广义的 boolean [generalized boolean]都视作 true. 然而, 作为惯例, 即便对于广义的 boolean [generalized boolean]当没有更好的选择来表示它自身时, 符号[symbol] t 被当作规范化的值来使用. 

### <span id="SystemClassFUNCTION">系统类 FUNCTION</span>

* 类优先级列表(Class Precedence List):

        function, t

* 描述(Description):

        当适当数量的参数被提供时, 一个函数[function]是一个表示要被执行的代码的对象. 一个函数[function]由 function 特殊表达式形式[special form], 函数[form] coerce, 或函数[form] compile 产生. 一个函数[function]可以通过把它作为第一个参数给 funcall, apply, 或 multiple-value-call 来直接调用.

* 复合类型指定符种类(Compound Type Specifier Kind):

        特化.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        function [arg-typespec [value-typespec]]

        arg-typespec::= (typespec*  
                        [&optional typespec*]  
                        [&rest typespec]  
                        [&key (keyword typespec)*]) 

* 复合类型指定符的参数(Compound Type Specifier Arguments):

        typespec---一个类型指定符[type specifier].
        value-typespec---一个类型指定符[type specifier].

* 复合类型指定符的描述(Compound Type Specifier Description):

        这个 function 类型指定符的列表形式只能被用于声明不能用于辨别(discrimination). 这个类型[type]的每一个元素都是一个函数[function], 它接受由 argj-types 指定类型的参数并返回 value-type 指定类型的成员的返回值. 这里的 &optional, &rest, &key, 和 &allow-other-keys 标记可以出现在参数类型的列表中. 使用 &rest 提供的类型指定符[type specifier]是每一个实际参数的类型[type], 不是对应变量的类型[type].

        这个 &key 参数应该以 (keyword type) 这样形式的列表来提供. 这个关键字 keyword 必须是一个合法的关键字名字符号, 必须在调用的实际参数中提供. 这个通常是 KEYWORD 包中的符号[symbol]但是可以是任何符号[symbol]. 当 &key 在一个 function 类型指定符[type specifier]的 lambda 列表[lambda list]中被提供时, 这个给定的关键字参数[keyword parameter]必须是详尽的, 除非 &allow-other-keys 也出现了. &allow-other-keys 是一个指示符, 表示其他的关键字参数实际中也可以被提供, 如果提供了, 就可以被使用. 比如, 函数 make-list 类型可以按以下的方式来声明:

    ```LISP
    (function ((integer 0) &key (:initial-element t)) list)
    ```

        这个 value-type 可以是一个 values 类型指定符[type specifier]用来表示多值[multiple values]的类型.

        细想以下形式的一个声明:

    ```LISP
    (ftype (function (arg0-type arg1-type ...) val-type) f))
    ```

        任何在这个声明的作用域中的 (f arg0 arg1 ...) 表达式形式[form]等价于以下:

    ```LISP
    (the val-type (f (the arg0-type arg0) (the arg1-type arg1) ...))
    ```

        这也就是说, 如果任意参数不是指定的类型[type]或者结果不是指定的类型[type], 那么结果是未定义的. 具体来说, 如果任意参数不是正确的类型[type], 结果就不保证是指定的类型[type].

        因此, 一个函数[function]的 ftype 声明描述了这个函数[function]的调用[call], 不是这个函数[function]实际的定义.

        细想一个以下形式的声明:

    ```LISP
    (type (function (arg0-type arg1-type ...) val-type) fn-valued-variable)
    ```

        这个声明有着这样的解释, 在这个声明的作用域里, 如果 fn-valued-variable 的值被调用, 参数不是指定的类型[type], 那么结果是未定义的; 一个合法调用产生的值会是 val-type 类型.

        与变量类型声明一样, 嵌套声明意味着类型[type]的交集, 如下:

        * 细想以下两种 ftype 的声明:

            ```LISP
            (ftype (function (arg0-type1 arg1-type1 ...) val-type1) f)
            ```

            还有

            ```LISP
            (ftype (function (arg0-type2 arg1-type2 ...) val-type2) f)
            ```

            如果这些声明都生效, 那么在这些声明的共享作用域内, 对 f 的调用可以被认为它是按下面这种方式声明的:

            ```LISP
            (ftype (function ((and arg0-type1 arg0-type2) (and arg1-type1 arg1-type2 ...) ...)
                            (and val-type1 val-type2)) 
                f))
            ```

            允许忽略一个或全部有效的 ftype 声明.

        * 如果一个变量的两个(或更多)类型声明生效, 并且它们都是 function 声明, 这些声明也会类似地组合. 

### <span id="TypeCOMPILEDFUNCTION">类型 COMPILED-FUNCTION</span>

* 超类型(Supertypes):

        compiled-function, function, t

* 描述(Description):

        如果一个函数不包含必须在运行时展开的宏[macro]的引用, 并且它也不包含加载期值[load time values]的未解决的引用, 那么任何这样的函数都可以被具体实现[implementation]认为是一个编译后的函数[compiled function]. 见章节 3.2.2 (编译语义).

        一个词法上出现在一个被 compile-file 编译并且被 load 加载的文件[file]中的函数[function]定义是 compiled-function 类型[type]. compile 函数产生的函数[function]也是 compiled-function 类型[type]. 其他函数[function]也可能是 compiled-function 类型[type]. 

### <span id="SystemClassGENERICFUNCTION">系统类 GENERIC-FUNCTION</span>

* 类优先级列表(Class Precedence List):

        generic-function, function, t

* 描述(Description):

        一个广义函数[generic function]是一个行为取决于提供给它的实参[argument]标识或类[class]的函数[function]. 一个广义函数对象包含一个方法[method]的集合, 一个 lambda 列表[lambda list], 一个方法组合[method combination]类型[type], 还有其他信息. 方法[method]定义了广义函数[generic function]的特定于类的行为和操作; 一个方法[method]也说是特化[specialize]一个广义函数[generic function]. 当被调用时, 一个广义函数[generic function]基于那些类[class]和实参[argument]标识去执行它的那些方法[method]的一个子集.

        一个广义函数[generic function]可以和普通函数[function]相同的方式被使用; 特别地, 一个广义函数[generic function]可以被用作 funcall 和 apply 的参数, 并且可以被赋予一个全局或局部的名字. 

### <span id="SystemClassSTANDARDGENERICFUNCTION">系统类 STANDARD-GENERIC-FUNCTION</span>

* 类优先级列表(Class Precedence List):

        standard-generic-function, generic-function, function, t

* 描述(Description):

        类[class] standard-generic-function 是 defmethod, ensure-generic-function, defgeneric, 和 defclass 表达式形式[form]建立的广义函数[generic function]的默认类[class]. 

### <span id="SystemClassCLASS">系统类 CLASS</span>

* 类优先级列表(Class Precedence List):

        class, standard-object, t

* 描述(Description):

        类型[type] class 表示确定它们的实例[instance]的结构的行为的对象[object]. 与 class 类型[type]的对象[object]相关联的信息是描述其在类[class]的非循环有向图中的位置, 它的槽[slot]还有它的选项的信息. 

### <span id="SystemClassBUILTINCLASS">系统类 BUILT-IN-CLASS</span>

* 类优先级列表(Class Precedence List):

        built-in-class, class, standard-object, t

* 描述(Description):

        一个内置类[built-in class]是一个实例[instance]具有限制功能和特殊表示的类[class]. 尝试用 defclass 去定义一个内置类[built-in class]的子类[subclass]会发出一个 error 类型[type]的错误. 调用 make-instance 去创建一个内置类[built-in class]的实例[instance]会发出一个 error 类型[type]的错误. 在一个内置类[built-in class]的实例[instance]上调用 slot-value 会发出一个 error 类型[type]的错误. 重定义一个内置类[built-in class]或使用 change-class 去改变一个实例[instance]的类[class]为内置类[built-in class]或改变一个内置类[built-in class]为其他类会发出一个 error 类型[type]的错误. 然而, 内置类[built-in class]可以被用作方法[method]的参数指定符[parameter specializer]. 

### <span id="SystemClassSTRUCTURECLASS">系统类 STRUCTURE-CLASS</span>

* 类优先级列表(Class Precedence List):

        structure-class, class, standard-object, t

* 描述(Description):

        所有通过 defstruct 定义的类[class]的都是类[class] structure-class 的实例[instance]. 

### <span id="SystemClassSTANDARDCLASS">系统类 STANDARD-CLASS</span>

* 类优先级列表(Class Precedence List):

        standard-class, class, standard-object, t

* 描述(Description):

        类[class] standard-class 是 defclass 定义出来的类[class]的默认类[class]. 

### <span id="SystemClassMETHOD">系统类 METHOD</span>

* 类优先级列表(Class Precedence List):

        method, t

* 描述(Description):

        一个方法[method]是表示一个广义函数[generic function]的行为的模块化部分的对象[object].

        一个方法[method]包含了实现这个方法[method]行为的代码[code], 一个指定什么时候这个给定方法[method]可以被应用的参数指定符[parameter specializer]序列, 还有一个被用于方法组合机制来辨别方法的限定符[qualifier]序列. 每一个方法[method]的每一个必要参数都有一个关联的参数指定符[parameter specializer], 并且只有在参数满足方法的这些参数指定符[parameter specializer]时, 该方法才会被调用.

        方法组合机制控制方法[method]的选择, 它们执行的顺序, 还有这个广义函数返回的值. 对象系统提供一个默认方法组合类型并且提供一个机制来声明新的方法组合类型.

* 参见(See Also):

        章节 7.6 (广义函数和方法) 

### <span id="SystemClassSTANDARDMETHOD">系统类 STANDARD-METHOD</span>

* 类优先级列表(Class Precedence List):

        standard-method, method, standard-object, t

* 描述(Description):

        这个类[class] standard-method 是 defmethod 和 defgeneric 表达式形式[form]定义的方法[method]的默认类[class]. 

### <span id="ClassSTRUCTUREOBJECT">类 STRUCTURE-OBJECT</span>

* 类优先级列表(Class Precedence List):

        structure-object, t

* 描述(Description):

        类[class] structure-object 是 structure-class 的一个实例[instance], 并且是作为 structure-class 的实例[instance]的除了它自身以外的每一个类[class]的超类[superclass], 并且是 defstruct 定义的每一个类[class]的超类[superclass].

* 参见(See Also):

        defstruct, 章节 2.4.8.13 (井号S(#S)), 章节 22.1.3.12 (打印结构体) 

### <span id="ClassSTANDARDOBJECT">类 STANDARD-OBJECT</span>

* 类优先级列表(Class Precedence List):

        standard-object, t

* 描述(Description):

        类[class] standard-object 是 standard-class 的一个实例[instance]并且是作为 standard-class 的实例[instance]的除了它自身以外的每个类[class]的超类[superclass]. 

### <span id="SystemClassMETHODCOMBINATION">系统类 METHOD-COMBINATION</span>

* 类优先级列表(Class Precedence List):

        method-combination, t

* 描述(Description):

        每一个方法组合[method combination]对象[object]是类[class] method-combination 的间接实例[indirect instance]. 一个方法组合[method combination]对象[object]表示这个方法组合[method combination]被一个广义函数[generic function]所使用的信息. 一个[method combination]对象[object]包含了方法组合[method combination]的类型还有这个类型[type]要使用的参数相关的信息. 

### <span id="SystemClassT">系统类 T</span>

* 类优先级列表(Class Precedence List):

        t

* 描述(Description):

        所有对象[object]的集合. 类型[type] t 是每个类型[type]的超类型[supertype], 包括它自身. 每个对象[object]都是类型[type] t. 

### <span id="TypeSpecifierSATISFIES">类型指定符 SATISFIES</span>

* 复合类型指定符种类(Compound Type Specifier Kind):

        谓语(Predicating).

* 复合类型指定符语法(Compound Type Specifier Syntax):

        satisfies predicate-name

* 复合类型指定符的参数(Compound Type Specifier Arguments):

        predicate-name---一个符号.

* 复合类型指定符的描述(Compound Type Specifier Description):

        这个表示满足断言[predicate] predicate-name 的所有对象[object]的集合, 这个断言必须是全局函数[function]定义为单参数断言的符号[symbol]. predicate-name 需要一个名字; 不允许 lambda 表达式[lambda expression]. 比如, 类型指定符[type specifier] (and integer (satisfies evenp)) 表示偶数整型的集合. 表达式 (typep x '(satisfies p)) 等价于 (if (p x) t nil).

        这个参数是必要的. 符号[symbol] * 可以是参数, 但是它表示它自身 (这个符号[symbol] *), 不表示一个未指定的类型.

        符号 satisfies 作为类型指定符[type specifier]是不合法的. 

### <span id="TypeSpecifierMEMBER">类型指定符 MEMBER</span>

* 复合类型指定符种类(Compound Type Specifier Kind):

        结合(Combining).

* 复合类型指定符语法(Compound Type Specifier Syntax):

        member object*

* 复合类型指定符的参数(Compound Type Specifier Arguments):

        object---一个对象[symbol].

* 复合类型指定符的描述(Compound Type Specifier Description):

        这表示这个集合包含 objects 命名的对象. 一个对象[object]只有在它 eql 指定的那些对象 objects 中的其中一个时才是这个类型[type].

        类型指定符[type specifier] (member) 和 nil 是等价的. * 可以在那些对象 objects 之中, 但是如果这样的话它表示它自身 (这个符号[symbol] *) 而不是表示一个未指定的值. 符号 member 作为类型指定符[type specifier]是非法的; 并且, 特别指出, 它既不是 (member) 的缩写也不是 (member *) 的缩写.

* 参见(See Also):

        类型[type] eql 

### <span id="TypeSpecifierNOT">类型指定符 NOT</span>

* 复合类型指定符种类(Compound Type Specifier Kind):

        结合(Combining).

* 复合类型指定符语法(Compound Type Specifier Syntax):

        not typespec

* 复合类型指定符的参数(Compound Type Specifier Arguments):

        typespec---一个类型指定符[type specifier].

* 复合类型指定符的描述(Compound Type Specifier Description):

        这表示所有不是类型[type] typespec 的对象的集合.

        这个参数是必要的, 并且不能是 *.

        符号 not 作为类型指定符[type specifier]是非法的. 

### <span id="TypeSpecifierAND">类型指定符 AND</span>

* 复合类型指定符种类(Compound Type Specifier Kind):

        结合(Combining).

* 复合类型指定符语法(Compound Type Specifier Syntax):

        and typespec*

* 复合类型指定符的参数(Compound Type Specifier Arguments):

        typespec---一个类型指定符[type specifier].

* 复合类型指定符的描述(Compound Type Specifier Description):

        这表示所有 typespecs 的交集所确定的类型[type]的对象[object]集合.

        * 不允许作为参数.

        类型指定符[type specifier] (and) 和 t 是等价的. 符号 and 作为一个类型指定符[type specifier]是不合法的, 并且, 特别指出, 它不是 (and) 的一个缩写. 

### <span id="TypeSpecifierOR">类型指定符 OR</span>

* 复合类型指定符种类(Compound Type Specifier Kind):

        结合(Combining).

* 复合类型指定符语法(Compound Type Specifier Syntax):

        or typespec*

* 复合类型指定符的参数(Compound Type Specifier Arguments):

        typespec---一个类型指定符[type specifier].

* 复合类型指定符的描述(Compound Type Specifier Description):

        这表示所有 typespecs 的并集所确定的类型[type]的对象[object]集合. 比如, 类型[type] list 定义等价于 (or null cons). 同样, 通过 position 返回的值是类型[type] (or null (integer 0 *)) 的一个对象[object]; 换句化说, 可以是 nil 或者一个非负整数[integer].

        * 不允许作为一个参数.

        类型指定符[type specifier] (or) 和 nil 是等价的. 符号 or 作为类型指定符[type specifier]是非法的; 并且, 特别指出, 这个不是 (or) 的缩写. 

### <span id="TypeSpecifierVALUES">类型指定符 VALUES</span>

* 复合类型指定符种类(Compound Type Specifier Kind):

        特化(Specializing).

* 复合类型指定符语法(Compound Type Specifier Syntax):

        values value-typespec

        value-typespec::= typespec* [&optional typespec*] [&rest typespec] [&allow-other-keys] 

* 复合类型指定符的参数(Compound Type Specifier Arguments):

        typespec---一个类型指定符[type specifier].

* 复合类型指定符的描述(Compound Type Specifier Description):

        这个类型指定符[type specifier]只能被用作一个 function 类型指定符[type specifier]或一个 the 特殊表达式形式[special form]的 value-type 部分. 当涉及到多值[multiple values]时它被用于指定单独的类型[type]. 这个 &optional 和 &rest 标记可以出现在 value-type 列表中; 它们指定和值一起传递给 multiple-value-call 的一个函数[function]的参数列表会正确地接收到那些值.

        符号 * 不能在 value-types 之中.

        符号 values 作为类型指定符[type specifier]是不合法的; 并且, 特别指出, 它不是 (values) 的缩写. 

### <span id="TypeSpecifierEQL">类型指定符 EQL</span>

* 复合类型指定符种类(Compound Type Specifier Kind):

        结合(Combining).

* 复合类型指定符语法(Compound Type Specifier Syntax):

        eql object

* 复合类型指定符的参数(Compound Type Specifier Arguments):

        object---一个对象.

* 复合类型指定符的描述(Compound Type Specifier Description):

        表示对于 (eql object x) 为 true 的所有 x 的类型[type].

        参数 object 是必要的. 这个 object 可以是 *, 但是如果是这样它表示它自身(这个符号[symbol] *) 并且不表示一个未指定的值. 符号[symbol] eql 作为一个原子类型指定符[atomic type specifier]是不合法的. 

### <span id="FunctionCOERCE">函数 COERCE</span>

* 语法(Syntax):

        coerce object result-type => result

* 参数和值(Arguments and Values):

        object---一个对象[object].
        result-type---一个类型指定符[type specifier].
        result---一个类型[type] result-type 的对象[object], 除了在章节 12.1.5.3 (复有理数的正规表示规则) 所描述的情况外.

* 描述(Description):

        强制转换[coerce]对象 object 为类型[type] result-type.

        如果对象 object 已经是类型[type] result-type, 返回对象 object 自身, 一般不管是否会有可能强制一些其他类型的对象为 result-type.

        否则, 这个 object 根据以下规则强制转换为类型[type] result-type:

    * sequence

            如果这个 result-type 是 list 的一个可识别子类型[recognizable subtype], 并且这个对象[object]是一个序列[sequence], 那么这个 result 是一个和对象 object 有者相同[same]元素[element]的列表[list].

            如果 result-type 是 vector 的一个可识别子类型[recognizable subtype], 并且这个对象[object]是一个序列[sequence], 那么这个 result 是一个和对象 object 有者相同[same]元素[element]的向量[vector]. 如果 result-type 是一个特化的类型[type], 那么 result 会有一个实际数组元素类型[actual array element type], 它是对特化[specialized]类型[type]的元素类型部分进行提升的结果. 如果没有指定元素类型, 那么这个元素类型默认是 t. 如果具体实现[implementation]不能确定元素类型, 会发出一个错误.

    * character

            如果这个 result-type 是 character 并且这个对象[object]是一个字符标识符[character designator], 那么这个 result 是它表示的字符[character].

    * complex

            如果这个 result-type 是 complex 而这个对象[object]是一个实数[real], 那么这个 result 是通过构造一个实部是这个对象[object]并且虚部是将一个整数[integer] 0 强制转为这个对象[object]的类型[type]的结果(使用 coerce)的复数[complex]来获取到的. (然而, 如果这个实部是一个有理数[rational], 那么结果必须被表示为一个有理数[rational]而不是一个复数[complex]; 见章节 12.1.5.3 (复有理数的正规表示规则). 所以, 比如, (coerce 3 'complex) 允许的, 但是会返回 3, 它不是一个复数[complex].)

    * float

            如果 result-type 是 float, short-float, single-float, double-float, long-float 中的任何一个, 并且这个对象[object]是一个实数[real], 那么 result 是一个 result-type 类型[type]的浮点数[float], 无论那个浮点数[float]表示法允许的是多大的表征精度, 它都和这个对象[object]的符号和大小是相等的. (如果这个 result-type 是 float 并且对象 object 还不是一个浮点数[float], 那么这个 result 是一个单浮点数[single-float].)

    * function

            如果 result-type 是 function, 并且对象 object 是任何被 fbound 的函数名字[function name]但是既不是全局定义的宏名字[macro name]也不是特殊操作符[special operator], 那么这个 result 是对象 object 的函数值[functional value].

            如果 result-type 是 function, 而对象 object 是一个 lambda 表达式[lambda expression], 那么这个 result 是 object 在空词法环境[null lexical environment]的一个闭包[closure].

    * t

            任何对象 object 可以被强制转为 t 类型[type]的对象[object]. 这个情况下, 这个 object 被简单地返回.

* 示例(Examples):

    ```LISP
    (coerce '(a b c) 'vector) =>  #(A B C)
    (coerce 'a 'character) =>  #\A
    (coerce 4.56 'complex) =>  #C(4.56 0.0)
    (coerce 4.5s0 'complex) =>  #C(4.5s0 0.0s0)
    (coerce 7/2 'complex) =>  7/2
    (coerce 0 'short-float) =>  0.0s0
    (coerce 3.5L0 'float) =>  3.5L0
    (coerce 7/2 'float) =>  3.5
    (coerce (cons 1 2) t) =>  (1 . 2)
    ```

        所有以下表达式形式[form]都会发出一个错误:

    ```LISP
    (coerce '(a b c) '(vector * 4))
    (coerce #(a b c) '(vector * 4))
    (coerce '(a b c) '(vector * 2))
    (coerce #(a b c) '(vector * 2))
    (coerce "foo" '(string 2))
    (coerce #(#\a #\b #\c) '(string 2))
    (coerce '(0 1) '(simple-bit-vector 3))
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果一个强制转换是不可以的, 会发出一个 type-error 类型[type]的错误.

        (coerce x 'nil) 总是发出一个 type-error 类型[type]的错误.

        如果 result-type 是一个 function 但是对象 object 是一个没有被 fbound 的符号[symbol]或者这个符号[symbol]命名一个宏[macro]或特殊操作符[special operator], 那么就会发出一个 error 类型[type]的错误.

        如果 result-type 指定了元素数量而对象 object 是不同长度的, 那么应该发出 type-error 类型[type]的错误.

* 参见(See Also):

        rational, floor, char-code, char-int

* 注意(Notes):

        由于舍入问题, 没有提供从浮点数[float]到有理数[rational]和从比率[ratio]到整数[integer]的强制转换.

    ```LISP
    (coerce x 't) ==  (identity x) ==  x
    ```

### <span id="MacroDEFTYPE">宏 DEFTYPE</span>

* 语法(Syntax):

        deftype name lambda-list [[declaration* | documentation]] form* => name

* 参数和值(Arguments and Values):

        name---一个符号[symbol].
        lambda-list---一个 deftype lambda 列表[deftype lambda list].
        declaration---一个 declare 表达式[expression]; 不求值.
        documentation---一个字符串[string]; 不求值.
        form---一个表达式形式[form].

* 描述(Description):

        deftype 定义一个名为 name 的派生类型指定符[derived type specifier].

        新的类型指定符[type specifier]的意义在于一个函数, 它将这个类型指定符[type specifier]展开为另一个类型指定符[type specifier], 如果另一个类型指定符自身包含对另一个派生类型指定符[derived type specifier]的引用, 它本身就会被展开.

        新定义的类型指定符[type specifier]可以用 (name arg1 arg2 ...) 形式的一个列表来引用. 参数的数量必须和 lambda-list 一样. 如果新的类型指定符[type specifier]不接受参数, 或者它的所有参数是可选的, 这个类型指定符[type specifier]可以被用作原子类型指定符[atomic type specifier].

        给这个类型指定符[type specifier]的实参[argument]表达式[expression], arg1 ... argn, 是不求值的. 相反, 这些字面化[literal]对象[object]变成了相应的形参[parameter]被绑定[bound]的对象[object].

        这个 deftype 表达式形式[form]主体部分(不是 lambda-list)隐含在一个名为 name 的块[block]中, 并且作为一个隐式 progn [implicit progn]被求值, 返回一个新的类型指定符[type specifier].

        这个主体部分的词法环境[lexical environment]是 deftype 表达式形式被求值时的当前那个, 由 lambda-list 中的那些变量[variable]来扩展.

        作为展开式返回的类型说明符[type specifier]的递归展开必须终止, 包括在展开式中嵌套的那些类型指定符[type specifier]的展开式.

        如果完全展开一个类型指定符[type specifier]的结果包含任何环状结构, 那么其结果是未定义的, 除非是在被 member 和 eql 类型指定符[type specifier]引用的对象[object]中.

        这个 documentation 作为 type 种类的文档字符串[documentation string]关联到 name.

        如果一个 deftype 表达式形式[form]作为顶层表达式形式[top level form]出现, 编译器[compiler]必须确保 name 在后续类型[type]声明中被识别. 如果这个 name 在后续类型[type]声明中被引用, 那么程序员[programmer]必须确保这个 deftype 表达式形式的主体部分可以在编译时被求值. 如果一个类型指定符[type specifier]的展开式没有在编译时被完全定义 (或许是因为它展开为一个未知类型指定符[type specifier]或者一个已命名函数[function]的满足因素[satisfies]没有在这个编译时环境中定义), 那么一个具体实现[implementation]可能忽略任何声明中这个类型[type]的引用 并且/或者 发出一个警告.

* 示例(Examples):

    ```LISP
    (defun equidimensional (a)
      (or (< (array-rank a) 2)
          (apply #'= (array-dimensions a)))) =>  EQUIDIMENSIONAL
    (deftype square-matrix (&optional type size)
      `(and (array ,type (,size ,size))
            (satisfies equidimensional))) =>  SQUARE-MATRIX
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        declare, defmacro, documentation, 章节 4.2.3 (类型指定符), 章节 3.4.11 (文档字符串和声明的语法交互)

* 注意(Notes): None. 

### <span id="FunctionSUBTYPEP">函数 SUBTYPEP</span>

* 语法(Syntax):

        subtypep type-1 type-2 &optional environment => subtype-p, valid-p

* 参数和值(Arguments and Values):

        type-1---一个类型指定符[type specifier].
        type-2---一个类型指定符[type specifier].
        environment---一个环境[environment]对象[object]. 默认是 nil, 表示空词法环境[null lexical environment]和当前的全局环境[global environment].
        subtype-p---一个广义的 boolean [generalized boolean].
        valid-p---一个广义的 boolean [generalized boolean].

* 描述(Description):

        如果 type-1 是 type-2 的一个可识别子类型[recognizable subtype], 第一个值[value]就是 true. 否则, 第一个值[value]就是 false, 表示 type-1 不是 type-2 的子类型[subtype], 或者 type-1 是 type-2 的子类型[subtype]但是不是一个可识别子类型[recognizable subtype].

        返回的第二个值[value]表示第一个值[value]的'确定性(certainty)'. 如果这个值是 true, 那么第一个值就是子类型[subtype]关系的精确表示. (当第一个值[value]是 true 时第二个值[value]总是为 true.)

        下面这段总结了返回值[value]的可能的组合.

            值 1     值 2     意义                                               
            true     true     type-1 确定是 type-2 的子类型[subtype].             
            false    true     type-1 确定不是 type-2 的子类型[subtype].         
            false    false    subtypep 不能确定关系, 所以 type-1 可能或可能不是 type-2 的子类型[subtype].  

            Figure 4-9. subtypep 结果的可能性

        subtypep 只有当至少一个参数涉及到后面其中一个类型指定符[type specifier]时才允许返回 false 和 false 的多值[values]: and, eql, function 的列表表达式, member, not, or, satisfies, or values. (在被类型[type]展开后, 如果一个类型指定符[type specifier]将一个符号[symbol]包含在某个位置, 该位置将调用它作为一个要被使用的类型指定符[type specifier]的意义, 那么这个类型指定符[type specifier]就'涉及'这样一个符号[symbol].) 一个可能的推论是, 如果 type-1 和 type-2 都不涉及这些类型指定符[type specifier], 那么 subtypep 不得不去准确确定关系. 具体来说, 如果那些参数是 equal 的并且不涉及任何这些类型指定符[type specifier]时 subtypep 返回 true 和 true 的多值[values].

        当 type-1 和 type-2 只涉及 Figure 4-2 中的名字, 或者由 defstruct, define-condition, 或 defclass 定义的类型[type]的名字, 或者只展开到那些名字的衍生类型[derived type]时, subtypep 第二个返回值一定不是 nil. 当列在 Figure 4-2 的类型指定符[type specifier]还有 defclass 和 defstruct 名称在一些情况下被实现为衍生类型[derived type]时, subtypep 把它们当作原语(primitive).

        subtypep 所反映的类型[type]之间的关系是特定于具体实现的那些. 比如, 如果一个实现只支持浮点数的单个类型, 在那个实现中 (subtypep 'float 'long-float) 返回 true 和 true 的多值[values] (因为两个类型[type]是一样的).

        对于所有除了 * 以外的 T1 和 T2, 当且仅当 (array T1) 和 (array T2) 指向相同特化表示的数组[array]时, 它们是总指向相同集合的两种不同的类型指定符[type specifier], 换句话说, 就是当且仅当 (upgraded-array-element-type 'T1) 和 (upgraded-array-element-type 'T2) 返回两个指向相同对象集合的不同类型指定符. 这是 `(array type-specifier) 和 `(array ,(upgraded-array-element-type 'type-specifier)) 指向相同特化数组[array]表示的另一种说法. 对于所有除了 * 以外的 T1 和 T2, 当且仅当 (array T1) 和 (array T2) 指向不同的有区别特化表示的数组时, 它们的交集是个空集合.

        因此,

    ```LISP
    (subtypep '(array T1) '(array T2)) =>  true
    ```

        当且仅当 (upgraded-array-element-type 'T1) 和 (upgraded-array-element-type 'T2) 返回两个指向相同对象[object]集合的不同类型指定符[type specifier]的时候.

        对于所有除了 * 以外的类型指定符 T1 和 T2,

    ```LISP
    (subtypep '(complex T1) '(complex T2)) =>  true, true
    ```

        如果:

        1. T1 是 T2 的子类型[subtype], 或者
        2. (upgraded-complex-part-type 'T1) 和 (upgraded-complex-part-type 'T2) 返回指向相同对象集合的不同类型指定符[type specifier]; 这个情况下, (complex T1) 和 (complex T2) 都指向相同的特化表示.

        否则多值[values]就是 false 和 true.

        表达式形式

    ```LISP
    (subtypep '(complex single-float) '(complex float))
    ```

        在所有实现一定返回 true, 但是

    ```LISP
    (subtypep '(array single-float) '(array float))
    ```

        只有在没有为单浮点[single float]和其他浮点数[float]作区分的特化数组[array]表示的具体实现中返回 true.

* 示例(Examples):

    ```LISP
    (subtypep 'compiled-function 'function) =>  true, true
    (subtypep 'null 'list) =>  true, true
    (subtypep 'null 'symbol) =>  true, true
    (subtypep 'integer 'string) =>  false, true
    (subtypep '(satisfies dummy) nil) =>  false, implementation-dependent
    (subtypep '(integer 1 3) '(integer 1 4)) =>  true, true
    (subtypep '(integer (0) (0)) 'nil) =>  true, true
    (subtypep 'nil '(integer (0) (0))) =>  true, true
    (subtypep '(integer (0) (0)) '(member)) =>  true, true ;or false, false
    (subtypep '(member) 'nil) =>  true, true ;or false, false
    (subtypep 'nil '(member)) =>  true, true ;or false, false
    ```

        让 <aet-x> 和 <aet-y> 是两个有区别的类型指定符[type specifier], 在一个给定实现中不总是指向相同对象[object]集合, 但是 make-array 对于它们, 会返回一个相同数组[array]类型[type]的对象[object].

        因此, 在每种情况下,

    ```LISP
    (subtypep (array-element-type (make-array 0 :element-type '<aet-x>))
        (array-element-type (make-array 0 :element-type '<aet-y>)))
    =>  true, true

    (subtypep (array-element-type (make-array 0 :element-type '<aet-y>))
        (array-element-type (make-array 0 :element-type '<aet-x>)))
    =>  true, true
    ```

        如果 (array <aet-x>) 和 (array <aet-y>) 是相同对象[object]集合的不同名称, 这些名字应该指向相同的对象[object]集合. 这意味着下面的测试也是正确的:

    ```LISP
    (subtypep '(array <aet-x>) '(array <aet-y>)) =>  true, true
    (subtypep '(array <aet-y>) '(array <aet-x>)) =>  true, true
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        章节 4.2 (类型)

* 注意(Notes):

        对于 array 和 complex 类型, subtypep 规范中细微的差异是有必要的, 因为这里没有复数[complex]的创建函数允许产生的各个部分类型独立于这些部分的实际类型. 因此，在 complex 类型[type]的情况下, 虽然一个数字[number]可以是不止一个类型[type]的成员, 但引用的是它的实际类型. 比如, 17 是类型[type] (mod 18) 也是类型[type] (mod 256) 并且也是 integer 类型[type]; 还有 2.3f5 是类型[type] single-float 也是类型[type] float. 

### <span id="FunctionTYPEOF">函数 TYPE-OF</span>

* 语法(Syntax):

        type-of object => typespec

* 参数和值(Arguments and Values):

        object---一个对象[object].
        typespec---一个类型指定符[type specifier].

* 描述(Description):

    返回一个类型[type]的类型指定符[type specifier], typespec, 这个类型有着对象 object 作为它的一个元素[element]. 这个 typespec 满足以下条件:

    1. 对于任何是内置类型[built-in type]的元素[element]的对象 object:

        a. 返回的类型[type]是一个内置类型[built-in type]的可识别子类型[recognizable subtype].

        b. 返回的类型[type]没有涉及 and, eql, member, not, or, satisfies, 或 values.

    2. 对于所有对象 object, (typep object (type-of object)) 返回 true. 其中隐含的是类型指定符[type specifier]和 typep 一起使用是无效的, 比如 function 类型指定符[type specifier]的列表[list]表达式形式是从来不会被 type-of 返回的.

    3. type-of 返回的类型[type]总是为 class-of 返回的类[class]的可识别子类型[recognizable subtype]. 这也就是说,

        ```LISP
        (subtypep (type-of object) (class-of object)) =>  true, true
        ```

    4. 对于元类 structure-class 或 standard-class 的对象 object, 还有状况[condition], type-of 返回那个由 class-of 返回的类[class]的专有名字[proper name], 如果有的话, 否则返回这个类本身. 具体来说, 对于一个由不带 :type 选项的 defstruct 定义的结构体的构造器函数创建的对象 object, type-of 返回结构体的名字; 对于由 make-condition 创建的对象 object, 这个 typespec 就是状况[condition]类型[type]的名字[name].

    5. 对于类型[type] short-float, single-float, double-float, 或 long-float 中的每一个, 如果 object 是其中一个的元素[element], 这个 typespec 是那个类型[type]的可识别子类型[recognizable subtype].

* 示例(Examples):

    ```LISP
    (type-of 'a) =>  SYMBOL          
    (type-of '(1 . 2))
    =>  CONS
    OR=>  (CONS FIXNUM FIXNUM)
    (type-of #c(0 1))
    =>  COMPLEX
    OR=>  (COMPLEX INTEGER)
    (defstruct temp-struct x y z) =>  TEMP-STRUCT
    (type-of (make-temp-struct)) =>  TEMP-STRUCT
    (type-of "abc")
    =>  STRING
    OR=>  (STRING 3)
    (subtypep (type-of "abc") 'string) =>  true, true
    (type-of (expt 2 40))
    =>  BIGNUM
    OR=>  INTEGER
    OR=>  (INTEGER 1099511627776 1099511627776)
    OR=>  SYSTEM::TWO-WORD-BIGNUM
    OR=>  FIXNUM
    (subtypep (type-of 112312) 'integer) =>  true, true
    (defvar *foo* (make-array 5 :element-type t)) =>  *FOO*
    (class-name (class-of *foo*)) =>  VECTOR
    (type-of *foo*)
    =>  VECTOR
    OR=>  (VECTOR T 5)
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        array-element-type, class-of, defstruct, typecase, typep, 章节 4.2 (类型)

* 注意(Notes):

        鼓励实现者去安排 type-of 返回一个可移植的值. 

### <span id="FunctionTYPEP">函数 TYPEP</span>

* 语法(Syntax):

        typep object type-specifier &optional environment => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        type-specifier---任何除了 values 以外的类型指定符[type specifier], 或者是一个第一个元素为 function 或 values 的类型指定符[type specifier]列表.
        environment---一个环境[environment]对象[object]. 默认是 nil, 表示空词法环境[null lexical environment]和当前的全局环境[global environment].
        generalized-boolean---一个广义的 boolean [generalized boolean].

* 描述(Description):

        如果 object 是类型指定符 type-specifier 所指定的类型[type]就返回 true;否则, 返回 false.

        表达式形式 (satisfies fn) 作为类型指定符 type-specifier 的话, 就通过应用函数 fn 给 object 来处理.

        (typep object '(array type-specifier)), 其中 type-specifier 不是 *, 当且仅当 object 是一个可以通过提供 type-specifier 作为 make-array 的 :element-type 参数所构建出来的数组[array]时返回 true. (array *) 指向所有数组[array]不管其元素类型, 而 (array type-specifier) 只指向那些可以通过把 type-specifier 作为 make-array 的 :element-type 参数所构建出来的数组[array]. 一个类似的解释可以应用于 (simple-array type-specifier) 和 (vector type-specifier). 见章节 15.1.2.1 (数组提升).

        (typep object '(complex type-specifier)) 对于所有可以通过给定 type-specifier 类型的数字到函数[function] complex 来产生的复数返回 true, 附加其他相同特化表示的复数[complex]. 任何这样的复数[complex]的实部和虚部必须满足:

    ```LISP
    (typep realpart 'type-specifier)
    (typep imagpart 'type-specifier)
    ```

        见函数[function] upgraded-complex-part-type.

* 示例(Examples):

    ```LISP
    (typep 12 'integer) =>  true
    (typep (1+ most-positive-fixnum) 'fixnum) =>  false
    (typep nil t) =>  true
    (typep nil nil) =>  false
    (typep 1 '(mod 2)) =>  true
    (typep #c(1 1) '(complex (eql 1))) =>  true
    ;; To understand this next example, you might need to refer to
    ;; Section 12.1.5.3 (Rule of Canonical Representation for Complex Rationals).
    (typep #c(0 0) '(complex (eql 0))) =>  false
    ```

        让 Ax 和 Ay 为表示不同类型[type]的类型指定符[type specifier], 但是对于它们

    ```LISP
    (upgraded-array-element-type 'Ax)
    ```

        和

    ```LISP
    (upgraded-array-element-type 'Ay)
    ```

        表示相同的类型[type]. 注意

    ```LISP
    (typep (make-array 0 :element-type 'Ax) '(array Ax)) =>  true
    (typep (make-array 0 :element-type 'Ay) '(array Ay)) =>  true
    (typep (make-array 0 :element-type 'Ax) '(array Ay)) =>  true
    (typep (make-array 0 :element-type 'Ay) '(array Ax)) =>  true
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 type-specifier 是 values, 或者第一个元素是 function 或 values 的类型指定符[type specifier]列表, 那么就会发出一个 error 类型[type]的错误.

        如果 type-specifier 不是一个类型指定符[type specifier], 那么结果是未定义的.

* 参见(See Also):

        type-of, upgraded-array-element-type, upgraded-complex-part-type, 章节 4.2.3 (类型指定符)

* 注意(Notes):

        鼓励具体实现[implementation]去识别和优化 (typep x (the class y)) 的情况, 因为它不需要在运行时展开 deftype 信息. 

### <span id="ConditionTypeTYPEERROR">状况类型 TYPE-ERROR</span>

* 类优先级列表(Class Precedence List):

        type-error, error, serious-condition, condition, t

* 描述(Description):

        类型[type] type-error 表示一个对象[object]不是期望类型的情况. 这个违反基准(offending datum)和期望类型(expected type)被 make-condition 的名为 :datum 和 :expected-type 的参数所初始化, 并且通过函数 type-error-datum 和 type-error-expected-type 来访问.

* 参见(See Also):

        type-error-datum, type-error-expected-type 

### <span id="FunctionTEDTEET">函数 TYPE-ERROR-DATUM, TYPE-ERROR-EXPECTED-TYPE</span>

* 语法(Syntax):

        type-error-datum condition => datum

        type-error-expected-type condition => expected-type

* 参数和值(Arguments and Values):

        condition---一个 type-error 类型[type]的状况[condition].
        datum---一个对象[object].
        expected-type---一个类型指定符[type specifier].

* 描述(Description):

        type-error-datum 返回由 condition 表示的情况[situation]的违反基准.

        type-error-expected-type 返回由 condition 表示的违反基准的期望类型.

* 示例(Examples):

    ```LISP
    (defun fix-digits (condition)
      (check-type condition type-error)
      (let* ((digits '(zero one two three four
              five six seven eight nine))
             (val (position (type-error-datum condition) digits)))
        (if (and val (subtypep 'fixnum (type-error-expected-type condition)))
          (store-value 7))))

    (defun foo (x)
      (handler-bind ((type-error #'fix-digits))
        (check-type x number)
        (+ x 3)))

    (foo 'seven)
    =>  10
    ```LISP

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        type-error, 章节 9 (状况)

* 注意(Notes): None. 

### <span id="ConditionTypeSIMPLETYPEERROR">状况类型 SIMPLE-TYPE-ERROR</span>

* 类优先级列表(Class Precedence List):

        simple-type-error, simple-condition, type-error, error, serious-condition, condition, t

* 描述(Description):

        类型[type] simple-type-error 的状况[condition]类似类型[type] type-error 的状况[condition], 除了它们提供了另一种机制来指定如何报告状况[condition]; 见类型 simple-condition.

* 参见(See Also):

        simple-condition, simple-condition-format-control, simple-condition-format-arguments, type-error-datum, type-error-expected-type 


# 5. 数据和控制流

> * 5.1 [广义引用](#GeneralizedReference)
> * 5.2 [退出点的控制转移](#TCEP)
> * 5.3 [数据和控制流字典](#DCFDictionary)

## 5.1 <span id="GeneralizedReference">广义引用</span>

> * 5.1.1 [位置和广义引用的概述](#OverviewPlacesGeneralizedReference)
> * 5.1.2 [位置的种类](#KindsOfPlaces)
> * 5.1.3 [基于 SETF 的其他宏的处理](#TreatmentMacrosSETF)

### 5.1.1 <span id="OverviewPlacesGeneralizedReference">位置和广义引用的概述</span>

一个广义引用[generalized reference]是一个表达式形式[form]的使用, 这个表达式形式[form]有时也称作一个位置[place], 就好像它是一个可以被读写的变量[variable]. 一个位置[place]的值[value]就是这个位置[place]表达式形式[form]求值后的对象[object]. 一个位置[place]的值[value]可以通过使用 setf 来改变. 绑定一个位置[place]的概念没有在 Common Lisp 中定义, 但是一个具体实现[implementation]允许通过定义它的概念来扩展这个语言.

下面这段包含了 setf 使用的示例. 注意, 求值第二列的表达式形式[form]返回的值没有必要和求值第三列中的表达式形式[form]获取到的值一样. 总之, setf 表达式形式[form]准确的宏展开[macro expansion]是不保证的, 甚至是依赖于具体实现的[implementation-dependent]; 可以保证的是, 这个展开式是一个针对特定实现[implementation]的更新表达式形式, 对子表达式形式[subform]的从左到右求值是保留的, 而求值 setf 的最终结果是存储的值或多值.

|访问函数(Access function) |  更新函数(Update Function) |  使用 setf 更新   |
| -              | -                | -                               |
|x               |  (setq x datum)  |  (setf x datum)                 |
|(car x)         |  (rplaca x datum)|  (setf (car x) datum)           |
|(symbol-value x)|  (set x datum)   |  (setf (symbol-value x) datum)  |

Figure 5-1. setf 的示例

下面这段展示了和位置[place]以及广义引用[generalized reference]相关的操作符[operator].

    assert                defsetf             push
    ccase                 get-setf-expansion  remf
    ctypecase             getf                rotatef
    decf                  incf                setf
    define-modify-macro   pop                 shiftf
    define-setf-expander  psetf

Figure 5-2. 位置[place]以及广义引用[generalized reference]相关的操作符.

上面的一些操作符[operator]操作位置[place], 而一些操作 setf 展开器[setf expander]. 一个 setf 展开器[setf expander]可以来自于任何位置[place]. 可以通过使用 defsetf 和 define-setf-expander 来定义新的 setf 展开器[setf expander].

> * 5.1.1.1 [位置的子表达式形式求值](#EvaluationSubformsPlaces)
> * 5.1.1.2 [Setf 展开式](#SetfExpansions)

#### 5.1.1.1 <span id="EvaluationSubformsPlaces">位置的子表达式形式求值</span>

以下规则应用于位置[place]的子表达式形式[subform]的求值[evaluation]:

1. 一个位置[place]中的子表达式形式[subform]的求值顺序由 get-setf-expansion 返回的第二个值指定的顺序所决定. 对于这个标准定义的所有位置[place] (比如, getf, ldb, ...), 求值的顺序是从左到右的. 当一个位置[place]从一个宏展开式中得到, 这个规则将在宏展开后应用, 以找到合适的位置[place].

    通过使用 defmacro 或 define-setf-expander 定义的位置[place]使用这些定义所定义的求值顺序. 比如, 思考下面这个:

    ```LISP
    (defmacro wrong-order (x y) `(getf ,y ,x))
    ```

    下面这个表达式形式[form]先求值 place2 然后再是 place1 因为这个是它们在宏展开式中的求值顺序:

    ```LISP
    (push value (wrong-order place1 place2))
    ```

2. 对于操纵位置[place]的宏[macro] (push, pushnew, remf, incf, decf, shiftf, rotatef, psetf, setf, pop, 还有那些 define-modify-macro 定义的宏), 宏调用的子表达式形式[subform]按从左到右的顺序求值一次, 其中这些位置[place]的子表达式形式[subform]按照 (1) 中指定的顺序求值.

    push, pushnew, remf, incf, decf, shiftf, rotatef, psetf, pop 在修改任意位置[place]之前求值所有子表达式形式[subform]. setf (当 setf 有超过两个参数的情况下) 在序列中的每一对上执行它的操作. 比如, 在下面这个表达式中

    ```LISP
    (setf place1 value1 place2 value2 ...)
    ```

    子表达式形式[subform] place1 和 value1 被求值, 修改 place1 指定的位置来包含 value1 返回的值, 然后 setf 表达式形式的剩余部分按照类似的方式处理.

3. 对于 check-type, ctypecase, 和 ccase, 位置[place]的子表达式形式[subform]像 (1) 中那样被求值一次, 但是如果 check-type 中类型检测失败了或者 ctypecase 和 ccase 中没有情况(case)被处理可能会再次求值.

4. 对于 assert, 广义引用[generalized reference]的求值顺序没有被指定.

规则 2, 3 和 4 覆盖所有操作位置[place]的标准化[standardized]宏[macro].

##### 5.1.1.1.1 对位置的子表达式形式求值的示例

```LISP
(let ((ref2 (list '())))
  (push (progn (princ "1") 'ref-1)
        (car (progn (princ "2") ref2))))
>>  12
=>  (REF-1)

(let (x)
  (push (setq x (list 'a))
        (car (setq x (list 'b))))
    x)
=>  (((A) . B))
```

push 先求值 (setq x (list 'a)) => (a), 然后求值 (setq x (list 'b)) => (b), 再修改最后的值的 car 部分为 ((a) . b).

#### 5.1.1.2 <span id="SetfExpansions">Setf 展开式</span>

有时避免多次求值一个位置[place]的子表达式形式[subform]或以错误的顺序求值是可能的. 对于一个给定的表达式形式, 一个 setf 展开式[setf expansion]可以被表达为五个对象[object]的一个有序集合:

临时对象的列表

    一个命名临时变量的符号列表, 这些符号被依次绑定到由值表达式形式返回的那些值, 就像是通过 let* 一样.

值表达式形式列表

    一个表达式形式列表(典型地, 这个位置[place]的子表达式形式[subform]), 当求值时, 会产生相应的临时变量应该被绑定的值.

存储变量的列表

    一个用来命名临时存储变量的符号列表, 用来保存将被分配给这个位置[place]的新值.

存储表达式形式

    一个可以同时引用临时变量和存储变量的表达式形式, 它会改变这个位置[place]的值[value], 并保证返回存储变量的值作为它的值, 这是 setf 返回的正确值.

访问表达式形式

    一个可以引用临时变量并且返回这个位置[place]的值[value]的表达式形式[form].

访问表达式形式返回的值受到存储表达式形式执行的影响, 但是这些表达式形式中的任何一种都可能被多次求值.

可以通过 psetf, shiftf 和 rotatef 并行执行多个 setf. 由于这个, setf 展开器[setf expander]必须每次产生新的临时和存储变量名字. 关于如何去做这个的示例, 见 gensym.

对于每一个标准化[standardized]的访问器函数 F, 除非它被显式地记载, 否则使用一个 F 表达式形式[form]作为一个 setf 位置[place]的能力被实现为使用一个 setf 展开器[setf expander]还是一个 setf 函数[setf function], 是依赖于具体实现的[implementation-dependent]. 同样, 由此可以得出, 名字 (setf F) 是否被 fbound 是依赖于具体实现的[implementation-dependent].

##### 5.1.1.2.1 Setf 展开式的示例

下面是 setf 展开式[setf expansion]组成成分内容的示例.

对于一个变量 x:

```LISP
()              ;list of temporary variables
()              ;list of value forms
(g0001)         ;list of store variables
(setq x g0001)  ;storing form
x               ;accessing form
```

Figure 5-3. 一个变量的简单 setf 展开式

对于 (car exp):

```LISP
(g0002)                             ;list of temporary variables
(exp)                               ;list of value forms
(g0003)                             ;list of store variables
(progn (rplaca g0002 g0003) g0003)  ;storing form
(car g0002)                         ;accessing form
```

Figure 5-4. CAR 表达式形式的简单 setf 展开式

对于 (subseq seq s e):

```LISP
(g0004 g0005 g0006)         ;list of temporary variables
(seq s e)                   ;list of value forms
(g0007)                     ;list of store variables
(progn (replace g0004 g0007 :start1 g0005 :end1 g0006) g0007)
                            ;storing form
(subseq g0004 g0005 g0006)  ; accessing form
```

Figure 5-5. SUBSEQ 表达式形式的简单 setf 展开式

在一些情况下, 如果一个位置[place]的一个子表达式形式[subform]自身也是一个位置[place], 为了计算外面的位置[place]展开式的一些值, 展开子表达式形式[subform]是有必要的. 对于 (ldb bs (car exp)):

```LISP
(g0001 g0002)            ;list of temporary variables
(bs exp)                 ;list of value forms
(g0003)                  ;list of store variables
(progn (rplaca g0002 (dpb g0003 g0001 (car g0002))) g0003)
                         ;storing form
(ldb g0001 (car g0002))  ; accessing form
```

Figure 5-6. LDB 表达式形式的简单 setf 展开式

### 5.1.2 <span id="KindsOfPlaces">位置的种类</span>

Common Lisp 定义了多个位置[place]的种类; 这个章节会列举它们. 这个集合可以被具体实现[implementation]和程序员的代码[programmer code]所扩展.

> * 5.1.2.1 [变量名作为位置](#VariableNamesPlaces)
> * 5.1.2.2 [函数调用表达式形式作为位置](#FunctionCallFormsPlaces)
> * 5.1.2.3 [VALUES 表达式形式作为位置](#VALUESFormsPlaces)
> * 5.1.2.4 [THE 表达式形式作为位置](#THEFormsPlaces)
> * 5.1.2.5 [APPLY 表达式形式作为位置](#APPLYFormsPlaces)
> * 5.1.2.6 [Setf 展开式和位置](#SetfExpansionsPlaces)
> * 5.1.2.7 [宏表达式形式作为位置](#MacroFormsPlaces)
> * 5.1.2.8 [符号宏作为位置](#SymbolMacrosPlaces)
> * 5.1.2.9 [其他复合表达式形式作为位置](#OtherCompoundFormsPlaces)

#### 5.1.2.1 <span id="VariableNamesPlaces">变量名作为位置</span>

一个词法变量[lexical variable]或动态变量[dynamic variable]的名字可以被用作一个位置[place].

#### 5.1.2.2 <span id="FunctionCallFormsPlaces">函数调用表达式形式作为位置</span>

如果一个函数表达式形式[function form]属于下列类别之一, 它被用作一个位置[place]:

  * 第一个元素是下面这段中任何一个函数名的函数调用表达式形式.

        aref    cdadr                    get
        bit     cdar                     gethash
        caaaar  cddaar                   logical-pathname-translations
        caaadr  cddadr                   macro-function
        caaar   cddar                    ninth
        caadar  cdddar                   nth
        caaddr  cddddr                   readtable-case
        caadr   cdddr                    rest
        caar    cddr                     row-major-aref
        cadaar  cdr                      sbit
        cadadr  char                     schar
        cadar   class-name               second
        caddar  compiler-macro-function  seventh
        cadddr  documentation            sixth
        caddr   eighth                   slot-value
        cadr    elt                      subseq
        car     fdefinition              svref
        cdaaar  fifth                    symbol-function
        cdaadr  fill-pointer             symbol-plist
        cdaar   find-class               symbol-value
        cdadar  first                    tenth
        cdaddr  fourth                   third

        Figure 5-7. 可以和 setf 一起使用的函数---1

    在 subseq 的情况中, 替换的值必须是一个序列[sequence], 其元素可能被 subseq 的序列参数所包含, 但它不一定是与指定子序列的序列[sequence]相同类型[type]的序列[sequence]. 如果替换的值的长度和要被替换的子序列长度不一样, 那么更短的那个长度决定要被存储的元素的数量, 如 replace.

* 第一个元素是 defstruct 构造的选择器函数的名字的一个函数调用表达式形式. 这个函数名字必须引用全局函数定义, 而不是一个局部定义的函数[function].

* 第一个元素是下面这段中任何一个函数名的函数调用表达式形式, 前提是给那个函数的提供的参数为一个位置[place]表达式形式; 在本例中, 新位置[place]存储回了调用提供的"更新(update)"函数的结果中.

    |函数名      |    是位置(place)的参数  | 使用的更新(update)函数 |
    | --        | --                      | --                   |
    |ldb        |   second                |     dpb              |
    |mask-field |   second                |     deposit-field    |
    |getf       |   first                 |     依赖于具体实现 |

    Figure 5-8. 可以和 setf 一起使用的函数---2 
    
    在这些表达式形式[form]的 setf 展开期间, 需要调用 get-setf-expansion 来以了解内部的, 嵌套的广义变量必须如何处理.

    来自 get-setf-expansion 的信息按如下使用.

    * ldb

        在像这样的表达式形式中:

        ```LISP
        (setf (ldb byte-spec place-form) value-form)
        ```
        
        被 place-form 引用的位置必须总是既可读[read]又可写[write]的; 注意这个更新是对 place-form 指定的广义变量, 不是任何 integer 类型[type]的对象.

        因此, setf 应该生成代码来执行以下操作:

        1. 求值 byte-spec (并且把它绑定到一个临时变量).
        2. 为 place-form 绑定临时变量.
        3. 求值 value-form (并绑定它的值或多值到存储变量中).
        4. 执行从 place-form 中读取[read].
        5. 使用来自步骤 3 的值替换步骤 4 中获取到的整数[integer]的给定位来写[write]入 place-form.

        如果步骤 3 中的 value-form 求值修改了 place-form 的内容, 就像设置整数[integer]的不同的位, 那么由 byte-spec 表示的位改变为修改后的整数[integer], 因为步骤 4 在 value-form 求值后被执行. 不过, 绑定[binding]临时变量所需的求值在步骤 1 和步骤 2 中完成, 因此可以看到预期的从左到右的求值顺序. 比如:

        ```LISP
        (setq integer #x69) =>  #x69
        (rotatef (ldb (byte 4 4) integer)
                (ldb (byte 4 0) integer))
        integer =>  #x96
        ;;; This example is trying to swap two independent bit fields
        ;;; in an integer.  Note that the generalized variable of
        ;;; interest here is just the (possibly local) program variable
        ;;; integer.
        ```

    * mask-field

        这个情况和 ldb 在所有重要方面都是一样的.

    * getf

        在像这样的表达式形式中:

        ```LISP
        (setf (getf place-form ind-form) value-form)
        ```
        
        place-form 引用的位置必须总是可读[read]可写[write]的; 注意这个更新是对 place-form 指定的广义变量, 而不一定是讨论中的特定属性列表.

        因此, setf 应该生成代码来执行以下操作:

        1. 绑定 place-form 的临时变量.
        2. 求值 ind-form (并且把它绑定到临时变量).
        3. 求值 value-form (并且绑定它的值或多值到存储变量中).
        4. 执行从 place-form 中读取[read].
        5. 用通过组合步骤2, 3 和 4 中的值获取的可能是新的属性列表写[write]到 place-form 中. (注意这个措辞 "可能的新属性列表(possibly-new property list)" 可能意味着之前的属性列表以某种方式破坏性的再次使用, 或者可能意味着它的部分或完全的复制. 因为不管是复制还是破坏性地再使用都可以发生, 因此必须继续处理可能的新属性列表的结果值, 就好像它是需要存储回广义变量中的不同副本一样.)

        如果步骤 3 中的 value-form 求值修改了 place-form 中的内容, 例如在列表中设置一个不同的已命名属性, 那么 ind-form 表示的属性的修改是对那个修改后的列表的, 因为步骤 4 在 value-form 求值后执行. 不过, 绑定临时变量所需的求值在步骤 1 和步骤 2 中完成, 因此可以看到预期的从左到右的求值顺序.

        比如:

        ```LISP
        (setq s (setq r (list (list 'a 1 'b 2 'c 3)))) =>  ((a 1 b 2 c 3))
        (setf (getf (car r) 'b)
              (progn (setq r nil) 6)) =>  6
        r =>  NIL
        s =>  ((A 1 B 6 C 3))
        ;;; Note that the (setq r nil) does not affect the actions of
        ;;; the SETF because the value of R had already been saved in
        ;;; a temporary variable as part of the step 1. Only the CAR
        ;;; of this value will be retrieved, and subsequently modified
        ;;; after the value computation.
        ```

#### 5.1.2.3 <span id="VALUESFormsPlaces">VALUES 表达式形式作为位置</span>

一个 values 表达式形式[form]可以被用作一个位置[place], 前提是它的每一个子表达式形式[subform]也是一个位置[place]表达式形式[form].

一个像这样的表达式形式

```LISP
(setf (values place-1 ...place-n) values-form)
```

执行了以下动作:

1. 每一个嵌套位置 place 的子表达式形式[subform]都按照从左到右的顺序求值.
2. 这个 values-form 被求值, 并且来自每一个位置 place 的第一个存储变量被绑定给它的返回值, 就像是通过 multiple-value-bind 一样.
3. 如果任何位置 place 的 setf 展开式[setf expansion]涉及超过一个存储变量, 那么额外的存储变量会绑定为 nil.
4. 每个位置 place 的存储表达式形式都按照从左到右的顺序计算.

values 的 setf 展开式[setf expansion]中的存储表达式形式以多值[multiple values[2]]的形式返回步骤 2 中存储变量的值. 这也就是说, 返回的值的数量和位置[place]表达式形式数量一样. 这个可能比 values-form 所产生的值更多或更少.

#### 5.1.2.4 <span id="THEFormsPlaces">THE 表达式形式作为位置</span>

一个 the 表达式形式[form]可以被用作一个位置[place], 在这个情况下这个声明被转到那个新值表达式形式 newvalue 中, 然后对产生的 setf 进行分析. 比如,

```LISP
(setf (the integer (cadr x)) (+ y 3))
```

就像下面这样被处理

```LISP
(setf (cadr x) (the integer (+ y 3)))
```

#### 5.1.2.5 <span id="APPLYFormsPlaces">APPLY 表达式形式作为位置</span>

以下涉及 apply 的 setf 情况必须被支持:

* (setf (apply #'aref array subscript* more-subscripts) new-element)
* (setf (apply #'bit array subscript* more-subscripts) new-element)
* (setf (apply #'sbit array subscript* more-subscripts) new-element)

在所有这三种情况中, 由 subscripts 和 more-subscripts 连接所指定的数组 array 的元素[element] (换句话说, 同样的元素, 如果不是 setf 表达式形式[form]的一部分, 它将通过调用 apply 来读取[read]) 被改变为 new-element 给定的值[value]. 对于这些用法, 函数名 (aref, bit, 或 sbit) 必须引用全局函数定义, 而不是局部定义函数[function].

没有其他标准化[standardized]函数[function]需要被支持, 但是一个具体实现[implementation]可以定义这样的支持. 一个具体实现[implementation]也可以为具体实现[implementation-defined]所定义的操作符定义支持.

如果一个用户定义的函数[function]被用于这个上下文, 那么以下等价是成立的, 除了要注意保留对参数子表达式形式[subform]的正确的从左到右的求值:

```LISP
(setf (apply #'name arg*) val)
==  (apply #'(setf name) val arg*)
```

#### 5.1.2.6 <span id="SetfExpansionsPlaces">Setf 展开式和位置</span>

任何有着已定义的 setf 展开器[setf expander]的操作符[operator]的复合表达式形式[compound form]可以被用作一个位置[place]. 这个操作符[operator]必须引用一个全局函数定义, 而不是一个局部定义的函数[function]或宏[macro].

#### 5.1.2.7 <span id="MacroFormsPlaces">宏表达式形式作为位置</span>

一个宏表达式形式[macro form]可以被用作一个位置[place], 在这个情况下 Common Lisp 展开那个宏表达式形式[macro form]就像是通过 macroexpand-1 然后用这个宏展开式[macro expansion]替换原始的位置[place]. 这样的宏展开式[macro expansion]只在耗尽所有其他可能性之后才尝试, 而不是在展开到对一个名为 (setf reader) 的函数调用之后.

#### 5.1.2.8 <span id="SymbolMacrosPlaces">符号宏作为位置</span>

对一个已经建立[establish]为符号宏[symbol macro]的符号[symbol]的引用可以被用作一个位置[place]. 在这个情况下, setf 展开这个引用并且分析产生的表达式形式[form].

#### 5.1.2.9 <span id="OtherCompoundFormsPlaces">其他复合表达式形式作为位置</span>

对于其他任何复合表达式形式[compound form], 假定其中操作符[operator]为符号[symbol] f, 这个 setf 表达式形式[form]展开为一个对名为 (setf f) 的函数[function]调用. 这个新构建的函数表达式形式[function form]的第一个实参[argument]是 newvalue 并且剩下的实参[argument]是位置 place 的剩余元素[element]. 不管 f 或者 (setf f) 被局部还是全局地定义为函数, 或者都不是, 这个展开都会发生. 比如,

```LISP
(setf (f arg1 arg2 ...) new-value)
```

展开为一个和下面这个有着相同效果和值的表达式形式

```LISP
(let ((#:temp-1 arg1)          ;force correct order of evaluation
      (#:temp-2 arg2)
      ...
      (#:temp-0 new-value))
  (funcall (function (setf f)) #:temp-0 #:temp-1 #:temp-2...))
```

一个名为 (setf f) 的函数[function]必须返回它的第一个参数作为它唯一的值, 以便保留 setf 的语义.

### 5.1.3 <span id="TreatmentMacrosSETF">基于 SETF 的其他宏的处理</span>

对于下一段中的每个 "读-修改-写(read-modify-write)" 操作符[operator], 还有对于任何程序员[programmer]使用 define-modify-macro 定义的额外的宏[macro], 对参数从左到右求值的常规规则导致一个例外. 对参数[argument]表达式形式[form]的求值以从左到右的顺序发生, 除了位置 place 参数[argument]例外, 那个 place 的"旧值"的实际读取[read]发生在所有的参数[argument]表达式形式[form]求值[evaluation]之后, 并且在一个"新值"被计算并重新写入到该 place 之前.

具体地说, 这些操作符[operator]中的每一个都可以被看作是带有以下通用语法的表达式形式[form]:

```LISP
(operator preceding-form* place following-form*)
```

对每个这样的表达式形式[form]的求值都是这样处理的:

1. 按从左到右的顺序求值[evaluate]每一个 preceding-forms.
2. 求值[evaluate]这个位置 place 的子表达式形式[subform], 按照这个位置 place 的 setf 展开式[setf expansion]的第二个值指定的顺序.
3. 按从左到右的顺序求值[evaluate]每一个 following-forms.
4. 从位置 place 中读取[read]旧的值.
5. 计算新的值.
6. 存储新的值到这个位置 place.

        decf  pop   pushnew
        incf  push  remf

        Figure 5-9. 读-修改-写(read-modify-write) 宏

## 5.2 <span id="TCEP">退出点的控制转移</span>

当控制转移由 go, return-from, 或 throw 发起时, 为了完成控制权的转移, 发生以下事件. 注意, 对于 go, 退出点[exit point]是 go 执行时要被执行的 tagbody 里的表达式形式[form]; 对于 return-from, 退出点[exit point]是对应的 block 表达式形式[form]; 对于 throw, 退出点[exit point]是对应的 catch 表达式形式[form].

1. 中间的退出点[exit point]被"抛弃"了 (换句话说, 它们的范围[extent]结束了, 试图通过它们来转移控制已经不再有效了).
2. 对任何中间 unwind-protect 子句的清理子句进行求值.
3. 中间的 special 变量, 捕捉标签[catch tag], 状况处理者[condition handler], 还有重启器[restart]的动态绑定[binding]被消除.
4. 被调用的退出点[exit point]的范围[extent]结束, 控制被传递给目标.

由于被跳过而"抛弃"的退出的范围在发生控制转移时就结束了. 这也就是说, 事件 1 发生在控制转移的开始. 如果尝试去转移控制到一个动态范围[dynamic extent]已经结束的退出点[exit point], 那么结果是未定义的.

事件 2 和 3 实际上是交替进行的, 顺序与它们建立的逆序相对应. 这样做的效果是一个 unwind-protect 的清理子句看到进入 unwind-protect 时变量和捕捉标签[catch tag]的相同动态绑定[binding].

事件 4 发生在控制转移结束的时候.

## 5.3 <span id="DCFDictionary">数据和控制流字典</span>

> * [函数 APPLY](#FAPPLY)
> * [宏 DEFUN](#MDEFUN)
> * [访问器 FDEFINITION](#AFDEFINITION)
> * [函数 FBOUNDP](#FFBOUNDP)
> * [函数 FMAKUNBOUND](#FFMAKUNBOUND)
> * [特殊操作符 FLET, LABELS, MACROLET](#SOFLETLABELSMACROLET)
> * [函数 FUNCALL](#FFUNCALL)
> * [特殊操作符 FUNCTION](#SOFUNCTION)
> * [函数 FUNCTION-LAMBDA-EXPRESSION](#FFUNCTION-LAMBDA-EXPRESSION)
> * [函数 FUNCTIONP](#FFUNCTIONP)
> * [函数 COMPILED-FUNCTION-P](#FCOMPILED-FUNCTION-P)
> * [常量 CALL-ARGUMENTS-LIMIT](#CCALL-ARGUMENTS-LIMIT)
> * [常量 LAMBDA-LIST-KEYWORDS](#CLAMBDA-LIST-KEYWORDS)
> * [常量 LAMBDA-PARAMETERS-LIMIT](#CLAMBDA-PARAMETERS-LIMIT)
> * [宏 DEFCONSTANT](#MDEFCONSTANT)
> * [宏 DEFPARAMETER, DEFVAR](#MDEFPARAMETERDEFVAR)
> * [宏 DESTRUCTURING-BIND](#MDESTRUCTURING-BIND)
> * [特殊操作符 LET, LET*](#SOLETLET*)
> * [特殊操作符 PROGV](#SOPROGV)
> * [特殊表达式 SETQ](#SOSETQ)
> * [宏 PSETQ](#MPSETQ)
> * [特殊操作符 BLOCK](#SOBLOCK)
> * [特殊操作符 CATCH](#SOCATCH)
> * [特殊操作符 GO](#SOGO)
> * [特殊操作符 RETURN-FROM](#SORETURN-FROM)
> * [宏 RETURN](#MRETURN)
> * [特殊操作符 TAGBODY](#SOTAGBODY)
> * [特殊操作符 THROW](#SOTHROW)
> * [特殊操作符 UNWIND-PROTECT](#SOUNWIND-PROTECT)
> * [常量 NIL](#CNIL)
> * [函数 NOT](#FNOT)
> * [常量 T](#CT)
> * [函数 EQ](#FEQ)
> * [函数 EQL](#FEQL)
> * [函数 EQUAL](#FEQUAL)
> * [函数 EQUALP](#FEQUALP)
> * [函数 IDENTITY](#FIDENTITY)
> * [函数 COMPLEMENT](#F)
> * [函数 CONSTANTLY](#COMPLEMENT)
> * [函数 EVERY, SOME, NOTEVERY, NOTANY](#FEVERYSOMENOTEVERYNOTANY)
> * [宏 AND](#MAND)
> * [宏 COND](#MCOND)
> * [特殊操作符 IF](#SOIF)
> * [宏 OR](#MOR)
> * [宏 WHEN, UNLESS](#MWHENUNLESS)
> * [宏 CASE, CCASE, ECASE](#MCASECCASEECASE)
> * [宏 TYPECASE, CTYPECASE, ETYPECASE](#MTYPECASECTYPECASEETYPECASE)
> * [宏 MULTIPLE-VALUE-BIND](#MMULTIPLE-VALUE-BIND)
> * [特殊操作符 MULTIPLE-VALUE-CALL](#SOMULTIPLE-VALUE-CALL)
> * [宏 MULTIPLE-VALUE-LIST](#MMULTIPLE-VALUE-LIST)
> * [特殊操作符 MULTIPLE-VALUE-PROG1](#SOMULTIPLE-VALUE-PROG1)
> * [宏 MULTIPLE-VALUE-SETQ](#MMULTIPLE-VALUE-SETQ)
> * [访问器 VALUES](#AVALUES)
> * [函数 VALUES-LIST](#FVALUES-LIST)
> * [常量 MULTIPLE-VALUES-LIMIT](#CMULTIPLE-VALUES-LIMIT)
> * [宏 NTH-VALUE](#MNTH-VALUE)
> * [宏 PROG, PROG*](#MPROGPROG*)
> * [宏 PROG1, PROG2](#MPROG1PROG2)
> * [特殊操作符 PROGN](#SOPROGN)
> * [宏 DEFINE-MODIFY-MACRO](#MDEFINE-MODIFY-MACRO)
> * [宏 DEFSETF](#MDEFSETF)
> * [宏 DEFINE-SETF-EXPANDER](#MDEFINE-SETF-EXPANDER)
> * [函数 GET-SETF-EXPANSION](#FGET-SETF-EXPANSION)
> * [宏 SETF, PSETF](#MSETFPSETF)
> * [宏 SHIFTF](#MSHIFTF)
> * [宏 ROTATEF](#MROTATEF)
> * [状况类型 CONTROL-ERROR](#CTCONTROL-ERROR)
> * [状况类型 PROGRAM-ERROR](#CTPROGRAM-ERROR)
> * [状况类型 UNDEFINED-FUNCTION](#CTUNDEFINED-FUNCTION)



### <span id="FAPPLY">函数 APPLY</span>

* 语法(Syntax):

        apply function &rest args+ => result*

* 参数和值(Arguments and Values):

        function---一个函数标识符[function designator].
        args---一个可扩展参数列表标识符[spreadable argument list designator].
        results---函数 function 返回的值[value].

* 描述(Description):

        应用[apply]函数 function 到这些参数 args.

        当这个函数 function 通过 &rest 接受到它的参数时, 允许(但不是必须)一个实现[implementation]去绑定[bind]剩余参数[rest parameter]到一个和 apply 的最后一个参数共享结构的对象[object]. 因为一个函数既不能检测它是否通过 apply 被调用, (如果是这样的话)也不能检测到给 apply 的最后一个参数是否是一个常量[constant], 因此符合规范的程序[conforming program]既不能依赖于剩余列表[rest list]的列表[list]结构是新创建的, 也不能修改这个列表[list]结构.

        在某些情况下, setf 可以和 apply 一起使用; 见章节 5.1.2.5 (APPLY 表达式形式作为位置).

* 示例(Examples):

    ```LISP
    (setq f '+) =>  +
    (apply f '(1 2)) =>  3
    (setq f #'-) =>  #<FUNCTION ->
    (apply f '(1 2)) =>  -1
    (apply #'max 3 5 '(2 7 3)) =>  7
    (apply 'cons '((+ 2 3) 4)) =>  ((+ 2 3) . 4)
    (apply #'+ '()) =>  0

    (defparameter *some-list* '(a b c))
    (defun strange-test (&rest x) (eq x *some-list*))
    (apply #'strange-test *some-list*) =>  implementation-dependent

    (defun bad-boy (&rest x) (rplacd x 'y))
    (bad-boy 'a 'b 'c) has undefined consequences.
    (apply #'bad-boy *some-list*) has undefined consequences.

    (defun foo (size &rest keys &key double &allow-other-keys)
      (let ((v (apply #'make-array size :allow-other-keys t keys)))
        (if double (concatenate (type-of v) v v) v)))
    (foo 4 :initial-contents '(a b c d) :double t)
        =>  #(A B C D A B C D)
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        funcall, fdefinition, function, 章节 3.1 (求值), 章节 5.1.2.5 (APPLY 表达式形式作为位置)

* 注意(Notes): None.


### <span id="MDEFUN">宏 DEFUN</span>

* 语法(Syntax):

        defun function-name lambda-list [[declaration* | documentation]] form*
        => function-name

* 参数和值(Arguments and Values):

        function-name---一个函数名[function name].
        lambda-list---一个普通 lambda 列表[ordinary lambda list].
        declaration---一个 declare 表达式[expression]; 不求值.
        documentation---一个字符串[string]; 不求值.
        forms---一个隐式的 progn [implicit progn].
        block-name---这个 function-name 的函数块名字[function block name].

* 描述(Description):

        在全局环境[global environment]中定义一个名为 function-name 的新函数[function]. 由 defun 定义的函数[function]的主体部分由这些表达式形式 forms 组成; 当函数[function]被调用时它们会作为一个隐式的 progn [implicit progn]被执行. defun 可以被用于定义一个新的函数[function], 去设置一个错误定义的修正版本, 去重定义一个已经定义的函数[function], 或者把一个宏[macro]重定义为函数[function].

        defun 隐式地把一个名为 block-name 的块[block]放置在这个函数[function]定义的主体表达式形式 forms 周围 (而不是 lambda-list 中的那些表达式形式[form]).

        documentation 作为一个文档字符串附加到 name (作为 function 种类) 和函数[function]对象[object]上.

        求值 defun 导致 function-name 成为 defun 被执行的词法环境[lexical environment]中的 lambda 表达式[lambda expression]

    ```LISP
    (lambda lambda-list
      [[declaration* | documentation]]
      (block block-name form*))
    ```

        所指定的函数[function]的全局名字.

        (参数中没有在宏展开时被求值.)

        defun 不需要去产生任何编译时副作用. 具体来说, defun 不会使这个函数[function]定义在编译时可用. 一个实现[implementation]可能选择去存储关于这个函数的信息用于编译时错误检测的目的 (比如检测一个调用的参数数量), 或者去使函数[function]被内联展开.

* 示例(Examples):

    ```LISP
    (defun recur (x)
      (when (> x 0)
        (recur (1- x)))) =>  RECUR
    (defun ex (a b &optional c (d 66) &rest keys &key test (start 0))
        (list a b c d keys test start)) =>  EX
    (ex 1 2) =>  (1 2 NIL 66 NIL NIL 0)
    (ex 1 2 3 4 :test 'equal :start 50)
    =>  (1 2 3 4 (:TEST EQUAL :START 50) EQUAL 50)
    (ex :test 1 :start 2) =>  (:TEST 1 :START 2 NIL NIL 0)

    ;; This function assumes its callers have checked the types of the
    ;; arguments, and authorizes the compiler to build in that assumption.
    (defun discriminant (a b c)
      (declare (number a b c))
      "Compute the discriminant for a quadratic equation."
      (- (* b b) (* 4 a c))) =>  DISCRIMINANT
    (discriminant 1 2/3 -2) =>  76/9

    ;; This function assumes its callers have not checked the types of the
    ;; arguments, and performs explicit type checks before making any assumptions.
    (defun careful-discriminant (a b c)
      "Compute the discriminant for a quadratic equation."
      (check-type a number)
      (check-type b number)
      (check-type c number)
      (locally (declare (number a b c))
        (- (* b b) (* 4 a c)))) =>  CAREFUL-DISCRIMINANT
    (careful-discriminant 1 2/3 -2) =>  76/9
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        flet, labels, block, return-from, declare, documentation, 章节 3.1 (求值), 章节 3.4.1 (普通 Lambda 列表), 章节 3.4.11 (文档字符串和声明的语法交互)

* 注意(Notes):

        return-from 可以用于从 defun 定义的函数[function]中提前返回.

        当关于这个函数定义的额外信息(通常是调试信息)被记录时, 可能发生额外的副作用.

### <span id="AFDEFINITION">访问器 FDEFINITION</span>

* 语法(Syntax):

        fdefinition function-name => definition

        (setf (fdefinition function-name) new-definition)

* 参数和值(Arguments and Values):

        function-name---一个函数名[function]. 在非 setf 的情况下, 这个名字[name]在全局环境[global environment]中必须是被 fbound 的.
        definition---由 function-name 命名的当前全局函数定义.
        new-definition---一个函数[function].

* 描述(Description):

        fdefinition 访问[access]由 function-name 命名的当前全局函数定义. 这个定义可能是一个函数[function]或表示一个特殊表达式形式[special form]或宏[macro]的对象[object]. 当 fboundp 返回 true 但是这个函数名 function-name 表示一个宏[macro]或者特殊表达式形式[special form]时, fdefinition 返回的值不是明确定义的, 但是 fdefinition 不发出一个错误.

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 function-name 不是一个函数名字[function name], 那么应该发出一个 type-error 类型[type]的错误.

        在非 setf 的情况下如果 function-name 没有被 fbound, 那么就会发出 undefined-function 类型[type]的错误.

* 参见(See Also):

        fboundp, fmakunbound, macro-function, special-operator-p, symbol-function

* 注意(Notes):

        fdefinition 不能访问[access]由 flet 或 labels 产生的词法函数名的值; 它只能访问[access]全局函数的值.

        当这个函数名 function-name 的函数定义不表示一个特殊表达式形式[special form]时, setf 可以和 fdefinition 一起使用去替换全局函数定义. fdefinition 的 setf 需要一个函数[function]作为新的值. 把 function-name 的 fdefinition 设置为一个符号[symbol], 一个列表[list], 或者是一个在一个宏[macro]或特殊表达式形式[special form]上调用 fdefinition 返回的值都是错误的.


### <span id="FFBOUNDP">函数 FBOUNDP</span>

* 语法(Syntax):

        fboundp name => generalized-boolean

* 发音(Pronunciation):

        [,ef'bandpee]

* 参数和值(Arguments and Values):

        name---一个函数名[function].
        generalized-boolean---一个广义的 boolean [generalized boolean].

* 描述(Description):

        如果 name 被 fbound 就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (fboundp 'car) =>  true
    (fboundp 'nth-value) =>  false
    (fboundp 'with-open-file) =>  true
    (fboundp 'unwind-protect) =>  true
    (defun my-function (x) x) =>  MY-FUNCTION
    (fboundp 'my-function) =>  true
    (let ((saved-definition (symbol-function 'my-function)))
      (unwind-protect (progn (fmakunbound 'my-function)
                            (fboundp 'my-function))
        (setf (symbol-function 'my-function) saved-definition)))
    =>  false
    (fboundp 'my-function) =>  true
    (defmacro my-macro (x) `',x) =>  MY-MACRO
    (fboundp 'my-macro) =>  true
    (fmakunbound 'my-function) =>  MY-FUNCTION
    (fboundp 'my-function) =>  false
    (flet ((my-function (x) x))
      (fboundp 'my-function)) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 name 不是一个函数名[function name], 应该会发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        symbol-function, fmakunbound, fdefinition

* 注意(Notes):

        允许在任何被 fbound 的符号[symbol]上调用 symbol-function.

        fboundp 有时候被用于 "保护" 一个对函数存储格[function cell]的访问, 就像:

    ```LISP
    (if (fboundp x) (symbol-function x))
    ```

        定义一个 setf 展开器[setf expander] F 不会导致 setf 函数[setf function] (setf F) 被定义.


### <span id="FFMAKUNBOUND">函数 FMAKUNBOUND</span>

* 语法(Syntax):

        fmakunbound name => name

* 发音(Pronunciation):

        [,ef'makuhn,band] 或 [,ef'maykuhn,band]

* 参数和值(Arguments and Values):

        name---一个函数名字[function name].

* 描述(Description):

        在全局环境[global environment]中移除这个名字 name 的函数[function]或宏[macro]定义, 如果有的话.

* 示例(Examples):

    ```LISP
    (defun add-some (x) (+ x 19)) =>  ADD-SOME
    (fboundp 'add-some) =>  true
    (flet ((add-some (x) (+ x 37)))
        (fmakunbound 'add-some)
        (add-some 1)) =>  38
    (fboundp 'add-some) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 name 不是一个函数名[function], 应该发出一个 type-error 类型[type]的错误.

        如果 name 是一个特殊操作符[special operator]那么后果是未定义的.

* 参见(See Also):

        fboundp, makunbound

* 注意(Notes): None.

### <span id="SOFLETLABELSMACROLET">特殊操作符 FLET, LABELS, MACROLET</span>

* 语法(Syntax):

        flet ((function-name lambda-list [[local-declaration* | local-documentation]] local-form*)*) declaration* form*
        => result*

        labels ((function-name lambda-list [[local-declaration* | local-documentation]] local-form*)*) declaration* form*
        => result*

        macrolet ((name lambda-list [[local-declaration* | local-documentation]] local-form*)*) declaration* form*
        => result*

* 参数和值(Arguments and Values):

        function-name---一个函数名[function name].
        name---一个符号[symbol].
        lambda-list---一个 lambda 列表[lambda list]; 对于 flet 和 labels, 它是一个普通 lambda 列表[ordinary lambda list]; 对于 macrolet, 它是一个宏 lambda 列表[macro lambda list].
        local-declaration---一个 declare 表达式[expression]; 不求值.
        declaration---一个 declare 表达式[expression]; 不求值.
        local-documentation---一个字符串[string]; 不求值.
        local-forms, forms---一个隐式的 progn [implicit progn].
        results---表达式形式 forms 的值[value].

* 描述(Description):

        flet, labels, 和 macrolet 定义局部函数[function]和宏[macro], 并且使用这些局部定义执行表达式形式 forms. 这些表达式形式 forms 以出现的顺序被执行.

        每一个由 flet 和 labels 创建的函数[function]和每一个由 macrolet 创建的宏[macro]的主体表达式形式 (而不是 lambda 列表[lambda list]) 被封闭在一个隐式块[implicit block]中, 它的名字为 function-name 或 name 的函数块名字[function block name].

        在局部函数/宏定义的列表和 flet 或 labels 中的主体表达式形式 forms 的声明 declarations 的作用域不包括局部定义的函数[function]的主体, 除了对于 labels, 任何引用局部定义函数的 inline, notinline, 或 ftype 声明可以应用于局部函数的主体. 这就是说, 它们的作用域[scope]和它们影响的函数名一样. 这些声明 declarations 的作用域不包括由 macrolet 定义的这个宏展开函数的主体.

    * flet

            flet 局部定义已命名函数[function]并且用这些定义绑定[binding]执行一连串的表达式形式 forms. 可以定义任意数量的局部函数[function].

            这个名称绑定[binding]的作用域[scope]仅包含主体部分. 在 flet 的主体中, 与 flet 定义的那些匹配的 function-names 引用的是局部定义的函数[function], 而不是同名的全局函数定义. 此外, 在 flet 的作用域内, 由 flet 定义的函数名 function-name 的全局 setf 展开器[setf expander]定义不适用. 注意这个适用于 (defsetf f ...), 不是 (defmethod (setf f) ...).

            flet 定义的函数[function]的名字是在这个词法环境[lexical environment]中的; 它们仅在 flet 的主体中保持他们的局部定义. 这个函数定义绑定仅在 flet 的主体中可见, 在定义自身中不可见. 在这个函数定义中, 匹配那些要被定义的局部函数名字引用的是那些在 flet 外面定义的函数[function]或宏[macro]. flet 可以局部遮蔽[shadow]一个全局函数的名字, 并且这个新的定义可以引用全局定义.

            任何局部文档 local-documentation 都作为一个文档字符串[documentation string]被附加到相应的局部函数 function 中(如果实际创建的话).

    * labels

            labels 等价于 flet 除了 labels 定义的函数名的范围包含函数定义本身以及主体.

    * macrolet

            macrolet 建立一个局部宏[macro]定义, 使用和 defmacro 相同的格式.

            在 macrolet 的主体中, 由 macrolet 定义的名字 names 对应的全局 setf 展开器[setf expander]定义是不适用的; 相反, setf 展开宏表达式形式[macro form]并递归地处理生成的表达式形式[form].

            由 macrolet 定义的宏展开函数是定义在 macrolet 表达式形式出现的词法环境[lexical environment]中的. 声明和 macrolet 和 symbol-macrolet 定义影响一个 macrolet 中的局部宏定义, 但是, 如果局部宏定义引用在该词法环境[lexical environment]中可见的任何局部变量[variable]或函数[function]绑定[binding], 那么后果是没有定义的.

            任何局部文档 local-documentation 都作为一个文档字符串[documentation string]被附加到相应的局部宏函数中.

* 示例(Examples):

    ```LISP
    (defun foo (x flag)
      (macrolet ((fudge (z)
                    ;The parameters x and flag are not accessible
                    ; at this point; a reference to flag would be to
                    ; the global variable of that name.
                    ` (if flag (* ,z ,z) ,z)))
      ;The parameters x and flag are accessible here.
        (+ x
          (fudge x)
          (fudge (+ x 1)))))
    ==
    (defun foo (x flag)
      (+ x
        (if flag (* x x) x)
        (if flag (* (+ x 1) (+ x 1)) (+ x 1))))
    ```

        在宏展开之后. x 和 flag 的出现合理地引用了函数 foo 的参数, 因为这些参数在这个产生展开式的宏调用的位置是可见的.

    ```LISP
    (flet ((flet1 (n) (+ n n)))
        (flet ((flet1 (n) (+ 2 (flet1 n))))
          (flet1 2))) =>  6

    (defun dummy-function () 'top-level) =>  DUMMY-FUNCTION
    (funcall #'dummy-function) =>  TOP-LEVEL
    (flet ((dummy-function () 'shadow))
          (funcall #'dummy-function)) =>  SHADOW
    (eq (funcall #'dummy-function) (funcall 'dummy-function))
    =>  true
    (flet ((dummy-function () 'shadow))
      (eq (funcall #'dummy-function)
          (funcall 'dummy-function)))
    =>  false

    (defun recursive-times (k n)
      (labels ((temp (n)
                  (if (zerop n) 0 (+ k (temp (1- n))))))
        (temp n))) =>  RECURSIVE-TIMES
    (recursive-times 2 3) =>  6

    (defmacro mlets (x &environment env)
        (let ((form `(babbit ,x)))
          (macroexpand form env))) =>  MLETS
    (macrolet ((babbit (z) `(+ ,z ,z))) (mlets 5)) =>  10

    (flet ((safesqrt (x) (sqrt (abs x))))
      ;; The safesqrt function is used in two places.
      (safesqrt (apply #'+ (map 'list #'safesqrt '(1 2 3 4 5 6)))))
    =>  3.291173

    (defun integer-power (n k)
      (declare (integer n))
      (declare (type (integer 0 *) k))
      (labels ((expt0 (x k a)
                  (declare (integer x a) (type (integer 0 *) k))
                  (cond ((zerop k) a)
                        ((evenp k) (expt1 (* x x) (floor k 2) a))
                        (t (expt0 (* x x) (floor k 2) (* x a)))))
                (expt1 (x k a)
                  (declare (integer x a) (type (integer 0 *) k))
                  (cond ((evenp k) (expt1 (* x x) (floor k 2) a))
                        (t (expt0 (* x x) (floor k 2) (* x a))))))
        (expt0 n k 1))) =>  INTEGER-POWER

    (defun example (y l)
      (flet ((attach (x)
                (setq l (append l (list x)))))
        (declare (inline attach))
        (dolist (x y)
          (unless (null (cdr x))
            (attach x)))
        l))

    (example '((a apple apricot) (b banana) (c cherry) (d) (e))
              '((1) (2) (3) (4 2) (5) (6 3 2)))
    =>  ((1) (2) (3) (4 2) (5) (6 3 2) (A APPLE APRICOT) (B BANANA) (C CHERRY))
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        declare, defmacro, defun, documentation, let, 章节 3.1 (求值), 章节 3.4.11 (文档字符串和声明的语法交互)

* 注意(Notes):

        用 flet 去定义递归的函数[function]是可以的. labels 可以被用于定义相互递归函数[function].

        如果一个 macrolet 表达式形式[form]是一个顶层表达式形式[top level form], 主体表达式形式 forms 也被当作顶层表达式形式[top level form]处理. 见章节 3.2.3 (文件编译).


### <span id="FFUNCALL">函数 FUNCALL</span>

* 语法(Syntax):

        funcall function &rest args => result*

* 参数和值(Arguments and Values):

        function---一个函数指定符[function designator].
        args---给这个函数 function 的实参[argument].
        results---这个函数 function 返回的值[value].

* 描述(Description):

        funcall 对 args 应用函数 function. 如果 function 是一个符号[symbol], 它会被强制转为一个函数[function], 就好像是通过在全局环境[global environment]中找它的函数性值[functional value]一样.

* 示例(Examples):

    ```LISP
    (funcall #'+ 1 2 3) =>  6
    (funcall 'car '(1 2 3)) =>  1
    (funcall 'position 1 '(1 2 3 2 1) :start 1) =>  4
    (cons 1 2) =>  (1 . 2)
    (flet ((cons (x y) `(kons ,x ,y)))
      (let ((cons (symbol-function '+)))
        (funcall #'cons
                (funcall 'cons 1 2)
                (funcall cons 1 2))))
    =>  (KONS (1 . 2) 3)
    ```LISP

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 function 是一个没有作为函数[function]的全局定义或者有着作为宏[macro]或特殊操作符[special operator]的全局定义的符号[symbol], 那么应该会发出一个 undefined-function 类型[type]的错误.

* 参见(See Also):

        apply, function, 章节 3.1 (求值)

* 注意(Notes):

    ```LISP
    (funcall function arg1 arg2 ...)
    ==  (apply function arg1 arg2 ... nil)
    ==  (apply function (list arg1 arg2 ...))
    ```

        funcall 和一个普通函数调用的区别在于, 在前一种情况下, 函数是通过对一种表达式形式[form]的普通求值[evaluation]得到的, 在后者的情况下, 它是由正常发生的函数位置的特殊解释得到的.


### <span id="SOFUNCTION">特殊操作符 FUNCTION</span>

* 语法(Syntax):

        function name => function

* 参数和值(Arguments and Values):

        name---一个函数名[function name]或者一个 lambda 表达式[lambda expression].
        function---一个函数[function]对象[object].

* 描述(Description):

        这个 function 的值[value]是当前词法环境[lexical environment]中 name 的函数性值[functional value].

        如果 name 是一个函数名[function name], 这个名称的函数定义是由最内部词法上闭合的 flet, labels, 或 macrolet 表达式形式[form]建立的那个, 如果有的话. 否则会返回这个函数名[function name]的全局函数定义会被返回.

        如果 name 是一个 lambda 表达式[lambda expression], 那么返回一个词法闭包[lexical closure]. 如果在可能不止依次产生同一组绑定[binding]上的闭包[closure]的情况中, 那么产生的各种闭包可能也可能不是 eq 的.

        在一个 function 表达式形式出现的词法环境中, 在一个不表示函数[function]的函数名[function name]上用 function 是错误的. 具体来说, 在一个表示宏[macro]或者特殊表达式形式[special form]的符号[symbol]上使用 function 是错误的. 一个具体实现可能出于性能原因不去发出这个错误, 但是具体实现禁止去把这个发送错误的失败定义为一个有用的行为. 

* 示例(Examples):

    ```LISP
    (defun adder (x) (function (lambda (y) (+ x y))))
    ```

        这个 (adder 3) 的结果是一个把 3 加给参数的函数:

    ```LISP
    (setq add3 (adder 3))
    (funcall add3 5) =>  8
    ```

        这个可以正常工作是因为 function 创建了一个 lambda 表达式[lambda expression]的闭包[closure], 这个闭包引用了变量 x 的值[value] 3, 即便控制流已经中函数 adder 中返回了.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        defun, fdefinition, flet, labels, symbol-function, 章节 3.1.2.1.1 (符号表达式形式), 章节 2.4.8.2 (井号单引号(#')), 章节 22.1.3.13 (打印其他对象)

* 注意(Notes):

        标记 #'name 可能被用于 (function name) 的缩写.


### <span id="FFUNCTION-LAMBDA-EXPRESSION">函数 FUNCTION-LAMBDA-EXPRESSION</span>

* 语法(Syntax):

        function-lambda-expression function
        => lambda-expression, closure-p, name

* 参数和值(Arguments and Values):

        function---一个函数[function].
        lambda-expression---一个 lambda 表达式[lambda expression]或 nil.
        closure-p---一个广义的 boolean [generalized boolean].
        name---一个对象[object].

* 描述(Description):

        按如下返回关于函数 function 的信息:

        这个主值[primary value], lambda-expression, 是函数 function 的定义 lambda 表达式[lambda expression], 如果这个信息不可用那么就是 nil. 这个 lambda 表达式[lambda expression]可能已经在某些方面进行了预处理, 但它仍然应该是 compile 或 function 的一个合适的参数. 任何具体实现[implementation]可以合理地返回 nil 作为任何函数 function 的 lambda-expression.

        第二个值[secondary value], closure-p, 如果函数 function 的定义是空词法环境[null lexical environment]中封闭的那么就是 nil, 如果是非空词法环境[non-null lexical environment]封闭的那么就不是 nil [non-nil]. 任何具体实现[implementation]可以合理地返回 true 作为任何 function 的 closure-p.

        第三个值[tertiary value], name, 是函数 function 的 "名字(name)". 该名称仅用于调试, 例如, 没有必要是在 defun 或 function 中可以有效用作名称的一个名称. 按照惯例, nil 被用于表示这个函数 function 没有名字. 任何具体实现[implementation]可以合理地返回 nil 作为任何 function 的 name.

* 示例(Examples):

        下面的例子说明了一些可能的返回值, 但是并不是详尽的:

    ```LISP
    (function-lambda-expression #'(lambda (x) x))
    =>  NIL, false, NIL
    OR=>  NIL, true, NIL
    OR=>  (LAMBDA (X) X), true, NIL
    OR=>  (LAMBDA (X) X), false, NIL

    (function-lambda-expression
        (funcall #'(lambda () #'(lambda (x) x))))
    =>  NIL, false, NIL
    OR=>  NIL, true, NIL
    OR=>  (LAMBDA (X) X), true, NIL
    OR=>  (LAMBDA (X) X), false, NIL

    (function-lambda-expression
        (funcall #'(lambda (x) #'(lambda () x)) nil))
    =>  NIL, true, NIL
    OR=>  (LAMBDA () X), true, NIL
    NOT=>  NIL, false, NIL
    NOT=>  (LAMBDA () X), false, NIL

    (flet ((foo (x) x))
      (setf (symbol-function 'bar) #'foo)
      (function-lambda-expression #'bar))
    =>  NIL, false, NIL
    OR=>  NIL, true, NIL
    OR=>  (LAMBDA (X) (BLOCK FOO X)), true, NIL
    OR=>  (LAMBDA (X) (BLOCK FOO X)), false, FOO
    OR=>  (SI::BLOCK-LAMBDA FOO (X) X), false, FOO

    (defun foo ()
      (flet ((bar (x) x))
        #'bar))
    (function-lambda-expression (foo))
    =>  NIL, false, NIL
    OR=>  NIL, true, NIL
    OR=>  (LAMBDA (X) (BLOCK BAR X)), true, NIL
    OR=>  (LAMBDA (X) (BLOCK BAR X)), true, (:INTERNAL FOO 0 BAR)
    OR=>  (LAMBDA (X) (BLOCK BAR X)), false, "BAR in FOO"
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes):

        虽然具体实现[implementation]可以在所有情况下返回 "nil, true, nil", 但是还是鼓励这些实现在参数是对 compile 或 eval 的调用所创建的情况下返回一个 lambda 表达式[lambda expression]作为主值[primary value] (与通过加载已编译文件[compiled file]所创建的相反).


### <span id="FFUNCTIONP">函数 FUNCTIONP</span>

* 语法(Syntax):

        functionp object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义的 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 function 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (functionp 'append) =>  false
    (functionp #'append) =>  true
    (functionp (symbol-function 'append)) =>  true
    (flet ((f () 1)) (functionp #'f)) =>  true
    (functionp (compile nil '(lambda () 259))) =>  true
    (functionp nil) =>  false
    (functionp 12) =>  false
    (functionp '(lambda (x) (* x x))) =>  false
    (functionp #'(lambda (x) (* x x))) =>  true
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes):

        (functionp object) ==  (typep object 'function)


### <span id="FCOMPILED-FUNCTION-P">函数 COMPILED-FUNCTION-P</span>

* 语法(Syntax):

        compiled-function-p object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义的 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 compiled-function 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (defun f (x) x) =>  F
    (compiled-function-p #'f)
    =>  false
    OR=>  true
    (compiled-function-p 'f) =>  false
    (compile 'f) =>  F
    (compiled-function-p #'f) =>  true
    (compiled-function-p 'f) =>  false
    (compiled-function-p (compile nil '(lambda (x) x)))
    =>  true
    (compiled-function-p #'(lambda (x) x))
    =>  false
    OR=>  true
    (compiled-function-p '(lambda (x) x)) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        compile, compile-file, compiled-function

* 注意(Notes):

        (compiled-function-p object) ==  (typep object 'compiled-function)


### <span id="CCALL-ARGUMENTS-LIMIT">常量 CALL-ARGUMENTS-LIMIT</span>

* 常量值(Constant Value):

        一个不小于 50 的整数, 至少和 lambda-parameters-limit 的值[value]一样大, 它的精确大小是依赖于具体实现的[implementation-dependent].

* 描述(Description):

        传递给函数[function]的实参[arugment]数量的上限.

* 示例(Examples): None.

* 参见(See Also):

        lambda-parameters-limit, multiple-values-limit

* 注意(Notes): None.


### <span id="CLAMBDA-LIST-KEYWORDS">常量 LAMBDA-LIST-KEYWORDS</span>

* 常量值(Constant Value):

        一个列表[list], 其中的元素[element]是依赖于具体实现的[implementation-dependent], 但是其中至少需要包含符号[symbol] &allow-other-keys, &aux, &body, &environment, &key, &optional, &rest, 和 &whole.

* 描述(Description):

        在这个具体实现[implementation]中使用的所有 lambda 列表关键字[lambda list keywords]的列表[list], 包括仅被宏[macro]定义表达式形式[form]所使用的其他关键词.

* 示例(Examples): None.

* 参见(See Also):

        defun, flet, defmacro, macrolet, 章节 3.1.2 (求值模型)

* 注意(Notes): None.

### <span id="CLAMBDA-PARAMETERS-LIMIT">常量 LAMBDA-PARAMETERS-LIMIT</span>

* 常量值(Constant Value):

        依赖于具体实现[implementation-dependent], 但是不小于 50.

* 描述(Description):

        一个正整数[integer], 表示可以出现在一个单独的 lambda 列表[lambda list]中的形参[parameter]名字[name]数量的上限.

* 示例(Examples): None.

* 参见(See Also):

        call-arguments-limit

* 注意(Notes):

        鼓励实现者去使 lambda-parameters-limit 的值[value]尽可能的大.

### <span id="MDEFCONSTANT">宏 DEFCONSTANT</span>

* 语法(Syntax):

        defconstant name initial-value [documentation] => name

* 参数和值(Arguments and Values):

        name---一个符号[symbol]; 不求值.
        initial-value---一个表达式形式[form]; 求值.
        documentation---一个字符串[string]; 不求值.

* 描述(Description):

        defconstant 导致由 name 命名的全局变量被赋予 initial-value 求值后的结果值.

        一个由 defconstant 定义的常量可以被 defconstant 重定义. 然而, 如果尝试去使用其他操作符去给这个符号[symbol]赋一个值[value]或者使用后面的 defconstant 将其赋给不同[different]的值[value], 那么后果是未定义的.

        如果提供了 documentation, 它会作为一个 variable 种类的文档字符串[documentation string]关联到 name 上.

        defconstant 通常以顶层表达式形式[top level form]出现, 但它作为非顶层表达式形式[non-top-level form]出现也是有意义的. 然而, 下面描述的编译时副作用只发生在 defconstant 以顶层表达式形式[top level form]出现的情况中.

        如果在 defconstant 被执行时存在任何由 name 命名的变量的绑定[binding]或者其中的值和 initial-value 不是 eql 的, 那么结果是未定义的.

        当常量符号被重绑定为词法或动态变量时, 其结果是未定义的. 换句话说, 指向 defconstant 声明的符号[symbol]的一个引用总是指向它的全局的值.

        执行 defconstant 的副作用必须与以下代码执行的副作用相等:

    ```LISP
    (setf (symbol-value 'name) initial-value)
    (setf (documentation 'name 'variable) 'documentation)
    ```

        如果一个 defconstant 表达式形式[form]作为顶层表达式形式[top level form]出现, 编译器[compiler]必须识别出 name 是一个常变量[constant variable]. 一个具体实现可能选择在编译时或加载时或两种情况下都去求值值表达式形式(value-form). 因此, 用户必须确保 initial-value 可以在编译时被求值 (不管对这个名字 name 的引用是否出现在文件中) 并且总是求值为同一个值.

* 示例(Examples):

    ```LISP
    (defconstant this-is-a-constant 'never-changing "for a test") =>  THIS-IS-A-CONSTANT
    this-is-a-constant =>  NEVER-CHANGING
    (documentation 'this-is-a-constant 'variable) =>  "for a test"
    (constantp 'this-is-a-constant) =>  true
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        declaim, defparameter, defvar, documentation, proclaim, 章节 3.1.2.1.1.3 (常变量), 章节 3.2 (编译)

* 注意(Notes): None.


### <span id="MDEFPARAMETERDEFVAR">宏 DEFPARAMETER, DEFVAR</span>

* 语法(Syntax):

        defparameter name initial-value [documentation] => name
        defvar name [initial-value [documentation]] => name

* 参数和值(Arguments and Values):

        name---一个符号[symbol]; 不求值.
        initial-value---一个表达式形式[form]; 对于 defparameter, 它总是被求值, 但是对于 defvar 只有在 name 还没有被绑定的情况下求值.
        documentation---一个字符串; 不求值.

* 描述(Description):

        defparameter 和 defvar 把名字 name 建立[establish]为一个动态变量[dynamic variable].

        defparameter 无条件地把 initial-value 赋值[assign]给 name 命名的动态变量[dynamic variable]. defvar, 相比之下, 只有在 name 还没有被绑定[bound]时把 initial-value (如果提供的话) 赋值[assign]给 name 命名的动态变量[dynamic variable].

        如果没有提供 initial-value, defvar 让名为 name 的动态变量[dynamic variable]的值存储格[value cell]保持不变; 如果 name 以前绑定[bound]过的话, 它的旧值[value]就会一直存在, 如果它之前未绑定[unbound], 那么它仍然是未绑定[unbound].

        如果提供了 documentation, 它会作为 variable 类型的文档字符串[documentation string]关联给 name.

        defparameter 和 defvar 通常作为顶层表达式形式[top level form]出现, 但是当它们作为非顶层表达式形式[non-top-level form]出现时也是有意义的. 然而, 下面描述的编译时副作用仅发生在它们作为顶层表达式形式[top level form]的时候.

* 示例(Examples):

    ```LISP
    (defparameter *p* 1) =>  *P*
    *p* =>  1
    (constantp '*p*) =>  false
    (setq *p* 2) =>  2
    (defparameter *p* 3) =>  *P*
    *p* =>  3

    (defvar *v* 1) =>  *V*
    *v* =>  1
    (constantp '*v*) =>  false
    (setq *v* 2) =>  2
    (defvar *v* 3) =>  *V*
    *v* =>  2

    (defun foo ()
      (let ((*p* 'p) (*v* 'v))
        (bar))) =>  FOO
    (defun bar () (list *p* *v*)) =>  BAR
    (foo) =>  (P V)
    ```

        defparameter 和 defvar 之间的主要操作上区别是, defparameter 对 name 做出了一个无条件的赋值, 而 defvar 则是一个有条件的赋值. 在实践中, 这就意味着在加载或重新加载定义会想要获得变量的新值时 defparameter 是很有用的, 而当文件被加载或重新加载时想要保持旧值时 defvar 是比较有用的. 比如, 可以创建一个文件, 其中包含:

    ```LISP
    (defvar *the-interesting-numbers* '())
    (defmacro define-interesting-number (name n)
      `(progn (defvar ,name ,n)
              (pushnew ,name *the-interesting-numbers*)
              ',name))
    (define-interesting-number *my-height* 168) ;cm
    (define-interesting-number *my-weight* 13)  ;stones
    ```

        这里的变量 *the-interesting-numbers* 的初始值, (), 只是一个种子, 一旦从中扩展出什么时我们不会想去重置它为某个其他东西. 像这样, 我们使用 defvar 来避免文件第二次加载时 *the-interesting-numbers* 信息被重置. 确实, 这里的两个对 define-interesting-number 调用会被重新处理, 但是如果在另一个文件中由其他调用, 它们不会被重新处理并且信息会丢失. 另一方面, 思考下面代码:

    ```LISP
    (defparameter *default-beep-count* 3)
    (defun beep (&optional (n *default-beep-count*))
      (dotimes (i n) (si:%beep 1000. 100000.) (sleep 0.1)))
    ```
    
        这里我们可以简单地想象编辑代码去改变 *default-beep-count* 的初始值, 然后重新载入文件去取出新的值. 为了使值更新更简单, 我们使用 defparameter.

        另一方面, 在这种情况下使用 defvar 是有潜在价值的. 比如, 假设某人为 *default-beep-count* 预先定义了一个替代值, 或者已经加载这个文件然后手动修改这个值. 在这两种情况下, 如果我们已经使用 defvar 而不是 defparameter, 那些用户设置不会因加载(或重新加载) 而被重写.

        使用 defparameter 还是 defvar 的选择对程序有明显的影响, 但通常是出于主观原因.

* 副作用(Side Effects):

        如果一个 defvar 或 defparameter 表达式形式[form]作为顶层表达式形式[top level form]出现, 编译器[compiler]必须识别这个已经被公告为 special 的 name. 然而, 在编译时它既不能求值[evaluate] initial-value 表达式形式[form], 也不能对名为 name 的动态变量[dynamic variable]赋值[assign].

        这里可能由额外的编译期或运行期副作用 (依赖于具体实现的[implementation-defined]), 只要这些副作用不影响符合规范的程序[conforming program]的正常操作.

* 受此影响(Affected By):

        defvar 受 name 是否已经被绑定[bound]的影响.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        declaim, defconstant, documentation, 章节 3.2 (编译)

* 注意(Notes):

        通常, 在名称的开头和结尾用星号[asterisk]来命名动态变量[dynamic variable]. 比如, *foo* 对于一个动态变量[dynamic variable]是一个好名字, 但是对于一个词法变量[lexical variable]则不是好名字; foo 对于词法变量[lexical variable]是一个好名字, 但是对于动态变量[[dynamic variable]]不是一个好名字. Common Lisp 中所有已定义的名字[defined name]都遵守这种命名约定; 然而, 符合规范的程序[conforming program]和符合规范的实现[conforming implementation]都不是必须去遵守这个约定.

        允许额外的副作用的目的是去允许具体实现[implementation]伴随着定义做正常的"记录(bookkeeping)". 比如, 一个 defvar 或 defparameter 表达式形式[form]的宏展开式[macro expansion]可能包含安排记录这个定义发生的源文件名字的代码.

        defparameter 和 defvar 可能按如下定义:

    ```LISP
    (defmacro defparameter (name initial-value 
                            &optional (documentation nil documentation-p))
      `(progn (declaim (special ,name))
              (setf (symbol-value ',name) ,initial-value)
              ,(when documentation-p
                  `(setf (documentation ',name 'variable) ',documentation))
              ',name))
    (defmacro defvar (name &optional
                            (initial-value nil initial-value-p)
                            (documentation nil documentation-p))
      `(progn (declaim (special ,name))
              ,(when initial-value-p
                  `(unless (boundp ',name)
                    (setf (symbol-value ',name) ,initial-value)))
              ,(when documentation-p
                  `(setf (documentation ',name 'variable) ',documentation))
              ',name))
    ```

### <span id="MDESTRUCTURING-BIND">宏 DESTRUCTURING-BIND</span>

* 语法(Syntax):

        destructuring-bind lambda-list expression declaration* form*
        => result*

* 参数和值(Arguments and Values):

        lambda-list---一个解构 lambda 列表[destructuring lambda list].
        expression---一个表达式形式[from].
        declaration---一个 declare 表达式[expression]; 不求值.
        forms---一个隐式的 progn [implicit progn].
        results---这些表达式形式[forms]返回的值[value].

* 描述(Description):

        destructuring-bind 绑定 lambda-list 中指定的变量为 expression 求值结果的树结构的对应值中; 然后 destructuring-bind 求值表达式形式 forms.

        这个 lambda-list 按照章节 3.4.5 (解构 lambda 列表) 中描述的那样支持解构.

* 示例(Examples):

    ```LISP
    (defun iota (n) (loop for i from 1 to n collect i))       ;helper
    (destructuring-bind ((a &optional (b 'bee)) one two three)
        `((alpha) ,@(iota 3))
      (list a b three two one)) =>  (ALPHA BEE 3 2 1)
    ```
* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果求值 expression 的结果不匹配这个解构模式, 应该会发出一个 error 类型[type]的错误.

* 参见(See Also):

        macrolet, defmacro

* 注意(Notes): None.


### <span id="SOLETLET*">特殊操作符 LET, LET*</span>

* 语法(Syntax):

        let ({var | (var [init-form])}*) declaration* form* => result*
        let* ({var | (var [init-form])}*) declaration* form* => result*

* 参数和值(Arguments and Values):

        var---一个符号[symbol].
        init-form---一个表达式形式[form].
        declaration---一个 declare 表达式[expression]; 不求值.
        form---一个表达式形式[form].
        results---这些表达式形式[form]返回的值[value].

* 描述(Description):

        let 和 let* 创建新的变量绑定[binding]并且使用这些绑定[binding]执行一系列的表达式形式 forms. let 并行地执行这些绑定[binding]而 let* 顺序地执行.

        下面这个表达式形式

    ```LISP
    (let ((var1 init-form-1)
          (var2 init-form-2)
          ...
          (varm init-form-m))
      declaration1
      declaration2
      ...
      declarationp
      form1
      form2
      ...
      formn)
    ```

        首先求值表达式 init-form-1, init-form-2, 以此类推, 按照这个顺序, 保存结果值. 然后所有变量 varj 绑定为对应的值; 每一个绑定[binding]都是词法的除非相反有一个 special 声明. 然后表达式 formk 依次被求值; 除了最后一个, 所有的值都被丢弃 (这也就是说, 一个 let 的主体是一个隐式的 progn [implicit progn]).

        let* 类似于 let, 但是变量的绑定[binging]被顺序执行而非并行执行. 一个 var 的 init-form 的表达式可以引用前面 let* 绑定的 vars.

        下面这个表达式形式

    ```LISP
    (let* ((var1 init-form-1)
           (var2 init-form-2)
           ...
           (varm init-form-m))
      declaration1
      declaration2
      ...
      declarationp
      form1
      form2
      ...
      formn)
    ```

        首先求值 init-form-1, 然后绑定变量 var1 为那个值; 然后求值 init-form-2 并绑定 var2, 以此类推. 然后表达式 formj 按顺序求值; 除了最后一个, 所有的值都被丢弃 (这也就是说, 一个 let* 的主体是一个隐式的 progn).

        对于 let 和 let*, 如果这里没有和一个 var 关联的一个 init-form, var 被初始化为 nil.

        特殊表达式形式 let 有一个属性, 就是名称绑定的作用域[scope]不包括任何初始值表达式形式. 对于 let*, 一个变量的作用域[scope]包括了剩下的后续变量绑定的剩余初始化值表达式.

* 示例(Examples):

    ```LISP
    (setq a 'top) =>  TOP
    (defun dummy-function () a) =>  DUMMY-FUNCTION
    (let ((a 'inside) (b a))
       (format nil "~S ~S ~S" a b (dummy-function))) =>  "INSIDE TOP TOP"
    (let* ((a 'inside) (b a))
       (format nil "~S ~S ~S" a b (dummy-function))) =>  "INSIDE INSIDE TOP"
    (let ((a 'inside) (b a))
       (declare (special a))
       (format nil "~S ~S ~S" a b (dummy-function))) =>  "INSIDE TOP INSIDE"
    ```

        代码

    ```LISP
    (let (x)
      (declare (integer x))
      (setq x (gcd y z))
      ...)
    ```

        是错误的; 虽然 x 事实上在它被使用前设置, 并且被设置为一个声明类型整型[integer]的值, 然而, x 一开始在值为 nil 时违反了类型声明.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        progv

* 注意(Notes): None.


### <span id="SOPROGV">特殊操作符 PROGV</span>

* 语法(Syntax):

        progv symbols values form* => result*

* 参数和值(Arguments and Values):

        symbols---一个符号[symbol]列表[list]; 求值.
        values---一个对象[object]列表[list]; 求值.
        forms---一个隐式的 progn [implicit progn].
        results---这些表达式形式[form]返回的值.

* 描述(Description):

        progv 创建新的动态变量绑定[binding]并且使用这些绑定[binding]执行每个表达式形式 form. 每个表达式形式 form 按顺序求值.

        progv 允许去绑定[binding]一个或多个动态变量, 这些变量的名字可能在运行时确定. 每一个表达式形式 form 依次被求值, 其中名字在这些符号 symbols 中的这些动态变量被绑定为对应的值. 如果提供的值 values 太少, 剩余的符号[symbol]就会被绑定, 并且没有值. 如果提供了太多的值 values, 多余的值会被忽略. 这些动态变量的绑定在 progv 退出时被取消了.

* 示例(Examples):

    ```LISP
    (setq *x* 1) =>  1
    (progv '(*x*) '(2) *x*) =>  2
    *x* =>  1
    ```

        假设 *x* 不是全局特殊的,

    ```LISP
    (let ((*x* 3))
        (progv '(*x*) '(4)
          (list *x* (symbol-value '*x*)))) =>  (3 4)
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        let, 章节 3.1 (求值)

* 注意(Notes):

        除了别的之外, 为 Lisp 中的嵌入式语言写解释器时 progv 是很有用的; 它为绑定[binding]动态变量[dynamic variable]的机制提供了一个途径.


### <span id="SOSETQ">特殊表达式 SETQ</span>

* 语法(Syntax):

        setq {pair}* => result

        pair::= var form

* 发音(Pronunciation):

        ['set,kyoo]

* 参数和值(Arguments and Values):

        var---一个符号[symbol], 命名一个变量[variable], 而不是一个常量[constant variable].
        form---一个表达式形式[form].
        result---最后一个表达式形式 form 返回的主值[primary value], 如果没有提供 pair 就返回 nil.

* 描述(Description):

        赋值给那些变量[variable].

        (setq var1 form1 var2 form2 ...) 是 Lisp 简单的变量赋值语句. 首先 form1 被求值并且结果被存储在变量 var1 中, 然后 form2 被求值并且结果存在 var2 中, 等等. setq 可以被用于词法变量或动态变量的赋值.

        如果任何 var 引用了 symbol-macrolet 产生的一个绑定[binding], 那么这个 var 就好像是被 setf (不是 setq) 处理一样.

* 示例(Examples):

    ```LISP
    ;; A simple use of SETQ to establish values for variables.
    (setq a 1 b 2 c 3) =>  3
    a =>  1
    b =>  2
    c =>  3

    ;; Use of SETQ to update values by sequential assignment.
    (setq a (1+ b) b (1+ a) c (+ a b)) =>  7
    a =>  3
    b =>  4
    c =>  7

    ;; This illustrates the use of SETQ on a symbol macro.
    (let ((x (list 10 20 30)))
      (symbol-macrolet ((y (car x)) (z (cadr x)))
        (setq y (1+ z) z (1+ y))
        (list x y z)))
    =>  ((21 22 30) 21 22)
    ```

* 副作用(Side Effects):

        每一个表达式形式 form 的主值[primary value]都被赋给对应的 var.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        psetq, set, setf

* 注意(Notes): None.


### <span id="MPSETQ">宏 PSETQ</span>

* 语法(Syntax):

        psetq {pair}* => nil

        pair::= var form

* 发音(Pronunciation):

        psetq: [;pee'set,kyoo]

* 参数和值(Arguments and Values):

        var---一个符号[symbol], 命名一个变量[variable], 而不是一个常量[constant variable].
        form---一个表达式形式[form].

* 描述(Description):

        赋值给那些变量[variable].

        这个就像是 setq, 除了赋值是并行发生的之外. 这也就是说, 首先所有的表达式形式都被求值, 只有这样之后变量才会被设置成对应结果值. 通过这种方式, 对一个变量的赋值不会影响另一个变量的值计算, 这个会发生在 setq 的顺序赋值中.

        如果任何 var 引用了 symbol-macrolet 创建的绑定[binding], 那么这个 var 就好像是被 psetf (不是 psetq) 处理一样.

* 示例(Examples):

    ```LISP
    ;; A simple use of PSETQ to establish values for variables.
    ;; As a matter of style, many programmers would prefer SETQ
    ;; in a simple situation like this where parallel assignment
    ;; is not needed, but the two have equivalent effect.
    (psetq a 1 b 2 c 3) =>  NIL
    a =>  1
    b =>  2
    c =>  3

    ;; Use of PSETQ to update values by parallel assignment.
    ;; The effect here is very different than if SETQ had been used.
    (psetq a (1+ b) b (1+ a) c (+ a b)) =>  NIL
    a =>  3
    b =>  2
    c =>  3

    ;; Use of PSETQ on a symbol macro.
    (let ((x (list 10 20 30)))
       (symbol-macrolet ((y (car x)) (z (cadr x)))
        (psetq y (1+ z) z (1+ y))
        (list x y z)))
    =>  ((21 11 30) 21 11)
 
    ;; Use of parallel assignment to swap values of A and B.
    (let ((a 1) (b 2))
      (psetq a b  b a)
      (values a b))
    =>  2, 1
    ```

* 副作用(Side Effects):

        这些表达式形式 forms 的值会赋给那些变量 vars.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        psetf, setq

* 注意(Notes): None.


### <span id="SOBLOCK">特殊操作符 BLOCK</span>

* 语法(Syntax):

        block name form* => result*

* 参数和值(Arguments and Values):

        name---一个符号[symbol].
        form---一个表达式形式[form].
        results---如果发生正常返回[normal return]那么就是那些表达式形式[form]的那些值[value], 否则, 如果发生显式返回[explicit return], 就返回传递的那些值[value].

* 描述(Description):

        block 建立[establish]一个名为 name 的语句块[block]然后就好像一个隐式 progn 来求值多个 form.

        特殊操作符[special operator] block 和 return-from 一起使用来提供一个结构化的, 词法的, 非局部的退出机制. 词法上包含在这些表达式形式中的任何点, return-from 可以和给定的 name 一起使用来从 blook 表达式形式[form]中返回控制和值, 除了当内部有一个相同名字的块[block]被建立时, 在这种情况下较外部的块[block]会被更内部的那个所遮蔽.

        名为 name 的这个块有着词法作用域[lexical scope]和动态范围[dynamic extent].

        一旦建立, 一个块[block]可能只退出一次, 不管是正常退出[normal return]还是显式退出[explicit return].

* 示例(Examples):

    ```LISP
    (block empty) =>  NIL
    (block whocares (values 1 2) (values 3 4)) =>  3, 4
    (let ((x 1))
      (block stop (setq x 2) (return-from stop) (setq x 3))
      x) =>  2
    (block early (return-from early (values 1 2)) (values 3 4)) =>  1, 2
    (block outer (block inner (return-from outer 1)) 2) =>  1
    (block twin (block twin (return-from twin 1)) 2) =>  2
    ;; Contrast behavior of this example with corresponding example of CATCH.
    (block b
      (flet ((b1 () (return-from b 1)))
        (block b (b1) (print 'unreachable))
        2)) =>  1
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        return, return-from, 章节 3.1 (求值)

* 注意(Notes):

### <span id="SOCATCH">特殊操作符 CATCH</span>

* 语法(Syntax):

        catch tag form* => result*

* 参数和值(Arguments and Values):

        tag---一个捕捉标签[catch tag]; 求值的.
        forms---一个隐式的 progn [implicit progn].
        results---如果这些表达式形式 forms 正常退出, 那么就是这些表达式形式 forms 返回的那些值[value]; 如果发生一个对 tag 的抛出, 那么就是那些被抛出来的值[value].

* 描述(Description):

        catch 被用作 throw 的非局部控制转移的终点. 这些 tags 被用于查找 throw 控制转移到的 catch. (catch 'foo form) 捕捉一个 (throw 'foo form) 而不是 (throw 'bar form).

        catch 执行顺序如下:

        1. tag 被求值. 它是 catch 的名称.

        2. 然后这些表达式形式 forms 作为隐式 progn [implicit progn]来求值, 除非发生一个 throw, 否则返回最后一个表达式形式 form 的结果.

        3. 如果在执行这些表达式形式 forms 的其中一个时发生一个 throw, 控制被转移到一个 catch 表达式形式[form], 这个 catch 表达式形式的 tag 和 throw 的 tag 参数是 eq 的并且它是这个 tag 最近建立的 catch. 不再对这些表达式形式 forms 进行进一步的求值.

        4. catch 建立的这个 tag 在结果返回前就会被消除.

        如果在这些表达式形式 forms 的其中一个执行期间, 一个 throw 被执行而它的 tag 和 catch 的 tag 是 eq 的, 那么 throw 指定的值作为动态最新建立的这个 tag 的 catch 表达式的结果返回.

        即便 throw 不在 catch 的词法作用域里, catch 和 throw 机制还是会起作用. throw 必须发生在对应 tag 的 catch 的主体求值[evaluation]的动态范围[dynamic extent]内.

* 示例(Examples):

    ```LISP
    (catch 'dummy-tag 1 2 (throw 'dummy-tag 3) 4) =>  3
    (catch 'dummy-tag 1 2 3 4) =>  4
    (defun throw-back (tag) (throw tag t)) =>  THROW-BACK
    (catch 'dummy-tag (throw-back 'dummy-tag) 2) =>  T

    ;; Contrast behavior of this example with corresponding example of BLOCK.
    (catch 'c
      (flet ((c1 () (throw 'c 1)))
        (catch 'c (c1) (print 'unreachable))
        2)) =>  2
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果在没有合适的 catch tag 时 throw 被执行, 会发出一个 control-error 类型[type]的错误.

* 参见(See Also):

        throw, 章节 3.1 (求值)

* 注意(Notes):

        符号[symbol]被用作 tags 是惯例, 但是任何对象[object]也是允许的. 然而, 数字不应该被使用, 因为这个比较是使用 eq 来完成的.

        catch 和 block 的区别在于 catch 标签有着动态作用域[scope]而 block 名字有词法作用域[lexical scope].

### <span id="SOGO">特殊操作符 GO</span>

* 语法(Syntax):

        go tag =>|

* 参数和值(Arguments and Values):

        tag---一个 go 标签[go tag].

* 描述(Description):

        go 将控制转移到一个由和 tag 是 eql 的标签所标记的闭合 tagbody 表达式形式的主体上的一个点. 如果在这个主体内没有这样一个 tag, 那么词法上包含 tagbody 表达式形式[form]的那些主体 (如果有的话) 也会被检查. 如果有好几个标签和 tag 是 eql 的, 控制会被转移到包含这个 go 的最内部的包含这个匹配 tag 的 tagbody 表达式形式上. 如果在这个 go 的点上没有词法上可见的匹配的 tag 那么结果是未定义的.

        由 go 发起的控制转移是按照章节 5.2 (退出点的控制转移) 所描述的进行的.

* 示例(Examples):

    ```LISP
    (tagbody
      (setq val 2)
      (go lp)
      (incf val 3)
      lp (incf val 4)) =>  NIL
    val =>  6
    ```

        下面这个是错误的因为在 go 被执行前这里有一个 tagbody 正常的退出.

    ```LISP
    (let ((a nil))
      (tagbody t (setq a #'(lambda () (go t))))
      (funcall a))
    ```

        下面这个是错误的因为在 go 表达式形式[form]被执行前这个 tagbody 被跳过了.

    ```LISP
    (funcall (block nil
               (tagbody a (return #'(lambda () (go a))))))
    ```
    
* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        tagbody

* 注意(Notes): None.


### <span id="SORETURN-FROM">特殊操作符 RETURN-FROM</span>

* 语法(Syntax):

        return-from name [result] =>|

* 参数和值(Arguments and Values):

        name---一个块标签[block tag]; 不求值.
        result---一个表达式形式[form]; 求值. 默认是 nil.

* 描述(Description):

        从一个词法上闭合的块[block]中返回控制和多值[multiple values[2]].

        一个名为 name 的 block 表达式形式[form]必须词法上包含 return-from 的出现; 结果 result 的求值[evaluation]所产生的任何值[value]都将立即从最内层的词法上闭合的块[block]中返回.

        由 return-from 发起的控制转移是按照章节 5.2 (退出点的控制转移) 所所描述的进行的.

* 示例(Examples):

    ```LISP
    (block alpha (return-from alpha) 1) =>  NIL
    (block alpha (return-from alpha 1) 2) =>  1
    (block alpha (return-from alpha (values 1 2)) 3) =>  1, 2
    (let ((a 0))
       (dotimes (i 10) (incf a) (when (oddp i) (return)))
       a) =>  2
    (defun temp (x)
       (if x (return-from temp 'dummy))
       44) =>  TEMP
    (temp nil) =>  44
    (temp t) =>  DUMMY
    (block out
      (flet ((exit (n) (return-from out n)))
        (block out (exit 1)))
      2) =>  1
    (block nil
      (unwind-protect (return-from nil 1)
        (return-from nil 2)))
    =>  2
    (dolist (flag '(nil t))
      (block nil
        (let ((x 5))
          (declare (special x))
          (unwind-protect (return-from nil)
            (print x))))
      (print 'here))
    >>  5
    >>  HERE
    >>  5
    >>  HERE
    =>  NIL
    (dolist (flag '(nil t))
      (block nil
        (let ((x 5))
          (declare (special x))
          (unwind-protect
              (if flag (return-from nil))
            (print x))))
      (print 'here))
    >>  5
    >>  HERE
    >>  5
    >>  HERE
    =>  NIL
    ```

        下面这个结果也是未定义的因为在 return-from 表达式形式[form]被尝试之前这个 block 表达式形式[form]就正常退出了.

    ```LISP
    (funcall (block nil #'(lambda () (return-from nil)))) 
    ```

        是一个错误.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        block, return, 章节 3.1 (求值)

* 注意(Notes): None.


### <span id="MRETURN">宏 RETURN</span>

* 语法(Syntax):

        return [result] =>|

* 参数和值(Arguments and Values):

        result---一个表达式形式[form]; 求值. 默认是 nil.

* 描述(Description):

        从一个名为 nil 的块[block]中返回, 就像是通过 return-from 的一样.

* 示例(Examples):

    ```LISP
    (block nil (return) 1) =>  NIL
    (block nil (return 1) 2) =>  1
    (block nil (return (values 1 2)) 3) =>  1, 2
    (block nil (block alpha (return 1) 2)) =>  1
    (block alpha (block nil (return 1)) 2) =>  2
    (block nil (block nil (return 1) 2)) =>  1
    ```

* 受此影响(Affected By): None.

* 条件(Conditions): None.

* 参见(See Also):

        block, return-from, 章节 3.1 (求值)

* 注意(Notes):

    ```LISP
    (return) ==  (return-from nil)
    (return form) ==  (return-from nil form)
    ```

        被类似于 do 这样的宏建立的这些隐式块[implicit block]经常名为 nil, 因此 return 可以被用于从这样的表达式形式[form]中返回.


### <span id="SOTAGBODY">特殊操作符 TAGBODY</span>

* 语法(Syntax):

        tagbody {tag | statement}* => nil

* 参数和值(Arguments and Values):

        tag---一个 go 标签[go tag]; 不求值.
        statement---一个复合表达式形式[compound form]; 按照以下描述求值.

* 描述(Description):

        在一个提供了对这些 tag 所指示的标签的控制转移的词法环境[lexical environment]中执行零个或多个语句 statement.

        在一个 tagbody 中的语句 statements 按照从左到右的顺序被求值, 并且它们的值[value]会被丢弃. 如果在任何没有剩余语句 statement 的时候, 那么 tagbody 返回 nil. 然而, 如果 (go tag) 被求值, 控制会跳转到这个 tag 所表示的标签主体部分. (这些标签用 eql 来比较.)

        一个通过 tagbody 所建立的 tag 有着词法作用域[lexical scope]和动态范围[dynamic extent]. 一旦 tagbody 退出, 通过 go 到一个它的主体中的 tag 就不再合法. 允许 go 去跳转到一个不是最内部的包含这个 go 的 tagbody; 由 tagbody 所建立的这些 tag 只会遮蔽其他名字一样的 tag.

        在任何这个主体的元素的宏展开[macro expansion]之前, 确定主体的哪些元素是标签 tag, 哪些是语句 statement. 如果一个语句 statement 是一个宏表达式形式[macro form]并且它的宏展开式[macro expansion]是一个原子[atom], 那么这个原子[atom]被当作是一个语句而不是一个标签.

* 示例(Examples):

    ```LISP
    (let (val)
        (tagbody
          (setq val 1)
          (go point-a)
          (incf val 16)
        point-c
          (incf val 04)
          (go point-b)
          (incf val 32)
        point-a
          (incf val 02)
          (go point-c)
          (incf val 64)
        point-b
          (incf val 08))
        val)
    =>  15
    (defun f1 (flag)
      (let ((n 1))
        (tagbody 
          (setq n (f2 flag #'(lambda () (go out))))
          out
          (prin1 n))))
    =>  F1
    (defun f2 (flag escape)
      (if flag (funcall escape) 2))
    =>  F2
    (f1 nil)
    >>  2
    =>  NIL
    (f1 t)
    >>  1
    =>  NIL
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        go

* 注意(Notes):

        下一段的这些宏[macro]中有着隐式的 tagbody [implicit tagbody].

        do              do-external-symbols  dotimes
        do*             do-symbols           prog
        do-all-symbols  dolist               prog*

        Figure 5-10. 有着隐式的 tagbody 的宏.


### <span id="SOTHROW">特殊操作符 THROW</span>

* 语法(Syntax):

        throw tag result-form =>|

* 参数和值(Arguments and Values):

        tag---一个捕捉标签[catch tag]; 求值.
        result-form---一个表达式形式[form]; 按以下方式求值.

* 描述(Description):

        throw 导致一个局部控制转移, 转移到一个标签和 tag 是 eq 的 catch 中.

        标签 tag 首先被求值来产生一个称之为抛出标签[throw tag]的对象[object]; 然后结果表达式形式 result-form 被求值, 并且它的结果被保存下来. 如果这个结果表达式形式 result-form 产生多个值, 那么所有的值会被保存. 其中的 tag 和这个抛出标签是 eq 的最新的未完成的 catch 会退出; 保存的结果会被作为这个 catch 的值或多值返回.

        throw 发起的控制转移会像章节 5.2 (退出点的控制转移) 中描述的那样被执行.

* 示例(Examples):

    ```LISP
    (catch 'result
       (setq i 0 j 0)
       (loop (incf j 3) (incf i)
             (if (= i 3) (throw 'result (values i j))))) =>  3, 9

    (catch nil
      (unwind-protect (throw nil 1)
        (throw nil 2))) =>  2
    ```

        下面这个的结果是未定义的因为 b 的 catch 被第一个 throw 跳过了, 因此, 可移植程序必须假定其动态范围[dynamic extent]是终止的. 捕获标签[catch tag]的绑定[binding]还没有被消除, 因此它是第二个 throw 的目标.

    ```LISP
    (catch 'a
      (catch 'b
        (unwind-protect (throw 'a 1)
          (throw 'b 2))))
    ```

        下面的打印 "The inner catch returns :SECOND-THROW" 然后返回 :outer-catch.

    ```LISP
    (catch 'foo
            (format t "The inner catch returns ~s.~%"
                    (catch 'foo
                        (unwind-protect (throw 'foo :first-throw)
                            (throw 'foo :second-throw))))
            :outer-catch)
    >>  The inner catch returns :SECOND-THROW
    =>  :OUTER-CATCH
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果这里没有匹配抛出标签的未完成的捕捉标签[catch tag], 那么不会执行栈的解除(unwinding), 并且会发出一个 control-error 类型[type]的错误. 当这个错误被发出时, 动态环境[dynamic environment]是在 throw 点处生效的那个.

* 参见(See Also):

        block, catch, return-from, unwind-protect, 章节 3.1 (求值)

* 注意(Notes):

        通常当退出点[exit point]必须有动态作用域[dynamic scope]时使用 catch 和 throw (比如, 这个 throw 词法上没有被 catch 封闭), 而当词法作用域[lexical scope]足够时使用 block 和 return.


### <span id="SOUNWIND-PROTECT">特殊操作符 UNWIND-PROTECT</span>

* 语法(Syntax):

        unwind-protect protected-form cleanup-form* => result*

* 参数和值(Arguments and Values):

        protected-form---一个表达式形式[form].
        cleanup-form---一个表达式形式[form].
        results---这个 protected-form 的值[value].

* 描述(Description):

        unwind-protect 求值 protected-form 并且保证这个 cleanup-form 在 unwind-protect 退出前被执行, 不管它正常终止或被某种控制转移所跳过. unwind-protect 的目的是确保求值 protected-form 之后会发生某些副作用.

        如果在执行 cleanup-form 的时候发生一个非局部退出[non-local exit], 不会采取特殊动作. 这个 unwind-protect 的 cleanup-forms 不受 unwind-protect 保护.

        unwind-protect 防止所有企图退出 protected-form 的尝试, 包括 go, handler-case, ignore-errors, restart-case, return-from, throw, 还有 with-simple-restart.

        在退出时取消处理者[handler]和重启动[restart]绑定[binding], 与取消动态变量[dynamic variable]和 catch 标签绑定是并行的, 和它们建立的顺序是相反的. 这样做的效果是 cleanup-form 可以看到和进入 unwind-protect 时见到的一样的处理者[handler]和重启动[restart]绑定[binding], 以及动态变量[dynamic variable]绑定和 catch 标签.

* 示例(Examples):

    ```LISP
    (tagbody
      (let ((x 3))
        (unwind-protect
          (if (numberp x) (go out))
          (print x)))
     out
      ...)
    ```

        当 go 被执行时, 对 print 的调用首先被执行, 然后完成控制转移到标签 out.

    ```LISP
    (defun dummy-function (x)
       (setq state 'running)
       (unless (numberp x) (throw 'abort 'not-a-number))
       (setq state (1+ x))) =>  DUMMY-FUNCTION
    (catch 'abort (dummy-function 1)) =>  2
    state =>  2
    (catch 'abort (dummy-function 'trash)) =>  NOT-A-NUMBER
    state =>  RUNNING
    (catch 'abort (unwind-protect (dummy-function 'trash)
                     (setq state 'aborted))) =>  NOT-A-NUMBER
    state =>  ABORTED
    ```

        下面的代码是不对的:

    ```LISP
    (unwind-protect
      (progn (incf *access-count*)
             (perform-access))
      (decf *access-count*))
    ```
    
        如果在 incf 完成之前发生了一个退出, 这个 decf 表达式形式[form]无论如何都会被执行, 导致 *access-count* 的一个不正确的值. 正确的代码如下:

    ```LISP
    (let ((old-count *access-count*))
      (unwind-protect
        (progn (incf *access-count*)
               (perform-access))
        (setq *access-count* old-count)))

    ;;; The following returns 2.
    (block nil
      (unwind-protect (return 1)
        (return 2)))

    ;;; The following has undefined consequences.
    (block a
      (block b
        (unwind-protect (return-from a 1)
          (return-from b 2))))

    ;;; The following returns 2.
    (catch nil
      (unwind-protect (throw nil 1)
        (throw nil 2)))

    ;;; The following has undefined consequences because the catch of B is
    ;;; passed over by the first THROW, hence portable programs must assume
    ;;; its dynamic extent is terminated.  The binding of the catch tag is not
    ;;; yet disestablished and therefore it is the target of the second throw.
    (catch 'a
      (catch 'b
        (unwind-protect (throw 'a 1)
          (throw 'b 2))))

    ;;; The following prints "The inner catch returns :SECOND-THROW"
    ;;; and then returns :OUTER-CATCH.
    (catch 'foo
            (format t "The inner catch returns ~s.~%"
                    (catch 'foo
                        (unwind-protect (throw 'foo :first-throw)
                            (throw 'foo :second-throw))))
            :outer-catch)

    ;;; The following returns 10. The inner CATCH of A is passed over, but
    ;;; because that CATCH is disestablished before the THROW to A is executed,
    ;;; it isn't seen.
    (catch 'a
      (catch 'b
        (unwind-protect (1+ (catch 'a (throw 'b 1)))
          (throw 'a 10))))

    ;;; The following has undefined consequences because the extent of
    ;;; the (CATCH 'BAR ...) exit ends when the (THROW 'FOO ...)
    ;;; commences.
    (catch 'foo
      (catch 'bar
          (unwind-protect (throw 'foo 3)
            (throw 'bar 4)
            (print 'xxx))))

    ;;; The following returns 4; XXX is not printed.
    ;;; The (THROW 'FOO ...) has no effect on the scope of the BAR
    ;;; catch tag or the extent of the (CATCH 'BAR ...) exit.
    (catch 'bar
      (catch 'foo
          (unwind-protect (throw 'foo 3)
            (throw 'bar 4)
            (print 'xxx))))

    ;;; The following prints 5.
    (block nil
      (let ((x 5))
        (declare (special x))
        (unwind-protect (return)
          (print x))))
    ```
    
* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        catch, go, handler-case, restart-case, return, return-from, throw, 章节 3.1 (求值)

* 注意(Notes): None.


### <span id="CNIL">常量 NIL</span>

* 常量值(Constant Value):

        nil.

* 描述(Description):

        nil 表示布尔值[boolean] (还有广义的 boolean [generalized boolean]) false 还有空列表[empty list].

* 示例(Examples):

    ```LISP
    nil =>  NIL
    ```

* 参见(See Also):

        t

* 注意(Notes): None.


### <span id="FNOT">函数 NOT</span>

* 语法(Syntax):

        not x => boolean

* 参数和值(Arguments and Values):

        x---一个广义的 boolean [generalized boolean] (换句话说, 任何对象[object]).

        boolean---一个布尔值[boolean].

* 描述(Description):

        如果 x 是 false 就返回 t; 否则, 返回 nil.

* 示例(Examples):

    ```LISP
    (not nil) =>  T
    (not '()) =>  T
    (not (integerp 'sss)) =>  T
    (not (integerp 1)) =>  NIL
    (not 3.7) =>  NIL
    (not 'apple) =>  NIL
    ```
    
* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        null

* 注意(Notes):

        not 的目的是用来反转布尔值[boolean] (或者是广义的 boolean [generalized boolean]) 的"真实值(truth value)"  而 null 用于测试空列表[empty list]. 操作上, not 和 null 的计算结果是一样的; 使用哪个是一个风格问题.


### <span id="CT">常量 T</span>

* 常量值(Constant Value):

        t.

* 描述(Description):

        表示 true 的布尔值[boolean], 并且是表示 true 的标准的广义 boolean [generalized boolean]. 虽然除了 nil 以外的任何对象[object]都被当成 true, t 通常用于没有特殊理由偏爱其中一个对象而不喜欢另一个对象的情况.

        符号[symbol] t 有时也被用作其他目的. 比如, 作为一个类[class]的名字[name], 作为一个标识符[designator] (比如, 一个流标识符[stream designator]) 或者由于某些语法原因作为一个特殊符号 (比如, 在 case 和 typecase 中去表示 otherwise-clause 子句).

* 示例(Examples):

    ```LISP
    t =>  T
    (eq t 't) =>  true
    (find-class 't) =>  #<CLASS T 610703333>
    (case 'a (a 1) (t 2)) =>  1
    (case 'b (a 1) (t 2)) =>  2
    (prin1 'hello t)
    >>  HELLO
    =>  HELLO
    ```
    
* 参见(See Also):

        nil

* 注意(Notes): None.


### <span id="FEQ">函数 EQ</span>

* 语法(Syntax):

        eq x y => generalized-boolean

* 参数和值(Arguments and Values):

        x---一个对象[object].
        y---一个对象[object].
        generalized-boolean---一个广义的 boolean [generalized boolean].

* 描述(Description):

        如果它的那两个实参[argument]是一样的, 完全相同的对象[object]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (eq 'a 'b) =>  false
    (eq 'a 'a) =>  true
    (eq 3 3)
    =>  true
    OR=>  false
    (eq 3 3.0) =>  false
    (eq 3.0 3.0)
    =>  true
    OR=>  false
    (eq #c(3 -4) #c(3 -4))
    =>  true
    OR=>  false
    (eq #c(3 -4.0) #c(3 -4)) =>  false
    (eq (cons 'a 'b) (cons 'a 'c)) =>  false
    (eq (cons 'a 'b) (cons 'a 'b)) =>  false
    (eq '(a . b) '(a . b))
    =>  true
    OR=>  false
    (progn (setq x (cons 'a 'b)) (eq x x)) =>  true
    (progn (setq x '(a . b)) (eq x x)) =>  true
    (eq #\A #\A)
    =>  true
    OR=>  false
    (let ((x "Foo")) (eq x x)) =>  true
    (eq "Foo" "Foo")
    =>  true
    OR=>  false
    (eq "Foo" (copy-seq "Foo")) =>  false
    (eq "FOO" "foo") =>  false
    (eq "string-seq" (copy-seq "string-seq")) =>  false
    (let ((x 5)) (eq x x))
    =>  true
    OR=>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        eql, equal, equalp, =, 章节 3.2 (编译)

* 注意(Notes):

        在打印时显示相同的对象[object]不一定是相互之间 eq 的. 由于 intern 函数的使用, 在打印时相同的符号[symbol]通常相互之间是 eq 的. 然而, 值相同的数字[number]不需要是 eq 的, 并且两个相似的列表[list]通常也不是一样的[identical].

        一个具体实现允许在任何时间去 "拷贝" 字符[character]和数字[number]. 其结果是, 如果参数是字符[character]或数字[number], 即使它们是"相同的", Common Lisp 无法保证 eq 是 true 的.

        大部分 Common Lisp 操作符[operator]使用 eql 而不是 eq 来比较对象, 或者它们会默认用 eql, 只在特定要求下使用 eq. 然而, 下面的操作符[operator]被定义为使用 eq 而不是 eql , 它不能被使用它们的代码所覆盖:

        catch           getf     throw
        get             remf
        get-properties  remprop

        Figure 5-11. 总是使用 EQ 而不是 EQL 的操作符


### <span id="FEQL">函数 EQL</span>

* 语法(Syntax):

        eql x y => generalized-boolean

* 参数和值(Arguments and Values):

        x---一个对象[object].
        y---一个对象[object].
        generalized-boolean---一个广义的 boolean [generalized boolean].

* 描述(Description):

        两个对象, x 和 y, 在下面情况下 eql 的值是 true:

        1. 如果 x 和 y 是 eq 的.
        2. 如果 x 和 y 都是相同类型[type]的数字[number]并且值相同.
        3. 如果它们都是表示相同字符的字符[character].

        否则 eql 的值就是 false.

        如果一个具体实现支持正负零是不同[distinct]的值, 那么 (eql 0.0 -0.0) 返回 false. 否则, 当语法 -0.0 被读取时会被解释为值 0.0, 所以 (eql 0.0 -0.0) 返回 true.

* 示例(Examples):

    ```LISP
    (eql 'a 'b) =>  false
    (eql 'a 'a) =>  true
    (eql 3 3) =>  true
    (eql 3 3.0) =>  false
    (eql 3.0 3.0) =>  true
    (eql #c(3 -4) #c(3 -4)) =>  true
    (eql #c(3 -4.0) #c(3 -4)) =>  false
    (eql (cons 'a 'b) (cons 'a 'c)) =>  false
    (eql (cons 'a 'b) (cons 'a 'b)) =>  false
    (eql '(a . b) '(a . b))
    =>  true
    OR=>  false
    (progn (setq x (cons 'a 'b)) (eql x x)) =>  true
    (progn (setq x '(a . b)) (eql x x)) =>  true
    (eql #\A #\A) =>  true
    (eql "Foo" "Foo")
    =>  true
    OR=>  false
    (eql "Foo" (copy-seq "Foo")) =>  false
    (eql "FOO" "foo") =>  false
    ```
    
        通常 (eql 1.0s0 1.0d0) 是 false, 在 1.0s0 和 1.0d0 是不同的数据类型的设定下. 然而, 不提供 4 种不同浮点格式的具体实现允许将这四种格式"折叠"成更小的数字格式; 在这样一个实现中 (eql 1.0s0 1.0d0) 可能是 true.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        eq, equal, equalp, =, char=

* 注意(Notes):

        eql 和 eq 是一样的, 除了当参数是字符[character]或相同类型的数字[number]时它们的值会被比较. 因此 eql 讲述两个对象[object]是否在概念上相等, 而 eq 讲述两个对象[object]是否在实现上相等. 这也就是 eql, 而不是 eq, 是序列[sequence]作为参数的运算符[operator]的默认比较谓词的原因.

        eql 对于两个表示相同值的浮点数[float]可能不是 true. = 被用于比较算数值.

        两个复数[complex]如果它们的实部和虚部都是 eql 的就认为它们是 eql 的. 比如, (eql #C(4 5) #C(4 5)) 是 true 而 (eql #C(4 5) #C(4.0 5.0)) 是 false. 注意 (eql #C(5.0 0.0) 5.0) 是 false, 而 (eql #C(5 0) 5) 是 true. 在 (eql #C(5.0 0.0) 5.0) 情况下两个参数是不同类型, 因此不能满足 eql. 在 (eql #C(5 0) 5) 情况下, #C(5 0) 不是一个复数[complex], 但是被自动归约为整数[integer] 5.


### <span id="FEQUAL">函数 EQUAL</span>

* 语法(Syntax):

        equal x y => generalized-boolean

* 参数和值(Arguments and Values):

        x---一个对象[object].
        y---一个对象[object].
        generalized-boolean---一个广义的 boolean [generalized boolean].

* 描述(Description):

        如果 x 和 y 是结构上类似(同构)的对象[object], 则返回 true. 这些对象[object]按照以下类别被 equal 处理.

    * 符号[symbol], 数字[number], 和字符[character]

            两个对象[object]如果它们是相互 eq 的符号[symbol], 或者是相互 eql 的数字[number], 或者相互 eql 的字符[character], 那么它们的 equal 就是 true.

    * 构造[cons]

            对于 cons, equal 按照递归定义, 如果两个 car 是 equal 的并且两个 cdr 也是 equal 的那么就是 equal 的.

    * 数组[array]

            两个数组[array]只有当它们是 eq 的情况下才会 equal, 除了一个例外: 字符串[string]和位向量[bit vector]按照元素对元素一一比较 (使用 eql). 如果 x 或 y 有一个填充指针[fill pointer], 这个填充指针[fill pointer]限制被 equal 检查元素的数量. 字符串[string]中的大写字母和小写字母被 equal 认为是不同的.

    * 路径名[pathname]

            两个路径名[pathname]当且仅当所有对应的成分 (host, device, 等等) 相等的时候才是 equal 的. 大写和小写字母在组件的字符串[string]中是否被认为是等价的是依赖于具体实现的[implementation-dependent]. 多个 equal 的路径名[pathname]应该在功能上是等同的.

    * 其他 (结构体, 哈希表, 实例, ...)

            只有当两个其他对象[object]是 eq 的情况下才会 equal.

        equal 不会下降(descend)任何对象[object], 除了上面显式指定的那些. 下面这段总结了前面的列表中的信息. 另外, 这段中指明了 equal 行为的优先级, 上面的条目优先于下面的条目.

    |类型       |    行为    |
    |--        | --         |
    |数字[number]    |    使用 eql|
    |字符[character] |    使用 eql|
    |构造[cons]      |    下降(descend)|
    |位向量[bit vector]|    下降(descend)|
    |字符串[string]    |    下降(descend)|
    |路径名[pathname]  |    "功能上等价(functionally equivalent)"|
    |结构体[structure] |    使用 eq|
    |其他数组[array]|   使用 eq|
    |哈希表[hash table] |   使用 eq|
    |其他对象[object]|  使用 eq|

    Figure 5-12. equal 行为的概要和优先级

        任何两个 eql 的对象[object]也是 equal 的.

        如果 x 和 y 是环状的 equal 可能不会终止.

* 示例(Examples):

    ```LISP
    (equal 'a 'b) =>  false
    (equal 'a 'a) =>  true
    (equal 3 3) =>  true
    (equal 3 3.0) =>  false
    (equal 3.0 3.0) =>  true
    (equal #c(3 -4) #c(3 -4)) =>  true
    (equal #c(3 -4.0) #c(3 -4)) =>  false
    (equal (cons 'a 'b) (cons 'a 'c)) =>  false
    (equal (cons 'a 'b) (cons 'a 'b)) =>  true
    (equal #\A #\A) =>  true
    (equal #\A #\a) =>  false
    (equal "Foo" "Foo") =>  true
    (equal "Foo" (copy-seq "Foo")) =>  true
    (equal "FOO" "foo") =>  false
    (equal "This-string" "This-string") =>  true
    (equal "This-string" "this-string") =>  false
    ```
    
* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        eq, eql, equalp, =, string=, string-equal, char=, char-equal, tree-equal

* 注意(Notes):

        对象[object]相等性不是一个只有唯一确定的正确算法的概念. 等价谓词的适当性只能在某些特定程序的需求上下文中进行判断. 虽然这些函数接受任何类型的参数并且它们的名字听起来很通用, 但是 equal 和 equalp 不适用于每一个应用.

        一个粗略的经验法则是两个对象当且仅当它们的打印表示是相同的时候是 equal 的.


### <span id="FEQUALP">函数 EQUALP</span>

* 语法(Syntax):

        equalp x y => generalized-boolean

* 参数和值(Arguments and Values):

        x---一个对象[object].
        y---一个对象[object].
        generalized-boolean---一个广义的 boolean [generalized boolean].

* 描述(Description):

    如果 x 和 y 是 equal 的就返回 true, 或者如果它们有着相同类型[type]的组件并且那些组件也是 equalp 的就返回 true; 具体来说, equalp 在以下情况返回 true:

    * 字符[character]

            如果两个字符[character]是 char-equal 的.

    * 数字[number]

            如果两个数字[number]在 = 下是相同的[same].

    * 构造[cons]

            如果这两个 cons 中的 car 是 equalp 的并且 cdr 也是 equalp 的.

    * 数组[array]

            如果两个数组[array]有着相同的维度, 维度是匹配的, 并且对应有效[active]元素[element]是 equalp 的. 数组[array]特化[specialized]的类型[type]不需要匹配; 比如, 一个字符串[string]和一个包含相同字符[character]的普通的数组[array]是 equalp 的. 由于 equalp 执行字符串[string]元素对元素的比较并且忽略字符[character]的大小写[case], 当使用 equalp 比较字符串[string]时大小写[case]差别是被忽略的.

    * 结构体[structure]

            如果两个结构体[structure] S1 和 S2 有着相同的类[class]并且 S1 中每一个槽[slot]的值和 S2 中对应槽[slot]的值在 equalp 下是相同的[same].

    * 哈希表[hash table]

            equalp 首先通过判断元素的数量和这个 :test 函数来递减(descend) hash-tables; 如果这些是一样的, 它用 :test 函数来比较这个哈希表的 key 然后匹配的 key 对应的 value 也递归地使用 equalp.

    equalp 不会下降(descend)任何对象[object], 除了上面显式指定的那些. 下一段中总结了上面列表中给定的信息. 另外, 这段中指明了 equalp 行为的优先级, 上面的条目优先于下面的条目.

    |类型       |    行为 |
    | -- | -- |
    |数字[number]     |   使用 =|
    |字符[character]  |   使用 char-equal|
    |构造[cons]       |   descends|
    |位向量[bit vector] |   descends|
    |字符串[string]     |   descends|
    |路径名[pathname]   |   same as equal|
    |结构体[structure]  |   descends, as described above|
    |其他数组[array]|   descends|
    |哈希表[hash table] |   descends, as described above|
    |其他对象[object]|  使用 eq|

    Figure 5-13. equalp行为的优先级和总结

* 示例(Examples):

    ```LISP
    (equalp 'a 'b) =>  false
    (equalp 'a 'a) =>  true
    (equalp 3 3) =>  true
    (equalp 3 3.0) =>  true
    (equalp 3.0 3.0) =>  true
    (equalp #c(3 -4) #c(3 -4)) =>  true
    (equalp #c(3 -4.0) #c(3 -4)) =>  true
    (equalp (cons 'a 'b) (cons 'a 'c)) =>  false
    (equalp (cons 'a 'b) (cons 'a 'b)) =>  true
    (equalp #\A #\A) =>  true
    (equalp #\A #\a) =>  true
    (equalp "Foo" "Foo") =>  true
    (equalp "Foo" (copy-seq "Foo")) =>  true
    (equalp "FOO" "foo") =>  true
  
    (setq array1 (make-array 6 :element-type 'integer
                               :initial-contents '(1 1 1 3 5 7)))
    =>  #(1 1 1 3 5 7)
    (setq array2 (make-array 8 :element-type 'integer
                               :initial-contents '(1 1 1 3 5 7 2 6)
                               :fill-pointer 6))
    =>  #(1 1 1 3 5 7)
    (equalp array1 array2) =>  true
    (setq vector1 (vector 1 1 1 3 5 7)) =>  #(1 1 1 3 5 7)
    (equalp array1 vector1) =>  true
    ```
    
* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        eq, eql, equal, =, string=, string-equal, char=, char-equal

* 注意(Notes):

        对象[object]相等性不是一个只有唯一确定的正确算法的概念. 等价谓词的适当性只能在某些特定程序的需求上下文中进行判断. 虽然这些函数接受任何类型的参数并且它们的名字听起来很通用, 但是 equal 和 equalp 不适用于每一个应用.


### <span id="FIDENTITY">函数 IDENTITY</span>

* 语法(Syntax):

        identity object => object

* 参数和值(Arguments and Values):

        object---一个对象[object].

* 描述(Description):

        返回它的参数对象 object.

* 示例(Examples):

    ```LISP
    (identity 101) =>  101
    (mapcan #'identity (list (list 1 2 3) '(4 5 6))) =>  (1 2 3 4 5 6)
    ```
 
* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes):

        identity 被用于需要一个函数作为参数的函数.

        (eql x (identity x)) 对于所有 x 的可能的值返回 true, 但是 (eq x (identity x)) 当 x 是一个数字[number]或者字符[character]时可能返回 false.

        identity 可以通过以下定义

        (defun identity (x) x)


### <span id="FCOMPLEMENT">函数 COMPLEMENT</span>

* 语法(Syntax):

        complement function => complement-function

* 参数和值(Arguments and Values):

        function---一个函数[function].
        complement-function---一个函数[function].

* 描述(Description):

        返回一个和函数 function 接受相同实参[argument]并且和 function 有着相同副作用但是只返回单个值的函数[function], 返回的单个值为一个广义的 boolean [generalized boolean], 表示 function 返回的主值[primary value]的相反值. 这也就是说, 当这个 function 会返回 true 作为主值[primary value]时 complement-function 返回 false, 而当这个 function 返回 false 作为主值[primary value]时, complement-function 返回 true.

* 示例(Examples):

    ```LISP
    (funcall (complement #'zerop) 1) =>  true
    (funcall (complement #'characterp) #\A) =>  false
    (funcall (complement #'member) 'a '(a b c)) =>  false
    (funcall (complement #'member) 'd '(a b c)) =>  true
    ```
    
* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        not

* 注意(Notes):

        (complement x) ==  #'(lambda (&rest arguments) (not (apply x arguments)))

        在 Common Lisp 中, 带有像 "xxx-if-not" 名字的函数和有着类似 "xxx-if" 名字的函数之间的关系如下

        (xxx-if-not f . arguments) ==  (xxx-if (complement f) . arguments)

        比如,

        (find-if-not #'zerop '(0 0 3)) ==
        (find-if (complement #'zerop) '(0 0 3)) =>  3

        注意由于这些 "xxx-if-not" 函数[function]和 :test-not 参数已经被废弃, 首选是和 complement 一起使用 "xxx-if" 函数[function]或  :test 参数.


### <span id="FCONSTANTLY">函数 CONSTANTLY</span>

* 语法(Syntax):

        constantly value => function

* 参数和值(Arguments and Values):

        value---一个对象[object].
        function---一个函数[function].

* 描述(Description):

        constantly 返回一个接受任何数量参数的函数[function], 没有副作用, 并且总是返回 value.

* 示例(Examples):

    ```LISP
    (mapcar (constantly 3) '(a b c d)) =>  (3 3 3 3)
    (defmacro with-vars (vars &body forms)
      `((lambda ,vars ,@forms) ,@(mapcar (constantly nil) vars)))
    =>  WITH-VARS
    (macroexpand '(with-vars (a b) (setq a 3 b (* a a)) (list a b)))
    =>  ((LAMBDA (A B) (SETQ A 3 B (* A A)) (LIST A B)) NIL NIL), true
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        identity

* 注意(Notes):

        constantly 可以通过以下方式来定义:

    ```LISP
    (defun constantly (object)
      #'(lambda (&rest arguments) object))
    ```


### <span id="FEVERYSOMENOTEVERYNOTANY">函数 EVERY, SOME, NOTEVERY, NOTANY</span>

* 语法(Syntax):

        every predicate &rest sequences+ => generalized-boolean
        some predicate &rest sequences+ => result
        notevery predicate &rest sequences+ => generalized-boolean
        notany predicate &rest sequences+ => generalized-boolean

* 参数和值(Arguments and Values):

        predicate---一个实参[argument]数量多达这些序列 sequences 数量的函数[function]标识符[designator].
        sequence---一个序列[sequence].
        result---一个对象[object].
        generalized-boolean---一个广义的 boolean [generalized boolean].

* 描述(Description):

        every, some, notevery, 还有 notany 测试这些序列 sequences 的元素[element]对于这个给定的断言 predicate 的满足情况. 给 predicate 的第一个参数是第一个序列 sequence 的元素[element]; 每一个后续的参数都是后续序列 sequence 的元素[element].

        这个断言 predicate 首先应用到这些序列 sequences 的每一个索引为 0 的元素, 然后可能是索引为 1 的, 以此类推, 直到遇到一个终止准则或者到达最短序列的末尾.

        当任何一个 predicate 的调用返回 false 的时候 every 返回 false. 如果到达一个 sequence 的末尾, every 返回 true. 因此, every 当且仅当所有 predicate 返回 true 的时候返回 true.

        some 返回由一个 predicate 调用返回的第一个非 nil [non-nil]的值. 如果到达一个 sequence 的末尾还没有任何 predicate 的调用返回 true, some 返回 false. 因此, some 当且仅当某个 predicate 调用返回 true 的时候返回 true.

        当任何一个 predicate 调用返回 true 时 notany 返回 false. 如果到达一个 sequence 的末尾, notany 返回 true. 因此, notany 当且仅当任何 predicate 调用都不返回 true 的时候返回 true.

        当任何一个 predicate 调用返回 false 时 notevery 返回 true. 如果到达一个 sequence 的末尾, notevery 返回 false. 因此, notevery 当且仅当不是每一个 predicate 都返回 true 时返回 true.

* 示例(Examples):

    ```LISP
    (every #'characterp "abc") =>  true
    (some #'= '(1 2 3 4 5) '(5 4 3 2 1)) =>  true
    (notevery #'< '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) =>  false
    (notany #'> '(1 2 3 4) '(5 6 7 8) '(9 10 11 12)) =>  true
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果它的第一个参数既不是符号[symbol]也不是一个函数[function]或者如果任何后续的参数都不是一个正常序列[proper sequence], 那么应该发出一个 type-error 类型的错误.

        其他异常情况也是有可能的, 取决于 predicate 的性质.

* 参见(See Also):

        and, or, 章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        (notany predicate sequence*) ==  (not (some predicate sequence*))
        (notevery predicate sequence*) ==  (not (every predicate sequence*))


### <span id="MAND">宏 AND</span>

* 语法(Syntax):

        and form* => result*

* 参数和值(Arguments and Values):

        form---一个表达式形式[form].
        results---最后一个表达式形式 form 求值产生的值[value], 或者符号 nil 或 t.

* 描述(Description):

        宏 and 对每一个表达式形式 form 从左到右的顺序求值一次. 当任何表达式形式 form 求值为 nil 时, and 在不求值剩余表达式形式 forms 的情况下返回 nil. 如果除了最后一个以外的所有表达式形式 forms 都被求值为 true, 那么 and 就返回最后一个表达式形式 form 求值产生的结果.

        如果没有提供这些表达式形式 forms, (and) 就返回 t.

        and 传递回来自最后一个子表达式形式[subform]的多值, 但是不会传递来自除了最后一个以外的其他的子表达式形式[subform]的多值.

* 示例(Examples):

    ```LISP
    (if (and (>= n 0)
             (< n (length a-simple-vector))
             (eq (elt a-simple-vector n) 'foo))
        (princ "Foo!"))
    ```
    
        假如 n 事实上是 a-simple-vector 的一个合法的索引, 如果 a-simple-vector 中的元素 n 是符号 foo, 上面表达式就打印 Foo!. 由于 and 保证从左到右测试它的各个部分, 如果 n 超出范围那么 elt 不会被调用.

    ```LISP
    (setq temp1 1 temp2 1 temp3 1) =>  1
    (and (incf temp1) (incf temp2) (incf temp3)) =>  2
    (and (eql 2 temp1) (eql 2 temp2) (eql 2 temp3)) =>  true
    (decf temp3) =>  1
    (and (decf temp1) (decf temp2) (eq temp3 'nil) (decf temp3)) =>  NIL
    (and (eql temp1 temp2) (eql temp2 temp3)) =>  true
    (and) =>  T
    ```
    
* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        cond, every, if, or, when

* 注意(Notes):

        (and form) ==  (let () form)
        (and form1 form2 ...) ==  (when form1 (and form2 ...))

### <span id="MCOND">宏 COND</span>

* 语法(Syntax):

        cond {clause}* => result*

        clause::= (test-form form*)

* 参数和值(Arguments and Values):

        test-form---一个表达式形式[form].
        forms---一个隐式的 progn [implicit progn].
        results---第一个产生[yield] true 的 test-form 的子句 clause 的值[value], 如果在这样的子句 clause 中没有表达式形式 form 那么就是 test-form 的主值[primary value], 如果没有 test-form 产生[yield] true 就返回 nil.

* 描述(Description):

        cond 允许这些表达式形式 forms 的执行依赖于 test-form.

        test-form 按它们出现在参数列表中的顺序一次求值一个, 直到有一个 test-form 求值为 true.

        如果在这样一个子句 clause 中没有表达式形式[form], 那么 test-form 的主值[primary value]被 cond 表达式形式[form]返回. 否则, 和这个 test-form 关联的那些表达式形式 forms 按顺序求值, 从左到右, 像一个隐式的 progn [implicit progn], 并且最后一个表达式形式 form 返回的值[value]被 cond 表达式形式[form]返回.

        一旦一个 test-form 已经产生 true, 不会有其他的 test-forms 被求值. 如果没有 test-form 产生[yield] true, 那么就返回 nil.

* 示例(Examples):

    ```LISP
    (defun select-options ()
      (cond ((= a 1) (setq a 2))
            ((= a 2) (setq a 3))
            ((and (= a 3) (floor a 2)))
            (t (floor a 3)))) =>  SELECT-OPTIONS
    (setq a 1) =>  1
    (select-options) =>  2
    a =>  2
    (select-options) =>  3
    a =>  3
    (select-options) =>  1
    (setq a 5) =>  5
    (select-options) =>  1, 2
    ```
    
* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        if, case.

* 注意(Notes): None.


### <span id="SOIF">特殊操作符 IF</span>

* 语法(Syntax):

        if test-form then-form [else-form] => result*

* 参数和值(Arguments and Values):

        Test-form---一个表达式形式[form].
        Then-form---一个表达式形式[form].
        Else-form---一个表达式形式[form]. 默认是 nil.
        results---如果这个 test-form 产生[yield] true, 那么就是 then-form 返回的值[value]; 否则, 就是 else-form 返回的值[value].

* 描述(Description):

        if 允许一个表达式形式[form]的执行取决于一个单独的 test-form.

        首先 test-form 被求值. 如果结果是 true, 那么 then-form 被选择; 否则 else-form 被选择. 不管哪个 form 被选择, 都会在接下来被求值.

* 示例(Examples):

    ```LISP
    (if t 1) =>  1
    (if nil 1 2) =>  2
    (defun test ()
      (dolist (truth-value '(t nil 1 (a b c)))
        (if truth-value (print 'true) (print 'false))
        (prin1 truth-value))) =>  TEST
    (test)
    >>  TRUE T
    >>  FALSE NIL
    >>  TRUE 1
    >>  TRUE (A B C)
    =>  NIL
    ```
    
* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        cond, unless, when

* 注意(Notes):

        (if test-form then-form else-form)
        ==  (cond (test-form then-form) (t else-form))


### <span id="MOR">宏 OR</span>

* 语法(Syntax):

        or form* => results*

* 参数和值(Arguments and Values):

        form---一个表达式形式[form].

        results---最后一个被执行的表达式形式 form 的求值所产生的值[value]或主值[primary value] (见下方) 或者是 nil.

* 描述(Description):

        or 求值每个表达式形式 form, 一次一个, 从左到右. 当一个表达式形式 form 求值为 true (换句话说, 某个不是 nil 的结果) 则所有表达式形式 forms 的求值结束.

        如果除了最后一个以外的任何表达式形式 form 的求值[evaluation]都返回 true 的主值[primary value], 那么 or 在不求值剩下那些表达式形式 forms 的情况下立即返回这个值[value] (但是没有其他额外的值[value]). 如果除了最后一个以外每个表达式形式 form 都返回 false 作为主值[primary value], or 返回最后一个表达式形式 form 的所有值[value]. 如果没有提供表达式形式 forms, or 返回 nil.

* 示例(Examples):

    ```LISP
    (or) =>  NIL
    (setq temp0 nil temp1 10 temp2 20 temp3 30) =>  30
    (or temp0 temp1 (setq temp2 37)) =>  10
    temp2 =>  20
    (or (incf temp1) (incf temp2) (incf temp3)) =>  11
    temp1 =>  11
    temp2 =>  20
    temp3 =>  30
    (or (values) temp1) =>  11
    (or (values temp1 temp2) temp3) =>  11
    (or temp0 (values temp1 temp2)) =>  11, 20
    (or (values temp0 temp1) (values temp2 temp3)) =>  20, 30
    ```
    
* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        and, some, unless

* 注意(Notes): None.


### <span id="MWHENUNLESS">宏 WHEN, UNLESS</span>

* 语法(Syntax):

        when test-form form* => result*
        unless test-form form* => result*

* 参数和值(Arguments and Values):

        test-form---一个表达式形式[form].
        forms---一个隐式的 progn [implicit progn].
        results---如果 when 表达式形式[form]中的 test-form 产生[yield] true 那么就是一个 when 表达式形式[form]中的那些表达式形式 forms 的值[value], 如果 unless 表达式形式[form]中的 test-form 产生[yield] false 那么就是 unless 表达式形式[form]中的那些表达式形式 forms 的值[value]; 否则就是 nil.

* 描述(Description):

        when 和 unless 允许这些表达式形式 forms 的求值取决于单独的 test-form.

        在一个 when 表达式形式[form]中, 如果这个 test-form 产生[yield] true, 这些表达式形式 forms 按从左到右的顺序求值并从 when 表达式形式[form]中返回这些表达式形式 forms 所返回的值[value]. 否则, 如果 test-form 产生 false, 这些表达式形式 forms 不会被求值, 然后这个 when 表达式形式[form]返回 nil.

        在一个 unless 表达式形式[form]中, 如果这个 test-form 产生[yield] false, 这些表达式形式 forms 按从左到右的顺序求值并从 unless 表达式形式[form]中返回 forms 所返回的值[value]. 否则, 如果这个 test-form 产生[yield] false, 这些表达式形式 forms 不会被求值, 并且这个 unless 表达式形式[form]返回 nil.

* 示例(Examples):

    ```LISP
    (when t 'hello) =>  HELLO
    (unless t 'hello) =>  NIL
    (when nil 'hello) =>  NIL
    (unless nil 'hello) =>  HELLO
    (when t) =>  NIL
    (unless nil) =>  NIL
    (when t (prin1 1) (prin1 2) (prin1 3))
    >>  123
    =>  3
    (unless t (prin1 1) (prin1 2) (prin1 3)) =>  NIL
    (when nil (prin1 1) (prin1 2) (prin1 3)) =>  NIL
    (unless nil (prin1 1) (prin1 2) (prin1 3))
    >>  123
    =>  3
    (let ((x 3))
      (list (when (oddp x) (incf x) (list x))
            (when (oddp x) (incf x) (list x))
            (unless (oddp x) (incf x) (list x))
            (unless (oddp x) (incf x) (list x))
            (if (oddp x) (incf x) (list x))
            (if (oddp x) (incf x) (list x))
            (if (not (oddp x)) (incf x) (list x))
            (if (not (oddp x)) (incf x) (list x))))
    =>  ((4) NIL (5) NIL 6 (6) 7 (7))
    ```
    
* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        and, cond, if, or

* 注意(Notes):

    ```LISP
    (when test {form}+) ==  (and test (progn {form}+))
    (when test {form}+) ==  (cond (test {form}+))
    (when test {form}+) ==  (if test (progn {form}+) nil)
    (when test {form}+) ==  (unless (not test) {form}+)
    (unless test {form}+) ==  (cond ((not test) {form}+))
    (unless test {form}+) ==  (if test nil (progn {form}+))
    (unless test {form}+) ==  (when (not test) {form}+)
    ```

### <span id="MCASECCASEECASE">宏 CASE, CCASE, ECASE</span>

* 语法(Syntax):

        case keyform {normal-clause}* [otherwise-clause] => result*
        ccase keyplace {normal-clause}* => result*
        ecase keyform {normal-clause}* => result*
        normal-clause::= (keys form*)
        otherwise-clause::= ({otherwise | t} form*)
        clause::= normal-clause | otherwise-clause

* 参数和值(Arguments and Values):

        keyform---一个表达式形式[form]; 求值后产生一个 test-key.
        keyplace---一个表达式形式[form]; 求值后产生一个 test-key. 如果没有 key 匹配那么可能被用作一个位置[place].
        test-key---通过求值 keyform 或 keyplace 所产生的一个对象.
        keys---一个对象[object]列表[list]的标识符[designator]. 在 case 的情况下, 符号[symbol] t 和 otherwise 可能不被用作 keys 标识符[designator]. 为了将这些符号[symbol]自身作为 keys 来引用, 必须分别使用标识符[designator] (t) 和 (otherwise), .
        forms---一个隐式的 progn [implicit progn].
        results---匹配的子句 clause 中的表达式形式 form 所返回的值[value].

* 描述(Description):

        这些宏[macro]允许一个子句 clause 中的那些表达式形式 forms 主体被条件执行, 这个子句通过在它的标识上匹配 test-key 来选择.

        这个 keyform 或者 keyplace 被求值用于产生 test-key.

        每一个 normal-clause 依次被考虑. 如果 test-key 和任何子句 clause 中的键[key]是相同的[same], 那么这个子句 clause 中的那些表达式形式 forms 作为一个隐式的 progn [implicit progn]来求值, 然后它返回的值[value]会被 case, ccase, 或 ecase 表达式形式[form]作为结果返回.

        这些宏[macro]只在没有匹配到 normal-clause 时, 会有不同的行为; 具体来说:

    * case

            如果没有匹配到 normal-clause, 并且这里有一个 otherwise-clause, 那么这个 otherwise-clause 自动匹配; 那个子句 clause 中的那些表达式形式 forms 会作为一个隐式的 progn [implicit progn]被求值, 并且它返回的值[value]作为 case 的结果被返回.

            如果这里没有 otherwise-clause, case 返回 nil.

    * ccase

            如果没有 normal-clause 匹配, 一个 type-error 类型[type]的可校正[correctable]的错误[error]会被发出. 这个违背的基准是 test-key 和期望的类型是类型等价[type equivalent]于 (member key1 key2 ...). 这个 store-value 重启动[restart]可以被用于校正这个错误.

            如果这个 store-value 重启动[restart]被调用, 它的实参[argument]会成为新的 test-key, 并且被存储在 keyplace 就像是通过 (setf keyplace test-key) 一样. 然后 ccase 重新开始, 再考虑每一个子句 clause.

            如果没有情况支持, 这个 keyplace 的那些子表达式形式可能被再次求值.

    * ecase

            如果没有 normal-clause 匹配, 一个 type-error 类型[type]的不可校正[non-correctable]的错误[error]会被发出. 违背的基准是 test-key 和期望的类型是类型等价[type equivalent]于 (member key1 key2 ...).

            注意, 与 ccase 相比, 对 ecase 的调用可能依赖于如果没有 normal-clause 匹配的情况下那么 ecase 不返回的事实.

* 示例(Examples):

    ```LISP
    (dolist (k '(1 2 3 :four #\v () t 'other))
       (format t "~S "
          (case k ((1 2) 'clause1)
                  (3 'clause2)
                  (nil 'no-keys-so-never-seen)
                  ((nil) 'nilslot)
                  ((:four #\v) 'clause4)
                  ((t) 'tslot)
                  (otherwise 'others))))
    >>  CLAUSE1 CLAUSE1 CLAUSE2 CLAUSE4 CLAUSE4 NILSLOT TSLOT OTHERS
    =>  NIL
    (defun add-em (x) (apply #'+ (mapcar #'decode x)))
    =>  ADD-EM
    (defun decode (x)
      (ccase x
        ((i uno) 1)
        ((ii dos) 2)
        ((iii tres) 3)
        ((iv cuatro) 4)))
    =>  DECODE
    (add-em '(uno iii)) =>  4
    (add-em '(uno iiii))
    >>  Error: The value of X, IIII, is not I, UNO, II, DOS, III,
    >>         TRES, IV, or CUATRO.
    >>   1: Supply a value to use instead.
    >>   2: Return to Lisp Toplevel.
    >>  Debug> :CONTINUE 1
    >>  Value to evaluate and use for X: 'IV
    =>  5
    ```

* 副作用(Side Effects):

        可能进入调试器(debugger). 如果调用了 store-value 重启动[restart], 这个 keyplace 的值[value]可能被改变.

* 受此影响(Affected By):

        ccase 和 ecase, 因为它们可能发出一个错误, 所以受存在的那些处理者 handlers 和 *debug-io* 的潜在影响.

* 异常情况(Exceptional Situations):

        如果没有匹配到 normal-clause 那么 ccase 和 ecase 发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        cond, typecase, setf, 章节 5.1 (广义引用)

* 注意(Notes):

        (case test-key
          {((key*) form*)}*)
        ==
        (let ((#1=#:g0001 test-key))
          (cond {((member #1# '(key*)) form*)}*))

        ecase 和 ccase 所使用的具体错误信息在不同的具体实现之间可以是不同的. 在错误消息的特定措辞的控制是很重要的情况下, 最好使用 case 与 otherwise-clause 来显式地用适当的消息发出错误消息.


### <span id="MTYPECASECTYPECASEETYPECASE">宏 TYPECASE, CTYPECASE, ETYPECASE</span>

* 语法(Syntax):

        typecase keyform {normal-clause}* [otherwise-clause] => result*
        ctypecase keyplace {normal-clause}* => result*
        etypecase keyform {normal-clause}* => result*
        normal-clause::= (type form*)
        otherwise-clause::= ({otherwise | t} form*)
        clause::= normal-clause | otherwise-clause

* 参数和值(Arguments and Values):

        keyform---一个表达式形式[form]; 求值后产生一个 test-key.
        keyplace---一个表达式形式[form]; 求值后产生一个 test-key. 如果没有类型匹配的时候也可能被用作一个位置[place].
        test-key---求值 keyform 或 keyplace 产生的对象.
        type---一个类型指定符[type specifier].
        forms---一个隐式的 progn [implicit progn].
        results---匹配的子句 clause 中的那些表达式形式 forms 所返回的值[value].

* 描述(Description):

        这些宏[macro]允许有条件地执行一个子句 clause 中的主体表达式形式 forms, 这个子句 clause 是通过在 test-key 上匹配它的类型[type]来选择的.

        这里的 keyform 或 keyplace 求值后产生 test-key.

        每一个 normal-clauses 都会被依次考虑. 如果 test-key 是这些子句 clauses 的类型所给定的类型[type], 那么这个子句 clause 中的这些表达式形式 forms 作为一个隐式的 progn [implicit progn]被执行, 并且它返回的值作为 typecase, ctypecase, 或 etypecase 表达式形式[form]的值被返回.

        这些宏[macro]的行为只有在没有匹配的 normal-clause 情况下有所区别; 具体来说:

    * typecase

            如果没有 normal-clause 匹配, 并且这里有一个 otherwise-clause, 那么这个 otherwise-clause 自动匹配; 这个子句 clause 中的那些表达式形式 forms 作为一个隐式的 progn [implicit progn]被执行, 并且它返回的值[value]作为 typecase 的值被返回.

            如果这里没有 otherwise-clause, typecase 返回 nil.

    * ctypecase

            如果没有 normal-clause 匹配, 一个 type-error 类型[type]的可校正[correctable]的错误[error]会被发出. 违背的基准是 test-key 和期望的类型是和 (or type1 type2 ...) 类型等价[type equivalent]. 这个 store-value 重启动[restart]可以被用于校正这个错误.

            如果调用了 store-value 重启动[restart], 它的实参[argument]会成为新的 test-key, 然后被存储在 keyplace 就好像是通过 (setf keyplace test-key) 一样. 然后 ctypecase 重新启动, 再次考虑每一个 clause.

            如果这个 store-value 重启动[restart]被交互式地调用了, 那么提示用户去使用一个新的 test-key.

            如果没有情况支持, 这个 keyplace 的子表达式形式可能被再次求值.

    * etypecase

            如果没有匹配的 normal-clause, 一个不可校正[non-correctable]的 type-error 类型[type]的错误[error]会被发出. 违背的基准是 test-key 以及期望的类型和 (or type1 type2 ...) 类型等价[type equivalent].

            注意, 相比于 ctypecase, 对 etypecase 的调用可能依赖于如果没有匹配的 normal-clause 那么 etypecase 不返回的事实.

    在所有这三种情况下, 允许超过一个子句 clause 去指定匹配类型[type], 特别是在一个已经是另一个的子类型[subtype]的时候; 最早可应用的 clause 会被选择.

* 示例(Examples):

    ```LISP
    ;;; (Note that the parts of this example which use TYPE-OF
    ;;;  are implementation-dependent.)
    (defun what-is-it (x)
      (format t "~&~S is ~A.~%"
              x (typecase x
                  (float "a float")
                  (null "a symbol, boolean false, or the empty list")
                  (list "a list")
                  (t (format nil "a(n) ~(~A~)" (type-of x))))))
    =>  WHAT-IS-IT
    (map 'nil #'what-is-it '(nil (a b) 7.0 7 box))
    >>  NIL is a symbol, boolean false, or the empty list.
    >>  (A B) is a list.
    >>  7.0 is a float.
    >>  7 is a(n) integer.
    >>  BOX is a(n) symbol.
    =>  NIL
    (setq x 1/3)
    =>  1/3
    (ctypecase x
        (integer (* x 4))
        (symbol  (symbol-value x)))
    >>  Error: The value of X, 1/3, is neither an integer nor a symbol.
    >>  To continue, type :CONTINUE followed by an option number:
    >>   1: Specify a value to use instead.
    >>   2: Return to Lisp Toplevel.
    >>  Debug> :CONTINUE 1
    >>  Use value: 3.7
    >>  Error: The value of X, 3.7, is neither an integer nor a symbol.
    >>  To continue, type :CONTINUE followed by an option number:
    >>   1: Specify a value to use instead.
    >>   2: Return to Lisp Toplevel.
    >>  Debug> :CONTINUE 1
    >>  Use value: 12
    =>  48
    x =>  12
    ```

* 受此影响(Affected By):

        ctypecase 和 etypecase, 因为它们可能发出一个错误, 所以被存在的那些处理者 handlers 和 *debug-io* 潜在地影响.

* 异常情况(Exceptional Situations):

        如果没有 normal-clause 匹配那么 ctypecase 和 etypecase 发出一个 type-error 类型[type]的错误.

        如果一个 clause 被更早子句所遮蔽导致不会被选择到, 编译器[compiler]可能会选择去发出一个 style-warning 类型[type]的警告.

* 参见(See Also):

        case, cond, setf, 章节 5.1 (广义引用)

* 注意(Notes):

        (typecase test-key
          {(type form*)}*)
        ==
        (let ((#1=#:g0001 test-key))
          (cond {((typep #1# 'type) form*)}*))

        etypecase 和 ctypecase 所使用的具体错误信息在不同的具体实现之间可以是不同的. 在错误消息的具体措辞的控制很重要的情况下, 最好使用 typecase 与 otherwise-clause 来显式地用适当的消息发出错误消息.


### <span id="MMULTIPLE-VALUE-BIND">宏 MULTIPLE-VALUE-BIND</span>

* 语法(Syntax):

        multiple-value-bind (var*) values-form declaration* form*
        => result*

* 参数和值(Arguments and Values):

        var---一个命名一个变量的符号[symbol]; 不求值.
        values-form---一个表达式形式[form]; 求值.
        declaration---一个 declare 表达式[expression]; 不求值.
        forms---一个隐式的 progn [implicit progn].
        results---这些表达式形式 forms 返回的值[value].

* 描述(Description):

        为 vars 创建新的变量绑定[binding]并且使用这些绑定[binding]执行一系列表达式形式 forms.

        创建的这个变量绑定[binding]是词法的, 除非指定了 special 声明.

        值表达式形式 values-form 被求值, 并且这些变量 vars 中的每一个都分别被绑定为那个表达式形式 form 返回的值. 如果这里的 vars 数量超过返回的值的数量, 额外的 nil 值被赋予剩余的 vars. 如果值的数量超过 vars, 多出来的值会被丢弃. vars 在这些表达式形式 forms 执行时被绑定为这些值, 这些表达式形式 forms 组成了隐式的 progn [implicit progn]. 如果一个 var 被指定了类型声明 declaration, 而绑定到这个 var 的值不符合这个类型声明 declaration, 那么结果是不确定的.

        这些名称绑定和声明 declarations 的作用域[scope]不包括 values-form.

* 示例(Examples):
    
    ```LISP
    (multiple-value-bind (f r)
        (floor 130 11)
      (list f r)) =>  (11 9)
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        let, multiple-value-call

* 注意(Notes):

        (multiple-value-bind (var*) values-form form*)
        ==  (multiple-value-call #'(lambda (&optional var* &rest #1=#:ignore)
                                    (declare (ignore #1#))
                                    form*)
                                values-form)


### <span id="SOMULTIPLE-VALUE-CALL">特殊操作符 MULTIPLE-VALUE-CALL</span>

* 语法(Syntax):

        multiple-value-call function-form form* => result*

* 参数和值(Arguments and Values):

        function-form---一个表达式形式[form]; 求值后产生函数 function.
        function---通过求值 function-form 得到的一个函数标识符[function designator].
        form---一个表达式形式[form].
        results---函数 function 返回的值[value].

* 描述(Description):

        应用函数 function 到从多值[multiple values[2]]组中收集而来的这些对象[object]的一个列表[list]上.

        multiple-value-call 首先求值 function-form 来获取函数 function, 然后求值每一个表达式形式 form. 每个 form 的所有的值都被一起收集 (不只是每个表达式形式 form 的一个值) 然后作为参数传递给 function.

* 示例(Examples):

    ```LISP
    (multiple-value-call #'list 1 '/ (values 2 3) '/ (values) '/ (floor 2.5))
    =>  (1 / 2 3 / / 2 0.5)
    (+ (floor 5 3) (floor 19 4)) ==  (+ 1 4)
    =>  5
    (multiple-value-call #'+ (floor 5 3) (floor 19 4)) ==  (+ 1 2 4 3)
    =>  10
    ```
    
* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        multiple-value-list, multiple-value-bind

* 注意(Notes): None.


### <span id="MMULTIPLE-VALUE-LIST">宏 MULTIPLE-VALUE-LIST</span>

* 语法(Syntax):

        multiple-value-list form => list

* 参数和值(Arguments and Values):

        form---一个表达式形式[form]; 按如下所述求值.
        list---form 返回的那些值[value]的一个列表[list].

* 描述(Description):

        multiple-value-list 求值表达式形式 form 并且创建它返回的那些多值[multiple values[2]]的一个列表[list].

* 示例(Examples):
    
    ```LISP
    (multiple-value-list (floor -3 4)) =>  (-1 1)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        values-list, multiple-value-call

* 注意(Notes):

        multiple-value-list 和 values-list 是互逆的.

        (multiple-value-list form) ==  (multiple-value-call #'list form)


### <span id="SOMULTIPLE-VALUE-PROG1">特殊操作符 MULTIPLE-VALUE-PROG1</span>

* 语法(Syntax):

        multiple-value-prog1 first-form form* => first-form-results

* 参数和值(Arguments and Values):

        first-form---一个表达式形式[form]; 如下所述求值.
        form---一个表达式形式[form]; 如下所述求值.
        first-form-results---这个 first-form 的求值[evaluation]得到的值[value].

* 描述(Description):

        multiple-value-prog1 求值 first-form 然后把这个表达式形式[form]产生的所有值保存起来. 然后它从左到右求值每个表达式形式 form, 丢弃它们的值.

* 示例(Examples):

    ```LISP
    (setq temp '(1 2 3)) =>  (1 2 3)
    (multiple-value-prog1
       (values-list temp)
       (setq temp nil)
       (values-list temp)) =>  1, 2, 3
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        prog1

* 注意(Notes): None.


### <span id="MMULTIPLE-VALUE-SETQ">宏 MULTIPLE-VALUE-SETQ</span>

* 语法(Syntax):

        multiple-value-setq vars form => result

* 参数和值(Arguments and Values):

        vars---一个符号[symbol]列表[list], 这些符号是变量[variable]名字[name]或符号宏[symbol macro]的名字[name].
        form---一个表达式形式[form].
        result---这个表达式形式 form 返回的主值[primary value].

* 描述(Description):

        multiple-value-setq 给这些变量 vars 赋值.

        这个表达式形式 form 被求值, 然后每个变量 var 被赋予这个表达式形式 form 返回的对应的值[value]. 如果这里的这些变量 vars 的数量超过返回值[value]的数量, nil 会被赋值给多余的变量 vars. 如果返回值[value]的数量多于变量 vars, 多余的值[value]会被丢弃.

        如果任何变量 var 是一个符号宏[symbol macro]的名字[name], 那么它就会像是通过 setf 的一样被赋值. 具体的说, 为了使求值顺序和副作用的规则与 setf 使用的规则一致

        (multiple-value-setq (symbol1 ... symboln) value-producing-form)

        被定义为像下面方式一样运作

        (values (setf (values symbol1 ... symboln) value-producing-form))

        见章节 5.1.2.3 (VALUES 表达式形式作为位置).

* 示例(Examples):

    ```LISP
    (multiple-value-setq (quotient remainder) (truncate 3.2 2)) =>  1
    quotient =>  1
    remainder =>  1.2
    (multiple-value-setq (a b c) (values 1 2)) =>  1
    a =>  1
    b =>  2
    c =>  NIL
    (multiple-value-setq (a b) (values 4 5 6)) =>  4
    a =>  4
    b =>  5
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        setq, symbol-macrolet

* 注意(Notes): None.


### <span id="AVALUES">访问器 VALUES</span>

* 语法(Syntax):

        values &rest object => object*
        (setf (values &rest place) new-values)

* 参数和值(Arguments and Values):

        object---一个对象[object]
        place---一个位置[place].
        new-value---一个对象[object].

* 描述(Description):

        values 以多值[multiple values[2]]的形式返回这些对象 objects.

        values 的 setf 被用于存储这些多值[multiple values[2]] new-values 到这些位置 places. 见章节 5.1.2.3 (VALUES 表达式形式作为位置).

* 示例(Examples):

    ```LISP
    (values) =>  <no values>
    (values 1) =>  1
    (values 1 2) =>  1, 2
    (values 1 2 3) =>  1, 2, 3
    (values (values 1 2 3) 4 5) =>  1, 4, 5
    (defun polar (x y)
      (values (sqrt (+ (* x x) (* y y))) (atan y x))) =>  POLAR
    (multiple-value-bind (r theta) (polar 3.0 4.0)
      (vector r theta))
    =>  #(5.0 0.927295)
    ```

        有时我们需要显式指出函数只返回一个值. 比如, 函数
    
    ```LISP
    (defun foo (x y)
      (floor (+ x y) y)) =>  FOO
    ```
    
        由于 floor 返回两个值因此它也返回两个值. 第二个值可能是没有意义的, 或者出于效率考虑, 我们不希望计算第二个值. values 是表示只返回一个值的标准惯用语:

    ```LISP
    (defun foo (x y)
      (values (floor (+ x y) y))) =>  FOO
    ```

        这个正常工作是因为 values 只返回参数 args 中的每一个的一个值; 对于任何函数调用, 如果任何参数产生不止一个值, 除了第一个以外其他都被丢弃.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        values-list, multiple-value-bind, multiple-values-limit, 章节 3.1 (求值)

* 注意(Notes):

        由于 values 是一个函数[function], 不是一个宏[macro]或者特殊表达式形式[special form], 它只接收它的实参[argument]表达式形式[form]的主值[primary value]作为它的实参[argument].


### <span id="FVALUES-LIST">函数 VALUES-LIST</span>

* 语法(Syntax):

        values-list list => element*

* 参数和值(Arguments and Values):

        list---一个列表[list].
        elements---这个列表 list 的元素[element].

* 描述(Description):

        以多值[multiple values[2]]的形式返回这个列表 list 的元素[element].

* 示例(Examples):

    ```LISP
    (values-list nil) =>  <no values>
    (values-list '(1)) =>  1
    (values-list '(1 2)) =>  1, 2
    (values-list '(1 2 3)) =>  1, 2, 3
    ```
    
* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果参数不是一个正规列表[proper list], 应该会发出一个 type-error 的错误.

* 参见(See Also):

        multiple-value-bind, multiple-value-list, multiple-values-limit, values

* 注意(Notes):

        (values-list list) ==  (apply #'values list)

        (equal x (multiple-value-list (values-list x))) 对于所有的列表[list] x 返回 true.


### <span id="CMULTIPLE-VALUES-LIMIT">常量 MULTIPLE-VALUES-LIMIT</span>

* 常量值(Constant Value):

        一个不小于 20 的整数[integer], 准确的大小是依赖于具体实现的[implementation-dependent].

* 描述(Description):

        可以被一个函数[function]返回, 被 multiple-value-bind 或 multiple-value-setq 绑定或赋值还有作为传递给 nth-value 的第一个参数的值[value]数量的上限. (如果这些单独的限制不同, 则使用最小值.)

* 示例(Examples): None.

* 参见(See Also):

        lambda-parameters-limit, call-arguments-limit

* 注意(Notes):

        鼓励实现者去使这个限制尽可能的大.


### <span id="MNTH-VALUE">宏 NTH-VALUE</span>

* 语法(Syntax):

        nth-value n form => object

* 参数和值(Arguments and Values):

        n---一个非负整数[integer]; 求值的.
        form---一个表达式形式[form]; 按如下所述求值.
        object---一个对象[object].

* 描述(Description):

        求值 n 和表达式形式 form, 表达式形式 form 产生的第 n 个值作为唯一的值返回, 如果 n 大于等于表达式形式 form 返回的值[value]的数量那么就是 nil. (返回的第一个值编号为 0.)

* 示例(Examples):
    
    ```LISP
    (nth-value 0 (values 'a 'b)) =>  A
    (nth-value 1 (values 'a 'b)) =>  B
    (nth-value 2 (values 'a 'b)) =>  NIL
    (let* ((x 83927472397238947423879243432432432)
           (y 32423489732)
           (a (nth-value 1 (floor x y)))
           (b (mod x y)))
      (values a b (= a b)))
    =>  3332987528, 3332987528, true
    ```
    
* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        multiple-value-list, nth

* 注意(Notes):

        操作上, 下面的关系是 true 的, 尽管 nth-value 在某些实现中可能由于某些因素而更高效, 比如, 可以避免一些 cons.

        (nth-value n form) ==  (nth n (multiple-value-list form))


### <span id="MPROGPROG*">宏 PROG, PROG*</span>

* 语法(Syntax):

        prog ({var | (var [init-form])}*) declaration* {tag | statement}*
        => result*

        prog* ({var | (var [init-form])}*) declaration* {tag | statement}*
        => result*

* 参数和值(Arguments and Values):

        var---变量名字.
        init-form---一个表达式形式[form].
        declaration---一个 declare 表达式[expression]; 不求值.
        tag---一个 go 标签[go tag]; 不求值.
        statement---一个复合表达式形式[compound form]; 按如下所述求值.
        results---如果发生正常返回[normal return]就是 nil, 否则, 如果发生一个显式返回[explicit return], 就是转移的那些值[value].

* 描述(Description):

        由 prog 和 prog* 执行三个不同的操作: 它们绑定局部变量, 它们允许 return 语句的使用, 并且它们允许 go 语句的使用. 一个典型的 prog 看上去像这样:

        (prog (var1 var2 (var3 init-form-3) var4 (var5 init-form-5))
              declaration*
              statement1
         tag1
              statement2
              statement3
              statement4
         tag2
              statement5
              ...
              )

        对于 prog, 这些 init-forms 首先被求值, 按照它们提供的顺序. 这些变量 vars 并行地绑定为对应的值. 如果没有为一个给定的变量 var 提供 init-form, 那个这个变量 var 绑定为 nil.

        这个 prog 的主体部分好像它是一个 tagbody 表达式形式[form]一样被执行; 这个 go 语句可以被用于转移控制到一个 tag. 这些 tags 标注这些语句 statements.

        prog 在整个 prog 表达式形式[form]周围隐式建立一个名为 nil 的 block, 这样 return 可以在任何想要退出 prog 表达式形式[form]的时候被使用.

        prog* 和 prog 之间的不同在于 prog* 顺序执行这些变量 vars 的绑定[binding]和初始化, 因此每一个的 init-form 都可以使用前一个的值.

* 示例(Examples):
    
    ```LISP
    (prog* ((y z) (x (car y)))
          (return x))
    ```
    
        返回 z 的 car 部分.

    ```LISP
    (setq a 1) =>  1
    (prog ((a 2) (b a)) (return (if (= a b) '= '/=))) =>  /=
    (prog* ((a 2) (b a)) (return (if (= a b) '= '/=))) =>  =
    (prog () 'no-return-value) =>  NIL

    (defun king-of-confusion (w)
      "Take a cons of two lists and make a list of conses.
       Think of this function as being like a zipper."
      (prog (x y z)          ;Initialize x, y, z to NIL
           (setq y (car w) z (cdr w))
       loop
           (cond ((null y) (return x))
                 ((null z) (go err)))
       rejoin
           (setq x (cons (cons (car y) (car z)) x))
           (setq y (cdr y) z (cdr z))
           (go loop)
       err
           (cerror "Will self-pair extraneous items"
                   "Mismatch - gleep!  ~S" y)
           (setq z y)
           (go rejoin))) =>  KING-OF-CONFUSION
    ```
    
        按照下面这样这可以更详细地完成:

    ```LISP
    (defun prince-of-clarity (w)
      "Take a cons of two lists and make a list of conses.
       Think of this function as being like a zipper."
      (do ((y (car w) (cdr y))
           (z (cdr w) (cdr z))
           (x '() (cons (cons (car y) (car z)) x)))
          ((null y) x)
        (when (null z)
          (cerror "Will self-pair extraneous items"
                 "Mismatch - gleep!  ~S" y)
          (setq z y)))) =>  PRINCE-OF-CLARITY
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        block, let, tagbody, go, return, 章节 3.1 (求值)

* 注意(Notes):

        prog 可以被解释为 block, let, 和 tagbody, 如下所述:

        (prog variable-list declaration . body)
           ==  (block nil (let variable-list declaration (tagbody . body)))


### <span id="MPROG1PROG2">宏 PROG1, PROG2</span>

* 语法(Syntax):

        prog1 first-form form* => result-1
        prog2 first-form second-form form* => result-2

* 参数和值(Arguments and Values):

        first-form---一个表达式形式[form]; 按如下所述求值.
        second-form---一个表达式形式[form]; 按如下所述求值.
        forms---一个隐式的 progn [implicit progn]; 按如下所述求值.
        result-1---这个 first-form 的求值[evaluation]所产生的主值[primary value].
        result-2---这个 second-form 的求值[evaluation]所产生的主值[primary value].

* 描述(Description):

        prog1 求值[evaluate] first-form 然后再是其他表达式形式 forms, first-form 产生的主值[primary value]作为唯一的返回值[value].

        prog2 求值[evaluate] first-form, 然后 second-form, 然后再是这些表达式形式 forms, 第二个表达式形式 second-form 产生的主值[primary value]作为唯一的返回值[value].

* 示例(Examples):

    ```LISP
    (setq temp 1) =>  1
    (prog1 temp (print temp) (incf temp) (print temp))
    >>  1
    >>  2
    =>  1
    (prog1 temp (setq temp nil)) =>  2
    temp =>  NIL
    (prog1 (values 1 2 3) 4) =>  1
    (setq temp (list 'a 'b 'c))
    (prog1 (car temp) (setf (car temp) 'alpha)) =>  A
    temp =>  (ALPHA B C)
    (flet ((swap-symbol-values (x y)
             (setf (symbol-value x)
                   (prog1 (symbol-value y)
                          (setf (symbol-value y) (symbol-value x))))))
      (let ((*foo* 1) (*bar* 2))
        (declare (special *foo* *bar*))
        (swap-symbol-values '*foo* '*bar*)
        (values *foo* *bar*)))
    =>  2, 1
    (setq temp 1) =>  1
    (prog2 (incf temp) (incf temp) (incf temp)) =>  3
    temp =>  4
    (prog2 1 (values 2 3 4) 5) =>  2
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        multiple-value-prog1, progn

* 注意(Notes):

        prog1 和 prog2 通常被用于求值[evaluate]一个或多个带有副作用的表达式形式[form]并且返回一个在一些或所有副作用发生之前计算的值[value].

        (prog1 form*) ==  (values (multiple-value-prog1 form*))
        (prog2 form1 form*) ==  (let () form1 (prog1 form*))


### <span id="SOPROGN">特殊操作符 PROGN</span>

* 语法(Syntax):

        progn form* => result*

* 参数和值(Arguments and Values):

        forms---一个隐式的 progn [implicit progn].
        results---这些表达式形式[form]的值[value].

* 描述(Description):

        progn 求值这些表达式形式 forms, 按它们被提供的顺序.

        除了最后一个以外的所有表达式形式 form 的值都会被丢弃.

        如果 progn 作为顶层表达式形式[top level form]出现, 那么出现在这个 progn 中的所有表达式形式[form]都会被当作顶层表达式形式[top level form]处理.

* 示例(Examples):
    
    ```LISP
    (progn) =>  NIL
    (progn 1 2 3) =>  3
    (progn (values 1 2 3)) =>  1, 2, 3
    (setq a 1) =>  1
    (if a
         (progn (setq a nil) 'here)
         (progn (setq a t) 'there)) =>  HERE
    a =>  NIL
    ```name
    
* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        prog1, prog2, 章节 3.1 (求值)

* 注意(Notes):
name
        很多 Common Lisp 中的位置涉及使用隐式 progn [implicit progn]的语法. 这也就是说, 其语法的一部分允许编写的多个表达式形式[form]按顺序进行求值, 丢弃除了最后一个以外的表达式形式[form]的值并且返回最后一个表达式形式[form]的结果. 这些位置包括, 但不限于以下这些: 一个 lambda 表达式[lambda expression]的主体部分; 多种控制和条件表达式形式[form]的主体部分 (比如, case, catch, progn, 和 when).


### <span id="MDEFINE-MODIFY-MACRO">宏 DEFINE-MODIFY-MACRO</span>

* 语法(Syntax):

        define-modify-macro name lambda-list function [documentation] => name

* 参数和值(Arguments and Values):

        name---一个符号[symbol].
        lambda-list---一个 define-modify-macro lambda 列表[define-modify-macro lambda list].
        function---一个符号[symbol].
        documentation---一个字符串[string]; 不求值.

* 描述(Description):

        define-modify-macro 定义一个名为 name 的宏[macro]去读取[read]和写入[write]一个位置[place].

        给这个新的宏[macro]的这些参数是一个位置[place], 后面跟着 lambda-list 中提供的那些参数. 使用 define-modify-macro 定义的宏[macro]正确地传递环境参数[environment parameter]给 get-setf-expansion.

        当这个宏[macro]被调用, 函数 function 被应用到这个位置[place]的旧的内容和 lambda-list 的参数上来获取新的值, 然后这个位置[place]被更新为包含这个结果.

        除了避免多重求值的问题 (见下方), 一个 define-modify-macro 的展开式等价于下面这个:

    ```LISP
    (defmacro name (reference . lambda-list)
      documentation
      `(setf ,reference
              (function ,reference ,arg1 ,arg2 ...)))
    ```

        其中 arg1, arg2, ..., 是出现在 lambda-list 中的形参; 为剩余参数[rest parameter]制定适当的规定.

        通过 define-modify-macro 定义的这个宏调用的子表达式形式[subform]按照章节 5.1.1.1 (位置的子表达式形式求值) 中描述的求值.

        documentation 作为一个文档字符串[documentation string]关联给 name (作为 function) 和这个宏函数[macro function].

        如果一个 define-modify-macro 表达式形式[form]作为顶层表达式形式[top level form]出现, 编译器[compiler]必须在编译时存储这个宏[macro]定义, 以便出现在这个文件中后面的宏可以被正确地展开.

* 示例(Examples):

    ```LISP
    (define-modify-macro appendf (&rest args)
        append "Append onto list") =>  APPENDF
    (setq x '(a b c) y x) =>  (A B C)
    (appendf x '(d e f) '(1 2 3)) =>  (A B C D E F 1 2 3)
    x =>  (A B C D E F 1 2 3)
    y =>  (A B C)
    (define-modify-macro new-incf (&optional (delta 1)) +)
    (define-modify-macro unionf (other-set &rest keywords) union)
    ```

* 副作用(Side Effects):

        一个宏定义被赋值给 name.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        defsetf, define-setf-expander, documentation, 章节 3.4.11 (文档字符串和声明的语法交互)

* 注意(Notes): None.

### <span id="MDEFSETF">宏 DEFSETF</span>

* 语法(Syntax):

        "短表达式形式(short form)":

        defsetf access-fn update-fn [documentation]
        => access-fn

        "长表达式形式(long form)":

        defsetf access-fn lambda-list (store-variable*) [[declaration* | documentation]] form*
        => access-fn

* 参数和值(Arguments and Values):

        access-fn---命名一个函数[function]或一个宏[macro]的一个符号[symbol].
        update-fn---命名一个函数[function]或一个宏[macro]的一个符号[symbol].
        lambda-list---一个 defsetf lambda 列表[defsetf lambda list].
        store-variable---一个符号[symbol] (一个变量[variable]名字[name]).
        declaration---一个 declare 表达式[expression]; 不求值.
        documentation---一个字符串[string]; 不求值.
        form---一个表达式形式[form].

* 描述(Description):

        对于相对简单的情况 defsetf 定义了如何去 setf 这个表达式形式 (access-fn ...) 的一个位置[place]. (参阅 define-setf-expander 以获得更多对这个机制的使用方式.) 必须是由 access-fn 命名的函数[function]或宏[macro]计算了其所有参数.

        defsetf 可能接受两个表达式形式的其中之一, 它们称之为 "短表达式形式(short form)" 和  "长表达式形式(long form)", 它们是由第二个实参[argument]的类型[type]来区分的.

        当使用短表达式形式时, update-fn 必须命名一个函数[function] (或者宏[macro]), 它比 access-fn 多接收一个参数. 当 setf 被给予一个 access-fn 调用的位置[place], 它展开为一个 update-fn 的调用并且给定所有给 access-fn 的参数, 还有作为它的最后一个参数, 那个新的值(这个值必须被 update-fn 作为它的值返回).

        这个长表达式形式的 defsetf 类似于 defmacro. 其中 lambda-list 描述了 access-fn 的参数. 这些 store-variables 描述了存储到这个位置[place]的值或多值. 这个主体 body 必须计算一个 access-fn 上调用的 setf 的展开式. 这个展开函数定义在 defsetf 表达式形式[form]出现的相同词法环境[lexical environment]内.

        在这些表达式形式 forms 的求值期间, 在 lambda-list 和 store-variables 中的那些变量绑定为临时变量的名字, 就像是通过 gensym 或 gentemp 生成的一样, 这会通过对这些子表达式形式[subform]的值的 setf 的展开式来绑定. 这个绑定允许在不考虑求值顺序问题的情况下编写这些表达式形式 forms. 在可能的情况下, defsetf 会安排临时变量, 以优化最终结果.

        这个 defsetf 中的主体代码隐式地闭合在一个名为 access-fn 的块[block]内.

        defsetf 确保这个位置[place]的子表达式形式[subform]只被求值一次.

        documentation 作为 setf 种类的文档字符串[documentation string]关联到 access-fn.

        如果一个 defsetf 表达式形式[form]作为顶层表达式形式[top level form]出现, 编译器[compiler]必须使这个 setf 展开器[setf expander]可用, 以便它可以被用于展开这个文件[file]中后面的 setf 调用. 如果在同一文件[file]中后面的一个位置[place]中使用 access-fn, 那么如果有的话, 用户必须确保这些表达式形式 forms 能够在编译时进行求值. 编译器[compiler]必须使这些 setf 展开器[setf expander]对 get-setf-expansion 的编译期调用是可用的, 当它的 environment 参数是一个作为一个宏[macro]的环境参数[environment parameter]接收到的值时.

* 示例(Examples):

        下面这个表达式

    ```LISP
    (defsetf symbol-value set)
    ```
    
        的效果被构建到 Common Lisp 系统中. 这个导致表达式形式 (setf (symbol-value foo) fu) 展开为 (set foo fu).

        注意

    ```LISP
    (defsetf car rplaca)
    ```

        会是不正确的因为 rplaca 不会返回它的最后一个参数.

    ```LISP
    (defun middleguy (x) (nth (truncate (1- (list-length x)) 2) x)) =>  MIDDLEGUY
    (defun set-middleguy (x v)
        (unless (null x)
          (rplaca (nthcdr (truncate (1- (list-length x)) 2) x) v))
        v) =>  SET-MIDDLEGUY
    (defsetf middleguy set-middleguy) =>  MIDDLEGUY
    (setq a (list 'a 'b 'c 'd)
          b (list 'x)
          c (list 1 2 3 (list 4 5 6) 7 8 9)) =>  (1 2 3 (4 5 6) 7 8 9)
    (setf (middleguy a) 3) =>  3
    (setf (middleguy b) 7) =>  7
    (setf (middleguy (middleguy c)) 'middleguy-symbol) =>  MIDDLEGUY-SYMBOL
    a =>  (A 3 C D)
    b =>  (7)
    c =>  (1 2 3 (4 MIDDLEGUY-SYMBOL 6) 7 8 9)
    ```

        一个 defsetf 的长表达式的使用的示例是:

    ```LISP
    (defsetf subseq (sequence start &optional end) (new-sequence)
      `(progn (replace ,sequence ,new-sequence
                        :start1 ,start :end1 ,end)
              ,new-sequence)) =>  SUBSEQ

    (defvar *xy* (make-array '(10 10)))
    (defun xy (&key ((x x) 0) ((y y) 0)) (aref *xy* x y)) =>  XY
    (defun set-xy (new-value &key ((x x) 0) ((y y) 0))
      (setf (aref *xy* x y) new-value)) =>  SET-XY
    (defsetf xy (&key ((x x) 0) ((y y) 0)) (store)
      `(set-xy ,store 'x ,x 'y ,y)) =>  XY
    (get-setf-expansion '(xy a b))
    =>  (#:t0 #:t1),
      (a b),
      (#:store),
      ((lambda (&key ((x #:x)) ((y #:y)))
          (set-xy #:store 'x #:x 'y #:y))
        #:t0 #:t1),
      (xy #:t0 #:t1)
    (xy 'x 1) =>  NIL
    (setf (xy 'x 1) 1) =>  1
    (xy 'x 1) =>  1
    (let ((a 'x) (b 'y))
      (setf (xy a 1 b 2) 3)
      (setf (xy b 5 a 9) 14))
    =>  14
    (xy 'y 0 'x 1) =>  1
    (xy 'x 1 'y 2) =>  3
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        documentation, setf, define-setf-expander, get-setf-expansion, Section 5.1 (Generalized Reference), Section 3.4.11 (文档字符串和声明的语法交互)

* 注意(Notes):

        这些表达式形式 forms 必须包含返回正确值的规定 (这个 store-variable 的值或多值). 这个由这些表达式形式 forms 处理而不是 defsetf 因为在很多情况下这个值不需要额外成本就可以被返回, 通过调用一个同时存储到那个位置[place]并返回正确值的函数.

        一个在 access-fn 上调用的 setf 也求值所有 access-fn 的参数; 它不能特别地对待任何一个. 这就意味着 defsetf 不能被用于描述如何存储到一个广义引用[generalized reference]为一个字节, 例如 (ldb field reference). define-setf-expander 用于处理不符合 defsetf 所施加的限制的情况, 并为用户提供额外的控制.

### <span id="MDEFINE-SETF-EXPANDER">宏 DEFINE-SETF-EXPANDER</span>

* 语法(Syntax):

        define-setf-expander access-fn lambda-list [[declaration* | documentation]] form*
        => access-fn

* 参数和值(Arguments and Values):

        access-fn---命名[name]一个宏[macro]或函数[function]的一个符号[symbol].
        lambda-list -- 宏 lambda 列表[macro lambda list].
        declaration---一个 declare 表达式[expression]; 不求值.
        documentation---一个字符串[string]; 不求值.
        forms---一个隐式的 progn [implicit progn].

* 描述(Description):

        define-setf-expander 指定了 setf 更新一个被 access-fn 引用的位置[place]的方法.

        当 setf 被给定一个根据 access-fn 指定的位置[place]和这个位置的一个新值时, 它被展开为一个执行适当更新的表达式形式.

        这个 lambda-list 支持解构. 见章节 3.4.4 (宏 lambda 列表).

        documentation 作为一个 setf 类型的文档字符串[documentation string]关联给 access-fn.

        这些表达式形式 forms 组成了 setf 展开器[setf expander]定义的主体, 并且必须计算一个借助于给定 access-fn 来引用这个位置[place]的 setf 上的调用的 setf 展开式[setf expansion]. 这个 setf 展开器[setf expander]函数被定义在 define-setf-expander 表达式形式[form]出现的同一个词法环境[lexical environment]里. 当这些表达式形式 forms 要被执行时, lambda-list 中的变量被绑定为位置[place]表达式形式[form]的各个部分. 一个 define-setf-expander 表达式形式[form]的主体表达式形式 forms (不包括 lambda-list) 被隐式地闭合在一个名为 access-fn 的块[block]中.

        这些表达式形式 forms 的求值必须产生章节 5.1.1.2 (Setf 展开式) 中描述的 5 个值.

        如果一个 define-setf-expander 表达式形式[form]作为顶层表达式形式[top level form]出现, 编译器[compiler]必须使这个 setf 展开器[setf expander]可用, 这样它就可以被用于展开这个文件[file]中后面对 setf 的调用. 如果这个 access-fn 被用于同一个文件[file]后面的一个位置[place], 程序员[programmer]必须确保这些表达式形式 forms 可以在编译期被求值. 编译器[compiler]必须使这些 setf 展开器[setf expander]对 get-setf-expansion 的编译期调用是可用的, 当它的 environment 参数是一个作为一个宏[macro]的环境参数[environment parameter]接收到的值时.

* 示例(Examples):

    ```LISP
    (defun lastguy (x) (car (last x))) =>  LASTGUY
    (define-setf-expander lastguy (x &environment env)
      "Set the last element in a list to the given value."
      (multiple-value-bind (dummies vals newval setter getter)
          (get-setf-expansion x env)
        (let ((store (gensym)))
          (values dummies
                  vals
                  `(,store)
                  `(progn (rplaca (last ,getter) ,store) ,store)
                  `(lastguy ,getter))))) =>  LASTGUY
    (setq a (list 'a 'b 'c 'd)
          b (list 'x)
          c (list 1 2 3 (list 4 5 6))) =>  (1 2 3 (4 5 6))
    (setf (lastguy a) 3) =>  3
    (setf (lastguy b) 7) =>  7
    (setf (lastguy (lastguy c)) 'lastguy-symbol) =>  LASTGUY-SYMBOL
    a =>  (A B C 3)
    b =>  (7)
    c =>  (1 2 3 (4 5 LASTGUY-SYMBOL))

    ;;; Setf expander for the form (LDB bytespec int).
    ;;; Recall that the int form must itself be suitable for SETF.
    (define-setf-expander ldb (bytespec int &environment env)
      (multiple-value-bind (temps vals stores
                              store-form access-form)
          (get-setf-expansion int env);Get setf expansion for int.
        (let ((btemp (gensym))     ;Temp var for byte specifier.
              (store (gensym))     ;Temp var for byte to store.
              (stemp (first stores))) ;Temp var for int to store.
          (if (cdr stores) (error "Can't expand this."))
    ;;; Return the setf expansion for LDB as five values.
          (values (cons btemp temps)       ;Temporary variables.
                  (cons bytespec vals)     ;Value forms.
                  (list store)             ;Store variables.
                  `(let ((,stemp (dpb ,store ,btemp ,access-form)))
                      ,store-form
                      ,store)               ;Storing form.
                  `(ldb ,btemp ,access-form) ;Accessing form.
                  ))))
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        setf, defsetf, documentation, get-setf-expansion, 章节 3.4.11 (文档字符串和声明的语法交互)

* 注意(Notes):

        define-setf-expander 与长表达式形式的 defsetf 不同在于, 在执行主体的过程中, lambda-list 中的那些变量[variable]被绑定为位置[place]表达式形式[form]的各个部分, 而不是绑定到这些部分的值的临时变量. 另外, define-setf-expander 没有 defsetf 的 access-fn 必须是一个函数[function]或类函数宏[macro]的限制; 一个任意 defmacro 解构模式允许出现在 lambda-list 中.


### <span id="FGET-SETF-EXPANSION">函数 GET-SETF-EXPANSION</span>

* 语法(Syntax):

        get-setf-expansion place &optional environment
        => vars, vals, store-vars, writer-form, reader-form

* 参数和值(Arguments and Values):

        place---一个位置[place].
        environment---一个环境对象[environment object].
        vars, vals, store-vars, writer-form, reader-form---一个 setf 展开式[setf expansion].

* 描述(Description):

        确定在环境 environment 中组成这个 place 的 setf 展开式[setf expansion]的 5 个值; 见章节 5.1.1.2 (Setf 展开式).

        如果 environment 没有被提供或者是 nil, 那么环境就是那个空词法环境[null lexical environment].

* 示例(Examples):

    ```LISP
    (get-setf-expansion 'x)
    =>  NIL, NIL, (#:G0001), (SETQ X #:G0001), X

    ;;; This macro is like POP

    (defmacro xpop (place &environment env)
      (multiple-value-bind (dummies vals new setter getter)
                            (get-setf-expansion place env)
          `(let* (,@(mapcar #'list dummies vals) (,(car new) ,getter))
            (if (cdr new) (error "Can't expand this."))
            (prog1 (car ,(car new))
                    (setq ,(car new) (cdr ,(car new)))
                    ,setter))))

    (defsetf frob (x) (value)
        `(setf (car ,x) ,value)) =>  FROB
    ;;; The following is an error; an error might be signaled at macro expansion time
    (flet ((frob (x) (cdr x)))  ;Invalid
      (xpop (frob z)))
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

    defsetf, define-setf-expander, setf

* 注意(Notes):

        任何复合表达式形式[compound form]都是一个合法的位置[place], 因为对于任何操作符[operator] f 没有 setf 展开器[setf expander]的复合表达式形式[compound form]都被展开为一个对 (setf f) 的调用.


### <span id="MSETFPSETF">宏 SETF, PSETF</span>

* 语法(Syntax):

        setf {pair}* => result*
        psetf {pair}* => nil
        pair::= place newvalue

* 参数和值(Arguments and Values):

        place---一个位置[place].
        newvalue---一个表达式形式[form].
        results---最后一个位置 place 的存储表达式形式返回的多值[multiple values[2]], 如果没有这些对 pairs 的话就是 nil.

* 描述(Description):

        setf 改变 place 的值[value]为 newvalue.

        (setf place newvalue) 展开为一个更新表达式形式, 它存储 newvalue 求值的结果到这个位置 place 引用的位置. 有些 place 表达式形式涉及接受可选参数的访问器(accessor)的使用. 这些可选参数是否被 setf 允许, 或者它们的用途是什么, 取决于 setf 展开器函数, 不在 setf 的控制之下. 对于任何接受 &optional, &rest, 或 ..... key 参数并且与 setf 一起使用的声明的函数[function]的文档都必须指明这些参数是如何处理的.

        如果提供了不止一个对(pair) pair, 这些对(pair)会按照顺序处理; 这也就是说,

        (setf place-1 newvalue-1
              place-2 newvalue-2
              ...
              place-N newvalue-N)

        正号等价于

        (progn (setf place-1 newvalue-1)
                (setf place-2 newvalue-2)
                ...
                (setf place-N newvalue-N))

        对于 psetf, 如果提供了不止一个对(pair) pair, 那么赋新的值到这些位置的操作被并行执行. 更准确地说, 要求值的所有子表达式形式[subform] (不管是 place 还是 newvalue 表达式形式[form]中) 都是从左到右进行求值的; 在所有求值被执行后, 所有的赋值都以不可预计的顺序执行.

        关于对待 setf 和 psetf 的展开式的详细信息, 见章节 5.1.2 (位置的种类).

* 示例(Examples):

    ```LISP
    (setq x (cons 'a 'b) y (list 1 2 3)) =>  (1 2 3)
    (setf (car x) 'x (cadr y) (car x) (cdr x) y) =>  (1 X 3)
    x =>  (X 1 X 3)
    y =>  (1 X 3)
    (setq x (cons 'a 'b) y (list 1 2 3)) =>  (1 2 3)
    (psetf (car x) 'x (cadr y) (car x) (cdr x) y) =>  NIL
    x =>  (X 1 A 3)
    y =>  (1 A 3)
    ```

* 受此影响(Affected By):

        define-setf-expander, defsetf, *macroexpand-hook*

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        define-setf-expander, defsetf, macroexpand-1, rotatef, shiftf, 章节 5.1 (广义引用)

* 注意(Notes): None.


### <span id="MSHIFTF">宏 SHIFTF</span>

* 语法(Syntax):

        shiftf place+ newvalue => old-value-1

* 参数和值(Arguments and Values):

        place---一个位置[place].
        newvalue---一个表达式形式[form]; 求值.
        old-value-1---一个对象[object] (第一个 place 的旧值[value]).

* 描述(Description):

        shiftf 通过存储 newvalue 到最后一个 place 并将第二个到最后一个 place 的值移动到到其余 place 中来修改每一个 place 的值, .

        如果 newvalue 产生了超过这里的存储变量数量的值, 多余的值会被忽略. 如果 newvalue 产生的值少于存储变量的数量, 缺少的值会被设置为 nil.

        在表达式形式 (shiftf place1 place2 ... placen newvalue) 中, 从 place1 到 placen 的值被读取[read]和保存, 然后 newvalue 被求值, 总共 n+1 个值. 从 2 到 n+1 的值被分别存储到 place1 到 placen. 就好像所有这些 place 都形成了一个移位寄存器; newvalue 从右边移过来, 所有的值都转移到左边一个位置, 然后返回的值从 place1 中移出.

        关于这些位置 places 的子表达式形式[subform]的求值[evaluation]的更多信息, 见章节 5.1.1.1 (位置的子表达式形式求值).

* 示例(Examples):

    ```LISP
    (setq x (list 1 2 3) y 'trash) =>  TRASH
    (shiftf y x (cdr x) '(hi there)) =>  TRASH
    x =>  (2 3)
    y =>  (1 HI THERE)

    (setq x (list 'a 'b 'c)) =>  (A B C)
    (shiftf (cadr x) 'z) =>  B
    x =>  (A Z C)
    (shiftf (cadr x) (cddr x) 'q) =>  Z
    x =>  (A (C) . Q)
    (setq n 0) =>  0
    (setq x (list 'a 'b 'c 'd)) =>  (A B C D)
    (shiftf (nth (setq n (+ n 1)) x) 'z) =>  B
    x =>  (A Z C D)
    ```

* 受此影响(Affected By):

        define-setf-expander, defsetf, *macroexpand-hook*

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        setf, rotatef, 章节 5.1 (广义引用)

* 注意(Notes):

        这个 (shiftf place1 place2 ... placen newvalue) 的影响差不多等价于

        (let ((var1 place1)
              (var2 place2)
              ...
              (varn placen)
              (var0 newvalue))
          (setf place1 var2)
          (setf place2 var3)
          ...
          (setf placen var0)
          var1)

        除了后者会对每个 place 的任何子表达式形式[subform]进行两次求值, 而 shiftf 计算一次. 比如,

        (setq n 0) =>  0
        (setq x (list 'a 'b 'c 'd)) =>  (A B C D)
        (prog1 (nth (setq n (+ n 1)) x)
                (setf (nth (setq n (+ n 1)) x) 'z)) =>  B
        x =>  (A B Z D)


### <span id="MROTATEF">宏 ROTATEF</span>

* 语法(Syntax):

        rotatef place* => nil

* 参数和值(Arguments and Values):

        place---一个位置[place].

* 描述(Description):

        rotatef 通过将值从一个 place 旋转到另一个 place 来修改每个 place 的值.

        如果一个 place 产生了超过这里的存储变量数量的值, 多余的值会被忽略. 如果一个 place 产生的值少于存储变量的数量, 缺少的值会被设置为 nil.

        在表达式形式 (rotatef place1 place2 ... placen) 中, 从 place1 到 placen 的值被读取[read]和写入[write]. 第 2 到 n 个值和值 1 接下来被存储到 place1 到 placen. 就好像所有这些位置都形成了一个末端的移位寄存器, 它将一个位置旋转到左边, 而 place1 的值被移动到 placen.

        关于这些位置 places 的子表达式形式[subform]的求值[evaluation]的更多信息, 见章节 5.1.1.1 (位置的子表达式形式求值).

* 示例(Examples):

    ```LISP
    (let ((n 0)
            (x (list 'a 'b 'c 'd 'e 'f 'g)))
        (rotatef (nth (incf n) x)
                (nth (incf n) x)
                (nth (incf n) x))
        x) =>  (A C D B E F G)
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        define-setf-expander, defsetf, setf, shiftf, *macroexpand-hook*, 章节 5.1 (广义引用)

* 注意(Notes):

        这个 (rotatef place1 place2 ... placen) 的效果粗略等价于

        (psetf place1 place2
                place2 place3
                ...
                placen place1)

        除了后者会对每个 place 的任何子表达式形式[subform]进行两次求值, 而 rotatef 求值一次.

### <span id="CTCONTROL-ERROR">状况类型 CONTROL-ERROR</span>

* 类优先级列表(Class Precedence List):

        control-error, error, serious-condition, condition, t

* 描述(Description):

        类型[type] control-error 由程序中非法的动态控制转移所引起的错误状况组成. throw 一个不活跃的 tag 或者 go 或 return-from 一个不再是动态可用的 tag 导致的错误就是 control-error 类型[type]的.


### <span id="CTPROGRAM-ERROR">状况类型 PROGRAM-ERROR</span>

* 类优先级列表(Class Precedence List):

        program-error, error, serious-condition, condition, t

* 描述(Description):

        类型[type] program-error 由不正确的程序语法相关的错误状况组成. 命名一个不是词法上可见的 go 标签[go tag]或 block 标签[block tag]所导致的错误就是类型[type] program-error 的.


### <span id="CTUNDEFINED-FUNCTION">状况类型 UNDEFINED-FUNCTION</span>

* 类优先级列表(Class Precedence List):

        undefined-function, cell-error, error, serious-condition, condition, t

* 描述(Description):

        类型[type] undefined-function 由表示尝试去读取[read]一个未定义函数[undefined function]的定义的错误[error]状况[condition]组成.

        这个存储格(cell) (见 cell-error) 的名字是一个 funbound 的函数名[function name].

* 参见(See Also):

        cell-error-name


# 6. 循环

> * 6.1 [LOOP 机制](#TheLOOPFacility)
> * 6.2 [循环字典](#TheIterationDictionary)

## 6.1 <span id="TheLOOPFacility">LOOP 机制</span>

> * 6.1.1 [Loop 机制概述](#OverviewLoopFacility)
> * 6.1.2 [变量初始化和步进子句](#VarInitAndStepClauses)
> * 6.1.3 [值累积子句](#ValueAccumulationClauses)
> * 6.1.4 [终止测试子句](#TerminationTestClauses)
> * 6.1.5 [无条件执行子句](#UnconditionalExecutionClauses)
> * 6.1.6 [条件执行子句](#ConditionalExecutionClauses)
> * 6.1.7 [其他子句](#MiscellaneousClauses)
> * 6.1.8 [其他 Loop 特性的示例](#ExamplesMLF)
> * 6.1.9 [Loop 的注意事项](#NotesAboutLoop)

### 6.1.1 <span id="OverviewLoopFacility">Loop 机制概述</span>

这个 loop 宏[macro]执行循环.

> * 6.1.1.1 [简单 vs 扩展 Loop](#SimpleExtendedLoop)
> * 6.1.1.2 [Loop 关键字](#LoopKeywords)
> * 6.1.1.3 [解析 Loop 子句](#ParsingLoopClauses)
> * 6.1.1.4 [展开 Loop 表达式形式](#ExpandingLoopForms)
> * 6.1.1.5 [Loop 子句综述](#SummaryLoopClauses)
> * 6.1.1.6 [执行顺序](#OrderExecution)
> * 6.1.1.7 [解构](#Destructuring)
> * 6.1.1.8 [副作用的限制](#RestrictionsSideEffects)

#### 6.1.1.1 <span id="SimpleExtendedLoop">简单 vs 扩展 Loop</span>

loop 表达式形式[form]可以被分为两类: 简单 loop 表达式形式[form]和扩展 loop 表达式形式[form].

##### 6.1.1.1.1 简单 Loop

一个简单 loop 表达式形式[form]是有着只包含复合表达式形式[compound form]的主体(body)的 loop 表达式形式. 每个表达式形式[form]都按从左到右的次序依次求值. 当最后一个表达式形式 form 被求值后, 第一个表达式形式 form 被再一次求值, 以此类推, 在一个不终止的循环中. 一个简单 loop 表达式形式[form]建立一个名为 nil 的隐式块[implicit block]. 这个简单 loop 的执行可以通过显式控制转移到这个隐式块[implicit block] (使用 return 或 return-from) 或者到这个块[block]外部的某个退出点[exit point] (比如, 使用 throw, go, 或 return-from)来终止. 

##### 6.1.1.1.2 扩展 Loop

一个扩展 loop 表达式形式[form]是指有着包含原子[atomic]表达式[expression]的主体(body)的一个 loop 表达式形式[form]. 当这个 loop 宏[macro]处理这样一个表达式形式[form]时, 它调用一个通常称为 "Loop 工具" 的工具.

这个 Loop 工具通过循环模式提供对循环中常用机制的标准化访问, 循环模式是由 loop 关键字[loop keyword]引入的.

扩展 loop 表达式形式[form]的主体(body)被分为 loop 子句, 每一个子句都由 loop 关键字[loop keyword]和表达式形式[form]组成. 

#### 6.1.1.2 <span id="LoopKeywords">Loop 关键字</span>

Loop 关键字[loop keyword]不是真的关键字[keyword[1]]; 它们是特殊的符号[symbol], 通过名字[name]而不是对象[object]标识来识别, 并只有在 loop 工具中有意义. 一个 loop 关键字[loop keyword]是一个通过它的名字[name] (而不是它的标识) 来识别的符号[symbol], 不管它在哪个包[package]中是可访问的[accessible].

通常, loop 关键字[loop keyword]不是 COMMON-LISP 包中的外部符号[external symbol], 除非在一种巧合的情况下 Common Lisp 需要使用与 loop 关键字[loop keyword]相同名称的符号[symbol]来实现其他目的. 比如, 在 COMMON-LISP 包中有一个符号名字[name]为 "UNLESS" 但是没有名字[name]为 "UNTIL" 的符号[symbol].

如果在一个 loop 表达式形式[form]中没有提供 loop 关键字[loop keyword], 那么这个 Loop 工具就会重复地执行主体(body); 见章节 6.1.1.1.1 (简单 Loop). 


#### 6.1.1.3 <span id="ParsingLoopClauses">解析 Loop 子句</span>

扩展 loop 表达式形式[form]的语法部分称之为子句(clause); 解析的规则由子句的关键字决定. 下面这个例子展示了有着 6 个子句的 loop 表达式形式[form]:

```LISP
(loop for i from 1 to (compute-top-value)       ; first clause
      while (not (unacceptable i))              ; second clause
      collect (square i)                        ; third clause
      do (format t "Working on ~D now" i)       ; fourth clause
      when (evenp i)                            ; fifth clause
        do (format t "~D is a non-odd number" i)
      finally (format t "About to exit!"))      ; sixth clause
```

每个 loop 关键字[loop keyword]都引入了一个复合 loop 子句或一个简单的 loop 子句, 它可以由一个 loop 关键字[loop keyword]后面跟着一个单独的表达式形式[form]所组成. 一个子句中表达式形式[form]的数量由开始这个子句的 loop 关键字[loop keyword]和这个子句中的辅助关键字决定. 关键字 do, doing, initially, 和 finally 是仅有的可以接受任何数量的表达式形式[form]并以一个隐式的 progn [implicit progn]组织起来的 loop 关键字.

Loop 子句可以包含辅助关键字, 这个关键字有时候称之为介词. 比如, 上面这段代码中的第一个子句包含了介词 from 和 to, 它们标记出了步进开始和结束的值.

关于 loop 语法的详细信息, 见宏[macro] loop. 


#### 6.1.1.4 <span id="ExpandingLoopForms">展开 Loop 表达式形式</span>

一个 loop 宏表达式形式[macro form]展开为一个包含一个或多个绑定表达式(这个建立[establish]循环变量的绑定[binding])和一个 block 和一个 tagbody(这个表示循环控制结构) 的表达式形式[form]. 在 loop 中建立的变量就像是通过 let 或者 lambda 绑定的一样.

具体实现可以将初始值的设置和绑定[binding]交错在一起. 然而, 初始值的赋值总是按照用户指定的顺序被计算. 因此, 变量有时会被绑定到正确类型[type]的无意义值, 然后在开始时使用 setq 将其设置为真正的初始值. 这个交错的一个含义是, 在除了 for-as-equals-then 之外的任何 for-as-subclause 中的初始值表达式形式[form] (不同地称为 form1, form2, form3, step-fun, vector, hash-table, 和 package) 被求值所在的词法环境[lexical environment]是只包含在该表达式形式之前的循环变量, 还是包含更多或全部的循环变量, 是依赖于具体实现的[implementation-dependent]; 在一个 for-as-equals-then 表达式形式的 form1 和 form2 包括了所有循环变量的词法环境[lexical environment].

在这个表达式形式[form]展开后, 它由 tagbody 中的三个基本部分组成: 循环序言(the loop prologue), 循环体(the loop body), 还有循环结尾(the loop epilogue).

循环序言(the loop prologue)

    循环序言包含在循环开始之前执行的表达式形式[form], 例如由 variable 子句以及任何 initially 子句所指定的任何自动变量按照它们出现在源代码中的顺序来初始化.

循环体(the loop body)

    循环体包含了在循环期间执行的表达式形式[form], 包括应用特定的计算, 终止测试, 还有变量步进[step[1]].

循环结尾(the loop epilogue)

    循环结尾包含循环终止后执行的表达式形式[form], 比如 finally 子句, 如果存在的话, 还有任何来自于 accumulation 子句或者一个 termination-test 子句的隐式的返回值.

一些来自于源表达式形式[form]的子句只对循环序言贡献代码; 这个子句必须在 loop 表达式主体中的其他子句之前. 其他子句只对循环结尾贡献代码. 所有其他的子句都以和原始的 loop 源表达式形式[form]中给出的相同的顺序为最终的转换表达式形式[form]贡献代码.

除非提供了 named, 否则 loop 宏的展开式产生一个名为 nil 的隐式块[implicit block]. 因此, return-from (有时为 return) 可以被用于从 loop 中返回值或退出 loop. 

#### 6.1.1.5 <span id="SummaryLoopClauses">Loop 子句综述</span>

Loop 子句属于以下类别之一:

> * 6.1.1.5.1 [变量初始化和步进子句综述](#SummaryVarInitStepClauses)
> * 6.1.1.5.2 [值累积子句综述](#SummaryValueAccumulationClauses)
> * 6.1.1.5.3 [终止测试子句综述](#SummaryTerminationTestClauses)
> * 6.1.1.5.4 [无条件执行子句综述](#SummaryUncondExecClauses)
> * 6.1.1.5.5 [条件执行子句综述](#SummaryCondExecClauses)
> * 6.1.1.5.6 [其他子句综述](#SummaryMiscellaneousClauses)

##### 6.1.1.5.1 <span id="SummaryVarInitStepClauses">变量初始化和步进子句综述</span>

这个 for 和 as 构造提供一个循环控制子句, 它建立一个要被初始化的变量. for 和 as 子句可以和 loop 关键字 and 组合使用来获得并行[parallel]初始化和步进[step[1]]. 否则, 这个初始化和步进[step[1]]就是顺序的[sequential].

这个 with 构造类似于单独的 let 子句. with 子句可以使用 loop 关键字[loop keyword] and 来组合使用进而获得并行[parallel]初始化 .

关于更多信息, 见章节 6.1.2 (变量初始化和步进子句). 

##### 6.1.1.5.2 <span id="SummaryValueAccumulationClauses">值累积子句综述</span>

这个 collect (或 collecting) 构造接受一个在它的子句中的表达式形式[form]并且添加这个表达式形式[form]的值到一个值列表[list]的末尾. 默认情况下, 当这个 loop 结束时这个值列表[list]被返回.

这个 append (或 appending) 构造接受一个在它的子句中的表达式形式[form]并追加这个表达式形式[form]的值到一个值列表[list]的末尾. 默认情况下, 当这个 loop 结束时这个值列表[list]被返回.

这个 nconc (或 nconcing) 构造类似于 append 构造, 但是它的列表[list]值是被串联起来的就像是通过函数 nconc 一样. 默认情况下, 当这个 loop 结束时这个值列表[list]被返回.

这个 sum (或 summing) 构造接受一个在它的子句中求值为数字[number]的表达式形式[form], 它累积所有这些数字[number]的和 . 默认情况下, 当这个 loop 结束时这个累积的总和被返回.

这个 count (或 counting) 构造接受一个在它的子句中的表达式形式[from]并且计算这个表达式形式[form]被求值为 true 的次数. 默认情况下, 当这个 loop 结束时这个计数被返回.

这个 minimize (或 minimizing) 构造接受一个在它的子句中的表达式形式[form]并且通过求值这个表达式形式[form]来决定获取最小值. 默认情况下, 当这个 loop 结束时这个最小值被返回.

这个 maximize (或 maximizing) 构造接受一个在它的子句中的表达式形式[form]并且通过求值这个表达式形式[form]来决定获取最大值. 默认情况下, 当这个 loop 结束时这个最大值被返回.

关于更多信息, 见章节 6.1.3 (值累积子句). 

##### 6.1.1.5.3 <span id="SummaryTerminationTestClauses">终止测试子句综述</span>

这个 for 和 as 构造提供一个由这个循环控制子句决定的终止测试.

这个 repeat 构造导致在指定次数的循环后终止. (它使用一个内部变量来跟踪循环次数.)

这个 while 构造接受一个表达式形式[form], 一个测试 test, 如果这个测试 test 求值为 false 就终止这个循环. 一个 while 子句等价于表达式 (if (not test) (loop-finish)).

这个 until 构造是 while 的倒转; 如果这个测试 test 求值为任何非 nil [non-nil]的值就终止这个循环. 一个 until 子句等价于表达式 (if test (loop-finish)).

这个 always 构造接受一个表达式形式[form], 当这个表达式形式[form]曾经求值为 false 就终止这个 loop; 在这个情况下, 这个 loop 表达式形式[form]返回 nil. 否则, 它提供一个 t 作为默认的返回值.

这个 never 构造接受一个表达式形式[form], 如果这个表达式形式[form]曾经求值为 true 就终止这个 loop; 在这个情况下, 这个 loop 表达式形式[form]返回 nil. 否则, 它提供一个 t 作为默认的返回值.

这个 thereis 构造接受一个表达式形式[form], 如果这个表达式形式[form]曾经求值为一个非 nil [non-nil]的对象[object]就终止这个 loop; 在这个情况下, 这个 loop 表达式形式[form]返回那个对象[object]. 否则, 它提供一个 nil 作为默认的返回值.

如果指定了多个终止测试子句,那么任何一个满足的情况下这个 loop 表达式形式[form]就终止.

关于更多信息, 见章节 6.1.4 (终止测试子句). 

##### 6.1.1.5.4 <span id="SummaryUncondExecClauses">无条件执行子句综述</span>

这个 do (或 doing) 构造求值它的子句中的所有表达式形式[form].

这个 return 构造接受一个表达式形式[form]. 这个表达式形式[form]返回的任何值[value]都立即被 loop 表达式形式返回. 它等价于子句 do (return-from block-name value), 其中 block-name 是在 named 子句中指定的名字, 如果没有 named 子句那么就是 nil.

关于更多信息, 见章节 6.1.5 (无条件执行子句). 

##### 6.1.1.5.5 <span id="SummaryCondExecClauses">条件执行子句综述</span>

这个 if 和 when 构造接受一个表达式形式[form]作为测试以及一个在这个测试表达式产生[yield] true 的时候执行的子句. 这个子句可以是一个值累积子句, 无条件执行子句, 或者另一个条件执行子句; 它也可以是通过 loop 关键字 and 连接的任何这样的子句的组合.

这个 loop unless 构造类似于 loop when 构造, 除了它互补那个检验结果.

这个 loop else 构造提供一个可选的 if, when, 和 unless 子句成分, 当一个 if 或 when 测试产生[yield] false 或者当一个 unless 测试产生[yield] true 的时候被执行. 这个成分是 if 下面描述的子句之一.

这个 loop end 构造提供一个可选的成分用于标记一个条件子句的结束.

关于更多信息, 见章节 6.1.6 (条件执行子句). 

##### 6.1.1.5.6 <span id="SummaryMiscellaneousClauses">其他子句综述</span>

这个 loop named 构造为这个 loop 的块[block]提供一个名字.

这个 loop initially 构造导致它的那些表达式形式[form]在循环序言中被求值, 也就是在除了由 with, for, or as 构造提供的初始设置之外的所有 loop 代码之前被求值.

这个 loop finally 构造导致它的表达式形式[form]在循环结尾中被求值, 也就是在正常循环终止后.

关于更多信息, 见章节 6.1.7 (其他子句). 

#### 6.1.1.6 <span id="OrderExecution">执行顺序</span>

除了下面列出的异常情况, 子句在循环体中以它们出现在源码中的顺序执行. 重复执行直到一个子句终止了这个 loop 或者直到遇到一个 return, go, 或 throw 表达式形式转移控制到 loop 外的一个点. 下面这些操作是执行的线性顺序的例外:

* 所有变量首先被初始化, 不管建立的子句出现在源码中的什么位置. 初始化顺序遵循这些子句的顺序.

* 任何 initially 子句的代码以它们出现在源码中的顺序被集中到一个 progn 中. 这个集中后的代码只在任何隐式变量初始化之后在循环序言中执行一次.

* 任何 finally 子句的代码以它们出现在源码中的顺序被集中到一个 progn 中. 这个集中后的代码只在任何隐式的来自累积子句的值被返回之前在循环结尾被执行一次. 但是, 在源码中的任何地方显式的返回会在没有执行结尾代码的情况下退出这个 loop.

* 一个 with 子句引入一个变量绑定[binding]和一个可选的初始值. 这个初始值会按照 with 子句出现的顺序被计算.

* 循环控制子句隐式执行下面这些动作:

    -- 初始化变量;

    -- 步进[step]变量, 通常在每个循环体执行之间;

    -- 执行终止检验, 通常只是在循环体执行之前. 


#### 6.1.1.7 <span id="Destructuring">解构</span>

这个 d-type-spec 参数被用于解构. 如果这个 d-type-spec 参数仅仅由类型[type] fixnum, float, t, 或 nil 构成, 那么这个 of-type 关键字是可选的. 在这些情况下, of-type 构造是可选的, 以提供向后兼容性; 因此, 下面两个表达式是一样的:

```LISP
;;; This expression uses the old syntax for type specifiers.
 (loop for i fixnum upfrom 3 ...)
 
;;; This expression uses the new syntax for type specifiers.
 (loop for i of-type fixnum upfrom 3 ...)

;; Declare X and Y to be of type VECTOR and FIXNUM respectively.
 (loop for (x y) of-type (vector fixnum) 
       in l do ...)
```

用于解构匹配模式的类型指定符[type specifier]是一种类型指定符[type specifier]的树[tree], 其形状与变量[variable]名[name]的树[tree]的形状相同, 但是具有以下例外:

* 当对齐这些树[tree]的时候, 和变量树中的一个 cons 匹配的类型指定符[type specifier]的树[tree]中的一个原子[atom]声明了以 cons 为根的子树中的每一个变量为相同的类型[type].

* 和变量[variable]名称[name]的树[tree]中的一个原子[atom]的匹配的类型指定符[type specifier]的树中的一个 cons 是一个复合类型指定符[compound type specifer].

在一个值可以正常地绑定到一个单独变量的任何地方, 解构允许将一组变量绑定[binding]为相应的一组值. 在 loop 展开期间, 在变量列表中的每个变量和值列表中的值匹配. 如果变量列表中的变量数超过值列表中的值的数量, 剩余的变量会被赋予 nil 值. 如果值的数量超过列出的变量数, 多余的值会被丢弃.

为了将一个列表中的值赋给变量 a, b, 还有 c, 这个 for 子句可以被用于绑定变量 numlist 到这个提供的表达式形式 form 的 car 部分, 而另一个 for 子句可以被用于顺序地[sequentially]绑定变量 a, b, 和 c.

```LISP
;; Collect values by using FOR constructs.
(loop for numlist in '((1 2 4.0) (5 6 8.3) (8 9 10.4))
      for a of-type integer = (first numlist)
      and b of-type integer = (second numlist)
      and c of-type float = (third numlist)
      collect (list c b a))
=>  ((4.0 2 1) (8.3 6 5) (10.4 9 8))
```

解构通过允许变量在每个循环迭代中被绑定来使这个过程变得更容易. 类型[type]可以通过使用一个 type-spec 参数的列表来声明. 如果所有的类型[type]都是相同的, 可以使用一个简写解构语法, 就像第二个例子说明的.

```LISP
;; Destructuring simplifies the process.
(loop for (a b c) of-type (integer integer float) in
      '((1 2 4.0) (5 6 8.3) (8 9 10.4))
      collect (list c b a))
=>  ((4.0 2 1) (8.3 6 5) (10.4 9 8))


;; If all the types are the same, this way is even simpler.
(loop for (a b c) of-type float in
      '((1.0 2.0 4.0) (5.0 6.0 8.3) (8.0 9.0 10.4))
      collect (list c b a))
=>  ((4.0 2.0 1.0) (8.3 6.0 5.0) (10.4 9.0 8.0))
```

如果解构被用来声明或初始化多个变量组到类型, 可以使用 loop 关键字[loop keyword] and 来进一步简化这个过程.

```LISP
;; Initialize and declare variables in parallel by using the AND construct.
(loop with (a b) of-type float = '(1.0 2.0)
      and (c d) of-type integer = '(3 4)
      and (e f)
      return (list a b c d e f))
=>  (1.0 2.0 3 4 NIL NIL)
```

如果在一个解构列表中使用 nil, 不会为它的位置提供一个变量.

```LISP
(loop for (a nil b) = '(1 2 3)
      do (return (list a b)))
=>  (1 3)
```

注意这个点对列表[dotted list]可以指定解构.

```LISP
(loop for (x . y) = '(1 . 2)
      do (return y))
=>  2
(loop for ((a . b) (c . d)) of-type ((float . float) (integer . integer)) in
      '(((1.2 . 2.4) (3 . 4)) ((3.4 . 4.6) (5 . 6)))
      collect (list a b c d))
=>  ((1.2 2.4 3 4) (3.4 4.6 5 6))
```

如果同一个变量在一个单独的 loop 表达式的任何变量绑定子句中被绑定两次, 会发出一个 program-error 类型[type]的错误(在宏展开的时候). 这些变量包括局部变量, 循环控制变量和通过解构找到的变量. 

#### 6.1.1.8 <span id="RestrictionsSideEffects">副作用的限制</span>

见章节 3.6 (遍历规则和副作用). 

### 6.1.2 <span id="VarInitAndStepClauses">变量初始化和步进子句</span>

> * 6.1.2.1 [循环控制](#IterationControl)
> * 6.1.2.2 [局部变量初始化](#LocalVarInit)

#### 6.1.2.1 <span id="IterationControl">循环控制</span>

循环控制子句允许有 loop 循环的方向. loop 关键字[loop keyword] for 和 as 指定循环控制子句. 循环控制子句的区别在于终止检验的说明以及 loop 变量的初始化和步进[step[1]]. 循环子句自身不会导致这个 loop 工具返回一些值, 但是它们可以和值累积子句协同使用来返回那些值.

所有变量都在循环序言中被初始化. 一个变量[variable]绑定[binding]有着词法作用域[lexical scope]除非它被公告为 special; 因此, 默认情况下, 这个变量只能被文本形式出现在 loop 中的那些表达式形式[form]访问. 在其他表达式形式[form]在主体中被求值之前, 在 loop 主体中进行步进任务.

循环控制子句中的变量参数可以是一个解构列表. 一个解构列表是一个非 nil [non-nil]原子是变量[variable]名称[name]的树[tree]. 见章节 6.1.1.7 (解构).

循环控制子句 for, as, 和 repeat 必须在除了 initially, with, 和 named 以外的其他 loop 子句之前, 因为它们建立变量绑定[binding]. 当循环控制子句被用于一个 loop 中时, 这个 loop 主体中的对应终止测试在任何其他 loop 主体代码被执行前求值.

如果多个循环子句被用于控制循环, 变量初始化和步进[step[1]]默认是顺序[sequentially]发生的. 当没有必要进行顺序[sequential]绑定[binding]和步进[step[1]]时, 这个 and 构造可以被用于连接两个或更多循环子句. 被 and 加入的子句的循环行为类似于宏 do 相对于 do* 的行为.

这个 for 和 as 子句通过使用一个或多个局部循环变量来循环, 这些变量被初始化为某个值并且可以在每次循环后被修改或步进[step[1]]. 对于这些子句, 当一个局部变量达到某个被提供的值时或者当某个其他 loop 子句终止循环时, 循环会停止. 在每次循环中, 变量可以通过一个递增或递减来步进[step[1]]或通过一个表达式形式[form]的求值来赋予新值. 在循环期间可以利用解构来给变量赋值.

这个 for 和 as 关键字是是同义词; 它们可以被交换使用. 对于这些构造, 有七种语法格式. 在每一个语法格式中, var 的类型[type]可以通过这个可选的 type-spec 参数来提供. 如果 var 是一个解构列表 list, 通过 type-spec 参数提供的类型[type]必须适当地匹配列表中的元素. 按照惯例, for 引入新的循环而 as 引入的循环依赖于前面循环说明.

> * 6.1.2.1.1 [for-as-arithmetic 分子句](#FAARSubclause)
> * 6.1.2.1.2 [for-as-in-list 分子句](#FAILSubclause)
> * 6.1.2.1.3 [for-as-on-list 分子句](#FAOLSubclause)
> * 6.1.2.1.4 [for-as-equals-then 分子句](#FAETSubclause)
> * 6.1.2.1.5 [for-as-across 分子句](#FAACSubclause)
> * 6.1.2.1.6 [for-as-hash 分子句](#FAHSubclause)
> * 6.1.2.1.7 [for-as-package 分子句](#FAPSubclause)


##### 6.1.2.1.1 <span id="FAARSubclause">for-as-arithmetic 分子句</span>

在 for-as-arithmetic 分子句中, 这个 for 或者 as 构造从 form1 提供的值以 form3 表示的递增或递减循环到 form2 提供的值. 每个表达式只被求值一次并且必须被求值为一个数字[number]. 变量 var 在第一次循环中被绑定为 form1 的值并且在随后的每次循环中步进[step[1]] form3 的值, 如果 form3 没有提供的话就是步进 1. 下面的 loop 关键字[loop keyword]被当作是这个语法中合法的介词. 必须使用至少一个介词; 在一个单独的分子句中下面的每一行最多使用一个.

    from | downfrom | upfrom

    to | downto | upto | below | above

    by

每个分子句中的介词短语可能以任何顺序出现. 比如, 不管是 "from x by y" 或是 "by y from x" 都是允许的. 然而, 因为保留从左到右的求值顺序, 在副作用上的效果可能会是不同的. 细想:

```LISP
(let ((x 1)) (loop for i from x by (incf x) to 10 collect i))
=>  (1 3 5 7 9)
(let ((x 1)) (loop for i by (incf x) from x to 10 collect i))
=>  (2 4 6 8 10)
```

以下是介词的描述:

* from

        loop 关键字[loop keyword] from 指定步进[step[1]]开始的值, 由 form1 提供. 步进[step[1]]默认是递增的. 如果需要递减的步进[step[1]], 介词 downto 或 above 必须和 form2 一起使用. 对于递增步进[step[1]], 默认的 from 值是 0.

* downfrom, upfrom

        loop 关键字[loop keyword] downfrom 表示变量 var 通过 from3 提供的衰减量递减; loop 关键字[loop keyword] upfrom 表示 var 通过 form3 提供的增量递增.

* to

        loop 关键字[loop keyword] to 标记由 form2 提供的步进[step[1]]的结束值. 步进[step[1]]默认是递增的. 如果需要递减的步进[step[1]], 介词 downfrom 必须和 form1 一起使用, 或者和 form2 一起使用介词 downto 或 above.

* downto, upto

        loop 关键字[loop keyword] downto 指定递减步进[step]; loop 关键字[loop keyword] upto 指定递增步进[step]. 在这两种情况下, 每一步改变的数额由 form3 指定, 当变量 var 超过 form2 的值时这个 loop 终止. 因为这里没有为递减步进[step[1]]提供 form1 的默认值, 所以当 downto 被提供时也必须提供 form1 的值(使用 from 或 downfrom).

* below, above

        loop 关键字[loop keyword] below 和 above 分别与 upto 和 downto 类似. 这些关键字仅仅在变量 var 的值达到 form2 提供的值前停止循环; 这个 form2 的结束值不会被包含进去. 因为这里没有为递减步进[step[1]]提供 form1 的默认值, 当 above 被提供时也必须提供 form1 的值(使用 from 或 downfrom).

* by

        loop 关键字[loop keyword] by 标记 form3 提供的递增或递减值. 这个 form3 的值可以是任何正数[number]. 默认值是 1.

在一个循环控制子句中, 当到达提供的限制时, 这个 for 或 as 构造导致终止. 这也就是说, 循环一直持续到值 var 被逐步执行到 form2 提供的排他性或包容性的限制. 如果 form3 递增或递减变量到 form2 的值而没有到达那个值那么这个范围就是排他的; loop 关键字 below 和 above 提供排他的限制. 一个包容的限制允许 var 达到 form2 的值; to, downto, 和 upto 提供包容的限制.

###### 6.1.2.1.1.1 for-as-arithmetic 分子句的示例

```LISP
;; Print some numbers.
 (loop for i from 1 to 3
       do (print i))
>>  1
>>  2
>>  3
=>  NIL
 
;; Print every third number.
 (loop for i from 10 downto 1 by 3
       do (print i))
>>  10 
>>  7 
>>  4 
>>  1 
=>  NIL
 
;; Step incrementally from the default starting value.
 (loop for i below 3
       do (print i))
>>  0
>>  1
>>  2
```


##### 6.1.2.1.2 <span id="FAILSubclause">for-as-in-list 分子句</span>

在这个 for-as-in-list 分子句中, 这个 for 或 as 构造遍历一个列表[list]的内容. 它检查这个列表[list]的末尾, 就像使用 endp 一样. 在每次循环前变量 var 被绑定为 form1 中列表[list]的连续元素. 在每次循环结束后, 函数 step-fun 被应用到这个列表[list]; step-fun 的默认值是 cdr. loop 关键字[loop keyword] in 和 by 在这个语法中是合法的介词. 当到达这个列表[list]的末尾时, 这个 for 或 as 构造就终止.

###### 6.1.2.1.2.1 for-as-in-list 分子句的示例

```LISP
;; Print every item in a list.
 (loop for item in '(1 2 3) do (print item))
>>  1
>>  2
>>  3
=>  NIL
 
;; Print every other item in a list.
 (loop for item in '(1 2 3 4 5) by #'cddr
       do (print item))
>>  1
>>  3
>>  5
=>  NIL
 
;; Destructure a list, and sum the x values using fixnum arithmetic.
 (loop for (item . x) of-type (t . fixnum) in '((A . 1) (B . 2) (C . 3))
       unless (eq item 'B) sum x)
=>  4
```

##### 6.1.2.1.3 <span id="FAOLSubclause">for-as-on-list 分子句</span>

在这个 for-as-on-list 分子句中, for 或 as 构造遍历一个列表[list]. 它检查这个列表[list]的末尾, 就像使用 atom 一样. 变量 var 被绑定为 form1 中的列表[list]的后续尾部. 在每次循环后, 函数 step-fun 被应用到这个列表[list]; 这个 step-fun 的默认值是 cdr. loop 关键字[loop keyword] on 和 by 在这个语法中被当作合法的介词. 当到达这个列表[list]的末尾时, 这个 for 或 as 构造就终止.

###### 6.1.2.1.3.1 for-as-on-list 分子句的示例

```LISP
;; Collect successive tails of a list.
 (loop for sublist on '(a b c d)
       collect sublist)
=>  ((A B C D) (B C D) (C D) (D))
 
;; Print a list by using destructuring with the loop keyword ON.
 (loop for (item) on '(1 2 3)
       do (print item))
>>  1 
>>  2 
>>  3 
=>  NIL
```

##### 6.1.2.1.4 <span id="FAETSubclause">for-as-equals-then 分子句</span>

在这个 for-as-equals-then 分子句中, 这个 for 或者 as 构造通过设置第一次循环时 form1 的求值结果到变量 var 来初始化它, 然后在第二次及后续的循环中将它设置为 form2 的求值结果. 如果省略了 form2, 这个构造在第二次及后续的循环中就使用 form1. loop 关键字[loop keyword] = 和 then 在这个语法中被当作合法介词. 这个构造不会提供任何的终止检验.

###### 6.1.2.1.4.1 for-as-equals-then 分子句的示例

```LISP
;; Collect some numbers.
(loop for item = 1 then (+ item 10)
      for iteration from 1 to 5
      collect item)
=>  (1 11 21 31 41)
```

##### 6.1.2.1.5 <span id="FAACSubclause">for-as-across 分子句</span>

在这个 for-as-across 分子句中, 这个 for 或 as 构造绑定变量 var 到这个数组 vector 的每一个元素的值. loop 关键字[loop keyword] across 标记这个数组 vector; across 在这个语法中被用作一个介词. 当提供的数组[array]中没有更多数据可以被引用时循环停止. 某些具体实现可能识别一个 vector 表达式形式中的 the 特殊表达式形式来产生更高效的代码.

###### 6.1.2.1.5.1 for-as-across 分子句的示例

```LISP
(loop for char across (the simple-string (find-message channel))
      do (write-char char stream))
```

##### 6.1.2.1.6 <span id="FAHSubclause">for-as-hash 分子句</span>

在这个 for-as-hash 分子句中, 这个 for 或 as 构造遍历一个哈希表[hash-table]的元素, 键, 还有值. 在这个语法中, 一个复合介词用于指定对哈希表的访问. 变量 var 呈现为提供的哈希表 hash-table 中的每一个哈希键或者哈希值. 在这个语法中以下 loop 关键字[loop keyword]被当作合法介词:

* being

        关键字 being 引入了这个 Loop 模式 hash-key 或 hash-value.

* each, the

        当 hash-key 或 hash-value 被使用时, loop 关键字[loop keyword] each 跟在 loop 关键字[loop keyword] being 后面. loop 关键字[loop keyword] the 和 hash-keys 还有 hash-values 一起使用仅为了便于阅读. 这个协议不是必须的.

* hash-key, hash-keys

        这些 loop 关键字[loop keyword]访问这个哈希表[hash table]的每个键条目. 如果 using 构造中提供名字 hash-value 和这些 Loop 模式中的一个, 那么这个循环可以选择性的访问这些键表示的值. 这些键访问的顺序是没有定义的; 哈希表[hash table]中空的槽会被忽略.

* hash-value, hash-values

        这些 loop 关键字[loop keyword]访问这个哈希表[hash table]的每个值条目. 如果 using 构造中提供名字 hash-key 和这些 Loop 模式中的一个, 这个循环可以选择性的访问这些值对应的键. 这些键访问的顺序是没有定义的; 哈希表[hash table]中空的槽会被忽略.

* using

        这个 loop 关键字[loop keyword] using 引入用于访问的可选的键或键表示的值. 如果循环到了哈希值, 那么它允许访问哈希键, 如果循环到了哈希键, 则可以访问哈希值.

* in, of

        这些 loop 介词引入 hash-table.

实际上

    being {each | the} {hash-value | hash-values | hash-key | hash-keys} {in | of}

是一个复合介词.

当提供的 hash-table 中没有更多的哈希键或哈希值要被引用时, 循环停止. 


##### 6.1.2.1.7 <span id="FAPSubclause">for-as-package 分子句</span>

在这个 for-as-package 分子句中 for 或 as 构造遍历一个包[package]中的符号[symbol]. 在这个语法中, 使用一个复合的介词来指定对一个包[package]的访问. 变量 var 接收这个提供的包[package]中每一个符号[symbol]的值. 在这个语法中下面的 loop 关键字[loop keyword]被当作合法的介词:

* being

        关键字 being 引入 Loop 模式 symbol, present-symbol, 或 external-symbol.

* each, the

        当使用 symbol, present-symbol, 或 external-symbol 时 loop 关键字[loop keyword] each 跟在 loop 关键字[loop keyword] being 后面. loop 关键字[loop keyword] the 和 symbols, present-symbols, 还有 external-symbols 一起使用仅方便于阅读. 这个参数不是必须的.

* present-symbol, present-symbols

        这些 Loop 模式遍历出现[present]在一个包[package]中的符号[symbol]. 要被循环的包 package 以提供给 find-package 的包[package]参数相同的方式被提供. 如果没有提供用于循环的包 package, 就使用当前包[current package]. 如果提供一个不存在的包 package, 会发出一个 package-error 类型[type]的错误.

* symbol, symbols

        这些 Loop 模式遍历这个给定包 package 中可访问的[accessible]符号[symbol]. 要被循环的包 package 以提供给 find-package 的包[package]参数相同的方式被提供. 如果没有提供用于循环的包 package, 就使用当前包[current package]. 如果提供一个不存在的包 package, 会发出一个 package-error 类型[type]的错误.

* external-symbol, external-symbols

        这些 Loop 模式遍历一个包 package 中的外部符号[external symbol]. 要被循环的包以提供给 find-package 的包参数相同的方式被提供. 如果没有提供用于循环的包, 就使用当前包. 如果提供一个不存在的包, 会发出一个 package-error 类型[type]的错误.

* in, of

        这些 loop 介词引入 package.

实际上

    being {each | the} {symbol | symbols | present-symbol | present-symbols | external-symbol | external-symbols} {in | of}

是一个复合介词.

当提供的包 package 中没有更多符号[symbol]要被引用时循环停止.

###### 6.1.2.1.7.1 for-as-package 分子句

```LISP
(let ((*package* (make-package "TEST-PACKAGE-1")))
  ;; For effect, intern some symbols
  (read-from-string "(THIS IS A TEST)")
  (export (intern "THIS"))
  (loop for x being each present-symbol of *package*
        do (print x)))
>>  A 
>>  TEST 
>>  THIS
>>  IS 
=>  NIL
```

#### 6.1.2.2 <span id="LocalVarInit">局部变量初始化</span>

当执行一个 loop 表达式形式[form]时, 局部变量会被绑定并且初始化到某个值. 这些局部变量直到 loop 循环结束都会存在, 在那个时候它们会消失. 隐式的变量也通过循环控制子句和累积子句的 into 介词来建立.

with 构造初始化的变量是一个 loop 的局部变量. 这个变量只被初始化一次. 如果为这个变量 var 提供了可选的 type-spec 参数, 而这里没有相关的表达式来求值, var 被初始化为它类型[type]的一个合适的默认值. 比如, 对于类型 t, number, 和 float, 默认值分别就是 nil, 0, 和 0.0. 如果为 var 提供了一个 type-spec 参数而相关表达式返回的值不是那个提供的类型[type], 那么结果是未定义的. 默认情况下, with 构造顺序[sequentially]初始化变量; 这也就是说, 一个变量在下一个表达式被求值之前被赋值. 然而, 通过使用 loop 关键字[loop keyword] and 连接几个 with 子句, 初始化可以强制并行[parallel]发生; 这也就是说, 提供的所有表达式形式都被求值, 并且结果被同时绑定给对应变量.

当需要某些变量的初始化依赖于前面绑定变量的值时, 就使用顺序[sequential]绑定[binding]. 比如, 假设变量 a, b, 和 c 被依次绑定:

```LISP
(loop with a = 1 
      with b = (+ a 2) 
      with c = (+ b 3)
      return (list a b c))
=>  (1 3 6)
```

上面的 loop 的执行等价于下面代码的执行:

```LISP
(block nil
  (let* ((a 1)
        (b (+ a 2))
        (c (+ b 3)))
    (tagbody
        (next-loop (return (list a b c))
                  (go next-loop)
                  end-loop))))
```

如果初始化其他变量不需要之前绑定的变量的值, 一个 and 子句可以被用于指定这些绑定并行[parallel]地发生:

```LISP
(loop with a = 1 
      and b = 2 
      and c = 3
      return (list a b c))
=>  (1 2 3)
```

上面的 loop 的执行等价于下面代码的执行:

```LISP
(block nil
  (let ((a 1)
        (b 2)
        (c 3))
    (tagbody
        (next-loop (return (list a b c))
                  (go next-loop)
                  end-loop))))
```

##### 6.1.2.2.1 WITH 子句的示例

```LISP
;; These bindings occur in sequence.
(loop with a = 1 
      with b = (+ a 2) 
      with c = (+ b 3)
      return (list a b c))
=>  (1 3 6)

;; These bindings occur in parallel.
(setq a 5 b 10)
=>  10
(loop with a = 1
      and b = (+ a 2)
      and c = (+ b 3)
      return (list a b c))
=>  (1 7 13)

;; This example shows a shorthand way to declare local variables 
;; that are of different types.
(loop with (a b c) of-type (float integer float)
      return (format nil "~A ~A ~A" a b c))
=>  "0.0 0 0.0"

;; This example shows a shorthand way to declare local variables 
;; that are the same type.
(loop with (a b c) of-type float 
      return (format nil "~A ~A ~A" a b c))
=>  "0.0 0.0 0.0"
```

### 6.1.3 <span id="ValueAccumulationClauses">值累积子句</span>

构造 collect, collecting, append, appending, nconc, nconcing, count, counting, maximize, maximizing, minimize, minimizing, sum, 和 summing, 允许在一个 loop 中累积值.

构造 collect, collecting, append, appending, nconc, 还有 nconcing, 用于指定将这些值累积到列表[list]中并返回它们的子句. 构造 count, counting, maximize, maximizing, minimize, minimizing, sum, 和 summing 指定累积并返回数字值的子句.

在每一次循环期间, 构造 collect 和 collecting 收集提供的表达式形式 form 的值到一个列表[list]中. 循环停止时, 返回这个列表[list]. 参数 var 被设置为收集值的列表[list]; 如果提供了 var, 这个 loop 不会自动返回最终的列表[list]. 如果 var 没有被提供, 等价于为 var 提供一个内部的名字并且在一个 finally 子句中返回它的值. 这个 var 参数就像是通过 with 构造一样被绑定. 没有为声明 var 的类型[type]提供机制; 它必须是类型[type] list.

除了提供的表达式形式 form 的那些值一定是列表[list]之外, 构造 append, appending, nconc, 和 nconcing 类似于 collect.

* append 关键字导致它的列表[list]值被连接到一个单独的列表[list]中, 就好像它们是给函数[function] append 的参数一样.

* nconc 关键字导致它的列表[list]值被连接到一个单独的列表[list]中, 就好像它们是给函数[function] nconc 的参数一样.

参数 var 被设置为连接的值的列表[list]; 如果提供了 var, loop 不会自动返回最终的列表[list]. var 参数就像是通过 with 构造一样被绑定. 不能为 var 提供一个类型; 它必须是 list 类型. 构造 nconc 破坏性地修改它的参数列表.

count 构造计算提供的表达式形式 form 返回 true 的次数. 参数 var 累计发生的次数; 如果提供了 var, loop 不会自动返回最终的计数. var 参数就像是通过 with 构造一样被绑定到一个 0 的适当的类型. 后面的值 (包括任何必要的强制转换) 就像是通过函数[function] 1+ 一样被计算. 如果使用了 into var, 可以用 type-spec 参数为 var 提供一个类型[type]; 如果提供了一个不是数字的类型[type], 那么结果是不可预料的. 如果这里没有 into 变量, 可选的 type-spec 参数应用给保留这个计数的内部变量. 默认类型[type]是依赖于具体实现的[implementation-dependent]; 但是它一定是 fixnum 的子类型[subtype].

maximize 和 minimize 构造比较第一次循环提供的表达式形式 form 的值和后续循环获取到的值. 确定遇到的最大 (对于 maximize) 或最小 (对于 minimize) 值 (对于 maximize 就像是通过函数[function] max, 对于 minimize 就像是通过函数[function] min) 并且返回. 如果这个 maximize 或 minimize 子句从来没有执行, 累计的值是未指定的. 参数 var 累计这个最大或最小值; 如果提供了 var, loop 不会自动返回这个最大值或最小值. 参数 var 就像是通过 with 构造一样被绑定. 如果使用了 into var, 可以使用 type-spec 参数为 var 指定一个类型[ty[e]]; 如果指定了非数字的类型[type], 那么结果是未定义的. 如果这也里没有 into 变量, 可选的 type-spec 参数应用给保留这个最大或最小值的内部变量. 默认类型[type]是依赖于具体实现的[implementation-dependent]; 但是它一定是 real 的子类型[subtype].

sum 构造在每次循环中形成了所提供 form 的连续主值[primary values]的累积总和. 参数 var 被用于累计这个总和; 如果提供了 var, loop 不会自动返回最终的总和. 参数 var 就像是通过 with 构造一样被绑定到一个 0 的适当类型. 后面的值 (包括任何必要的强制转换) 就像是通过函数[function] + 一样被计算. 如果使用了 into var, 可以使用 type-spec 参数为 var 指定一个类型[type]; 如果指定了非数字的类型[type], 那么结果是未定义的. 如果这也里没有 into 变量, 可选的 type-spec 参数应用给保留这个总和的内部变量. 默认类型[type]是依赖于具体实现的[implementation-dependent]; 但是它一定是 number 的子类型[subtype].

如果使用了 into, 这个构造不会提供默认的返回值; 然而, 在任何 finally 子句中这个变量都是可用的.

如果在一个 loop 中的累积子句它们的目标是相同的(loop 的结果或者一个 into var), 那么适当种类的累积子句可以被合并, 因为它们被认为累积概念上兼容的量. 尤其是, 在一个 loop 表达式形式[form]中, 下列集合子句的任何元素都可以与同一目标的其他元素混合在一起:

* collect, append, nconc

* sum, count

* maximize, minimize

```LISP
;; Collect every name and the kids in one list by using 
;; COLLECT and APPEND.
(loop for name in '(fred sue alice joe june)
      for kids in '((bob ken) () () (kris sunshine) ())
      collect name
      append kids)
=>  (FRED BOB KEN SUE ALICE JOE KRIS SUNSHINE JUNE)
```

在一个 loop 中当且仅当每个子句累积它们的值到不同变量[variable]时, 任何两个不累积相同类型[type]对象[object]的子句可以共存.

> * 6.1.3.1 [COLLECT 子句的示例](#ExamplesCOLLECTClause)
> * 6.1.3.2 [APPEND 和 NCONC 子句的示例](#ExamplesAPPENDNCONCClauses)
> * 6.1.3.3 [COUNT 子句的示例](#ExamplesCOUNTClause)
> * 6.1.3.4 [MAXIMIZE 和 MINIMIZE 子句的示例](#ExamplesMAXIMIZEMINIMIZEClauses)
> * 6.1.3.5 [SUM 子句的示例](#ExamplesSUMClause)

#### 6.1.3.1 <span id="ExamplesCOLLECTClause">COLLECT 子句的示例</span>

```LISP
;; Collect all the symbols in a list.
(loop for i in '(bird 3 4 turtle (1 . 4) horse cat)
      when (symbolp i) collect i)
=>  (BIRD TURTLE HORSE CAT)

;; Collect and return odd numbers.
(loop for i from 1 to 10
      if (oddp i) collect i)
=>  (1 3 5 7 9)

;; Collect items into local variable, but don't return them.
(loop for i in '(a b c d) by #'cddr
      collect i into my-list
      finally (print my-list))
>>  (A C) 
=>  NIL
```

#### 6.1.3.2 <span id="ExamplesAPPENDNCONCClauses">APPEND 和 NCONC 子句的示例</span>

```LISP
;; Use APPEND to concatenate some sublists.
(loop for x in '((a) (b) ((c)))
      append x)
=>  (A B (C))

;; NCONC some sublists together.  Note that only lists made by the
;; call to LIST are modified.
(loop for i upfrom 0 
      as x in '(a b (c))
      nconc (if (evenp i) (list x) nil))
=>  (A (C))
```

#### 6.1.3.3 <span id="ExamplesCOUNTClause">COUNT 子句的示例</span>

```LISP
(loop for i in '(a b nil c nil d e)
      count i)
=>  5
```

#### 6.1.3.4 <span id="ExamplesMAXIMIZEMINIMIZEClauses">MAXIMIZE 和 MINIMIZE 子句的示例</span>

```LISP
(loop for i in '(2 1 5 3 4)
      maximize i)
=>  5
(loop for i in '(2 1 5 3 4)
      minimize i)
=>  1

;; In this example, FIXNUM applies to the internal variable that holds
;; the maximum value.
(setq series '(1.2 4.3 5.7))
=>  (1.2 4.3 5.7)
(loop for v in series 
      maximize (round v) of-type fixnum)
=>  6

;; In this example, FIXNUM applies to the variable RESULT.
(loop for v of-type float in series
      minimize (round v) into result of-type fixnum
      finally (return result))
=>  1
```

#### 6.1.3.5 <span id="SUM 子句的示例">SUM 子句的示例</span>

```LISP
(loop for i of-type fixnum in '(1 2 3 4 5)
      sum i)
=>  15
(setq series '(1.2 4.3 5.7))
=>  (1.2 4.3 5.7)
(loop for v in series 
      sum (* 2.0 v))
=>  22.4
```

### 6.1.4 <span id="TerminationTestClauses">终止测试子句</span>

repeat 构造导致循环在指定的次数后终止. 这个 loop 主体执行了 n 次, 其中 n 是表达式 form 的值. 这个 form 参数只在循环序言中求值一次. 如果这个表达式求值为 0 或者是一个负数[number], 这个 loop 主体不会被求值.

构造 always, never, thereis, while, until, 和宏 loop-finish 允许一个 loop 中循环的条件终止.

构造 always, never, 和 thereis 提供那些当一个 loop 终止时要被返回的值. 在一个带有不是 into 子句的值累积子句的 loop 中使用 always, never, 或 thereis, 会发出一个 program-error 类型[type]的错误 (在宏展开期间). 由于 always, never, 和 thereis 使用 return-from 特殊操作符[special operator]来终止循环, 当由于这些构造中的任何一个导致退出时, 提供的任何 finally 子句不会被求值. 在所有方面这些构造都表现地像 while 和 until 构造.

always 构造接收一个表达式形式[form]并且如果这个表达式形式[form]曾求值为 nil 就终止这个 loop; 在这个情况下, 它返回 nil. 否则, 它提供一个默认返回值 t. 如果提供的表达式形式[form]的从来不返回 nil, 某个其他构造可以终止这个循环.

never 构造在提供的表达式形式 form 的值第一次不是 nil [non-bil]的时候终止循环; 这个 loop 返回 nil. 如果这个提供的表达式形式 form 总是为 nil, 某个其他构造可以终止这个循环. 除非某个其他子句提供一个返回值, 否则默认返回值就是 t.

thereis 构造在提供的表达式形式 form 的值第一次不是 nil [non-bil]的时候终止循环; 这个 loop 返回提供的表达式形式 form 的值. 如果这个提供的表达式形式 form 的值总是为 nil, 某个其他构造可以终止这个循环. 除非某个其他子句提供一个返回值, 否则默认返回值就是 nil.

在 thereis 和 until 构造中有两个区别:

* until 构造不会基于提供的表达式形式 form 的值返回一个值或者 nil.

* until 构造执行任何 finally 子句. 由于 thereis 使用 return-from 特殊操作符[special operator]来终止循环, 当 thereis 导致退出时, 任何提供的 finally 子句不会被求值.

while 构造允许循环直到提供的表达式形式 form 求值为 false 之前继续下去. 提供的表达式形式 form 在 while 子句的位置重复求值.

until 构造等价于 while (not form).... 如果提供表达式形式 form 的值不是 nil [non-nil], 循环终止.

终止测试控制构造可以被用于 loop 主体的任何位置. 终止测试以它们出现的顺序被使用. 如果一个 until 或 while 子句导致终止, 任何在源代码中先于它的子句都被求值. 如果 until 和 while 构造导致了终止, 控制会传递到 loop 结尾, 其中任何 finally 子句会被执行.

在 never 和 until 构造中有两个差别:

* until 构造不会返回基于提供表达式形式 form 的值的 t 或 nil.

* until 构造不会忽视任何 finally 子句. 由于 never 使用 return-from 特殊操作符[special operator]来终止循环, 任何提供的 finally 子句在 never 导致退出时不会被求值.

在大部分情况下没有必要去使用 loop-finish 因为其他 loop 控制子句会终止这个 loop. 宏 loop-finish 被用于提供一个从 loop 中的嵌套条件句中正常的退出. 由于 loop-finish 转移控制到 loop 结尾, 在一个 finally 表达式中使用 loop-finish 会导致无穷的循环.

> * 6.1.4.1 [REPEAT 子句的示例](#ExamplesREPEATClause)
> * 6.1.4.2 [ALWAYS, NEVER, 和 THEREIS 子句的示例](#ExamplesANTClauses)
> * 6.1.4.3 [WHILE 和 UNTIL 子句的示例](#ExamplesWHILEUNTILClauses)

#### 6.1.4.1 <span id="ExamplesREPEATClause">REPEAT 子句的示例</span>

```LISP
(loop repeat 3
      do (format t "~&What I say three times is true.~%"))
>>  What I say three times is true.
>>  What I say three times is true.
>>  What I say three times is true.
=>  NIL
(loop repeat -15
  do (format t "What you see is what you expect~%"))
=>  NIL
```

#### 6.1.4.2 <span id="ExamplesANTClauses">ALWAYS, NEVER, 和 THEREIS 子句的示例</span>

```LISP
;; Make sure I is always less than 11 (two ways).
;; The FOR construct terminates these loops.
(loop for i from 0 to 10
      always (< i 11))
=>  T
(loop for i from 0 to 10
      never (> i 11))
=>  T

;; If I exceeds 10 return I; otherwise, return NIL.
;; The THEREIS construct terminates this loop.
(loop for i from 0
      thereis (when (> i 10) i) )
=>  11

;;; The FINALLY clause is not evaluated in these examples.
(loop for i from 0 to 10
      always (< i 9)
      finally (print "you won't see this"))
=>  NIL
(loop never t
      finally (print "you won't see this"))
=>  NIL
(loop thereis "Here is my value"
      finally (print "you won't see this"))
=>  "Here is my value"

;; The FOR construct terminates this loop, so the FINALLY clause 
;; is evaluated.
(loop for i from 1 to 10
      thereis (> i 11)
      finally (prin1 'got-here))
>>  GOT-HERE
=>  NIL

;; If this code could be used to find a counterexample to Fermat's
;; last theorem, it would still not return the value of the
;; counterexample because all of the THEREIS clauses in this example
;; only return T.  But if Fermat is right, that won't matter
;; because this won't terminate.

(loop for z upfrom 2
      thereis
        (loop for n upfrom 3 below (log z 2)
              thereis
                (loop for x below z
                      thereis
                        (loop for y below z
                              thereis (= (+ (expt x n) (expt y n))
                                        (expt z n))))))
```

#### 6.1.4.3 <span id="ExamplesWHILEUNTILClauses">WHILE 和 UNTIL 子句的示例</span>

```LISP
(loop while (hungry-p) do (eat))

;; UNTIL NOT is equivalent to WHILE.
(loop until (not (hungry-p)) do (eat))

;; Collect the length and the items of STACK.
(let ((stack '(a b c d e f)))
  (loop for item = (length stack) then (pop stack)
        collect item
        while stack))
=>  (6 A B C D E F)

;; Use WHILE to terminate a loop that otherwise wouldn't terminate.
;; Note that WHILE occurs after the WHEN.
(loop for i fixnum from 3
      when (oddp i) collect i
      while (< i 5))
=>  (3 5)
```

### 6.1.5 <span id="UnconditionalExecutionClauses">无条件执行子句</span>

do 和 doing 构造无论出现在 loop 的展开形式的什么位置都会求值提供的那些 forms. 这个 form 参数可以是任何复合表达式形式[compound form]. 每个表达式形式 form 在每次循环都被求值. 因为每个 loop 子句必须以一个 loop 关键字[loop keyword]开始, 关键字 do 是在没有控制动作只需要执行的情况下使用的.

return 构造接收一个表达式形式[form]. 这个表达式形式[form]返回的任何值[value]都会被这个 loop 表达式形式立即返回. 它等价于子句 do (return-from block-name value), 其中 block-name 是 named 子句中指定的名字, 如果这里没有 named 子句那么就是 nil.

#### 6.1.5.1 无条件执行的示例

```LISP
;; Print numbers and their squares.
;; The DO construct applies to multiple forms.
(loop for i from 1 to 3
      do (print i)
        (print (* i i)))
>>  1 
>>  1 
>>  2 
>>  4 
>>  3 
>>  9 
=>  NIL
```

### 6.1.6 <span id="ConditionalExecutionClauses">条件执行子句</span>

if, when, 和 unless 构造在一个 loop 中建立条件控制. 如果通过了检验测试, 后面的 loop 子句会被执行. 如果没有通过检验测试, 后面的子句会被跳过, 并且程序控制会转移到 loop 关键字[loop keyword] else 后面的子句. 如果没有通过检验测试并且没有提供 else 子句, 控制会转移到整个条件子句后面的子句或构造.

如果条件子句是嵌套的, 每个 else 和前面最接近的没有关联 else 或 end 的条件子句组成一对.

在 if 和 when 子句中, 它们是同义的, 如果表达式形式 form 的值是 true 那么检验测试通过.

在 unless 子句中, 如果表达式形式 form 的值是 false 那么检验测试通过.

测试表达式后面的那些子句可以通过使用 loop 关键字[loop keyword] and 产生一个由复合子句组成的条件块来分组.

loop 关键字[loop keyword] it 可以用于引用一个子句中测试表达式的结果. 使用这个 loop 关键字[loop keyword] it 代替一个条件执行子句中的一个 return 子句或一个累积子句中的表达式形式. 如果多个子句用 and 连接, 这个 it 构造必须在这个块的第一个子句中.

可选的 loop 关键字[loop keyword] end 标记这个子句的结束. 如果没有提供这个关键字, 下一个 loop 关键字[loop keyword]标记着结束. 这个构造 end 可以被用于区分复合子句的作用域.

#### 6.1.6.1 WHEN 子句的示例

```LISP
;; Signal an exceptional condition.
(loop for item in '(1 2 3 a 4 5)
      when (not (numberp item))
      return (cerror "enter new value" "non-numeric value: ~s" item))
Error: non-numeric value: A

;; The previous example is equivalent to the following one.
(loop for item in '(1 2 3 a 4 5)
      when (not (numberp item))
      do (return 
          (cerror "Enter new value" "non-numeric value: ~s" item)))
Error: non-numeric value: A

;; This example parses a simple printed string representation from 
;; BUFFER (which is itself a string) and returns the index of the
;; closing double-quote character.
(let ((buffer "\"a\" \"b\""))
  (loop initially (unless (char= (char buffer 0) #\")
                    (loop-finish))
        for i of-type fixnum from 1 below (length (the string buffer))
        when (char= (char buffer i) #\")
        return i))
=>  2

;; The collected value is returned.
(loop for i from 1 to 10
      when (> i 5)
        collect i
      finally (prin1 'got-here))
>>  GOT-HERE
=>  (6 7 8 9 10) 

;; Return both the count of collected numbers and the numbers.
(loop for i from 1 to 10
      when (> i 5)
        collect i into number-list
        and count i into number-count
      finally (return (values number-count number-list)))
=>  5, (6 7 8 9 10)
```

### 6.1.7 <span id="MiscellaneousClauses">其他子句</span>

> * 6.1.7.1 [控制转移子句](#ControlTransferClauses)
> * 6.1.7.2 [初始化和最后执行](#InitialFinalExecution)

#### 6.1.7.1 <span id="ControlTransferClauses">控制转移子句</span>

named 构造为包在整个 loop 周围的隐式块[implicit block]建立一个名字, 这样 return-from 特殊操作符[special operator]可以被用于从 loop 返回值或者退出 loop. 一个 loop 表达式形式[form]只能被赋予一个名字. 如果使用了, 这个 named 构造必须是这个 loop 表达式中的第一个子句.

return 构造接收一个表达式形式[form]. 这个表达式形式[form]返回的任何值[value]都被这个 loop 表达式形式立即返回. 这个构造类似于 return-from 特殊操作符[special operator]和 return 宏[macro]. return 构造不会执行这个 loop 表达式形式[form]给定的任何 finally 子句.

##### 6.1.7.1.1 NAMED 子句的示例

```LISP
;; Just name and return.
(loop named max
      for i from 1 to 10
      do (print i)
      do (return-from max 'done))
>>  1 
=>  DONE
```

#### 6.1.7.2 <span id="InitialFinalExecution">初始化和最后执行</span>

initially 和 finally 构造在这个 loop 主体之前和之后求值表达式形式.

initially 构造导致提供的复合表达式形式 compound-forms 在循环序言中被求值, 它在除了构造 with, for, 或 as 提供的初始化设置以外的所有 loop 代码之前. 任何 initially 子句的代码都是按照子句出现在这个 loop 中的顺序执行的.

finally 构造导致提供的复合表达式形式 compound-forms 在正常循环终止的循环结尾中被求值. 任何 finally 子句的代码都是按照子句出现在这个 loop 中的顺序执行的. 收集起来的代码只在任何累积子句返回隐式的值之前在循环结尾执行一次. 但是一个从 loop 主体中显式的控制转移 (比如, 通过 return, go, 或 throw) 会在没有执行结尾代码的情况下退出 loop.

像 return, always, never, 和 thereis 这样的子句可以绕开 finally 子句. return (或者 return-from, 如果提供了 named 选项的话) 可以被用于在 finally 之后从一个 loop 返回值. 这样一个 finally 子句中显式返回[explicit return]优先于从通过诸如关键字 collect, nconc, append, sum, count, maximize, 和 minimize 提供的子句中返回累积值; 如果使用了 return 或 return-from, 这些子句累积的值不会被 loop 返回. 

### 6.1.8 <span id="ExamplesMLF">其他 Loop 特性的示例</span>

```LISP
(let ((i 0))                     ; no loop keywords are used
  (loop (incf i) (if (= i 3) (return i)))) =>  3
(let ((i 0)(j 0))
  (tagbody
    (loop (incf j 3) (incf i) (if (= i 3) (go exit)))
    exit)
  j) =>  9
```

在下面的例子中, 变量 x 在 y 被步进之前步进; 因此, y 的值反映了 x 的更新值:

```LISP
(loop for x from 1 to 10 
      for y = nil then x 
      collect (list x y))
=>  ((1 NIL) (2 2) (3 3) (4 4) (5 5) (6 6) (7 7) (8 8) (9 9) (10 10))
```

在这个示例中, x 和 y 并行步进:

```LISP
(loop for x from 1 to 10 
      and y = nil then x 
      collect (list x y))
=>  ((1 NIL) (2 1) (3 2) (4 3) (5 4) (6 5) (7 6) (8 7) (9 8) (10 9))
```

#### 6.1.8.1 子句分组示例

```LISP
;; Group conditional clauses.
(loop for i in '(1 324 2345 323 2 4 235 252)
      when (oddp i)
        do (print i)
        and collect i into odd-numbers
        and do (terpri)
      else                              ; I is even.
        collect i into even-numbers
      finally
        (return (values odd-numbers even-numbers)))
>>  1 
>>  
>>  2345 
>>  
>>  323 
>>  
>>  235 
=>  (1 2345 323 235), (324 2 4 252)

;; Collect numbers larger than 3.
(loop for i in '(1 2 3 4 5 6)
      when (and (> i 3) i)
      collect it)                      ; IT refers to (and (> i 3) i).
=>  (4 5 6)

;; Find a number in a list.
(loop for i in '(1 2 3 4 5 6)
      when (and (> i 3) i)
      return it)
=>  4
    
;; The above example is similar to the following one.
(loop for i in '(1 2 3 4 5 6)
      thereis (and (> i 3) i))
=>  4


;; Nest conditional clauses.
(let ((list '(0 3.0 apple 4 5 9.8 orange banana)))
  (loop for i in list
        when (numberp i)
          when (floatp i)
            collect i into float-numbers
          else                                  ; Not (floatp i)
            collect i into other-numbers
        else                                    ; Not (numberp i)
          when (symbolp i) 
            collect i into symbol-list
          else                                  ; Not (symbolp i)
            do (error "found a funny value in list ~S, value ~S~%" list i)
        finally (return (values float-numbers other-numbers symbol-list))))
=>  (3.0 9.8), (0 4 5), (APPLE ORANGE BANANA)

;; Without the END preposition, the last AND would apply to the
;; inner IF rather than the outer one.
(loop for x from 0 to 3 
      do (print x)
      if (zerop (mod x 2))
        do (princ " a")
        and if (zerop (floor x 2))
              do (princ " b")
              end
        and do (princ " c"))
>>  0  a b c
>>  1 
>>  2  a c
>>  3 
=>  NIL
```

### 6.1.9 <span id="NotesAboutLoop">Loop 的注意事项</span>

可以为 loop 变量提供类型[type]. 没有必要为任何变量提供一个类型[type], 但是提供类型可以确保这个变量有正确类型的初始值, 并且这样也可以启用编译器优化 (取决于具体实现[implementation]).

子句 repeat n ... 粗略等价于下面这个子句

    (loop for internal-variable downfrom (- n 1) to 0 ...)

但是在某些实现[implementation]中, repeat 构造可能更高效.

在 loop 子句的可执行部分中和整个 loop 表达式形式周围, 可以使用 let 来绑定变量.

在与 loop 有关时使用名为 IT (在任何包[package]中) 的变量时要谨慎, 因为它是一个 loop 关键字[loop keyword], 可以在某些上下文中替换表达式形式[form].

这里没有让用户给 loop 添加扩展的标准化[standardized]机制. 

## 6.2 <span id="TheIterationDictionary">循环字典</span>

> * [宏 DO, DO*](#MacroDODO)
> * [宏 DOTIMES](#MacroDOTIMES)
> * [宏 DOLIST](#MacroDOLIST)
> * [宏 LOOP](#MacroLOOP)
> * [局部宏 LOOP-FINISH](#LocalMacroLOOPFINISH)


### <span id="MacroDODO">宏 DO, DO*</span>

* 语法(Syntax):

        do ({var | (var [init-form [step-form]])}*) (end-test-form result-form*) declaration* {tag | statement}*
        => result*

        do* ({var | (var [init-form [step-form]])}*) (end-test-form result-form*) declaration* {tag | statement}*
        => result*

* 参数和值(Arguments and Values):

        var---一个符号[symbol].
        init-form---一个表达式形式[form].
        step-form---一个表达式形式[form].
        end-test-form---一个表达式形式[form].
        result-forms---一个隐式的 progn [implicit progn].
        declaration---一个 declare 表达式[expression]; 不求值.
        tag---一个 go 标签[go tag]; 不求值.
        statement---一个复合表达式形式[compound form]; 按以下所述求值.
        results---如果执行了一个 return 或 return-from 表达式形式, 就是从这个表达式形式[form]传出来的那些值[value]; 否则, 就是通过 result-forms 返回的那些值[value].

* 描述(Description):

        当测试条件保持时满足时, do 在一组语句 statements 上迭代. do 接受任意数量的循环变量 vars, 它们在这个循环中并行绑定和步进. 可以通过使用一个 init-form 来为每个循环变量提供一个初始值. step-forms 可以被用于指定这个循环中后续的循环如何更新变量 vars. step-forms 可能被用于可以被用于产生后续的值或累积结果. 如果 end-test-form 条件在一个主体的执行前满足, 这个循环终止. 这些 tags 标记这些语句 statements.

        do* 和 do 一样除了这些变量 vars 的绑定[binding]和步进是顺序执行而不是并行执行.

        在第一次循环前, 所有初始化表达式形式 init-forms 被求值, 如果提供了 init-form, 对应的每一个变量 var 被绑定到它的对应 init-form 的值. 这是一个绑定[binding], 不是一个赋值; 当这个循环终止时, 这些变量的旧值会被恢复. 对于 do, 所有的这些 init-forms 在任何一个变量 var 绑定前被求值. 这些 init-forms 可以引用 do 开始执行之前的可见的这些 vars 的绑定. 对于 do*, 第一个 init-form 被求值, 然后第一个 var 被绑定到那个值, 然后第二个 init-form 被求值, 接着第二个 var 被绑定, 以此类推; 通常, 如果 j < k, 那么第 k 个 init-form 可以引用第 j 个 var 的绑定, 否则引用的是第 j 个 var 的旧绑定.

        在每个循环开始前, 在处理这些变量后, 这个 end-test-form 被求值. 如果结果是 false, 执行 do (或 do*) 表达式形式的主体. 如果结果是 true, 这个 result-forms 按照一个隐式的 progn 的顺序被求值, 然后 do 或 do* 返回.

        在除了第一次以外的每个循环开始时, vars 按照如下更新. 所有的步进表达式形式 step-forms, 如果提供了就从左到右求值, 并且结果值被赋给对应变量 vars. 任何没有关联 step-form 的变量 var 不会被赋值. 对于 do, 所有 step-forms 在任何 var 更新前被求值; 给 vars 的赋值并行执行, 就像是通过 psetq 一样. 因为所有的 step-forms 在任何变量被修改前求值, 所以一个 step-form 求值时可以访问所有这些 vars 的旧值, 即便其他的 step-forms 在它之前. 对于 do*, 第一个 step-form 被求值, 然后这个值赋给第一个 var, 然后第二个 step-form 被求值, 接着值赋给第二个 var, 以此类推; 这个给变量的赋值是顺序执行, 就像是通过 setq 一样. 不管是对于 do 还是 do*, 在变量 vars 被更新后, end-test-form 按照如上所述被求值, 然后这个循环继续.

        剩余的 do (或 do*) 表达式形式部分构成一个隐式的 tagbody [implicit tagbody]. 这些 tags 可能出现在一个 do 循环的主体中, 供出现在主体中的 go 语句使用 (但是这样的 go 语句可能不会出现在变量标识符, end-test-form, 或 result-forms 中). 当到达 do 主体的结尾时, 开始下一个循环周期 (以 step-forms 的求值开始).

        一个名为 nil 的隐式块[implicit block]包在整个 do (或 do*) 表达式形式周围. 一个 return 语句可以在任何点被使用来立即退出这个循环.

        初始化表达式形式 init-form 是和 var 关联的初始值. 如果 init-form 省略了, 那么这个 var 的初始值就是 nil. 如果为 var 提供了一个声明 declaration, init-form 必须与这个声明 declaration 一致.

        声明可以出现在 do (或 do*) 主体的开始位置. 它们适用于 do (or do*) 主体中的代码, 这个 do (or do*) vars 的绑定[binding], step-forms, end-test-form, 还有 result-forms.

* 示例(Examples):

    ```LISP
    (do ((temp-one 1 (1+ temp-one))
          (temp-two 0 (1- temp-two)))
        ((> (- temp-one temp-two) 5) temp-one)) =>  4

    (do ((temp-one 1 (1+ temp-one))
          (temp-two 0 (1+ temp-one)))     
        ((= 3 temp-two) temp-one)) =>  3

    (do* ((temp-one 1 (1+ temp-one))
          (temp-two 0 (1+ temp-one)))
          ((= 3 temp-two) temp-one)) =>  2                     

    (do ((j 0 (+ j 1)))
        (nil)                       ;Do forever.
      (format t "~%Input ~D:" j)
      (let ((item (read)))
        (if (null item) (return)   ;Process items until NIL seen.
            (format t "~&Output ~D: ~S" j item))))
    >>  Input 0: banana
    >>  Output 0: BANANA
    >>  Input 1: (57 boxes)
    >>  Output 1: (57 BOXES)
    >>  Input 2: NIL
    =>  NIL

    (setq a-vector (vector 1 nil 3 nil))
    (do ((i 0 (+ i 1))     ;Sets every null element of a-vector to zero.
        (n (array-dimension a-vector 0)))
        ((= i n))
      (when (null (aref a-vector i))
        (setf (aref a-vector i) 0))) =>  NIL
    a-vector =>  #(1 0 3 0)

    (do ((x e (cdr x))
        (oldx x x))
        ((null x))
      body)
    ```

        是一个对索引变量并行赋值的示例. 在第一个循环时, oldx 的值是 x 在进入 do 之前的值. 在后续的循环中, oldx 包含了 x 在上一次循环中的值.

    ```LISP
    (do ((x foo (cdr x))
          (y bar (cdr y))
          (z '() (cons (f (car x) (car y)) z)))
        ((or (null x) (null y))
          (nreverse z)))
    ```

        和 (mapcar #'f foo bar) 做了一样的事. z 的步进计算就是变量是并行步进的一个例子. 并且, 这个循环的主体是空的.

    ```LISP
    (defun list-reverse (list)
            (do ((x list (cdr x))
                (y '() (cons (car x) y)))
                ((endp x) y)))
    ```

        作为一个嵌套循环的示例, 细想一个 cons 列表[list]的数据结构. 每个 cons 的 car 是一个符号[symbol]列表[list], 而每个 cons 的 cdr 是等长度的包含对应值的列表[list]. 这样一个数据结构类似于关联列表, 但是被划分为 "帧(frame)"; 整体结构类似于胸腔(rib-cage). 这样一个数据结构的一个查找函数可能是:

    ```LISP
    (defun ribcage-lookup (sym ribcage)           
            (do ((r ribcage (cdr r)))
                ((null r) nil)
              (do ((s (caar r) (cdr s))
                  (v (cdar r) (cdr v))) 
                  ((null s))
                (when (eq (car s) sym)
                  (return-from ribcage-lookup (car v)))))) =>  RIBCAGE-LOOKUP
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        其他循环函数 (dolist, dotimes, 和 loop) 和更原始的功能 (tagbody, go, block, return, let, 和 setq)

* 注意(Notes):

        如果 end-test-form 是 nil, 这个测试条件从来不会成功. 这为 "永远执行" 提供了一个惯用语法: 这个 do 或 do* 的主体被重复执行. 这个无限循环可以通过使用 return, return-from, go 到一个外部层级, 或 throw 来终止.

        一个 do 表达式形式[form]可能被解释为如下更原始的表达式形式[form] block, return, let, loop, tagbody, 和 psetq:

    ```LISP
    (block nil        
      (let ((var1 init1)
            (var2 init2)
            ...
            (varn initn))
        declarations
        (loop (when end-test (return (progn . result)))
              (tagbody . tagbody)
              (psetq var1 step1
                      var2 step2
                      ...
                      varn stepn))))
    ```

        do* 是类似的, 除了 let* 和 setq 分别替换 let 和 psetq. 

### <span id="MacroDOTIMES">宏 DOTIMES</span>

* 语法(Syntax):

        dotimes (var count-form [result-form]) declaration* {tag | statement}*
        => result*

* 参数和值(Arguments and Values):

        var---一个符号[symbol].
        count-form---一个表达式形式[form].
        result-form---一个表达式形式[form].
        declaration---一个 declare 表达式[expression]; 不求值.
        tag---一个 go 标签[go tag]; 不求值.
        statement---一个复合表达式形式[compound form]; 按如下所述求值.
        results---如果执行了一个 return 或 return-from 表达式形式, 那么就是从这个表达式形式[form]传出来的那些值[value]; 否则, 就是通过 result-form 返回的那些值[value], 如果没有 result-form 就是 nil.

* 描述(Description):

        dotimes 遍历一系列整数[integer].

        dotimes 求值 count-form, 它应该产生一个整数[integer]. 如果 count-form 是 zero 或者负的, 这个主体不会被执行. dotimes 对于每一个从 0 到 count-form 的值但是不包括那个值的整数[integer]执行一次主体, 以这些 tag 和 statement 出现的顺序执行, 其中 var 绑定到每一个 integer. 然后 result-form 被求值. 在 result-form 被处理时, var 被绑定为主体执行的次数. 这些 tags 标记 statements.

        名为 nil 的隐式块[implicit block]包在 dotimes 周围. return 可以被用于在没有执行进一步循环的情况下立即终止循环, 返回 0 个或多个值.

        这个循环的主体是一个隐式 tagbody [implicit tagbody]; 它可能包含被当作 go 语句目标的标签. 声明可能出现在这个循环的主体之前.

        var 绑定的作用域[scope]不包括 count-form, 但是包括 result-form.

        dotimes 是在每次循环为 var 建立[establish]一个新的绑定[binding], 还是在开始的时候为 var 建立一次绑定[binding]而后续的循环对它赋值, 这是依赖于具体实现的[implementation-dependent].

* 示例(Examples):

    ```LISP
    (dotimes (temp-one 10 temp-one)) =>  10
    (setq temp-two 0) =>  0
    (dotimes (temp-one 10 t) (incf temp-two)) =>  T
    temp-two =>  10
    ```

        这是使用 dotimes 来处理字符串的示例:

    ```LISP
    ;;; True if the specified subsequence of the string is a
    ;;; palindrome (reads the same forwards and backwards).
    (defun palindromep (string &optional
                              (start 0)
                              (end (length string)))
      (dotimes (k (floor (- end start) 2) t)
        (unless (char-equal (char string (+ start k))
                            (char string (- end k 1)))
          (return nil))))
    (palindromep "Able was I ere I saw Elba") =>  T
    (palindromep "A man, a plan, a canal--Panama!") =>  NIL
    (remove-if-not #'alpha-char-p          ;Remove punctuation.
                  "A man, a plan, a canal--Panama!")
    =>  "AmanaplanacanalPanama"
    (palindromep
      (remove-if-not #'alpha-char-p
                    "A man, a plan, a canal--Panama!")) =>  T
    (palindromep
      (remove-if-not
      #'alpha-char-p
      "Unremarkable was I ere I saw Elba Kramer, nu?")) =>  T
    (palindromep
      (remove-if-not
      #'alpha-char-p
      "A man, a plan, a cat, a ham, a yak,
                      a yam, a hat, a canal--Panama!")) =>  T
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        do, dolist, tagbody

* 注意(Notes):

        在 dotimes 的主体中 go 可能被用于转移控制到一个 tag 标记的语句上. 

### <span id="MacroDOLIST">宏 DOLIST</span>

* 语法(Syntax):

        dolist (var list-form [result-form]) declaration* {tag | statement}*
        => result*

* 参数和值(Arguments and Values):

        var---一个符号[symbol].
        list-form---一个表达式形式[form].
        result-form---一个表达式形式[form].
        declaration---一个 declare 表达式[expression]; 不求值.
        tag---一个 go 标签[go tag]; 不求值.
        statement---一个复合表达式形式[compound form]; 按如下所述求值.
        results---如果执行了一个 return 或 return-from 表达式形式, 就是从这个表达式形式[form]传出来的值[value]; 否则, 就是通过 result-form 返回的值[value], 如果没有 result-form 就是 nil.

* 描述(Description):

        dolist 遍历一个列表[list]的元素. dolist 的主体类似于一个 tagbody. 它由一系列的标签 tag 和语句 statement 组成.

        dolist 求值 list-form, 它应该产生一个列表[list]. 对于列表[list]中的每个元素执行一次主体, 以那些 tag 和 statement 出现的顺序求值, 其中 var 绑定为这个元素. 然后 result-form 被求值. 那些 tag 标记那些 statement.

        在 result-form 被处理时, var 绑定为 nil.

        一个名为 nil 的隐式块[implicit block]包在 dolist 周围. return 可以被用于在没有执行进一步循环的情况下立即终止循环, 返回 0 个或多个值[value].

        这个 var 的绑定的作用域[scope]不包括 list-form, 但是包括 result-form.

        dolist 是在每次循环为 var 建立[establish]一个新的绑定[binding]还是在开始的时候为 var 建立[establish]一次绑定而后续的循环对它赋值, 这是依赖于具体实现的[implementation-dependent].

* 示例(Examples):

    ```LISP
    (setq temp-two '()) =>  NIL
    (dolist (temp-one '(1 2 3 4) temp-two) (push temp-one temp-two)) =>  (4 3 2 1)

    (setq temp-two 0) =>  0
    (dolist (temp-one '(1 2 3 4)) (incf temp-two)) =>  NIL
    temp-two =>  4

    (dolist (x '(a b c d)) (prin1 x) (princ " ")) 
    >>  A B C D 
    =>  NIL
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        do, dotimes, tagbody, 章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        在 dolist 的主体中 go 可能被用于转移控制到一个由 tag 标记的语句上. 

### <span id="MacroLOOP">宏 LOOP</span>

* 语法(Syntax):

        "简单" loop 表达式形式:

        loop compound-form* => result*

        "扩展" loop 表达式形式:

        loop [name-clause] {variable-clause}* {main-clause}* => result*

        name-clause::= named name 

        variable-clause::= with-clause | initial-final | for-as-clause 

        with-clause::= with var1 [type-spec] [= form1] {and var2 [type-spec] [= form2]}* 

        main-clause::= unconditional | accumulation | conditional | termination-test | initial-final 

        initial-final::= initially compound-form+ | finally compound-form+ 

        unconditional::= {do | doing} compound-form+ | return {form | it} 

        accumulation::= list-accumulation | numeric-accumulation 

        list-accumulation::= {collect | collecting | append | appending | nconc | nconcing} {form | it}  
                            [into simple-var] 

        numeric-accumulation::= {count | counting | sum | summing | } 
                                maximize | maximizing | minimize | minimizing {form | it} 
                                [into simple-var] [type-spec] 

        conditional::= {if | when | unless} form selectable-clause {and selectable-clause}*  
                      [else selectable-clause {and selectable-clause}*]  
                      [end] 

        selectable-clause::= unconditional | accumulation | conditional 

        termination-test::= while form | until form | repeat form | always form | never form | thereis form 

        for-as-clause::= {for | as} for-as-subclause {and for-as-subclause}* 

        for-as-subclause::= for-as-arithmetic | for-as-in-list | for-as-on-list | for-as-equals-then | 
                            for-as-across | for-as-hash | for-as-package 

        for-as-arithmetic::= var [type-spec] for-as-arithmetic-subclause 

        for-as-arithmetic-subclause::= arithmetic-up | arithmetic-downto | arithmetic-downfrom 

        arithmetic-up::= [[{from | upfrom} form1 |   {to | upto | below} form2 |   by form3]]+ 

        arithmetic-downto::= [[{{from form1}}1  |   {{{downto | above} form2}}1  |   by form3]] 

        arithmetic-downfrom::= [[{{downfrom form1}}1  |   {to | downto | above} form2 |   by form3]] 

        for-as-in-list::= var [type-spec] in form1 [by step-fun] 

        for-as-on-list::= var [type-spec] on form1 [by step-fun] 

        for-as-equals-then::= var [type-spec] = form1 [then form2] 

        for-as-across::= var [type-spec] across vector 

        for-as-hash::= var [type-spec] being {each | the}  
                      {{hash-key | hash-keys} {in | of} hash-table  
                        [using (hash-value other-var)] |  
                        {hash-value | hash-values} {in | of} hash-table  
                        [using (hash-key other-var)]} 

        for-as-package::= var [type-spec] being {each | the}  
                          {symbol | symbols | 
                          present-symbol | present-symbols | 
                          external-symbol | external-symbols} 
                          [{in | of} package] 

        type-spec::= simple-type-spec | destructured-type-spec 

        simple-type-spec::= fixnum | float | t | nil 

        destructured-type-spec::= of-type d-type-spec 

        d-type-spec::= type-specifier | (d-type-spec . d-type-spec) 

        var::= d-var-spec 

        var1::= d-var-spec 

        var2::= d-var-spec 

        other-var::= d-var-spec 

        d-var-spec::= simple-var | nil | (d-var-spec . d-var-spec) 

* 参数和值(Arguments and Values):

        compound-form---一个复合表达式形式[compound form].
        name---一个符号[symbol].
        simple-var---一个符号[symbol] (一个变量[variable]名).
        form, form1, form2, form3---一个表达式形式[form].
        step-fun---一个求值为单参数[argument]函数[function]的表达式形式[form].
        vector---一个求值为一个向量[vector]的表达式形式[form].
        hash-table---一个求值为一个哈希表[hash table]的表达式形式[form].
        package---一个求值为一个包标识符[package designator]的表达式形式[form].
        type-specifier---一个类型指定符[type specifier]. 这个可能是原子类型指定符[atomic type specifier]也可能是复合类型指定符[compound type specifier], 在解构时它为正确解析引入了一些额外的复杂性; 关于更多信息, 见章节 6.1.1.7 (解构).
        result---一个对象[object].

* 描述(Description):

        关于详细信息, 见章节 6.1 (LOOP 机制).

* 示例(Examples):

    ```LISP
    ;; An example of the simple form of LOOP.
    (defun sqrt-advisor ()
      (loop (format t "~&Number: ")
            (let ((n (parse-integer (read-line) :junk-allowed t)))
              (when (not n) (return))
              (format t "~&The square root of ~D is ~D.~%" n (sqrt n)))))
    =>  SQRT-ADVISOR
    (sqrt-advisor)
    >>  Number: 5<NEWLINE>
    >>  The square root of 5 is 2.236068.
    >>  Number: 4<NEWLINE>
    >>  The square root of 4 is 2.
    >>  Number: done<NEWLINE>
    =>  NIL

    ;; An example of the extended form of LOOP.
    (defun square-advisor ()
      (loop as n = (progn (format t "~&Number: ")
                          (parse-integer (read-line) :junk-allowed t))
            while n
            do (format t "~&The square of ~D is ~D.~%" n (* n n))))
    =>  SQUARE-ADVISOR
    (square-advisor)
    >>  Number: 4<NEWLINE>
    >>  The square of 4 is 16.
    >>  Number: 23<NEWLINE>
    >>  The square of 23 is 529.
    >>  Number: done<NEWLINE>
    =>  NIL

    ;; Another example of the extended form of LOOP.
    (loop for n from 1 to 10
          when (oddp n)
            collect n)
    =>  (1 3 5 7 9)
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        do, dolist, dotimes, return, go, throw, 章节 6.1.1.7 (解构)

* 注意(Notes):

        除了 loop-finish 不能被用在一个简单 loop 表达式形式[form]中, 一个简单 loop 表达式形式[form]和一个扩展 loop 表达式形式[form]的关系如下:

        (loop compound-form*) ==  (loop do compound-form*)


### <span id="LocalMacroLOOPFINISH">局部宏 LOOP-FINISH</span>

* 语法(Syntax):

        loop-finish <no arguments> =>|

* 描述(Description):

        可以在词法上位于一个扩展 loop 表达式形式[form]中的地方使用这个 loop-finish 宏[macro]来"正常"地终止这个表达式形式[form]. 这也就是说, 它转移控制到词法上最内部的扩展 loop 表达式形式[form]的循环结尾. 这允许执行任何 finally 子句 (为了得到效果) 以及返回任何累积结果.

* 示例(Examples):

    ```LISP
    ;; Terminate the loop, but return the accumulated count.
    (loop for i in '(1 2 3 stop-here 4 5 6)
          when (symbolp i) do (loop-finish)
          count i)
    =>  3
    
    ;; The preceding loop is equivalent to:
    (loop for i in '(1 2 3 stop-here 4 5 6)
          until (symbolp i)
          count i)
    =>  3

    ;; While LOOP-FINISH can be used can be used in a variety of 
    ;; situations it is really most needed in a situation where a need
    ;; to exit is detected at other than the loop's `top level'
    ;; (where UNTIL or WHEN often work just as well), or where some 
    ;; computation must occur between the point where a need to exit is
    ;; detected and the point where the exit actually occurs.  For example:
    (defun tokenize-sentence (string)
      (macrolet ((add-word (wvar svar)
                    `(when ,wvar
                      (push (coerce (nreverse ,wvar) 'string) ,svar)
                      (setq ,wvar nil))))
        (loop with word = '() and sentence = '() and endpos = nil
              for i below (length string)
              do (let ((char (aref string i)))
                    (case char
                      (#\Space (add-word word sentence))
                      (#\. (setq endpos (1+ i)) (loop-finish))
                      (otherwise (push char word))))
              finally (add-word word sentence)
                      (return (values (nreverse sentence) endpos)))))
    =>  TOKENIZE-SENTENCE
    
    (tokenize-sentence "this is a sentence. this is another sentence.")
    =>  ("this" "is" "a" "sentence"), 19
    
    (tokenize-sentence "this is a sentence")
    =>  ("this" "is" "a" "sentence"), NIL
    ```

* 副作用(Side Effects):

        转移控制.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        loop-finish 在全局环境[global environment]中是否被 fbound 是依赖于具体实现的[implementation-dependent]; 然而, loop-finish 的遮蔽[shadow]和重定义的限制条件跟 COMMON-LISP 包中在全局环境[global environment]中被 fbound 的符号[symbol]一样. 在 loop 的外部去尝试使用 loop-finish 的结果是未定义的.

* 参见(See Also):

        loop, 章节 6.1 (LOOP 机制)

* 注意(Notes):


# 7. 对象

> * 7.1 [对象创建和初始化](#ObjectCreationInit)
> * 7.2 [修改一个实例的类](#ChangeClassInstance)
> * 7.3 [重新初始化一个实例](#ReinitInstance)
> * 7.4 [元对象](#MetaObjects)
> * 7.5 [槽](#Slots)
> * 7.6 [广义函数和方法](#GenericFunctionsMethods)
> * 7.7 [对象字典](#TheObjectsDictionary)

## 7.1 <span id="ObjectCreationInit">对象创建和初始化</span>

广义函数[generic function] make-instance 创建并且返回一个类[class]的实例[instance]. 第一个参数是一个类[class]或者一个类[class]的名字[name], 而剩余参数组成初始化参数列表[initialization argument list].

一个新的实例[instance]的初始化由多个独立不同的步骤组成, 包括以下这些: 将显式提供的初始化参数与未提供的初始化参数的默认值相结合, 检查初始化参数的有效性, 为实例[instance]分配存储, 用值来填充这些槽[slot], 并且执行用户提供的执行额外初始化的方法[method]. make-instance 的每个步骤都是通过一个广义函数[generic function]实现的, 以提供一种定制该步骤的机制. 另外, make-instance 自身也是一个广义函数[generic function]并且因此也可以被定制.

这个对象系统为每个步骤指定了系统提供的主方法[method]并且因此为整个初始化过程指定了一个定义明确的标准行为. 这个标准行为提供了四个简单的机制用于控制初始化:

* 声明一个符号[symbol]作为一个槽[slot]的初始化参数. 一个初始化参数是通过对 defclass 使用 :initarg 槽选项来声明的. 这个提供了一个机制, 可以在一个 make-instance 调用中来给一个槽[slot]提供值.

* 为一个初始化参数提供一个默认值表达式形式. 初始化参数的默认值表达式形式通过对 defclass 使用 :default-initargs 类选项来定义的. 如果没有显式给 make-instance 提供一个初始化参数作为参数, 那么默认值表达式形式就会在定义它的 defclass 表达式形式所在的词法环境中被求值, 并且产生的值被用作这个初始化参数的值.

* 为一个槽[slot]提供一个默认的初始值表达式形式. 一个槽[slot]的默认初始值表达式形式通过对 defclass 使用 :initform 槽选项来定义的. 如果没有给 make-instance 提供和那个槽[slot]关联的初始化参数或者通过 :default-initargs 提供默认值, 那么这个默认初始值表达式形式就会在定义它的 defclass 表达式形式所在的词法环境中被求值, 并且产生的这个值被存储到这个槽[slot]中. 当创建一个实例[instance]时, 更新一个实例[instance]来符合重定义的类[class]时, 或者更新一个实例[instance]来符合不同类[class]的定义时, 一个局部槽[local slot]的这个 :initform 表达式形式可能被使用. 当定义或者重定义这个类[class]时, 一个共享槽[shared slot]的这个 :initform 表达式形式会被使用.

* 为 initialize-instance 和 shared-initialize 定义方法[method]. 上面描述的槽填充行为是由一个系统提供的 initialize-instance 主方法[method]来实现的, 它调用 shared-initialize. 广义函数[generic function] shared-initialize 实现了由这四种情况所共享的初始化部分: 创建一个实例[instance]的时候, 重新初始化一个实例[instance]的时候, 更新一个实例[instance]来符合重定义的类[class]时, 还有更新一个实例[instance]来符合一个不同的类[class]的定义时. 系统提供的 shared-initialize 主方法[method]直接实现上述槽填充行为, 而 initialize-instance 简单地调用 shared-initialize.

> * 7.1.1 [初始化参数](#InitArguments)
> * 7.1.2 [声明初始化参数的有效性](#DeclaringValidityInitArg)
> * 7.1.3 [初始化参数的默认值](#DefaultInitArg)
> * 7.1.4 [初始化参数的规则](#RulesInitArg)
> * 7.1.5 [Shared-Initialize](#SharedInitialize)
> * 7.1.6 [Initialize-Instance](#InitializeInstance)
> * 7.1.7 [Make-Instance 和 Initialize-Instance 的定义](#DefMIII)

### 7.1.1 <span id="InitArguments">初始化参数</span>

一个初始化参数控制对象[object]的创建和初始化. 使用关键字符号[symbol]来命名初始化参数往往是很方便的, 但是初始化参数的名字[name]可以是任何符号[symbol], 包括 nil. 一个初始化参数可以以两种方式被使用: 用一个值去填充一个槽[slot]或者为一个初始化方法[method]提供一个参数. 一个单独的初始化参数可以被同时用作这两个目的.

一个初始化参数列表[initialization argument list]是一个初始化参数名字和值的属性列表[property list]. 它的结构与属性列表[property list]相同, 也与 &key 参数处理的参数列表部分相同. 在这些列表中, 如果一个初始化参数名称在初始化参数列表中出现不止一次, 那么最左边出现的就会提供值, 而其余的会被忽略. 给 make-instance 的那些参数 (在第一个参数后面的) 组成初始化参数列表[initialization argument list].

一个初始化参数可以和一个槽[slot]关联. 如果这个初始化参数在初始化参数列表[initialization argument list]中有一个值, 这个值会被存储到新创建对象[object]的那个槽[slot]中, 覆盖任何和这个槽[slot]关联的 :initform 表达式形式. 一个单独的初始化参数可以初始化不止一个槽[slot]. 初始化一个共享槽[shared slot]的初始化参数存储它的值到那个共享槽[shared slot]中, 替换掉任何先前的值.

一个初始化参数可以和一个方法[method]关联. 当一个对象[object]被创建并且提供一个特定的初始化参数时, 这个初始化参数的名字和值作为一个关键字参数对来调用广义函数[generic function] initialize-instance, shared-initialize, 和 allocate-instance. 如果在初始化参数列表[initialization argument list]中没有给这个初始化参数提供一个值, 这个方法[method]的 lambda 列表[lambda list]会提供一个默认值.

初始化参数被用于四种情况: 创建一个实例[instance]时, 重新初始化一个实例[instance]时, 更新一个实例[instance]去符合一个重定义的类[class], 还有更新一个实例[instance]去符合一个不同的类[class]的定义.

由于初始化参数被用于控制某个特定类[class]的实例[instance]的创建和初始化, 我们就说一个初始化参数是那个类的"一个初始化参数". 

### 7.1.2 <span id="DeclaringValidityInitArg">声明初始化参数的有效性</span>

在使用初始化参数的四种情况的任何一种时, 都会检测初始化参数的有效性. 一个初始化参数可能在一种情况是有效的但是在另一种却是无效的. 比如, 系统提供的针对类[class] standard-class 的 make-instance 的主方法[method]检测它的初始化参数的有效性, 如果提供的一个初始化参数在那个情况下没有被有效声明, 那么就会发出一个错误.

关于声明初始化参数有效性这里有两个方法.

* 填充槽[slot]的初始化参数通过给 defclass 的 :initarg 槽选项来声明为有效的. 这个 :initarg 槽选项从超类[superclass]中继承下来. 因此填充一个类[class]的槽[slot]的有效初始化参数集合是这个类[class]和它的超类[superclass]声明为有效的填充槽[slot]的初始化参数的并集. 填充槽[slot]的初始化参数在所有四种情况中都是有效的.

* 给方法[method]提供参数的初始化参数通过定义这些方法[method]来声明为有效的. 在这个方法[method]的 lambda 列表[lambda list]中指定的每个关键字参数的关键字名字成为这个方法[method]可应用的所有类[class]的初始化参数. 一个可应用方法的 lambda 列表[lambda list]中 &allow-other-keys 的出现会禁用初始化参数的有效性检测. 因此方法[method]继承控制了给方法[method]提供参数的有效初始化参数的集合. 用于声明初始化参数有效的方法[method]定义的广义函数[generic function]如下所示:

    -- 创建一个类[class]的实例[instance]: allocate-instance, initialize-instance, 和 shared-initialize. 通过这些方法[method]声明为有效的初始化参数在创建一个类[class]的一个实例[instance]时是有效的.

    -- 重新初始化一个实例[instance]: reinitialize-instance 和 shared-initialize. 通过这些方法[method]声明为有效的初始化参数在重新初始化一个实例[instance]时是有效的.

    -- 更新一个实例[instance]来符合重定义的类[class]: update-instance-for-redefined-class 和 shared-initialize. 通过这些方法[method]声明为有效的初始化参数在更新一个实例[instance]来符合重定义的类[class]时是有效的.

    -- 更新一个实例[instance]来复合一个不同类[class]的定义: update-instance-for-different-class 和 shared-initialize. 通过这些方法[method]声明为有效的初始化参数在更新一个实例[instance]来复合一个不同类[class]的定义时是有效的.

一个类[class]的有效初始化参数集是那些填充槽[slot]或给方法[method]提供参数的初始化参数以及预定义的初始化参数 :allow-other-keys 的集合. :allow-other-keys 的默认值是 nil. 如果初始化参数 :allow-other-keys 的值是 true 那么初始化参数的有效性检测就会被禁用. 

### 7.1.3 <span id="DefaultInitArg">初始化参数的默认值</span>

可以使用类[class]选项 :default-initargs 来给一个初始化参数提供一个默认值表达式形式[form]. 如果一个初始化参数被某个特定的类[class]声明为有效的, 它的默认值表达式形式可能被一个不同的类[class]指定. 在这个情况下 :default-initargs 被用于给一个继承的初始化参数提供一个默认值.

这个 :default-initargs 选项仅被用于给初始化参数提供默认值; 它不会声明一个符号[symbol]作为有效初始化参数的名字. 此外, 这个 :default-initargs 选项仅在创建一个实例[instance]时被用于给初始化提供默认值.

给这个 :default-initargs 类选项的参数是一个初始化参数名字和表达式形式[form]交替的列表. 每个表达式形式[form]是对应初始化参数的默认值表达式形式. 一个初始化参数的默认值表达式形式[form]当且仅当这个初始化参数没有出现在 make-instance 的参数中并且没有被一个更具体的类[class]所缺省的时候被使用和求值. 默认值表达式形式[form]在提供它的 defclass 表达式形式所在的词法环境中被求值; 产生的值被用作这个初始化参数的值.

提供给 make-instance 的初始化参数和默认初始化参数组合来产生一个默认初始化参数列表[defaulted initialization argument list]. 一个默认初始化参数列表[defaulted initialization argument list]是一个交替初始化参数名称和值的列表, 其中未提供的初始化参数是默认值, 在这个列表中显式提供的初始化参数出现在默认的初始化参数的前面. 默认初始化参数根据提供默认值的这些类[class]的类优先级列表[class precedence list]中的顺序来排序.

就槽[slot]的初始化而言, :default-initargs 和 :initform 选项的目的存在一个区别. 在不知道这个初始化参数是初始化一个槽[slot]还是传递给一个方法[method]的情况下, 这个 :default-initargs 类选项为用户提供一个机制去给这个初始化参数提供一个默认值表达式形式[form]. 如果那个初始化参数没有在一个 make-instance 的调用中显式提供, 那么就使用这个默认值表达式形式, 就像在这个调用中提供了一样. 与此相反, 这个 :initform 槽选项为用户提供一个机制去给一个槽[slot]提供一个默认初始值表达式形式. 当且仅当没有给 make-instance 传递一个和槽[slot]关联的初始化参数或者被 :default-initargs 省略的时候, 一个 :initform 表达式形式被用于初始化这个槽[slot].

初始化参数的默认值表达式形式的求值顺序和 :initform 表达式形式的求值顺序是没有定义的. 如果求值的顺序很重要, 应该使用 initialize-instance 或 shared-initialize 方法[method]. 

### 7.1.4 <span id="RulesInitArg">初始化参数的规则<\span>

这个 :initarg 槽选项对于一个给定的槽[slot]可能不止一次被指定.

下面的规则指出了初始化参数被多次定义的时机:

* 如果相同的初始化参数名出现在超过一个 :initarg 槽选项中时, 一个给定的初始化参数可以被用于初始化不止一个槽[slot].

* 一个给定的初始化参数名可以出现在不止一个初始化方法[method]的 lambda 列表[lambda list]中.

* 一个给定的初始化参数名可以同时出现在一个 :initarg 槽选项和一个初始化方法[method]的 lambda 列表[lambda list]中.

如果在 make-instance 的参数中给定初始化同一个槽[slot]的两个或更多初始化参数, 在这个初始化参数列表[initialization argument list]中的这些初始化参数中的最左边的那个来提供值, 即便这些初始化参数有着不同的名字.

如果初始化同一个槽的两个或更多不同的初始化参数有默认值并且在给 make-instance 的那些参数中都没有显式提供, 那么出现在最具体的那些类[class]的 :default-initargs 类选项中的初始化参数来提供值. 如果一个单独的 :default-initargs 类选项指定了两个或更多初始化相同槽[slot]的初始化参数并且在给 make-instance 的那些参数中都没有显式提供, 在 :default-initargs 类选项中最左边那个来提供值, 并且忽略剩余默认值表达式形式[form]的值.

在 make-instance 的参数中显式给定的初始化参数出现在默认初始化参数的左边. 假设类 C1 和 C2 为不同的槽[slot]提供默认初始化参数值, 并且 C1 比 C2 更具体; 那么在默认初始化参数列表[defaulted initialization argument list]中 C1 提供的默认初始化参数值在 C2 提供的值的左边. 如果一个单独的 :default-initargs 类选项为两个不同的槽[slot]提供了初始化参数的值, 被指定的值距离 :default-initargs 的左边更远的那个初始化参数在默认初始化参数列表[defaulted initialization argument list]中也距离左边更远.

如果一个槽[slot]同时有一个 :initform 表达式形式和一个 :initarg 槽选项, 并且这个初始化参数使用 :default-initargs 提供默认值或者给 make-instance 提供了这个参数, 那么这个捕获的 :initform 表达式形式既不会被使用也不会被求值.

下面都是上述规则的一个示例:

```LISP
(defclass q () ((x :initarg a)))
(defclass r (q) ((x :initarg b))
  (:default-initargs a 1 b 2))
```
                                                                       
| 表达式形式                   |  默认初始化参数列表 | X 槽的内容 |
|-                           |-                 |-          |         
|(make-instance 'r)          |  (a 1 b 2)       |  1        |     
|(make-instance 'r 'a 3)     |  (a 3 b 2)       |  3        |             
|(make-instance 'r 'b 4)     |  (b 4 a 1)       |  4        |         
|(make-instance 'r 'a 1 'a 2)|  (a 1 a 2 b 2)   |  1        |                 


### 7.1.5 <span id="SharedInitialize">Shared-Initialize</span>

在一个实例[instance]被创建时, 一个实例[instance]被重新初始化时, 一个实例[instance]被更新去符合一个重定义的类[class]时, 以及一个实例[instance]被更新去符合一个不同的类[class]时, 广义函数[generic function] shared-initialize 被用于使用初始化参数和 :initform 表达式形式来填充一个实例[instance]的槽[slot]. 它使用标准方法[method]组合. 它接受以下参数: 要被初始化的实例[instance], 这个实例[instance]中可以访问的[accessible]槽[slot]的名字[name]集合的一份说明, 还有任意数量的初始化参数. 在前两个后面的参数一定组成一个初始化参数列表[initialization argument list].

给 shared-initialize 的第二个参数可能是以下其中之一:

* 它可以是一个槽[slot]名字的列表[list] (可能是空的), 指定了那些槽名字的集合.

* 它可以是符号 t, 指定了所有槽[slot]的集合.

这里有个系统提供的 shared-initialize 的主方法[method], 其中第一个参数特化符[parameter specializer]是类[class] standard-object. 不管槽是共享的还是局部的, 这个方法[method]在每个槽[slot]上表现如下:

* 如果这个初始化参数列表[initialization argument list]中的一个初始化参数为那个槽[slot]指定了一个值, 那么这个值就会被存储到那个槽[slot]中, 即便在这个方法[method]执行前一个值已经被存储到那个槽[slot]里. 受影响的槽[slot]独立于由 shared-initialize 的第二个参数表示的槽[slot].

* 任何由第二个参数表示的在这个点仍是未绑定的槽[slot]都会根据它们的 :initform 表达式形式来初始化. 对于任何有着一个 :initform 表达式形式的槽[slot], 那个表达式形式[form]会在它的定义 defclass 表达式形式所在的词法环境中被求值, 并且结果被存储到那个槽[slot]中. 比如, 如果一个 before 方法[before method]存储一个值到槽[slot]中, 这个 :initform 表达式形式不会被用来给这个槽[slot]提供一个值. 如果第二个参数指定了一个不对应这个实例[instance]中任何可访问的[accessiable]槽[slot]的名字, 结果是未指定的.

* 在章节 7.1.4 (初始化参数的规则) 中提及的规则也是遵守的.

广义函数 shared-initialize 会被系统提供的 reinitialize-instance, update-instance-for-different-class, update-instance-for-redefined-class, 和 initialize-instance 的主方法[method]调用. 因此, 可以为 shared-initialize 写一个方法[method]来指定发生在所有这些上下文中的动作. 

### 7.1.6 <span id="InitializeInstance">Initialize-Instance</span>

广义函数[generic function] initialize-instance 被 make-instance 调用来初始化一个新创建的实例[instance]. 它使用标准方法组合[standard method combination]. 可以定义 initialize-instance 的方法[method], 以便执行任何无法通过为槽[slot]提供初始值来实现的初始化.

在初始化期间, initialize-instance 在以下动作执行后被调用:

* 默认初始化参数列表[defaulted initialization argument list]已经通过结合提供的初始化参数列表[initialization argument list]和这个类[class]的默认初始化参数被计算出来.

* 默认初始化参数列表[defaulted initialization argument list]的有效性已经被检测. 如果初始化参数中的任何一个还没有被有效声明, 那么就会发出一个错误.

* 一个槽[slot]还没有被绑定的实例[instance]被创建出来.

使用一个新的实例和默认初始化参数来调用广义函数 initialize-instance. 这里有一个系统提供的 initialize-instance 的主方法[method], 其中参数特化符[parameter specializer]是类[class] standard-object. 这个方法[method]调用广义函数 shared-initialize 根据槽[slot]的初始化参数和 :initform 表达式形式来填充槽[slot]; 使用以下参数来调用广义函数 shared-initialize : 这个实例[instance], t, 还有默认初始化参数.

注意, initialize-instance 在它对 shared-initialize 调用中提供默认初始化参数列表[defaulted initialization argument list], 因此, 由系统提供的 shared-initialize 主方法[method]执行的第一步考虑了在对 make-instance 的调用中提供的初始化参数和默认初始化参数列表[defaulted initialization argument list].

initialize-instance 的方法[method]可以被定义来指定一个实例[instance]被初始化时采取的动作. 如果只有 initialize-instance 的 after 方法[after method]被定义, 它们会在系统提供的用于初始化的主方法[method]之后被运行, 并且因此不会和 initialize-instance 的默认行为冲突.

对象系统提供了两个在 initialize-instance 方法的主体中有用的函数[function]. 函数[function] slot-boundp 返回一个广义 boolean 值, 表示一个指定的槽[slot]是否有一个值的; 这提供了一种机制, 用于编写 initialize-instance 的 after 方法[after method], 用于当且仅当槽尚未初始化的情况下去初始化槽. 函数[function] slot-makunbound 使这个槽[slot]没有值. 

### 7.1.7 <span id="DefMIII">Make-Instance 和 Initialize-Instance 的定义</span>

广义函数 make-instance 的行为表现就像它是如下定义的那样, 除了某些优化是允许的:

```LISP
(defmethod make-instance ((class standard-class) &rest initargs)
  ...
  (let ((instance (apply #'allocate-instance class initargs)))
    (apply #'initialize-instance instance initargs)
    instance))

(defmethod make-instance ((class-name symbol) &rest initargs)
  (apply #'make-instance (find-class class-name) initargs))
```

在 make-instance 的定义中省略的代码用默认初始化参数扩充了 initargs , 并检查产生的初始化参数, 以确定是否提供了一个初始化参数, 既不填充槽[slot], 也不向可应用的方法[method]提供参数.

广义函数 initialize-instance 的行为表现就像它是如下定义的那样, 除了某些优化是允许的:

```LISP
(defmethod initialize-instance ((instance standard-object) &rest initargs)
  (apply #'shared-initialize instance t initargs)))
```

这些程序可以被定制.

程序员接口级别的定制包括使用给 defclass 的 :initform, :initarg, 和 :default-initargs 选项, 还有为 make-instance, allocate-instance, 和 initialize-instance 定义方法[method]. 也可以为 shared-initialize 定义方法[method], 它会被广义函数 reinitialize-instance, update-instance-for-redefined-class, update-instance-for-different-class, 和 initialize-instance 调用. 元对象级别支持额外的定制.

具体实现允许去对 initialize-instance 和 shared-initialize 做某些优化. 在章节 7 中 shared-initialize 的描述提及了可能的优化. 

## 7.2 <span id="ChangeClassInstance">修改一个实例的类</span>

函数[function] change-class 可以被用来修改一个实例[instance]的类[class], 从它的当前类 Cfrom 到一个不同的类 Cto; 它修改这个实例[instance]的结构来符合这个类 Cto 的定义.

注意, 修改一个实例[instance]的类[class]可能导致槽[slot]被添加或删除. 修改一个实例[instance]的类[class]不会修改由 eq 函数定义的它的恒等性(identity).

当 change-class 在一个实例[instance]上被调用, 会发生一个分为两步的更新过程. 第一步通过添加新的局部槽[local slot]还有废弃这个新版本的实例[instance]中没有指定的局部槽[local slot]来修改这个实例的结构. 第二步初始化新添加的局部槽[local slot]并执行其他任何用户定义的动作. 这两步在以下两个章节中有进一步的描述.

### 7.2.1 修改实例的结构

为了使这个实例[instance]去符合类 Cto, 类 Cto 指定而类 Cfrom 没有指定的局部槽[local slot]会被添加, 并且类 Cfrom 指定而类 Cto 没有指定的局部槽[local slot]会被丢弃.

类 Cto 和类 Cfrom 都指定的局部槽[local slot]会被保留. 如果这样一个局部槽[local slot]没有被绑定, 它就保持未绑定状态.

在类 Cfrom 中指定为共享的但是在类 Cto 中指定为局部的槽[slot]的值会被保留.

这个更新中的第一步不会影响任何共享槽[shared slot]的值. 

### 7.2.2 初始化新添加的局部槽

更新操作的第二步初始化新添加的槽[slot]并且执行任何其他用户定义的动作. 这个步骤由广义函数 update-instance-for-different-class 来实现. 广义函数 update-instance-for-different-class 在更新的第一步完成后被 change-class 所调用.

广义函数 update-instance-for-different-class 在 change-class 计算的参数上被调用. 传递的第一个参数是这个要被更新的实例[instance]的一个拷贝并且是类 Cfrom 的一个实例[instance]; 这个拷贝在广义函数 change-class 中有着动态范围[dynamic extent]. 第二个参数是 change-class 到目前为止更新的实例[instance]并且那是类 Cto 的一个实例[instance]. 剩余的参数是一个初始化参数列表[initialization argument list].

这里有一个系统提供的 update-instance-for-different-class 的主方法[method], 它有两个参数特化符, 其中的每一个都是类[class] standard-object. 首先这个方法[method]检测初始化参数的有效性, 如果提供的一个初始化参数没有被有效声明就会发出一个错误. (关于更多信息, 见章节 7.1.2 (声明初始化参数的有效性).) 然后它调用广义函数 shared-initialize 并传递以下参数: 这个新的实例[instance], 新添加槽的名字[name]的一个列表, 还有它收到的那些初始化参数. 

### 7.2.3 定制一个实例的类的变更

update-instance-for-different-class 方法[method]可以被定义用来指定一个实例[instance]被更新时发生的动作. 如果只有 update-instance-for-different-class 的 after 方法[after method]被定义, 它们会在系统提供的初始化主方法[method]之后被运行并且不会干涉 update-instance-for-different-class 的默认行为.

shared-initialize 的方法[method]可能被定义用来定制类[class]的重定义行为. 关于更多信息, 见章节 7.1.5 (Shared-Initialize). 

## 7.3 <span id="ReinitInstance">重新初始化一个实例</span>

广义函数 reinitialize-instance 可以被用于根据初始化参数来修改槽[slot]的值.

重新初始化的过程修改一些槽[slot]的值并执行任何用户定义的动作. 它不会修改一个实例[instance]的结构来添加或删除槽[slot], 并且它也不会使用任何 :initform 表达式形式来初始化槽[slot].

广义函数 reinitialize-instance 可以被直接调用. 它接受一个必要参数, 就是这个实例[instance]. 它也接受任意数量的初始化参数来被 reinitialize-instance 或 shared-initialize 的方法[method]使用. 在必要的实例[instance]后面的参数必须组成一个初始化参数列表[initialization argument list].

这里有一个系统提供的 reinitialize-instance 主方法[method], 其中参数特化符[parameter specializer]是类[class] standard-object. 首先这个方法[method]检查初始化参数的有效性, 如果一个提供的参数没有被有效声明就会发出一个错误. (关于更多信息, 见章节 7.1.2 (声明初始化参数的有效性).) 然后它调用广义函数 shared-initialize 并传递如下参数: 这个实例[instance], nil, 还有它收到的初始化参数.

### 7.3.1 定制重新初始化行为

reinitialize-instance 的方法[method]可以被定义, 用来指定一个实例[instance]被更新时采取的动作. 如果只有 reinitialize-instance 的 after 方法[after method]被定义, 它们会在系统提供的初始化主方法[method]之后被运行并且因此不会影响 reinitialize-instance 的默认行为.

shared-initialize 的方法[method]可以被定义用来定制类[class]的重定义行为. 关于更多信息, 见章节 7.1.5 (Shared-Initialize). 

## 7.4 <span id="MetaObjects">元对象</span>

对象系统的具体实现操纵类[class], 方法[method]和广义函数[generic function]. 对象系统包含了由类[class]上的方法[method]定义的广义函数[generic function]的集合; 这些广义函数[generic function]的行为定义了这个对象系统的行为. 定义这些方法[method]的类[class]的实例[instance]称之为元对象.

### 7.4.1 标准元对象

对象系统提供了一个元对象的集合, 称之为标准元对象. 这些包括类[class] standard-object 和类 standard-method, standard-generic-function, method-combination 的实例[instance].

* 类[class] standard-method 是 defmethod 和 defgeneric 表达式形式[form]定义出来的方法[method]的默认类[class].

* 类[class] standard-generic-function 是 defmethod, defgeneric, 和 defclass 定义的广义函数[generic function]的默认类[class].

* 名为 standard-object 的类[class]是类[class] standard-class 的一个实例[instance]并且它是每个 standard-class 的实例[instance]的类[class]的一个超类[superclass], 除了它自身和 structure-class.

* 每个方法[method]组合对象都是类[class] method-combination 的一个子类[subclass]的实例[instance]. 

## 7.5 <span id="Slots">槽</span>

> * 7.5.1 [槽的介绍](#IntroductionSlots)
> * 7.5.2 [访问槽](#AccessingSlots)
> * 7.5.3 [槽和槽选项的继承](#InheritanceSlotsSlotOptions)

### 7.5.1 <span id="IntroductionSlots">槽的介绍</span>

一个元类[metaclass] standard-class 的对象[object]有 0 个或更多已命名的槽[slot]. 一个对象[object]的槽[slot]由这个对象[object]的类[class]决定. 每个槽[slot]都可以持有一个值. 一个槽[slot]的名字[name]是一个语法上可用作一个变量名的符号[symbol].

当一个槽[slot]没有一个值时, 这个槽[slot]就被称为未绑定的[unbound]. 当一个未绑定的槽[slot]被读取时, 广义函数[generic function] slot-unbound 会被调用. 系统提供的类[class] t 上的 slot-unbound 主方法[method]会发出一个错误. 如果 slot-unbound 返回了, 它的主值[primary value]那时会被用作那个槽[slot]的值[value].

一个槽[slot]的默认初始值表达式形式被 :initform 槽选项所定义. 当这个 :initform 表达式形式被用于提供一个值的时候, 它会在求值 defclass 表达式形式的词法环境中被求值. 这个 :initform 连同求值 defclass 表达式形式所在的词法环境一起被称为一个被捕获的初始化表达式形式[captured initialization form]. 关于更多详情, 见章节 7.1 (对象创建和初始化).

一个局部槽[local slot]被定义为仅对于分配槽[slot]的那个实例[instance]是可访问的[accessible]一个槽[slot]. 一个共享槽[shared slot]被定义为一个对于给定类[class]及其子类[subclass]的多个实例[instance]都是可见的槽[slot].

当一个类[class]的 defclass 表达式形式包含了某个给定名字[name]的槽指定符[slot specifier], 就说这个类[class]用这个名字定义一个槽[slot]. 定义一个局部槽[local slot]不会马上创建一个槽[slot]; 它导致每次这个类[class]的实例[instance]被创建时一个槽[slot]会被创建. 定义一个共享槽[shared slot]会马上创建一个槽[slot].

给 defclass 的这个 :allocation 槽选项控制被定义的槽[slot]的类型. 如果这个 :allocation 槽选项的值是 :instance, 会创建一个局部槽[local slot]. 如果 :allocation 的值是 :class, 就会创建一个共享槽[shared slot].

如果一个槽[slot]是由一个实例[instance]的类[class]定义的, 或者是从该类[class]的超类[superclass]中继承的, 那么就说这个槽[slot]在这个类[class]的实例[instance]中是可访问的[accessible]. 在一个实例[instance]中一个给定的名字[name]最多一个槽[slot]是可访问的[accessible]. 一个类[class]定义的共享槽[shared slot]在这个类[class]的所有实例[instance]中都是可访问的[accessible]. 关于槽的继承的详细解释在章节 7.5.3 (槽和槽选项的继承) 中给出. 

### 7.5.2 <span id="AccessingSlots">访问槽</span>

槽[slot]可以通过两种方式被访问: 通过使用基本函数 slot-value 和通过使用 defclass 表达式形式产生的广义函数[generic function].

函数[function] slot-value 可以通过这个 defclass 表达式形式中任何指定的槽名字来使用, 用于访问[access]给定类[class]的一个实例[instance]中一个可访问的[accessible]特定的槽[slot].

宏 defclass 为生成读取或写入槽[slot]的方法[method]提供语法. 如果请求了一个 reader 方法[method], 会自动生成一个用于读取这个槽[slot]的值的方法[method], 但是不会生成用于存储一个值到这个槽[slot]的方法[method]. 如果请求了一个 writer 方法[method], 会自动生成一个用于存储一个值到这个槽[slot]的方法, 但是不会生成读取它的值的方法[method]. 如果请求了一个 accessor 方法[method], 会自动生成一个用于读取这个槽[slot]的值的方法[method]和一个用于存储一个值到这个槽[slot]的方法[method]. reader 和 writer 方法通过使用 slot-value 来实现.

当为一个槽[slot]指定了 reader 或者 writer 方法[method]时, 所生成的方法[method]所属的广义函数[generic function]的名字是直接指定的. 如果为这个 writer 方法[method]指定的名字[name]是这个符号[symbol] name, 那么用于写入这个槽[slot]的广义函数[generic function]的名字[name]就是 name, 这个广义函数[generic function]接受两个参数: 新的值和这个实例[instance], 以这样的顺序. 如果为 accessor 方法[method]指定的名字[name]是符号 name, 用于读取这个槽[slot]的广义函数[generic function]的名字[name]就是符号 name, 而用于写入这个槽[slot]的广义函数[generic function]的名字[name]就是列表 (setf name).

通过提供 :reader, :writer, 或 :accessor 槽[slot]选项创建或修改的一个广义函数[generic function]可以被当作一个普通的广义函数[generic function].

注意, slot-value 可以被用于读取或写入一个槽[slot]的值, 不管那个槽[slot]的 reader 或 writer 方法[method]是否存在. 当使用 slot-value 时, 没有 reader 或 writer 方法[method]会被调用.

宏 with-slots 可以被用于建立一个词法环境[lexical environment], 在这个环境中指定的槽[slot]就像是变量一样是词法上可用的. 宏 with-slots 调用函数[function] slot-value 来访问[access]特定的槽[slot].

宏 with-accessors 可以被用于建立一个词法环境[lexical environment], 指定的槽[slot]在这个环境中通过它们的访问器是词法上可用的, 就像是变量一样. 宏 with-accessors 调用合适的访问器来访问[access]指定的槽[slot]. 

### 7.5.3 <span id="InheritanceSlotsSlotOptions">槽和槽选项的继承</span>

一个类[class] C 的实例[instance]中所有可访问[accessible]槽[slot]的名字[name]集合是 C 和它的超类[superclass]定义的槽[slot]的名字[name]的并集. 一个实例[instance]的结构是这个实例[instance]中局部槽[local slot]的名字[name]集合.

在最简单的情况下, 在 C 及其超类[superclass]中只有一个类[class]定义了一个带有给定槽[slot]名字的槽[slot]. 如果一个槽[slot]由 C 的一个超类[superclass]定义, 就说这个槽[slot]是继承的. 槽[slot]的特征是由定义类[class]的槽指定符[slot specifier]决定的. 细想一个槽 S 的定义类[class]. 如果这个 :allocation 槽选项的值是 :instance, 那么 S 是一个局部槽[local slot]并且 C 的每一个实例[instance]都有它自己的名为 S 的槽[slot]存储它自己的值. 如果这个 :allocation 槽选项的值是 :class, 那么 S 是一个共享槽[shared slot], 定义 S 的类[class]存储这个值, 并且所有 C 的实例[instance]可以访问[access]那个单独的槽[slot]. 如果这个 :allocation 槽选项被省略, 就使用 :instance.

通常情况下, 在 C 及其超类[superclass]中不止一个类[class]可以定义带有给定名称[name]的槽[slot]. 这样的情况下, 在 C 的一个实例[instance]中对应给定的名字只有一个槽[slot]是可访问的[accessible], 而这个槽[slot]的特性是这几个槽[slot]指定符的一个结合, 按如下计算:

* 对于一个给定的槽[slot]名字的所有槽指定符[slot specifier]按照从最具体到最不具体的顺序排列, 根据定义它们的那些类[class]在 C 的类优先级列表[class precedence list]中的顺序. 下面所有关于槽指定符[slot specifier]的特性的引用都是指这种排序.

* 一个槽[slot]的分配由最具体的槽指定符[slot specifier]来控制. 如果最具体的槽指定符[slot specifier]不包括一个 :allocation 槽选项, 就是用 :instance. 较不具体的槽指定符[slot specifier]不会影响这个分配.

* 一个槽[slot]的默认初始值表达式形式是包含一个 :initform 槽选项的最具体的槽指定符[slot specifier]中该选项的值. 如果没有包含 :initform 槽选项的槽指定符[slot specifier], 这个槽[slot]就没有默认的初始值表达式形式.

* 一个槽[slot]的内容总是为 (and T1 ... Tn) 类型, 其中 T1 ...Tn 是包含在所有槽指定符[slot specifier]中 :type 槽选项的值. 如果没有包含 :type 槽选项的槽指定符[slot specifier], 这个槽[slot]的内容总是为类型[type] t. 尝试去存储一个不满足一个槽[class]的类型[type]的值到这个槽[slot]中, 后果是未定义的.

* 初始化一个给定槽[slot]的初始化参数的集合是声明在所有这些槽指定符[slot specifier]的 :initarg 槽选项中的初始化参数的并集.

* 一个槽[slot]的文档字符串[documentation string]是包含 :documentation 槽[slot]选项的最具体的槽指定符[slot specifier]的该选项的值. 如果没有包含 :documentation 槽选项的槽指定符[slot specifier], 那么该槽没有文档字符串[documentation string].

这个分配规则的一个后果是一个共享槽[shared slot]可以被遮蔽[shadow]. 比如, 如果一个类 C1 定义了一个名为 S 的槽[slot], 其中 :allocation 槽选项的值是 :class, 这个槽[slot]在 C1 的实例[instance]中和所有它的子类[subclass]中都是可访问的[accessible]. 然而, 如果 C2 是 C1 的一个子类[subclass]并且也定义了名为 S 的槽[slot], C1 的槽[slot]不会被 C2 的实例[instance]和子类[sublcass]所共享. 当一个类 C1 定义了一个共享槽[shared slot]时, 任何 C1 的子类 C2 会共享这个单独的槽[slot]除非这个 C2 的 defclass 表达式形式指定了一个相同名字[name]的槽[slot], 或者这里有一个定义了相同名字的槽的 C2 的超类[superclass]并且在 C2 的类优先级列表[class precedence list]中这个超类[superclass]先于 C1.

这个类型规则的一个后果是一个槽[slot]的值满足提供给这个槽的所有槽指定符[slot specifier]的类型约束. 由于尝试存一个不满足这个槽[slot]的类型约束的值到该槽[slot]中的后果是未定义的, 一个槽[slot]中的值可能不满足它的类型约束.

这个 :reader, :writer, 和 :accessor 槽选项创建方法[method]而不是定义一个槽[slot]的属性. 在章节 7.6.7 (方法的继承) 所描述的观念中 reader 和 writer 方法是继承的.

访问[access]槽[slot]的方法[method]只使用这个槽[slot]的名字和槽[slot]的值类型[type]. 假设一个超类[superclass]提供了一个方法[method], 该方法希望访问[access]给定名称[name]的共享槽[shared slot], 并且一个子类[subclass]定义了一个相同名字[name]的局部槽[local slot]. 如果超类[superclass]提供的这个方法[method]在子类[subclass]的实例[instance]上被调用, 那么这个方法[method]会访问[access]这个局部槽[local slot]. 

## 7.6 <span id="GenericFunctionsMethods">广义函数和方法</span>

> * 7.6.1 [广义函数的介绍](#IntroductionGF)
> * 7.6.2 [方法的介绍](#IntroductionMethods)
> * 7.6.3 [关于参数指定符和限定符的一致性](#AgreeParamSpecQualifiers)
> * 7.6.4 [广义函数的所有方法的一致 Lambda-list](#LambdaMethodsGF)
> * 7.6.5 [广义函数和方法中的关键字参数](#KeywordArgGFAndMethods)
> * 7.6.6 [方法选择和组合](#MethodSelComb)
> * 7.6.7 [方法的继承](#InheritanceMethods)

### 7.6.1 <span id="IntroductionGF">广义函数的介绍</span>

一个广义函数[generic function]是一个行为取决于提供给它的实参[argument]的类[class]或恒等性(identity)的函数. 一个广义函数[generic function]对象[object]和一个方法[method]集合, 一个 lambda 列表[lambda list], 一个方法组合[method combination[2]], 还有其他信息相关联.

像一个普通函数[ordinary function]一样, 一个广义函数[generic function]接受实参[argument], 执行一系列动作, 并且可能返回有用的值[value]. 一个普通函数[ordinary function]有着一个在函数被调用时总是被执行的单独的代码[code]主体. 一个广义函数[generic function]有着一个代码[code]主体的集合, 其中一个子集会被选择来执行. 选择的代码[code]主体和它们的组合方式由提供给这个广义函数[generic function]的一个或多个实参[argument]的类[class]或恒等性以及这个广义函数的方法组合决定, .

普通函数[ordinary function]和广义函数[generic function]用相同的语法来调用.

广义函数[generic function]是可以作为传递给 funcall 和 apply 的实参[argument]并且用作第一个实参[argument]的真实函数[function].

函数名[function name]与广义函数[generic function]的绑定[binding]可以通过以下几种方式建立. 它可以通过 ensure-generic-function, defmethod (隐式的, 由于 ensure-generic-function) 或 defgeneric (也是隐式的, 由于 ensure-generic-function) 在全局环境[global environment]中建立. 没有为在词法环境[lexical environment]中建立一个函数名[function name]与广义函数[generic function]的绑定[binding]提供标准化[standardized]机制.

当一个 defgeneric 表达式形式被求值, 采取这三个动作中的其中一个 (由于 ensure-generic-function):

* 如果一个给定名字的广义函数已经存在, 这个存在的广义函数对象会被修改. 当前 defgeneric 表达式形式指定的方法会被添加, 并且在这个已存在的广义函数中由之前的 defgeneric 表达式形式定义的方法会被移除. 通过当前 defgeneric 表达式形式添加的方法可能替换由 defmethod, defclass, define-condition, 或 defstruct 定义的方法. 在这个广义函数中没有其他方法受到影响或替换.

* 如果这个给定的名字命名一个普通函数[ordinary function], 一个宏[macro], 或者一个特殊操作符[special operator], 就会发出一个错误.

* 否则就会使用这个 defgeneric 表达式形式中的方法定义指定的方法来创建一个广义函数.

一些操作符[operator]允许指定一个广义函数[generic function]的选项, 例如它使用的方法组合[method combination]的类型[type]或它的参数优先级顺序[argument precedence order]. 这些操作符[operator]会被称为 "指定广义函数选项的操作符". 这个类别中唯一的标准化[standardized]操作符[operator]是 defgeneric.

一些操作符[operator]为一个广义函数[generic function]定义方法[method]. 这些操作符[operator]会被称作方法定义操作符[method-defining operator]; 它们关联的表达式形式[form]被称作方法定义表达式形式[method-defining form]. 下面这段列出了标准化的[standardized]方法定义操作符[method-defining operator].

    defgeneric        defmethod  defclass  
    define-condition  defstruct            

    Figure 7-1. 标准化的方法定义操作符
    
注意这些标准化[standardized]方法定义操作符[method-defining operator]中只有 defgeneric 可以指定广义函数[generic function]选项. defgeneric 还有任何具体实现定义的可以指定广义函数选项的操作符都被称为 "指定广义函数选项的操作符".

### 7.6.2 <span id="IntroductionMethods">方法的介绍</span>

方法[method]定义了一个广义函数[generic function]的特定于类或者特定于恒等性的行为以及操作.

一个方法[method]对象[object]和实现这个方法的代码[code], 指定这个给定方法[method]何时是可应用的一系列参数特化符[parameter specializer], 一个 lambda 列表[lambda list], 还有被方法组合机制用来区分这些方法[method]的限定符[qualifier]相关联.

一个方法对象不是一个函数并且不能像函数一样被调用. 在这个对象系统中的各种机制接收一个方法对象并调用它的方法函数, 就像这个广义函数被调用时那样. 这个发生时就说这个方法被调用.

一个方法定义表达式形式包含了当这个广义函数的参数导致它定义的方法被调用时要运行的代码[code]. 当一个方法定义表达式形式被求值, 一个方法对象会被创建并且采取这四种动作中的一个:

* 如果一个给定名字的广义函数[generic function]已经存在并且如果一个在参数特化符[parameter specializer]和限定符[qualifier]上都符合新的那个的方法[method]对象[object]已经存在, 那么那个新的方法[method]对象[object]会替换旧的那个. 关于一个方法在参数特化符[parameter specializer]和限定符[qualifier]上与另一个方法一致的定义, 见章节 7.6.3 (关于参数特化符和限定符的一致性).

* 如果一个给定名字的广义函数[generic function]已经存在并且这里没有在参数特化符[parameter specializer]和限定符[qualifier]上都符合新的那个的方法[method]对象[object], 那么那个存在的广义函数[generic function]对象会被修改来包含那个新的方法[method]对象[object].

* 如果给定的名字[name]命名一个普通函数[ordinary function], 一个宏[macro], 或者一个特殊操作符[special operator], 就会发出一个错误.

* 否则就会用那个方法定义表达式形式[method-defining form]指定的方法[method]创建一个广义函数[generic function].

如果一个新的方法[method]的 lambda 列表[lambda list]和广义函数[[generic function]]的 lambda 列表[lambda list]是不相等的, 就会发出一个错误. 如果一个不能指定广义函数[generic function]选项的方法定义操作符[method-defining operator]创建了一个新的广义函数[generic function], 那么这个广义函数[generic function]的 lambda 列表[lambda list]是来自于这个方法定义表达式[method-defining form]中的方法[method]的 lambda 列表[lambda list], 在这种方式下它们是一致的. 关于一致性的讨论, 见章节 7.6.4 (广义函数的所有方法的一致 Lambda-list).

每个方法都有一个特化 lambda 列表[specialized lambda list], 它决定了何时这个方法可以被应用. 一个特化 lambda 列表[specialized lambda list]就像一个普通 lambda 列表[ordinary lambda list]一样, 除了可以出现一个特化参数来代替一个必要参数的名字. 一个参数特化符是一个列表 (variable-name parameter-specializer-name), 其中 parameter-specializer-name 以下的一种:

一个符号[symbol]

    表示一个以该符号[symbol]命名的类[class]的参数特化符[parameter specializer].

一个类[class]

    表示一个参数特化符[parameter specializer]就是类[class]本身.

(eql form)

    表示一个满足类型指定 (eql object) 的参数特化符[parameter specializer], 其中 object 是求值表达式形式 form 的结果. 这个 form 表达式形式在方法定义表达式形式被求值的词法环境中被求值. 注意, 这个 form 只被求值一次, 在方法被定义的时候, 而不是每次广义函数被调用的时候.

参数特化符名字[parameter specializer name]被用于用户级别接口的宏 (defmethod), 而参数特化符[parameter specializer]被用于函数接口中.

只有必要参数可以被特化, 并且这里对于每一个必要参数都必须有一个参数特化符[parameter specializer]. 为了表达的简单性, 如果一个方法定义表达式形式的特化 lambda 列表[specialized lambda list]中的某个必要参数仅仅是一个变量名, 它的参数特化符[parameter specializer]默认是类[class] t.

给定一个广义函数和一个参数集合, 一个可应用的方法是参数特化符满足广义函数的对应的参数的一个方法. 下面的定义指定了什么是可应用的方法, 以及满足参数特化符[parameter specializer]的参数的含义.

让 <A1, ..., An> 依次是给一个广义函数的必要参数. 让 <P1, ..., Pn> 依次是对应方法 M 的必要参数的参数特化符[parameter specializer]. 当每一个 Ai 都是类型指定符[type specifier] Pi 指定的类型[type]时, 方法 M 是可应用的. 由于每个有效参数特化符[parameter specializer]也是一个有效的类型指定符[type specifier], 在方法选择去决定一个参数是否满足一个参数特化符[parameter specializer]时, 可以使用函数[function] typep.

一个所有参数特化符[parameter specializer]都是类[class] t 的方法被称为默认方法[default method]; 它总是可应用的但是可能被一个更具体的方法所遮蔽.

方法可以有限定符[qualifier], 它给方法组合过程提供一种区分方法的方式. 一个带有一个或多个限定符[qualifier]的方法被称为限定方法[qualified method]. 一个没有限定符[qualifier]的方法被称为一个非限定方法[unqualified method]. 一个限定符[qualifier]是任何非列表[non-list]元素. 由标准化[standardized]方法组合类型定义的限定符[qualifier]是符号[symbol].

在这个规范中, 术语 "主方法[primary method]" 和 "辅助方法[auxiliary method]" 在方法组合类型中根据它们的用途被用于区分方法[method]. 在标准方法组合中, 主方法[primary method]是非限定方法[unqualified method]而辅助方法[auxiliary method]是有以下之一的单独限定符[qualifier]的方法: :around, :before, 或 :after. 带有有这些限定符[qualifier]的方法[method]分别被称为 around 方法[around method], before 方法[before method], 还有 after 方法[after method]. 当使用 define-method-combination 短表达式形式定义一个方法组合类型时, 主方法[primary method]是用方法组合的类型的名字来限定的方法, 而辅助方法有着限定符[qualifier] :around. 因此术语 "主方法[primary method]" 和 "辅助方法[auxiliary method]" 只有在给定方法组合类型中有相关定义. 

### 7.6.3 <span id="AgreeParamSpecQualifiers">关于参数特化符和限定符的一致性</span>

如果遵循以下条件, 则两个方法[method]在参数特化符[parameter specializer]和限定符[qualifier]上达成一致:

1. 两个方法有相同数量的必要参数. 假设这两个方法的参数特化符[parameter specializer]为 P1,1...P1,n 和 P2,1...P2,n.

2. 对于每一个 1<=i<=n, P1,i 和 P2,i 一致. 如果 P1,i 和 P2,i 是相同的类或者如果 P1,i=(eql object1), P2,i=(eql object2), 并且 (eql object1 object2), 那么参数特化符[parameter specializer] P1,i 和 P2,i 是一致的. 否则 P1,i 和 P2,i 是不一致的.

3. 两个限定符[qualifier]列表[list]在 equal 下是相同的[same]. 


### 7.6.4 <span id="LambdaMethodsGF">广义函数的所有方法的一致 Lambda-list</span>

这些规则定义了一个 lambda 列表[lambda list]的集合的一致性, 包括对于一个给定广义函数的每个方法[method]的 lambda 列表[lambda list]还有这个广义函数自身指定的 lambda 列表[lambda list], 如果存在的话.

1. 每个 lambda 列表[lambda list]必须有相同数量的必要参数.

2. 每个 lambda 列表[lambda list]必须有着相同数量的可选参数. 每个方法可以为可选参数提供它自己的默认值.

3. 如果任何 lambda 列表[lambda list]提及 &rest 或 &key, 那么每个 lambda 列表[lambda list]必须提及它们或它们的其中之一.

4. 如果广义函数[generic function]的 lambda 列表[lambda list]提及 &key, 每个方法必须接受 &key 后面提及的所有关键字的名字, 不管是通过显式地指定它们, 还是通过指定 &allow-other-keys, 或者通过指定 &rest 而不是 &key. 每个方法可以接收它自己的额外的关键字参数. 关键字名字的有效性检测在这个广义函数中进行, 而不是在每个方法中. 一个方法就像是提供了名字为 :allow-other-keys 而值为 true 的关键字参数对一样被调用, 尽管没有这样的参数对会被传递.

5. &allow-other-keys 的使用在 lambda 列表[lambda list]之间不需要是一致的. 如果 &allow-other-keys 在这个广义函数[generic function]或任何一个可应用方法[method]的 lambda 列表[lambda list]中被提及, 那么在对这个广义函数[generic function]的调用中任何关键字参数都可能被提及.

6. &aux 的使用在方法之间不需要是一致的.

    如果一个不能指定广义函数[generic function]选项的方法定义操作符[method-defining operator]创建了一个广义函数[generic function], 并且这个方法的 lambda 列表[lambda list]提及关键字参数, 那么这个广义函数的 lambda 列表[lambda list]会提及 &key (但是没有关键字参数).


### 7.6.5 <span id="KeywordArgGFAndMethods">广义函数和方法中的关键字参数</span>

当一个广义函数或者它的任何一个方法在一个 lambda 列表[lambda list]中提及 &key, 广义函数接受的关键字参数的具体集合根据所应用的方法而变化. 对于一个特定的调用, 被这个广义函数所接收的关键字参数的集合是所有可应用方法的关键字参数以及这个广义函数定义中 &key 后面提及的关键字参数的并集, 如果这个广义函数定义中的 &key 后提及关键字参数, 那么还包括这些关键字参数. 一个有着 &rest 但没有 &key 的方法不会影响可接受参数的集合. 如果任何可应用[lambda list]方法或广义函数定义的 lambda 列表中包含 &allow-other-keys, 所有关键字都可以被这个广义函数所接受.

这个 lambda 列表[lambda list]一致性规则要求每一个方法接受所有在广义函数定义中 &key 参数后提及的所有关键字参数, 通过显式地接收它们, 通过指定 &allow-other-keys, 通过指定 &rest 但不是 &key. 除了广义函数定义中提到的关键字参数之外, 每一个方法可以接受它自身的额外的关键字参数.

如果传递给一个广义函数[generic function]一个没有可应用方法接收的关键字参数, 应该会发出一个错误; 见章节 3.5 (函数调用中的错误检测).

#### 7.6.5.1 广义函数和方法的关键字参数示例

比如, 假设这里为 width 定义两个方法, 如下:

```LISP
(defmethod width ((c character-class) &key font) ...)

(defmethod width ((p picture-class) &key pixel-size) ...)
```

假设这里没有 width 的其他方法并且没有 width 广义函数. 以下表达式形式的求值应该会发出一个错误, 由于这个关键字参数 :pixel-size 不能被这个可应用的方法所接受.

```LISP
(width (make-instance `character-class :char #\Q) 
      :font 'baskerville :pixel-size 10)
```

以下表达式形式的求值应该发出一个错误.

```LISP
 (width (make-instance `picture-class :glyph (glyph #\Q)) 
        :font 'baskerville :pixel-size 10)
```

如果名为 character-picture-class 的类同时是 picture-class 和 character-class 的子类, 那么以下表达式形式的求值不会发出一个错误.

```LISP
(width (make-instance `character-picture-class :char #\Q)
      :font 'baskerville :pixel-size 10)
```

### 7.6.6 <span id="MethodSelComb">方法选择和组合</span>

当用特定的参数调用一个广义函数[generic function]时, 它必须决定要执行的代码. 这个代码被称为这些实参[argument]的有效方法[effective method]. 有效方法[effective method]是一个广义函数[generic function]中可应用方法[applicable method]的组合, 它调用[call]这些方法[method]的一部分或全部.

如果一个广义函数[generic function]被调用而没有可应用的方法[applicable method], 那么广义函数[generic function] no-applicable-method 会被调用, 这个调用的结果被用作对原始广义函数[generic function]调用的结果. 调用 no-applicable-method 优先于检测可接受的关键字参数; 见章节 7.6.5 (广义函数和方法中的关键字参数).

当这个有效方法[effective method]已经被决定时, 会用传递给这个广义函数[generic function]相同的实参[argument]去调用它. 不管它返回什么值[value]都会作为这个广义函数[generic function]的值[value]被返回.

> * 7.6.6.1 [确定有效方法](#DetermEffectMethod)
> * 7.6.6.2 [标准方法组合](#StandMethodComb)
> * 7.6.6.3 [声明方法组合](#DeclaraMethodComb)
> * 7.6.6.4 [内建的方法组合类型](#BuiltInMethodCombTypes)

#### 7.6.6.1 <span id="DetermEffectMethod">确定有效方法</span>

有效方法通过以下三个步骤来决定:

1. 选择可应用的方法.

2. 通过优先级顺序对可应用方法排序, 把最具体的方法放在第一位.

3. 对排序后的可应用方法列表应用方法组合, 产生有效方法.

##### 7.6.6.1.1 选择可应用的方法

这个步骤在章节 7.6.2 (方法的介绍) 中描述. 

##### 7.6.6.1.2 通过优先级顺序对可应用方法排序

为了比较两个方法的优先级, 它们的参数特化符[parameter specializer]会被按顺序检查. 默认的检查顺序是从左到右, 但是可以通过对 defgeneric 或任何指定广义函数选项的其他操作符指定 :argument-precedence-order 选项来指定一个替代的顺序.

每一个方法的对应参数特化符[parameter specializer]都会被比较. 当一对参数特化符[parameter specializer]一致时, 比较下一对的一致性. 如果所有对应的参数指定符都一致, 那么两个方法必须有不同的限定符[qualifier]; 在这个情况下, 任何一个方法都可以优先于另一个. 关于一致性的更多信息, 见章节 7.6.3 (关于参数特化符和限定符的一致性).

如果某些参数特化符[parameter specializer]不一致, 第一对不一致的参数特化符[parameter specializer]决定了这个优先级. 如果两个参数特化符[parameter specializer]都是类, 那么两个方法中更具体的是参数特化符[parameter specializer]在这个对应参数的类优先级列表[class precedence list]中出现的更早的那个方法. 由于可应用方法被选择的这个方式, 参数特化符[parameter specializer]保证存在于那个参数的类的类优先列表中.

如果一对对应参数特化符[parameter specializer]中只有一个是 (eql object), 那么带有这个参数特化符[parameter specializer]的方法[method]优先于另一个方法[method]. 如果两个参数特化符[parameter specializer]都是 eql 表达式[expression], 那么这些特化符一定是一致的 (否则对于这个参数这两个方法[method]不会都是可应用的).

产生的可应用方法[applicable method]列表中最具体的方法[method]在第一个, 最不具体的在最后一个. 

##### 7.6.6.1.3 对排序后的可应用方法应用方法组合

在这个简单的例子中---如果使用了标准方法组合并且所有可应用的方法都是主方法---这个有效方法就是最具体的方法. 这个方法可以通过函数[function] call-next-method 调用下一个最具体的方法. 这个 call-next-method 会调用的方法被称为下一个方法[next method]. 断言 next-method-p 检测是否存在下一个方法. 如果 call-next-method 被调用并且没有下一个最具体的方法, 那么广义函数 no-next-method 会被调用.

通常, 有效方法是那些可应用方法的某个组合. 它由一个表达式形式[form]来描述, 这个表达式形式包含对某些或全部可应用方法的调用, 返回值或多值来作为广义函数返回的值或多值, 并可选地使一些方法可以通过 call-next-method 访问.

在这个有效方法中的每一个方法的角色由它的限定符[qualifier]和方法的特性所决定. 一个限定符[qualifier]用于标记一个方法, 而限定符[qualifier]的含义由这个过程的这一步使用这些标记的方式决定. 如果一个可应用方法有一个不识别的限定符[qualifier], 这个步骤会发出一个错误并且不会在有效方法中包含那个方法.

当标准方法组合和受限定方法一起使用时, 就像章节 7.6.6.2 (标准方法组合) 中所描述的那样来产生有效方法.

另一个方法组合类型可以通过使用 defgenric 或者任何其他指定广义函数选项的操作符的 :method-combination 选项来指定. 在这个情况下, 这个过程的这个步骤可以被定制.

新的方法组合类型可以通过使用 define-method-combination 宏[macro]来定义. 

#### 7.6.6.2 <span id="StandMethodComb">标准方法组合</span>

标准方法组合由类[class] standard-generic-function 支持. 如果没有指定其他类型的方法组合或者指定了内置的方法组合类型 standard, 那么这个标准方法组合就会被使用.

主方法定义了这个有效方法的主要动作, 而辅助方法(auxiliary method)以三种方式之一修改那个动作. 一个主方法没有方法限定符[qualifier].

一个辅助方法是限定符[qualifier]为 :before, :after, 或 :around 的一个方法. 标准方法组合不允许每个方法有超过一个限定符[qualifier]; 如果一个方法定义中指定了每个方法有超过一个限定符[qualifier], 就会发出一个错误.

* 一个 before 方法[before method]有着关键字 :before 作为它仅有限定符[qualifier]. 一个 before 方法[before method]指定在任何主方法[primary method]之前执行的代码[code].

* 一个 after 方法[after method]有着关键字 :after 作为它仅有限定符[qualifier]. 一个 after 方法[after method]指定在主方法[primary method]后面运行的代码[code].

* 一个 around 方法[around method]有着关键字 :around 作为它仅有限定符[qualifier]. 一个 around 方法指定了要被运行的代码[code]来替换替代其他可应用方法[applicable method], 但是它可能包含显式的调用某些被遮蔽的方法[method]的代码[code] (通过 call-next-method).

标准方法组合的语义如下:

* 如果这里有任何 around 方法[around method], 最具体的 around 方法[around method]会被调用. 它提供这个广义函数的值或多值.

* 在一个 around 方法[around method]的主体内, call-next-method 可以被用于调用下一个方法[next method]. 当下一个方法返回时, 这个 around 方法[around method]可以执行更多的代码, 可能基于返回的值和多值. 如果调用了 call-next-method 并且这里没有可应用的方法[applicable method]被调用, 那么广义函数[generic function] no-next-method 会被调用. 函数[function] next-method-p 可能被用于确定是否存在下一个方法[next method].

* 如果一个 around 方法[around method]调用了 call-next-method, 下一个最具体的 around 方法[around method]会被调用, 如果存在一个可应用的话. 如果这里没有 around 方法[around method]或者如果 call-next-method 被最不具体的 around 方法[around method]所调用, 其他方法会按如下所述被调用:

    -- 所有的 before 方法[before method]会被调用, 以最具体优先的顺序. 它们的返回值会被忽略. 如果在一个 before 方法[before method]中使用 call-next-method 那么就会发出一个错误.

    -- 最具体的主方法会被调用. 在一个主方法的主体内, call-next-method 可以被用于调用下一个最具体的主方法. 当那个方法返回时, 前一个主要方法可能基于返回的值或多值来执行更多代码. 如果使用了 call-next-method 并且这里没有更多可应用的主方法, 那么广义函数 no-next-method 会被调用. 函数[function] next-method-p 可能被用于确定是否存在下一个方法[next method]. 如果 call-next-method 没有被使用, 只有最具体的主方法[primary method]会被调用.

    -- 所有的 after 方法[after method]按最不具体优先的顺序被调用. 它们的值会被忽略. 如果在一个 after 方法[after method]中使用 call-next-method, 那么会发出一个错误.

* 如果没有 around 方法[around method]被调用, 最具体的主方法提供这个广义函数返回的值或多值. 在最不具体的 around 方法[around method]中调用 call-next-method 返回的值或多值是最具体的主方法返回的那些.

在标准方法组合中, 如果这里有一个可应用的方法但是没有可应用的主方法, 会发出一个错误.

这个 before 方法[before]按最具体优先的顺序被运行而 after 方法[after method]则按最不具体优先的顺序被运行. 这个区别的设计原理可以用一个例子来说明. 假设类 C1 通过添加 before 方法[before method]和 after 方法[after method]修改了它的超类 C2 的行为. 不管这个类 C2 的行为是通过 C2 的方法直接定义或是从它的超类中继承而来, 都不会影响在类 C1 的实例上调用方法的相关顺序. 类 C1 的 before 方法[before method]在类 C2 的所有方法之前运行. 类 C1 的 after 方法[after method]在类 C2 的所有方法之后运行.

相比之下, 所有 around 方法[around method]在任何其他方法运行前运行. 因此一个较不具体的 around 方法[around method]在一个较具体的主方法之前运行.

如果只使用了主方法而没有使用 call-next-method, 那么只有最具体的方法会被调用; 这也就是说, 较为具体的方法遮蔽更一般的方法. 

#### 7.6.6.3 <span id="DeclaraMethodComb">声明方法组合</span>

宏 define-method-combination 定义方法组合的新形式. 它为定制有效方法的产生提供了一个机制. 对于产生一个有效方法的默认过程在章节 7.6.6.1 (确定有效方法) 中已描述. 这里有两个 define-method-combination 表达式形式. 短表达式形式是一个简单的工具而长表达式形式则更加强大和详细. 长表达式形式类似于 defmacro, 在它的主体中是一个计算一个 Lisp 表达式形式的表达式; 它为在方法组合中实现任意控制结构和方法限定符[qualifier]的任意处理提供一个机制. 

#### 7.6.6.4 <span id="BuiltInMethodCombTypes">内建的方法组合类型</span>

这个对象系统提供了一个内建的方法组合类型集合. 为了指定一个广义函数去使用这些方法组合类型之一, 那个方法组合类型的名字会作为传递给 defgeneric 的 :method-combination 选项或传递给任何指定广义函数选项的其他操作符的 :method-combination 选项的参数来给定.

内建的方法组合类型的名字列在下面这一段.

    +    append  max  nconc  progn     
    and  list    min  or     standard  

    Figure 7-2. 内建的方法组合类型

内建的 standard 方法组合类型的语义描述在章节 7.6.6.2 (标准方法组合). 其他内置的方法组合类型称为简单内建的方法组合类型.

简单内建方法组合类型表现得就像它们是通过 define-method-combination 的短表达式形式定义出来的. 它们识别方法[method]的两种角色:

* 一个 around 方法[around method]有着关键字符号 :around 作为它唯一限定符[qualifier]. 这个 :around 方法[method]的意义和标准方法组合中一样. around 方法[around method]中支持使用函数 call-next-method 和 next-method-p.

* 一个主方法有着方法组合类型的名字作为它唯一限定符[qualifier]. 比如, 内建的方法组合类型 and 识别单一限定符[qualifier]为 and 的方法; 这些是主方法. 在主方法[primary method]中不支持使用函数 call-next-method 和 next-method-p.

简单内建方法组合类型的语义如下:

* 如果这里有任何 around 方法[around method], 最具体的 around 方法[around method]会被调用. 它提供了这个广义函数[generic function]的值或多值.

* 在一个 around 方法[around method]的主体内, 函数 call-next-method 可以被用于调用下一个方法[next method]. 如果 call-next-method 被调用而这里没有可应用的方法被调用, 那么就会调用广义函数[generic function] no-next-method. 函数[function] next-method-p 可能被用于确定是否存在下一个方法[next method]. 当下一个方法[next method]返回时, 这个 around 方法[around method]可以执行更多代码, 或许基于那些返回的值或多值.

* 如果一个 around 方法[around method]调用了 call-next-method, 下一个最具体的 around 方法[around method]被调用, 如果存在一个可应用的话. 如果这里没有 around 方法[around method]或者 call-next-method 被最不具体的 around 方法[around method]调用, 从内建方法组合类型的名称和可应用的主方法列表中衍生出的 Lisp 表达式形式被求值来产生这个广义函数的值. 假设这个方法组合类型的名字是 operator 并且对广义函数的调用是

    (generic-function a1...an)

让 M1,...,Mk 依次是可应用的主方法; 那么衍生的 Lisp 表达式形式是

    (operator <M1 a1...an>...<Mk a1...an>)

如果表达式形式 <Mi a1...an> 被求值, 方法 Mi 会被应用给参数 a1...an. 比如, 如果 operator 是 or, 那么表达式形式 <Mi a1...an> 当且仅当 <Mj a1...an>, 1<=j<\i 返回 nil 时被求值.

主方法的默认顺序是 :most-specific-first. 然而, 这个顺序可以通过提供 :most-specific-last 作为 :method-combination 选项的第二个参数来倒转.

简单内建方法组合类型要求一个方法一个限定符[qualifier]. 如果这里存在没有限定符[qualifier]或者这个方法组合类型不支持的限定符[qualifier]的可应用方法, 那么就会发出一个错误. 如果这里有可应用的 around 方法[around method]并且没有可应用的主方法, 那么也会发出一个错误. 

### 7.6.7 <span id="InheritanceMethods">方法的继承</span>

一个子类继承方法的意义在于任何适用于一个类的所有实例的方法也适用于该类的任何子类的所有实例.

不管那个方法定义操作符[method-defining operator]创建了这个方法, 方法的继承还是表现一样.

方法的继承在章节 7.6.6 (方法选择和组合) 中详细描述. 

## 7.7 <span id="TheObjectsDictionary">对象字典</span>

> *  [标准广义函数 FUNCTION-KEYWORDS](#SGF-FUNCTION-KEYWORDS)
> *  [函数 ENSURE-GENERIC-FUNCTION](#F-ENSURE-GENERIC-FUNCTION)
> *  [标准广义函数 ALLOCATE-INSTANCE](#SGF-ALLOCATE-INSTANCE)
> *  [标准广义函数 REINITIALIZE-INSTANCE](#SGF-REINITIALIZE-INSTANCE)
> *  [标准广义函数 SHARED-INITIALIZE](#SGF-SHARED-INITIALIZE)
> *  [标准广义函数 UPDATE-INSTANCE-FOR-DIFFERENT-CLASS](#SGF-U-I-F-D-C)
> *  [标准广义函数 UPDATE-INSTANCE-FOR-REDEFINED-CLASS](#SGF-U-I-F-R-C)
> *  [标准广义函数 CHANGE-CLASS](#SGF-CHANGE-CLASS)
> *  [函数 SLOT-BOUNDP](#F-SLOT-BOUNDP)
> *  [函数 SLOT-EXISTS-P](#F-SLOT-EXISTS-P)
> *  [函数 SLOT-MAKUNBOUND](#F-SLOT-MAKUNBOUND)
> *  [标准广义函数 SLOT-MISSING](#SGF-SLOT-MISSING)
> *  [标准广义函数 SLOT-UNBOUND](#SGF-SLOT-UNBOUND)
> *  [函数 SLOT-VALUE](#F-SLOT-VALUE)
> *  [标准广义函数 METHOD-QUALIFIERS](#SGF-METHOD-QUALIFIERS)
> *  [标准广义函数 NO-APPLICABLE-METHOD](#SGF-NO-APPLICABLE-METHOD)
> *  [标准广义函数 NO-NEXT-METHOD](#SGF-NO-NEXT-METHOD)
> *  [标准广义函数 REMOVE-METHOD](#SGF-REMOVE-METHOD)
> *  [标准广义函数 MAKE-INSTANCE](#SGF-MAKE-INSTANCE)
> *  [标准广义函数 MAKE-INSTANCES-OBSOLETE](#SGF-MAKE-INSTANCES-OBSOLETE)
> *  [标准广义函数 MAKE-LOAD-FORM](#SGF-MAKE-LOAD-FORM)
> *  [函数 MAKE-LOAD-FORM-SAVING-SLOTS](#F-MAKE-LOAD-FORM-SAVING-SLOTS)
> *  [宏 WITH-ACCESSORS](#M-WITH-ACCESSORS)
> *  [宏 WITH-SLOTS](#M-WITH-SLOTS)
> *  [宏 DEFCLASS](#M-DEFCLASS)
> *  [宏 DEFGENERIC](#M-DEFGENERIC)
> *  [宏 DEFMETHOD](#M-DEFMETHOD)
> *  [访问器 FIND-CLASS](#A-FIND-CLASS)
> *  [局部函数 NEXT-METHOD-P](#LF-NEXT-METHOD-P)
> *  [局部宏 CALL-METHOD, MAKE-METHOD](#LM-CALL-METHOD-MAKE-METHOD)
> *  [局部函数 CALL-NEXT-METHOD](#LF-CALL-NEXT-METHOD)
> *  [标准广义函数 COMPUTE-APPLICABLE-METHODS](#SGF-COMPUTE-APPLICABLE-METHODS)
> *  [宏 DEFINE-METHOD-COMBINATION](#M-DEFINE-METHOD-COMBINATION)
> *  [标准广义函数 FIND-METHOD](#SGF-FIND-METHOD)
> *  [标准广义函数 ADD-METHOD](#SGF-ADD-METHOD)
> *  [标准广义函数 INITIALIZE-INSTANCE](#SGF-INITIALIZE-INSTANCE)
> *  [标准广义函数 CLASS-NAME](#SGF-CLASS-NAME)
> *  [标准广义函数 (SETF CLASS-NAME)](#SGF-SETF-CLASS-NAME)
> *  [函数 CLASS-OF](#F-CLASS-OF)
> *  [状况类型 UNBOUND-SLOT](#CT-UNBOUND-SLOT)
> *  [函数 UNBOUND-SLOT-INSTANCE](#F-UNBOUND-SLOT-INSTANCE)


### <span id="SGF-FUNCTION-KEYWORDS">标准广义函数 FUNCTION-KEYWORDS</span>

* 语法(Syntax):

        function-keywords method => keys, allow-other-keys-p

* 方法签名(Method Signatures):

        function-keywords (method standard-method)

* 参数和值(Arguments and Values):

        method---一个方法[method].
        keys---一个列表[list].
        allow-other-keys-p---一个广义 boolean [generalized boolean].

* 描述(Description):

        返回一个方法 method 的关键字参数指定符.

        返回两个值: 一个显式命名的关键字列表[list]和一个表示 &allow-other-keys 在这个方法 method 定义中是否被指定的广义的 boolean [generalized boolean].

* 示例(Examples):

    ```LISP
    (defmethod gf1 ((a integer) &optional (b 2)
                    &key (c 3) ((:dee d) 4) e ((eff f)))
      (list a b c d e f))
    =>  #<STANDARD-METHOD GF1 (INTEGER) 36324653>
    (find-method #'gf1 '() (list (find-class 'integer))) 
    =>  #<STANDARD-METHOD GF1 (INTEGER) 36324653>
    (function-keywords *)
    =>  (:C :DEE :E EFF), false
    (defmethod gf2 ((a integer))
      (list a b c d e f))
    =>  #<STANDARD-METHOD GF2 (INTEGER) 42701775>
    (function-keywords (find-method #'gf1 '() (list (find-class 'integer))))
    =>  (), false
    (defmethod gf3 ((a integer) &key b c d &allow-other-keys)
      (list a b c d e f))
    (function-keywords *)
    =>  (:B :C :D), true
    ```

* 受此影响(Affected By):

        defmethod

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        defmethod

* 注意(Notes): None. 


### <span id="">函数 ENSURE-GENERIC-FUNCTION</span>

* 语法(Syntax):

        ensure-generic-function function-name &key argument-precedence-order declare documentation environment generic-function-class lambda-list method-class method-combination

        => generic-function

* 参数和值(Arguments and Values):

        function-name---一个函数名字[function].
        这些关键字参数对应 defgeneric 的选项 option 参数, 除了 :method-class 和 :generic-function-class 参数可以是类[class]对象[object]和名字.
        method-combination -- 方法组合对象.
        environment -- 与宏展开函数的 &environment 参数相同, 用于区分编译时和运行时环境.
        generic-function---一个广义函数[generic function]对象[object].

* 描述(Description):

        函数[function] ensure-generic-function 被用于定义一个全局命名的没有方法[method]的广义函数[generic function]或者作为整体去指定或修改属于一个全局命名广义函数[generic function]的选项和声明.

        如果 function-name 没有在全局环境[global environment]中被 fbound, 一个新的广义函数[generic function]会被创建. 如果 (fdefinition function-name) 是一个普通函数[ordinary function], 一个宏[macro], 或者一个特殊操作符[special operator], 就会发出一个错误.

        如果 function-name 是一个列表[list], 它必须是 (setf symbol) 形式. 如果 function-name 指定一个对于任何下面参数都有一个不同的值的广义函数[generic function], 那么这个广义函数[generic function]被修改为有这个新值: :argument-precedence-order, :declare, :documentation, :method-combination.

        如果 function-name 指定一个对于 :lambda-list 参数有一个不同的值的广义函数[generic function], 并且这个新的值和所有已存在的方法[method]的 lambda 列表[lambda list]是相等的或者这里没有对应方法[method], 那么这个值就会被修改; 否则就会发出一个错误.

        如果 function-name 指定一个对于 :generic-function-class 参数有一个不同的值的广义函数[generic function]并且如果这个新的广义函数类和旧的兼容, 那么 change-class 会被调用来修改这个广义函数[generic function]的类[class]; 否则就会发出一个错误.

        如果 function-name 指定一个有着不同的 :method-class 参数的值的广义函数[generic function], 那么这个值会被修改, 但是任何存在的方法[method]不会改变.

* 示例(Examples): None.

* 受此影响(Affected By):

        function-name 的函数绑定的存在.

* 异常情况(Exceptional Situations):

        如果 (fdefinition function-name) 是一个普通函数[ordinary function], 一个宏[macro], 或者一个特殊操作符[special operator], 会发出一个 error 类型[type]的错误.

        如果 function-name 指定了一个对于 :lambda-list 参数有一个不同的值的广义函数[generic function], 并且这个新的值和任何一个已存在方法[method]的 lambda 列表[lambda list]不相同, 会发出一个 error 类型[type]的错误.

        如果 function-name 指定了一个对于 :generic-function-class 参数有一个不同的值的广义函数[generic function]并且如果这个新的广义函数类和旧的不兼容, 会发出一个 error 类型[type]的错误.

* 参见(See Also):

        defgeneric

* 注意(Notes): None. 


### <span id="SGF-ALLOCATE-INSTANCE">标准广义函数 ALLOCATE-INSTANCE</span>

* 语法(Syntax):

        allocate-instance class &rest initargs &key &allow-other-keys => new-instance

* 方法签名(Method Signatures):

        allocate-instance (class standard-class) &rest initargs
        allocate-instance (class structure-class) &rest initargs

* 参数和值(Arguments and Values):

        class---一个类[class].
        initargs---一个关键字/值对[keyword/value pair] (初始化参数的名字[name]和值[value]) 的列表[list].
        new-instance---类[class] class 的一个对象[object].

* 描述(Description):

        广义函数 allocate-instance 创建并返回一个类 class 的新的实例, 但是没有把它初始化. 当这个类 class 是一个标准类[standard class]时, 这就意味着这些槽[slot]是未绑定的[unbound]; 当这个类 class 是一个结构体类[structure class]时, 这就意味着这些槽[slot]的值[value]是没有被指定的.

        期望 allocate-instance 的调用者已经检查了初始化参数.

        广义函数[generic function] allocate-instance 被 make-instance 所调用, 像章节 7.1 (对象创建和初始化) 中描述的那样.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        defclass, make-instance, class-of, 章节 7.1 (对象创建和初始化)

* 注意(Notes):

        给 allocate-instance 添加方法[method]的后果是没有指定的. 这个功能可能被元对象协议[Metaobject Protocol]添加进来. 


### <span id="SGF-REINITIALIZE-INSTANCE">标准广义函数 REINITIALIZE-INSTANCE</span>

* 语法(Syntax):

        reinitialize-instance instance &rest initargs &key &allow-other-keys => instance

* 方法签名(Method Signatures):

        reinitialize-instance (instance standard-object) &rest initargs

* 参数和值(Arguments and Values):

        instance---一个对象[object].
        initargs---一个初始化参数列表[initialization argument list].

* 描述(Description):

        广义函数[generic function] reinitialize-instance 可以被用于根据初始化参数 initargs 来修改一个实例 instance 的局部槽[local slot]的值. 这个广义函数[generic function]可以被用户调用.

        系统提供的 reinitialize-instance 主方法[method]检查初始化参数 initargs 的有效性, 如果提供的 initargs 没有被有效声明, 就会发出一个错误. 这个方法[method]接下来用以下参数来调用广义函数 shared-initialize: 这个实例 instance, nil (这个意味着根据槽的初始化表达式形式没有槽[slot]应该被初始化), 还有它收到的 initargs.

* 示例(Examples): None.

* 副作用(Side Effects):

        广义函数[generic function] reinitialize-instance 修改局部槽[local slot]的值.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果提供的一个 initarg 没有被有效声明, 系统提供的 reinitialize-instance 主方法[method]会发出一个错误.

* 参见(See Also):

        initialize-instance, shared-initialize, update-instance-for-redefined-class, update-instance-for-different-class, slot-boundp, slot-makunbound, 章节 7.3 (重新初始化一个实例), 章节 7.1.4 (初始化参数的规则), 章节 7.1.2 (声明初始化参数的有效性)

* 注意(Notes):

        这些初始化参数 initargs 通过使用给 defclass 的 :initarg 选项, 或者通过定义 reinitialize-instance 或 shared-initialize 方法[method]来声明为有效的. 任何定义在 reinitialize-instance 或 shared-initialize 方法[method]的 lambda 列表[lambda list]中的每个关键字参数指定符的关键字名字对于那个方法[method]可应用的所有类[class]都被声明为有效的初始化参数.


### <span id="SGF-SHARED-INITIALIZE">标准广义函数 SHARED-INITIALIZE</span>

* 语法(Syntax):

        shared-initialize instance slot-names &rest initargs &key &allow-other-keys => instance

* 方法签名(Method Signatures):

        shared-initialize (instance standard-object) slot-names &rest initargs

* 参数和值(Arguments and Values):

        instance---一个对象[object].
        slot-names---一个列表[list]或者 t.
        initargs---一个关键字/值对[keyword/value pair]的列表[list] (其中是初始化参数的名字[name]和值[value]).

* 描述(Description):

        广义函数 shared-initialize 使用初始化参数 initargs 和 :initform 来填充一个实例 instance 的槽[slot]. 当一个实例被创建时, 当一个实例被重新初始化时, 当一个实例被更新去符合一个重定义的类[class]时,  还有当一个实例被更新来符合一个不同的类[class]时, 它会被调用. 广义函数 shared-initialize 被系统提供的 initialize-instance, reinitialize-instance, update-instance-for-redefined-class, 和 update-instance-for-different-class 的主方法[method]调用.

        广义函数 shared-initialize 接受以下参数: 要被初始化的实例 instance, 这个实例 instance 中可访问的[accessible]槽名字 slot-names 集合的一个说明, 还有任意数量的初始化参数 initargs. 在前两个后面的那些参数必须组成一个初始化参数列表[initialization argument list]. 系统提供的 shared-initialize 主方法[method]根据 initargs 和提供的 :initform 表达式形式用值初始化这些槽[slot]. 这些槽名字 slot-names 表示要被初始化的槽[slot], 如果没有为这些槽[slot]提供 initargs , 这些槽就根据它们的 :initform 表达式形式来初始化.

        系统提供的主方法[method]表现如下, 不管这个槽[slot]是局部的还是共享的:

            * 如果在初始化参数列表[initialization argument list]中的一个 initarg 为这个槽[slot]指定了一个值, 这个值会存储到这个槽[slot]中, 即便在这个方法[method]被运行之前已经存储一个值到这个槽[slot]中.

             * 任何由 slot-names 指定的槽[slot]在根据它们的 :initform 表达式形式来初始化时仍然是未绑定的. 对于任何有着一个 :initform 表达式形式的槽[slot], 这个表达式形式[form]都会在它的定义 defclass 表达式形式[form]的词法环境中被求值并且结果被存储到这个槽[slot]中. 比如, 如果一个 before 方法[before method]存储一个值到这个槽[slot]中, 那么这个 :initform 表达式形式不会为这个槽[slot]提供一个值.

            * 在章节 7.1.4 (初始化参数的规则) 中提及的规则也是遵守的.

        这些 slots-names 参数指定了要被初始化的槽[slot], 如果没有提供初始化参数时就根据它们的 :initform 表达式形式来初始化. 它可以是一个槽名字[name]的列表[list], 其中指定了这些槽名字[name]的集合; 或者它可以是符号[symbol] t, 表示所有槽[slot]的集合.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        initialize-instance, reinitialize-instance, update-instance-for-redefined-class, update-instance-for-different-class, slot-boundp, slot-makunbound, 章节 7.1 (对象创建和初始化), 章节 7.1.4 (初始化参数的规则), 章节 7.1.2 (声明初始化参数的有效性)

* 注意(Notes):

        可以通过对 defclass 使用 :initarg 选项或者定义 shared-initialize 的方法[method]来有效声明初始化参数 initargs. 任何定义在 shared-initialize 上的方法[method]的 lambda 列表[lambda list]中的关键字参数指定符的关键字名字对于所有这个方法[method]可应用的类[class]而言都是有效的 initarg.

        具体实现允许去优化既不产生副作用也不依赖副作用的 :initform 表达式形式: 通过对这些表达式形式[form]进行求值, 并在运行任何 initialize-instance 方法之前将它们存储到槽中, 而不是在 initialize-instance 主方法中处理它们. (这种优化可以通过使用 allocate-instance 方法复制原型实例来实现.)

        当仅有的接受完整的列表[list]的方法[method]是 standard-object 上的方法[method]时, 具体实现允许去通过没有实际创建完整初始化参数列表来优化和槽关联的默认初始化参数 initargs 的默认初始化值表达式. 在这个情况下默认初始值表达式形式可以被当作 :initform 表达式形式对待. 除了性能改进之外, 这种优化没有可见的效果. 

### <span id="SGF-U-I-F-D-C">标准广义函数 UPDATE-INSTANCE-FOR-DIFFERENT-CLASS</span>

* 语法(Syntax):

        update-instance-for-different-class previous current &rest initargs &key &allow-other-keys => 依赖于具体实现[implementation-dependent]

* 方法签名(Method Signatures):

        update-instance-for-different-class (previous standard-object) (current standard-object) &rest initargs

* 参数和值(Arguments and Values):

        previous---一个原始实例[instance]的拷贝.
        current---原始实例[instance] (修改后的).
        initargs---一个初始化参数列表[initialization argument list].

* 描述(Description):

        广义函数 update-instance-for-different-class 不旨在被程序员调用. 程序员可能为它编写写方法[method]. 函数[function] update-instance-for-different-class 只有通过函数[function] change-class 被调用.

        系统提供的 update-instance-for-different-class 主方法[method]会检查初始化参数 initargs 的有效性, 如果提供的一个 initarg 没有被有效声明就会发出一个错误. 接下来这个方法[method]会根据 initargs 的值来初始化槽[slot], 并且根据新添加的槽[slot]的 :initform 表达式形式来初始化它们. 它通过使用以下参数调用广义函数 shared-initialize 来完成这个: 这个实例 (current), 一个新添加槽[slot]的名字[name]的列表, 还有它接受到的初始化参数 initargs. 新添加的槽[slot]是那些在之前的 previous 的类中不存在相同名字的槽[slot]的局部槽[local slot].

        update-instance-for-different-class 方法[method]可以被定义来指定当一个实例[instance]被更新时要采取的动作. 如果只有 update-instance-for-different-class 的 after 方法[after method]被定义, 它们会在系统提供的初始化主方法[method]之后被运行, 因此不会影响 update-instance-for-different-class 的默认行为.

        update-instance-for-different-class 的方法[method]可以被定义用不同于 change-class 的方式来初始化槽[slot]. 这个 change-class 的默认行为在章节 7.2 (修改一个实例的类) 中描述.

        给 update-instance-for-different-class 的参数通过 change-class 计算. 当 change-class 在一个实例[instance]上被调用, 会创建那个实例[instance]的一个拷贝; change-class 接下来会破坏性地修改原始的实例[instance]. 给 update-instance-for-different-class 的第一个参数, previous, 就是那个拷贝; 它临时持有旧的槽[slot]的值. 这个参数有着 change-class 内的动态范围; 如果一旦 update-instance-for-different-class 返回后它被引用, 结果是未定义的. 给 update-instance-for-different-class 的第二个参数, current, 是修改后的原始实例[instance]. 这个 previous 的使用意图是通过使用 slot-value 或 with-slots 或通过调用一个 reader 广义函数来提取旧槽[slot]值, 或者用来运行可应用于原始类[class]的实例[instance]的其他方法[method].

* 示例(Examples):

        见函数[function] change-class 的示例.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果一个提供的初始化参数没有被有效声明, 那么系统提供的 update-instance-for-different-class 主方法[method]就会发出一个错误.

* 参见(See Also):

        change-class, shared-initialize, 章节 7.2 (修改一个实例的类), 章节 7.1.4 (初始化参数的规则), 章节 7.1.2 (声明初始化参数的有效性)

* 注意(Notes):

        这些初始化参数 initargs 通过使用给 defclass 的 :initarg 选项或者通过定义 update-instance-for-different-class 或 shared-initialize 的方法[method]来合法声明. 定义在 update-instance-for-different-class 或 shared-initialize 上的方法[method]的 lambda 列表[lambda list]中的每个关键字参数指定符的关键字名字被声明为一个对于所有那个方法[method]可应用的类[class]的有效 initarg 名字.

        这个 update-instance-for-different-class 返回的值会被 change-class 忽略. 


### <span id="SGF-U-I-F-R-C">标准广义函数 UPDATE-INSTANCE-FOR-REDEFINED-CLASS</span>

* 语法(Syntax):

        update-instance-for-redefined-class instance added-slots discarded-slots property-list &rest initargs &key &allow-other-keys
        => result*

* 方法签名(Method Signatures):

        update-instance-for-redefined-class (instance standard-object) added-slots discarded-slots property-list &rest initargs

* 参数和值(Arguments and Values):

        instance---一个对象[object].
        added-slots---一个列表[list].
        discarded-slots---一个列表[list].
        property-list---一个列表[list].
        initargs---一个初始化参数列表[initialization argument list].
        result---一个对象[object].

* 描述(Description):

        广义函数[generic function] update-instance-for-redefined-class 不打算给程序员调用. 程序员可以为它编写方法[method]. 广义函数[generic function] update-instance-for-redefined-class 通过 make-instances-obsolete 的机制被调用.

        系统提供的 update-instance-for-redefined-class 主方法[method]检查这些初始化参数 initargs 的有效性, 如果提供的一个初始化参数 initarg 没有被有效声明就会发出一个错误. 接下来这个方法[method]根据 initargs 的值来初始化槽[slot], 并且根据这些新添加槽 added-slots 的 :initform 表达式形式来初始化它们. 它通过使用以下参数调用广义函数 shared-initialize 来实现这个: 这个实例 instance, 给这个实例 instance 的新添加槽 added-slots 的名称列表, 还有它收到的初始化参数 initargs. 新添加槽 added-slots 是那些在旧版本类[class]中不存在相同名字的槽[slot]的局部槽[local slot].

        当 make-instances-obsolete 被调用或者当一个类[class]被重定义并且一个实例[instance]被更新时, 会创建一个捕获在这个原始实例 instance 中所有 discarded-slots 的名字和值的属性列表 property-list. 这个实例 instance 的结构会被转化以便符合当前类的定义. 给 update-instance-for-redefined-class 的参数是这个转化后的实例 instance, 一个给这个实例 instance 的新添加 added-slots 列表, 一个来自这个实例 instance 的丢弃的槽 discarded-slots 列表, 以及这个包含有值但是被丢弃的那些槽[slot]的名字和值的属性列表 property-list. 被包含在这个被丢弃的槽[slot]列表中的是那些在旧类[class]中是局部的而在新类[class]中是共享的那些槽[slot].

        这个 update-instance-for-redefined-class 返回的值会被忽略.

* 示例(Examples):

    ```LISP  
    (defclass position () ())
    
    (defclass x-y-position (position)
        ((x :initform 0 :accessor position-x)
          (y :initform 0 :accessor position-y)))
    
    ;;; It turns out polar coordinates are used more than Cartesian 
    ;;; coordinates, so the representation is altered and some new
    ;;; accessor methods are added.
    
    (defmethod update-instance-for-redefined-class :before
        ((pos x-y-position) added deleted plist &key)
      ;; Transform the x-y coordinates to polar coordinates
      ;; and store into the new slots.
      (let ((x (getf plist 'x))
            (y (getf plist 'y)))
        (setf (position-rho pos) (sqrt (+ (* x x) (* y y)))
              (position-theta pos) (atan y x))))
      
    (defclass x-y-position (position)
        ((rho :initform 0 :accessor position-rho)
          (theta :initform 0 :accessor position-theta)))
      
    ;;; All instances of the old x-y-position class will be updated
    ;;; automatically.
    
    ;;; The new representation is given the look and feel of the old one.
    
    (defmethod position-x ((pos x-y-position))  
        (with-slots (rho theta) pos (* rho (cos theta))))
    
    (defmethod (setf position-x) (new-x (pos x-y-position))
        (with-slots (rho theta) pos
          (let ((y (position-y pos)))
            (setq rho (sqrt (+ (* new-x new-x) (* y y)))
                  theta (atan y new-x))
            new-x)))
    
    (defmethod position-y ((pos x-y-position))
        (with-slots (rho theta) pos (* rho (sin theta))))
    
    (defmethod (setf position-y) (new-y (pos x-y-position))
        (with-slots (rho theta) pos
          (let ((x (position-x pos)))
            (setq rho (sqrt (+ (* x x) (* new-y new-y)))
                  theta (atan new-y x))
            new-y)))
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果提供的一个初始化参数 initarg 没有被有效声明, 那么这个系统提供的 update-instance-for-redefined-class 主方法[method]会发出一个错误.

* 参见(See Also):

        make-instances-obsolete, shared-initialize, 章节 4.3.6 (重定义类), 章节 7.1.4 (初始化参数的规则), 章节 7.1.2 (声明初始化参数的有效性)

* 注意(Notes):

        这些初始化参数 initargs 可以通过给 defclass 使用 :initarg, 或者通过为 update-instance-for-redefined-class 或 shared-initialize 定义方法[method]来有效声明. 定义在 update-instance-for-redefined-class 或 shared-initialize 上的任何方法[method]的 lambda 列表[lambda list]中的每个关键字参数指定符的关键字名字, 对于那个方法[method]可应用的所有类[class]都是有效的关键字. 


### <span id="SGF-CHANGE-CLASS">标准广义函数 CHANGE-CLASS</span>

* 语法(Syntax):

        change-class instance new-class &key &allow-other-keys => instance

* 方法签名(Method Signatures):

        change-class (instance standard-object) (new-class standard-class) &rest initargs

        change-class (instance t) (new-class symbol) &rest initargs

* 参数和值(Arguments and Values):

        instance---一个对象[object].
        new-class---一个类指定符[class designator].
        initargs---一个初始化参数列表[initialization argument list].

* 描述(Description):

        广义函数[generic function] change-class 修改一个实例 instance 的类为 new-class. 它破坏性地修改并返回这个实例 instance.

        如果在旧的类[class]中存在任何和 new-class 中的局部槽[slot]名字相同的槽[slot], 那个槽[slot]的值会被保留. 这个意味着如果这个槽[slot]有一个值, 在 change-class 被调用之后 slot-value 返回的值和在 change-class 被调用之前 slot-value 返回的值是 eql 的. 类似地, 如果这个槽[slot]没有被绑定, 它就保持未绑定状态. 其他槽[slot]按照章节 7.2 (修改一个实例的类) 中所描述的被初始化.

        在完成所有其他动作之后, change-class 调用 update-instance-for-different-class. 广义函数 update-instance-for-different-class 可以被用于赋值给转化后的实例中的槽. 见章节 7.2.2 (初始化新添加的局部槽).

        如果上述方法[method]中的第二个被选择, 那么这个方法[method]在实例 instance, (find-class new-class), 以及这些初始化参数 initargs 上调用 change-class.

* 示例(Examples):

    ```LISP
    (defclass position () ())
      
    (defclass x-y-position (position)
        ((x :initform 0 :initarg :x)
          (y :initform 0 :initarg :y)))
      
    (defclass rho-theta-position (position)
        ((rho :initform 0)
          (theta :initform 0)))
      
    (defmethod update-instance-for-different-class :before ((old x-y-position) 
                                                            (new rho-theta-position)
                                                            &key)
      ;; Copy the position information from old to new to make new
      ;; be a rho-theta-position at the same position as old.
      (let ((x (slot-value old 'x))
            (y (slot-value old 'y)))
        (setf (slot-value new 'rho) (sqrt (+ (* x x) (* y y)))
              (slot-value new 'theta) (atan y x))))
      
    ;;; At this point an instance of the class x-y-position can be
    ;;; changed to be an instance of the class rho-theta-position using
    ;;; change-class:
    
    (setq p1 (make-instance 'x-y-position :x 2 :y 0))
      
    (change-class p1 'rho-theta-position)
      
    ;;; The result is that the instance bound to p1 is now an instance of
    ;;; the class rho-theta-position.   The update-instance-for-different-class
    ;;; method performed the initialization of the rho and theta slots based
    ;;; on the value of the x and y slots, which were maintained by
    ;;; the old instance.
    ```

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        update-instance-for-different-class, 章节 7.2 (修改一个实例的类)

* 注意(Notes):

        广义函数 change-class 有几个语义难点. 首先, 它执行一个破坏性的操作, 并且可以在被用于选择这个方法[method]的一个的实例[instance]上的方法[method]中被调用. 当由于方法[method]被组合而导致多个方法[method]被调用时, 当前执行的方法[method]或要被执行的方法可能不再是可应用的. 其次, 一些具体实现可能使用编译器对槽访问[access]的优化, 当一个实例[instance]的类[class]被修改时可能违背编译器所做的假设. 这个意味着如果一个广义函数[generic function]的任何方法[method]访问[access]了任何槽[slot], 那么程序员一定不能在那个方法中使用 change-class, 否则结果是未定义的. 

### <span id="F-SLOT-BOUNDP">函数 SLOT-BOUNDP</span>

* 语法(Syntax):

        slot-boundp instance slot-name => generalized-boolean

* 参数和值(Arguments and Values):

        instance---一个对象[object].
        slot-name---命名实例 instance 的一个槽[slot]的符号[symbol].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果在实例 instance 中名为 slot-name 的槽[slot]已经是绑定的, 那么就返回 true; 否则, 返回 false.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果在这个实例 instance 中没有名为 slot-name 的槽[slot], 那么 slot-missing 会按如下被调用:

        (slot-missing (class-of instance)
                      instance
                      slot-name
                      'slot-boundp)

        (如果 slot-missing 被调用并且返回了一个值, 它的主值[primary value]的一个 boolean 等价物[boolean equivalent]会被 slot-boundp 返回.)

        这个具体行为依赖于实例 instance 的元类[metaclass]. 如果实例 instance 元类[metaclass]为 standard-class, 那么从来不会发出一个错误. 如果实例 instance 元类[metaclass]为 built-in-class, 那么总是会发出一个错误. 如果实例 instance 有着其他元类那么结果是未定义的--在这个情况可能会也可能不会发出一个错误. 特别注意, 对于状况[condition]和结构体[structure]的行为是没有指定的.

* 参见(See Also):

        slot-makunbound, slot-missing

* 注意(Notes):

        函数[function] slot-boundp 考虑到为 initialize-instance 编写仅用来初始化那些未绑定槽[slot]的 after 方法[after method].

        虽然没有具体实现[implementation]被要求, 但是强烈鼓励实现者去使用元对象协议[Metaobject Protocol]中描述的函数[function] slot-boundp-using-class 来实现函数[function] slot-boundp. 


### <span id="F-SLOT-EXISTS-P">函数 SLOT-EXISTS-P</span>

* 语法(Syntax):

        slot-exists-p object slot-name => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        slot-name---一个符号[symbol].
        generalized-boolean---一个广义的 boolean [generalized boolean].

* 描述(Description):

        如果这个对象 object 有着一个名为 slot-name 的槽[slot]就返回 true.

* 示例(Examples): None.

* 受此影响(Affected By):

        defclass, defstruct

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        defclass, slot-missing

* 注意(Notes):

        虽然没有具体实现[implementation]被要求, 但是还是强烈鼓励实现者去使用元对象协议[Metaobject Protocol]中描述的函数[function] slot-exists-p-using-class 来实现函数[function] slot-exists-p. 

### <span id="F-SLOT-MAKUNBOUND">函数 SLOT-MAKUNBOUND</span>

* 语法(Syntax):

        slot-makunbound instance slot-name => instance

* 参数和值(Arguments and Values):

        instance -- 实例.
        Slot-name---一个符号[symbol].

* 描述(Description):

        函数[function] slot-makunbound 将一个实例 instance 中名为 slot-name 的槽[slot]复原到未绑定状态.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果在这个实例 instanace 中不存在名为 slot-name 的槽[slot], slot-missing 会按如下被调用:

        (slot-missing (class-of instance)
                      instance
                      slot-name
                      'slot-makunbound)

        (在这个情况下任何由 slot-missing 返回的值都被会 slot-makunbound 忽略.)

        这个具体行为依赖于实例 instance 的元类[metaclass]. 如果实例 instance 的元类[metaclass]为 standard-class 那么从不发出一个错误. 如果实例 instance 的元类[metaclass]为 built-in-class 那么总是发出一个错误. 如果实例 instance 有着任何其他元类[metaclass]那么结果是未定义的--在这个情况下一个错误可能或可能不会发出. 特别要注意的是, 对于状况[condition]和结构体[structure]的行为是没有指定的.

* 参见(See Also):

        slot-boundp, slot-missing

* 注意(Notes):

        虽然没有具体实现[implementation]被要求, 还是强烈鼓励实现者用元对象协议[Metaobject Protocol]中描述的函数[function] slot-makunbound-using-class 来实现函数[function] slot-makunbound. 


### <span id="SGF-SLOT-MISSING">标准广义函数 SLOT-MISSING</span>

* 语法(Syntax):

        slot-missing class object slot-name operation &optional new-value => result*

* 方法签名(Method Signatures):

        slot-missing (class t) object slot-name operation &optional new-value

* 参数和值(Arguments and Values):

        class---对象 object 的类[class].
        object---一个对象[object].
        slot-name---一个符号[symbol] (一个要被绑定的槽[slot]的名字[name]).
        operation---符号[symbol] setf, slot-boundp, slot-makunbound, 或 slot-value 的其中之一.
        new-value---一个对象[object].
        result---一个对象[object].

* 描述(Description):

        当尝试去访问[access]一个元类[metaclass]是 standard-class 的对象 object 的槽[slot]并且在那个类[class]中没有名为 slot-name 的槽[slot]时, 广义函数 slot-missing 会被调用. 这个默认方法[method]会发出一个错误.

        广义函数 slot-missing 不打算给程序员调用. 程序员可以为它写方法[method].

        广义函数 slot-missing 可能在 slot-value, (setf slot-value), slot-boundp, 还有 slot-makunbound 求值期间被调用. 对于这些操作符中的每一个, 对应 operation 参数的符号[symbol]分别是 slot-value, setf, slot-boundp, 还有 slot-makunbound.

        当这个操作符尝试去设置这个槽[slot]的值时, 就使用给 slot-missing 可选的 new-value 参数.

        如果 slot-missing 返回, 它的值会按照如下方式对待:

            如果这个 operation 是 setf 或 slot-makunbound, 任何值[value]都会被调用者忽略.

            如果这个 operation 是 slot-value, 只有主值[primary value]会被调用者使用, 而其他所有值都会被忽略.

            如果这个 operation 是 slot-boundp, 任何这个方法主值[primary value]的 boolean 等价物[boolean equivalent]可能被使用, 而其他所有值都会被忽略.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        这个 slot-missing 默认方法[method]发出一个 error 类型[type]的错误.

* 参见(See Also):

        defclass, slot-exists-p, slot-value

* 注意(Notes):

        这个参数的集合 (包括这个实例的类[class]) 有助于为 slot-missing 定义元类方法. 


### <span id="SGF-SLOT-UNBOUND">标准广义函数 SLOT-UNBOUND</span>

* 语法(Syntax):

      slot-unbound class instance slot-name => result*

* 方法签名(Method Signatures):

      slot-unbound (class t) instance slot-name

* 参数和值(Arguments and Values):

        class---这个实例 instance 的类[class].
        instance---尝试去读取[read]未绑定[unbound]槽[slot]所在的实例 instance.
        slot-name---未绑定[unbound]槽[slot]的名字[name].
        result---一个对象[object].

* 描述(Description):

        当元类为 standard-class 的一个实例 instance 的一个未绑定的槽[slot]被读取时, 广义函数 slot-unbound 会被调用. 这个默认方法[meethod]会发出一个 unbound-slot 类型[type]的错误. 这个 unbound-slot 状况[condition]的名称槽被初始化为这个违规变量的名字, 而这个 unbound-slot 状况[condition]的实例槽被初始化为这个违规实例.

        广义函数 slot-unbound 不旨在被程序员调用. 程序员可以为它写方法[method]. 函数[function] slot-unbound 只会被 slot-value 间接调用.

        如果 slot-unbound 返回, 只有主值[primary value]会被调用者使用, 其他所有值都会被忽略.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        这个 slot-unbound 上的默认方法[method]发出一个 unbound-slot 类型[type]的错误.

* 参见(See Also):

        slot-makunbound

* 注意(Notes):

        如果没有为一个槽[slot]指定 :initform 表达式形式并且还没有设置槽[slot]的值, 或者在那个槽[slot]上调用了 slot-makunbound, 那么可能出现一个未绑定的槽[slot].

### <span id="F-SLOT-VALUE">函数 SLOT-VALUE</span>

* 语法(Syntax):

        slot-value object slot-name => value

* 参数和值(Arguments and Values):

        object---一个对象[object].
        name---一个符号[symbol].
        value---一个对象[object].

* 描述(Description):

        函数[function] slot-value 返回这个对象 object 中名为 slot-name 的槽[slot]的值[value]. 如果这里没有名为 slot-name 的槽[slot], 就会调用 slot-missing. 如果这个槽[slot]是未绑定的, slot-unbound 就会被调用.

        宏 setf 可以和 slot-value 一起使用来改变一个槽[slot]的值.

* 示例(Examples):

    ```LISP
    (defclass foo () 
      ((a :accessor foo-a :initarg :a :initform 1)
        (b :accessor foo-b :initarg :b)
        (c :accessor foo-c :initform 3)))
    =>  #<STANDARD-CLASS FOO 244020371>
    (setq foo1 (make-instance 'foo :a 'one :b 'two))
    =>  #<FOO 36325624>
    (slot-value foo1 'a) =>  ONE
    (slot-value foo1 'b) =>  TWO
    (slot-value foo1 'c) =>  3
    (setf (slot-value foo1 'a) 'uno) =>  UNO
    (slot-value foo1 'a) =>  UNO
    (defmethod foo-method ((x foo))
      (slot-value x 'a))
    =>  #<STANDARD-METHOD FOO-METHOD (FOO) 42720573>
    (foo-method foo1) =>  UNO
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果尝试去读取一个槽[slot]但是没有名为 slot-name 的槽[slot]存在于这个对象 object 中, slot-missing 会像下面这样被调用:

        (slot-missing (class-of instance)
                      instance
                      slot-name
                      'slot-value)

        (如果 slot-missing 被调用, 它的主值[primary value]被 slot-value 返回.)

        如果尝试去写入一个槽[slot]但是没有名为 slot-name 的槽[slot]存在于这个对象 object 中, slot-missing 会像下面这样被调用:

        (slot-missing (class-of instance)
                      instance
                      slot-name
                      'setf
                      new-value)

        (如果这个情况下 slot-missing 返回了, 任何值[value]都会被忽略.)

        这个具体行为依赖于对象 object 的元类[metaclass]. 如果对象 object 的元类[metaclass]为 standard-class 那么从不发出一个错误. 如果对象 object 的元类[metaclass]为 built-in-class 那么总是发出一个错误. 如果对象 object 有着任何其他元类[metaclass]那么结果是未定义的--在这个情况下一个错误可能或可能不会发出. 特别要注意的是, 状况[condition]和结构体[structure]的行为没有被指定.

* 参见(See Also):

        slot-missing, slot-unbound, with-slots

* 注意(Notes):

        虽然没有具体实现[implementation]被要求做这个, 但是强烈鼓励实现者通过使用元对象协议[Metaobject Protocol]中描述的函数[function] slot-value-using-class 来实现函数[function] slot-value.

        具体实现可能通过编译 slot-value 为内联的(inline)来优化它. 


### <span id="SGF-METHOD-QUALIFIERS">标准广义函数 METHOD-QUALIFIERS</span>

* 语法(Syntax):

        method-qualifiers method => qualifiers

* 方法签名(Method Signatures):

        method-qualifiers (method standard-method)

* 参数和值(Arguments and Values):

        method---一个方法[method].
        qualifiers---一个正规列表[proper list].

* 描述(Description):

        返回这个方法 method 的限定符[qualifier]列表[list].

* 示例(Examples):

    ```LISP
    (defmethod some-gf :before ((a integer)) a)
    =>  #<STANDARD-METHOD SOME-GF (:BEFORE) (INTEGER) 42736540>
    (method-qualifiers *) =>  (:BEFORE)
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        define-method-combination

* 注意(Notes): None. 


### <span id="SGF-NO-APPLICABLE-METHOD">标准广义函数 NO-APPLICABLE-METHOD</span>

* 语法(Syntax):

        no-applicable-method generic-function &rest function-arguments => result*

* 方法签名(Method Signatures):

        no-applicable-method (generic-function t) &rest function-arguments

* 参数和值(Arguments and Values):

        generic-function---一个没有找到可应用方法[applicable method]的广义函数[generic function].
        function-arguments---给这个广义函数 generic-function 的实参[argument].
        result---一个对象[object].

* 描述(Description):

        当一个广义函数[generic function]被调用而这个广义函数[generic function]上没有方法[method]可应用时, 那么这个广义函数 no-applicable-method 就会被调用. 默认方法[default method]会发出一个错误.

        广义函数 no-applicable-method 不旨在被程序员调用. 程序员可以为它写方法[method].

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        这个默认方法[default method]会发出一个 error 类型[type]的错误.

* 参见(See Also):

* 注意(Notes): None. 


### <span id="SGF-NO-NEXT-METHOD">标准广义函数 NO-NEXT-METHOD</span>

* 语法(Syntax):

        no-next-method generic-function method &rest args => result*

* 方法签名(Method Signatures):

        no-next-method (generic-function standard-generic-function) (method standard-method) &rest args

* 参数和值(Arguments and Values):

        generic-function -- 方法 method 所属的广义函数[generic function].

        method -- 包含了对 call-next-method 的调用但是没有下一个方法[method]的方法[method].

        args -- 给 call-next-method 的参数.

        result---一个对象[object].

* 描述(Description):

        当这里没有下一个方法[next method]时, 广义函数[generic function] no-next-method 被 call-next-method 调用.

        广义函数[generic function] no-next-method 不打算被程序员所调用. 程序员可以为它写方法[method].

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        系统提供的 no-next-method 上的方法[method]会发出一个 error 类型[type]的错误.

* 参见(See Also):

        call-next-method

* 注意(Notes): None. 


### <span id="SGF-REMOVE-METHOD">标准广义函数 REMOVE-METHOD</span>

* 语法(Syntax):

        remove-method generic-function method => generic-function

* 方法签名(Method Signatures):

        remove-method (generic-function standard-generic-function) method

* 参数和值(Arguments and Values):

        generic-function---一个广义函数[generic function].
        method---一个方法[method].

* 描述(Description):

        广义函数[generic function] remove-method 通过修改这个广义函数 generic-function (如果必要的话)来从广义函数 generic-function 中移除一个方法[method].

        如果这个方法[method]不是这个广义函数 generic-function 上的方法[method], 那么一定不会发出一个错误.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        find-method

* 注意(Notes): None. 


### <span id="SGF-MAKE-INSTANCE">标准广义函数 MAKE-INSTANCE</span>

* 语法(Syntax):

        make-instance class &rest initargs &key &allow-other-keys => instance

* 方法签名(Method Signatures):

        make-instance (class standard-class) &rest initargs
        make-instance (class symbol) &rest initargs

* 参数和值(Arguments and Values):

        class---一个类[class], 或者命名一个类[class]的符号[symbol].
        initargs---一个初始化参数列表[initialization argument list].
        instance---一个类[class] class 的新生[fresh]实例[instance].

* 描述(Description):

        广义函数[generic function] make-instance 创建并返回这个给定类 class 的新的实例[instance].

        如果选择了上述方法[method]中的第二个, 那个方法[method]在参数 (find-class class) 和 initargs 上调用 make-instance.

        初始化参数在 make-instance 中被检测.

        广义函数[generic function] make-instance 按章节 7.1 (对象创建和初始化) 中所描述的那样被使用.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果任何一个初始化参数没有被有效声明, 会发出一个 error 类型[type]的错误.

* 参见(See Also):

        defclass, class-of, allocate-instance, initialize-instance, 章节 7.1 (对象创建和初始化)

* 注意(Notes): None. 


### <span id="SGF-MAKE-INSTANCES-OBSOLETE">标准广义函数 MAKE-INSTANCES-OBSOLETE</span>

* 语法(Syntax):

        make-instances-obsolete class => class

* 方法签名(Method Signatures):

        make-instances-obsolete (class standard-class)
        make-instances-obsolete (class symbol)

* 参数和值(Arguments and Values):

        class---一个类标识符[class designator].

* 描述(Description):

        函数[function] make-instances-obsolete 具有启动更新类[class]实例的过程的效果. 在更新期间, 广义函数 update-instance-for-redefined-class 会被调用.

        当 defclass 被用来重定义一个已存在的标准类并且在一个实例中可访问的[accessible]局部槽[slot]的集合被改变或者存储中的槽[slot]的顺序被改变, 广义函数 make-instances-obsolete 会被系统自动调用. 它也可以被用户显式调用.

        如果选择了上述的第二个方法[method], 那个方法在 (find-class class) 上调用 make-instances-obsolete.

* 示例(Examples):

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        update-instance-for-redefined-class, 章节 4.3.6 (重定义类)

* 注意(Notes): None. 


### <span id="SGF-MAKE-LOAD-FORM">标准广义函数 MAKE-LOAD-FORM</span>

* 语法(Syntax):

        make-load-form object &optional environment => creation-form[, initialization-form]

* 方法签名(Method Signatures):

        make-load-form (object standard-object) &optional environment
        make-load-form (object structure-object) &optional environment
        make-load-form (object condition) &optional environment
        make-load-form (object class) &optional environment

* 参数和值(Arguments and Values):

        object---一个对象[object].
        environment---一个环境对象[environment object].
        creation-form---一个表达式形式[form].
        initialization-form---一个表达式形式[form].

* 描述(Description):

        广义函数[generic function] make-load-form 创建并返回一个或两个表达式形式[form], 一个创建表达式形式 creation-form 和一个初始化表达式形式 initialization-form, 这个启用 load 去构造一个 object 等价的对象[object]. 这个 environment 是一个和这个表达式形式[form]被处理时所在词法环境[lexical environment]对应的环境对象[environment object].

        文件编译器[file compiler]调用 make-load-form 来处理字面化[literal]对象[object]确定的类[class]; 见章节 3.2.4.4 (外部化对象的附加约束).

        符合规范的程序[conforming program]可能直接调用 make-load-form, 假定对象 object 是 standard-object, structure-object, 或 condition 的一个广义实例[generalized instance].

        这个创建表达式形式是一个在 load 时求值并且应该返回一个和对象 object 等价的对象[object]的表达式形式[form]. 这个等价性的确切意义取决于对象[object]的类型[type]以及为 make-load-form 定义方法[method]的程序员; 见章节 3.2.4 (编译后文件中的字面化对象).

        这个初始化表达式形式是一个在 load 时求值并且应该执行这个对象[object]的进一步初始化的表达式形式[form]. 这个初始化表达式形式返回的值会被忽略. 如果 make-load-form 只返回一个值, 那么初始化表达式形式就是 nil, 它是没有效果的. 如果对象 object 作为一个常量出现在初始化表达式形式中, 在 load 时它会被创建表达式形式构造的等价对象[object]所替代; 这就是进一步的初始化如何获得对这个对象[object]的访问.

        不管是创建表达式形式 creation-form 还是初始化表达式形式 initialization-form 都可能包含对任何可外部化对象[externalizable object]的引用. 然而, 在创建表达式形式中, 这里一定不能有任何循环依赖. 一个循环依赖的示例就是, 当这个对象 X 的创建表达式形式包含了对对象 Y 的一个引用, 并且对象 Y 的创建表达式形式包含了对对象 X 的引用. 初始化表达式形式不受任何对循环依赖的限制, 这就是初始化表达式形式存在的原因; 见下面环状数据结构的示例.

        一个对象[object]的创建表达式形式总是在这个对象[object]的初始化表达式形式之前被求值. 当创建表达式形式或是初始化表达式形式引用了其他在这个编译的文件[file]中之前没有被引用的对象[object]时, 编译器[compiler]保证在求值这些引用表达式形式[form]之前所有这些引用的对象[object]都已经被创建. 当引用的对象[object]是文件编译器[file compiler]使用 make-load-form 处理的类型[type]时, 这个就涉及到求值为它返回的创建表达式形式. (这就是禁止在创建表达式形式中循环引用的原因).

        每个初始化表达式形式在它关联的创建表达式形式之后尽快被求值, 由数据流决定. 如果一个对象[object]的初始化表达式形式没有引用该文件中之前没有被引用并且被文件编译器[file compiler]使用 make-load-form 处理的任何其他对象[object], 那么初始化表达式形式会在创建表达式形式之后被立即求值. 如果一个创建或初始化表达式形式 F 确实包含了对这样的对象[object]的引用, 那么这些其他对象[object]的创建表达式形式在 F 之前被求值, 并且这些其他对象[object]的初始化表达式形式也会在 F 之前被求值, 无论何时它们都不依赖 F 创建和初始化的对象[object]. 在这些规则没有唯一确定在两个创建/初始化表达式形式之间的求值[evaluation]顺序的地方, 求值[evaluation]的顺序是未指定的.

        在这些创建和初始化表达式形式要被求值时, 这些对象[object]可能处于一个未初始化状态, 类似一个对象[object]在被 allocate-instance 创建和被 initialize-instance 完全处理之间的状态. 程序员为 make-load-form 写方法[method]必须关注操纵的对象[object]不依赖没有被初始化的槽[slot].

        load 是否在表达式形式[form]上调用 eval 或者执行某个其他有等价效果的操作是依赖于具体实现的[implementation-dependent]. 比如, 这些表达式形式[form]可能被转成不同但是等价的表达式形式[form]然后被求值, 它们可能被编译并且产生的函数被 load 调用, 或者它们可能被一个特殊目的的有别于 eval 的函数所解释. 所需要的只是效果等价于求值这些表达式形式[form].

        如果一个类[class]在环境 environment 中有专有名字[proper name], 那么这个在 class 上特化[specialized]的方法[method]返回一个使用该类[class]的名字[name]的创建表达式形式[form], 如果没有一个专有名字[proper name]就会发出一个 error 类型[type]的错误. 这个创建表达式形式[form]的求值[evaluation]使用这个名字[name]去找到这个名字[name]对应的类[class], 就像是通过调用 find-class 一样. 如果这个名字[name]的一个类[class]还没有被定义, 那么一个类[class]可能以一种具体实现定义的[implementation-defined]方法被计算出来. 如果一个类[class]不能被求值这个创建表达式形式[form]作为结果返回, 那么就会发出一个 error 类型[type]的错误.

        不管是符合规范的实现[conforming implementation]还是符合规范的程序[conforming program]都可能进一步特化[specialize] make-load-form.

* 示例(Examples):

    ```LISP
    (defclass obj ()
        ((x :initarg :x :reader obj-x)
        (y :initarg :y :reader obj-y)
        (dist :accessor obj-dist)))
    =>  #<STANDARD-CLASS OBJ 250020030>
    (defmethod shared-initialize :after ((self obj) slot-names &rest keys)
      (declare (ignore slot-names keys))
      (unless (slot-boundp self 'dist)
        (setf (obj-dist self)
              (sqrt (+ (expt (obj-x self) 2) (expt (obj-y self) 2))))))
    =>  #<STANDARD-METHOD SHARED-INITIALIZE (:AFTER) (OBJ T) 26266714>
    (defmethod make-load-form ((self obj) &optional environment)
      (declare (ignore environment))
      ;; Note that this definition only works because X and Y do not
      ;; contain information which refers back to the object itself.
      ;; For a more general solution to this problem, see revised example below.
      `(make-instance ',(class-of self)
                      :x ',(obj-x self) :y ',(obj-y self)))
    =>  #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 26267532>
    (setq obj1 (make-instance 'obj :x 3.0 :y 4.0)) =>  #<OBJ 26274136>
    (obj-dist obj1) =>  5.0
    (make-load-form obj1) =>  (MAKE-INSTANCE 'OBJ :X '3.0 :Y '4.0)
    ```

        在上述示例中, 一个 obj 等价的实例[instance]通过使用它的两个槽[slot]的值被重新构建. 第三个槽[slot]的值由那两个值得到.

        在那个示例中编写 make-load-form 方法[method]的另一种方式是使用 make-load-form-saving-slots. 它产生的代码可能和上面展示的 make-load-form 方法产生稍微不同的结果, 但是运行效果是一样的. 比如:

    ```LISP
    ;; Redefine method defined above.
    (defmethod make-load-form ((self obj) &optional environment)
        (make-load-form-saving-slots self
                                    :slot-names '(x y)
                                    :environment environment))
    =>  #<STANDARD-METHOD MAKE-LOAD-FORM (OBJ) 42755655>
    ;; Try MAKE-LOAD-FORM on object created above.
    (make-load-form obj1)
    =>  (ALLOCATE-INSTANCE '#<STANDARD-CLASS OBJ 250020030>),
        (PROGN
          (SETF (SLOT-VALUE '#<OBJ 26274136> 'X) '3.0)
          (SETF (SLOT-VALUE '#<OBJ 26274136> 'Y) '4.0)
          (INITIALIZE-INSTANCE '#<OBJ 26274136>))
    ```

        在下面这个示例中, my-frob 的实例[instance]以某种方式被 "捕捉(interned)". 通过使用这个命名槽作为键来搜索已存在的对象[object[来重新构建一个等价实例[instance]. 在这个情况下如果没有找到已存在的对象[object], 程序员选择创建一个新对象[object]; 或者在这种情况下可能会发出一个错误.

    ```LISP
    (defclass my-frob ()
        ((name :initarg :name :reader my-name)))
    (defmethod make-load-form ((self my-frob) &optional environment)
      (declare (ignore environment))
      `(find-my-frob ',(my-name self) :if-does-not-exist :create))
    ```

        在下面这个示例中, 被转储的数据结构是环状的, 因为每个 parent 有着它的 children 的一个列表并且每个 child 有一个指回它的 parent 的引用. 如果在一个这样结构的对象[object]上调用 make-load-form, 创建表达式形式创建一个等价对象[object]并且填充 children 槽, 它强制进行它的 children, grandchildren, 等等的等价对象[object]的创建. 在这个时候没有 parent 的槽[slot]被填充. 这个初始化表达式形式填充这个 parent 的槽[slot], 如果 parent 的等价对象[object]没有被创建, 它强制创建它. 因此整个树在加载时被重新创建. 在编译时, make-load-form 对于这个树中的每个对象[object]被调用一次. 所有创建表达式形式都被求值, 以依赖于具体实现[implementation-dependent]的顺序, 然后所有初始化表达式形式被求值, 也按照依赖于实现[implementation-dependent]的顺序.

    ```LISP
    (defclass tree-with-parent () ((parent :accessor tree-parent)
                                    (children :initarg :children)))
    (defmethod make-load-form ((x tree-with-parent) &optional environment)
      (declare (ignore environment))
      (values
        ;; creation form
        `(make-instance ',(class-of x) :children ',(slot-value x 'children))
        ;; initialization form
        `(setf (tree-parent ',x) ',(slot-value x 'parent))))
    ```

        在下面示例中, 被转储的数据结构没有特殊属性并且一个等价结构可以简单地通过重新构建槽[slot]的内容来重新构建.

    ```LISP
    (defstruct my-struct a b c)
    (defmethod make-load-form ((s my-struct) &optional environment)
        (make-load-form-saving-slots s :environment environment))
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        在 standard-object, structure-object, and condition 上特化[specialized]的所有这些方法[method]都会发出一个 error 类型[type]的错误.

        在一个系统类[system class]的广义实例[generalized instance]上调用 make-load-form 是发出一个错误还是返回创建和初始化表达式形式[form], 依赖于具体实现[implementation-dependent].

* 参见(See Also):

        compile-file, make-load-form-saving-slots, 章节 3.2.4.4 (外部化对象的附加约束) 章节 3.1 (求值), 章节 3.2 (编译)

* 注意(Notes):

        文件编译器[file compiler]在章节 3.2.4.4 (外部化对象的附加约束) 中详述的特殊情况下调用 make-load-form .

        某些具体实现[implementation]可能为定义被指定为系统类[system class]的类[class]的新子类[subclass]提供工具. (一些候选项包括 generic-function, method, 还有 stream). 这样的具体实现[implementation]应该记录在遇到字面化[literal]对象[object]时文件编译器[file compiler]如何处理这样的类[class]的实例[instance], 并且应该记录任何和 make-load-form 相关的方法[method]. 


### <span id="F-MAKE-LOAD-FORM-SAVING-SLOTS">函数 MAKE-LOAD-FORM-SAVING-SLOTS</span>

* 语法(Syntax):

        make-load-form-saving-slots object &key slot-names environment
        => creation-form, initialization-form

* 参数和值(Arguments and Values):

        object---一个对象[object].
        slot-names---一个列表[list].
        environment---一个环境对象[environment object].
        creation-form---一个表达式形式[form].
        initialization-form---一个表达式形式[form].

* 描述(Description):

        返回在求值时不执行初始化表达式形式来构造和对象 object 等价对象[object]的表达式形式[form]. 这个新的对象[object]中和对象 object 初始化槽[slot]对应的那些槽[slot]使用来自对象 object 的值来初始化. 在对象 object 中没有初始化的槽[slot]在新的对象[object]中不会被初始化. make-load-form-saving-slots 对任何 standard-object 或 structure-object 的实例[instance]都起作用.

        这些槽名字 slot-names 是要保留的槽[slot]的名称列表[list]. 如果没有提供 slot-names, 它的值就是所有局部槽[local slot].

        make-load-form-saving-slots 返回两个值, 因此它可以处理环状结构. 在一个应用中结果是否有用取决于这个对象 object 的类型[type]和槽的内容是否完全捕捉了这个对象状态的应用意义.

        这个 environment 是这些表达式形式被处理时所处的环境.

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        make-load-form, make-instance, setf, slot-value, slot-makunbound

* 注意(Notes):

        make-load-form-saving-slots 在用户编写的 make-load-form 方法中是很有用的.

        当这个对象[object]是 standard-object 的一个实例[instance]时, make-load-form-saving-slots 返回一个调用[call] allocate-instance 的创建表达式形式和一个包含对 slot-value 的 setf 和 slot-makunbound 的调用[call]的初始化表达式形式, 尽管事实上可能使用其他类似效果的函数[function]. 


### <span id="M-WITH-ACCESSORS">宏 WITH-ACCESSORS</span>

* 语法(Syntax):

        with-accessors (slot-entry*) instance-form declaration* form*
        => result*

        slot-entry::= (variable-name accessor-name) 

* 参数和值(Arguments and Values):

        variable-name---一个变量[variable]名字[name]; 不求值.
        accessor-name---一个函数名[function name]; 不求值.
        instance-form---一个表达式形式[form]; 求值.
        declaration---一个 declare 表达式[expression]; 不求值.
        forms---一个隐式的 progn [implicit progn].
        results---这些表达式形式 forms 返回的值[value].

* 描述(Description):

        创建一个词法环境, 在这里由 slot-entry 指定的那些槽通过它们的访问器是词法上可用的, 就像它们是变量一样. 宏 with-accessors 调用合适的访问器来访问 slot-entry 指定的那些槽[slot]. 不管 setf 还是 setq 都可以被用来设置槽[slot]的值.

* 示例(Examples):

    ```LISP
    (defclass thing ()
              ((x :initarg :x :accessor thing-x)
                (y :initarg :y :accessor thing-y)))
    =>  #<STANDARD-CLASS THING 250020173>
    (defmethod (setf thing-x) :before (new-x (thing thing))
      (format t "~&Changing X from ~D to ~D in ~S.~%"
              (thing-x thing) new-x thing))
    (setq thing1 (make-instance 'thing :x 1 :y 2)) =>  #<THING 43135676>
    (setq thing2 (make-instance 'thing :x 7 :y 8)) =>  #<THING 43147374>
    (with-accessors ((x1 thing-x) (y1 thing-y))
                    thing1
      (with-accessors ((x2 thing-x) (y2 thing-y))
                      thing2
        (list (list x1 (thing-x thing1) y1 (thing-y thing1)
                    x2 (thing-x thing2) y2 (thing-y thing2))
              (setq x1 (+ y1 x2))
              (list x1 (thing-x thing1) y1 (thing-y thing1)
                    x2 (thing-x thing2) y2 (thing-y thing2))
              (setf (thing-x thing2) (list x1))
              (list x1 (thing-x thing1) y1 (thing-y thing1)
                    x2 (thing-x thing2) y2 (thing-y thing2)))))
    >>  Changing X from 1 to 9 in #<THING 43135676>.
    >>  Changing X from 7 to (9) in #<THING 43147374>.
    =>  ((1 1 2 2 7 7 8 8)
        9
        (9 9 2 2 7 7 8 8) 
        (9)
        (9 9 2 2 (9) (9) 8 8))
    ```

* 受此影响(Affected By):

        defclass

* 异常情况(Exceptional Situations):

        如果任何 accessor-name 不是这个实例 instance 的一个访问器的名字, 那么结果是未定义的.

* 参见(See Also):

        with-slots, symbol-macrolet

* 注意(Notes):

        这个表达式形式的一个 with-accessors 表达式:

        (with-accessors (slot-entry1 ... slot-entryn) instance-form form1 ... formk)

        展开为下面这个的等价体

        (let ((in instance-form))
          (symbol-macrolet (Q1 ... Qn) form1 ... formk))

        其中 Qi 是

        (variable-namei () (accessor-namei in))


### <span id="M-WITH-SLOTS">宏 WITH-SLOTS</span>

* 语法(Syntax):

        with-slots (slot-entry*) instance-form declaration* form*
        => result*

        slot-entry::= slot-name | (variable-name slot-name) 

* 参数和值(Arguments and Values):

        slot-name---一个槽[slot]的名字[name]; 不求值.
        variable-name---一个变量[variable]名字[name]; 不求值.
        instance-form---一个表达式形式[form]; 求值来产生这个实例 instance.
        instance---一个对象[object].
        declaration---一个 declare 表达式[expression]; 不求值.
        forms---一个隐式的 progn [implicit progn].
        results---这些表达式形式 forms 返回的值[value].

* 描述(Description):

        宏 with-slots 建立[establish]一个词法环境[lexical environment]来引用这个 instance 实例中由给定的那些槽名 slot-names 所命名的槽[slot], 就好像它们是变量[variable]一样. 在这样一个上下文中这个槽[slot]的值可以通过使用它的槽名来指定, 就好像它们是一个词法上绑定的变量一样. 不管是 setf 还是 setq 都可以被用于设置这个槽[slot]的值.

        宏 with-slots 把这个槽名的外观作为变量[variable]转化为一个对 slot-value 的调用.

* 示例(Examples):

    ```LISP
    (defclass thing ()
              ((x :initarg :x :accessor thing-x)
                (y :initarg :y :accessor thing-y)))
    =>  #<STANDARD-CLASS THING 250020173>
    (defmethod (setf thing-x) :before (new-x (thing thing))
      (format t "~&Changing X from ~D to ~D in ~S.~%"
              (thing-x thing) new-x thing))
    (setq thing (make-instance 'thing :x 0 :y 1)) =>  #<THING 62310540>
    (with-slots (x y) thing (incf x) (incf y)) =>  2
    (values (thing-x thing) (thing-y thing)) =>  1, 2
    (setq thing1 (make-instance 'thing :x 1 :y 2)) =>  #<THING 43135676>
    (setq thing2 (make-instance 'thing :x 7 :y 8)) =>  #<THING 43147374>
    (with-slots ((x1 x) (y1 y))
                thing1
      (with-slots ((x2 x) (y2 y))
                  thing2
        (list (list x1 (thing-x thing1) y1 (thing-y thing1)
                    x2 (thing-x thing2) y2 (thing-y thing2))
              (setq x1 (+ y1 x2))
              (list x1 (thing-x thing1) y1 (thing-y thing1)
                    x2 (thing-x thing2) y2 (thing-y thing2))
              (setf (thing-x thing2) (list x1))
              (list x1 (thing-x thing1) y1 (thing-y thing1)
                    x2 (thing-x thing2) y2 (thing-y thing2)))))
    >>  Changing X from 7 to (9) in #<THING 43147374>.
    =>  ((1 1 2 2 7 7 8 8)
        9
        (9 9 2 2 7 7 8 8) 
        (9)
        (9 9 2 2 (9) (9) 8 8))
    ```

* 受此影响(Affected By):

        defclass

* 异常情况(Exceptional Situations):

        如果任何的槽名 slot-name 都不是这个实例 instance 中的一个槽[slot]的名字, 那么结果是未定义的.

* 参见(See Also):

        with-accessors, slot-value, symbol-macrolet

* 注意(Notes):

        一个这个形式的 with-slots 表达式:

        (with-slots (slot-entry1 ... slot-entryn) instance-form form1 ... formk)

        展开为下面这个的等价体

        (let ((in instance-form))
          (symbol-macrolet (Q1 ... Qn) form1 ... formk))

        其中如果 slot-entryi 是一个符号[symbol]的话 Qi 就是

        (slot-entryi () (slot-value in 'slot-entryi))

        如果 slot-entryi 是下面这个形式

        (variable-namei 'slot-namei))

         那么 Qi 就是

        (variable-namei () (slot-value in 'slot-namei))


### <span id="M-DEFCLASS">宏 DEFCLASS</span>

* 语法(Syntax):

        defclass class-name ({superclass-name}*) ({slot-specifier}*) [[class-option]]
        => new-class

        slot-specifier::= slot-name | (slot-name [[slot-option]])
        slot-name::= symbol
        slot-option::= {:reader reader-function-name}* | 
                      {:writer writer-function-name}* | 
                      {:accessor reader-function-name}* | 
                      {:allocation allocation-type} | 
                      {:initarg initarg-name}* | 
                      {:initform form} | 
                      {:type type-specifier} | 
                      {:documentation string} 
        function-name::= {symbol | (setf symbol)}
        class-option::= (:default-initargs . initarg-list) | 
                        (:documentation string) | 
                        (:metaclass class-name) 

* 参数和值(Arguments and Values):

        Class-name---一个非 nil [non-nil]符号[symbol].
        Superclass-name--一个非 nil [non-nil]符号[symbol].
        Slot-name--一个符号[symbol]. 这个 slot-name 参数是一个符号[symbol], 它用作一个变量名是语法上有效的.
        Reader-function-name---一个非 nil [non-nil]符号[symbol]. 可以为一个给定的槽[slot]提供超过一个 :reader.
        Writer-function-name---一个广义函数[generic function]名字. 可以为一个给定的槽[slot]提供超过一个 :writer.
        Reader-function-name---一个非 nil [non-nil]符号[symbol]. 可以为一个给定的槽[slot]提供超过一个 :accessor.
        Allocation-type---(member :instance :class). 可以为一个给定的槽[slot]提供最多一个 :allocation.
        Initarg-name---一个符号[symbol]. 可以为一个给定的槽[slot]提供超过一个 :initarg.
        Form---一个表达式形式[form]. 可以为一个给定的槽[slot]提供最多一个 :init-form.
        Type-specifier---一个类型指定符[type specifier]. 可以为一个给定的槽[slot]提供最多一个 :type.
        Class-option--- 引用整个类或类的所有槽[slot].
        Initarg-list---一个交替的初始化参数名字[name]和默认初始化值表达式形式[form]的列表[list]. 最多只能提供一个 :default-initargs.
        Class-name---一个非 nil [non-nil]符号[symbol]. 最多只能提供一个 :metaclass.
        new-class---新的类[class]对象[object].

* 描述(Description):

        宏 defclass 定义一个新的已命名的类[class]. 它把新的类[class]对象[object]作为它的结果返回.

        defclass 的语法为给槽[slot]指定初始化参数, 为槽[slot]指定默认初始化值, 还有为给读取和写入槽[slot]的值自动生成指定的广义函数[generic function]的方法[method]提供选项. 默认没有定义 reader 或 writer 函数; 它们的生成必须是显式地请求. 然而, 槽[slot]总是可以通过使用 slot-value 来访问.

        定义一个新的类[class]同时也导致一个相同名字的类型[type]被定义. 如果给定对象 object 的类[class]是由 class-name 命名的类[class]或是 class-name 命名的类的子类, 那么断言 (typep object class-name) 返回 true. 一个类[class]对象[object]可以被用作一个类型指定符[type specifier]. 因此如果这个对象 object 的类[class]是 class 自身或者 class 的子类, 那么 (typep object class) 返回 true.

        这个 class-name 参数指定这个新的类[class]的专有名字[proper name]. 如果相同的专有名字[proper name]的一个类[class]已经存在并且那个类[class]是 standard-class 的一个实例[instance], 并且如果这个新类[class]的定义 defclass 表达式形式指定一个类[class] standard-class 的类[class], 那么这个已存在的类[class]会被重定义, 并且它(还有它的子类[subclass])的实例在它们被下一次访问时会被更新到新的定义. 关于详细信息, 见章节  4.3.6 (重定义类).

        每个 superclass-name 参数指定这个新类[class]的一个直接超类[superclass]. 如果这个超类[superclass]列表是空的, 那么这个超类[superclass]默认值取决于这个元类[metaclass], 而对于 standard-object 默认值就是 standard-class.

        这个新类[class]会从它的每个直接超类[superclass], 直接超类的直接超类[superclass]等等继承槽[slot]和方法[method]. 关于槽[slot]和方法[method]如何被继承的讨论, 见章节 4.3.4 (继承).

        以下槽选项是可用的:

            这个 :reader 槽选项指定在名为 reader-function-name 广义函数[generic function]上定义一个非限定方法[unqualified method]来读取这个给定槽[slot]的值.

            这个 :writer 槽选项指定在名为 writer-function-name 广义函数[generic function]上定义一个非限定方法[unqualified method]来写入这个槽[slot]的值.

            这个 :accessor 槽选项指定在名为 reader-function-name 的广义函数[generic function]上定义一个非限定方法[unqualified method]来读取这个给定槽[slot]的值, 并且在名为 (setf reader-function-name) 的广义函数[generic function]上定义一个非限定方法[unqualified method]来和 setf 一起使用来修改这个槽[slot]的值.

            这个 :allocation 槽选项用于指定这个给定的槽[slot]要被分配的存储的位置. 一个槽[slot]的存储可以位于每个实例或者这个类[class]对象[object]自身. 这个 allocation-type 参数的值可以是关键字 :instance 或者关键字 :class. 如果 :allocation 槽选项没有被指定, 结果和指定 :allocation :instance 一样.

                如果 allocation-type 是 :instance, 一个名为 slot-name 的局部槽[local slot]会被分配在这个类[class]的每个实例.

                如果 allocation-type 是 :class, 这个给定名字的共享槽[slot]会被分配在由这个 defclass 表达式形式创建的类[class]对象[object]中. 这个槽[slot]的值被这个类[class]的所有实例[instance]所共享. 如果一个类 C1 定义了这样一个共享槽[shared slot], 任何 C1 的子类 C2 会共享这个单独的槽除非这个 C2 的 defclass 表达式形式指定了一个相同名字[name]的槽[slot]或者这里有一个在 C2 的优先级列表中优先于 C1 并且定义了相同名字[name]的槽[slot]的 C2 的超类.

            这个 :initform 槽选项被用于提供在这个槽[slot]的初始化中使用的默认初始值表达式形式. 这个表达式形式[form]在每次被用来初始化这个槽[slot]时都会被求值. 这个表达式形式[form]被求值所在词法环境是 defclass 表达式形式被求值所在的词法环境. 注意这个词法环境既引用了变量也引用了函数. 对于局部槽[local slot], 动态环境是 make-instance 被调用所在的动态环境; 对于共享槽[slot], 动态环境是 defclass 表达式形式被求值所在的动态环境. 见章节 7.1 (对象创建和初始化).

            具体实现不允许去扩展 defclass 的语法来允许 (slot-name form) 作为一个 (slot-name :initform form) 的简写.

            这个 :initarg 槽选项声明一个名为 initarg-name 的初始化参数并且指定这个初始化参数初始化给定的槽[slot]. 在对 initialize-instance 的调用中如果这个初始化参数有一个值, 那么就会被存储到给定的槽[slot]中, 并且, 如果存在这个槽的 :initform 槽选项, 就不会求值. 如果没有为一个给定的槽[slot]指定有值的初始化参数, 如果指定了 :initform 槽选项的话, 就根据这个槽选项来初始化这个槽[slot].

            这个 :type 槽选项指定这个槽[slot]的内容总是为指定的数据类型. 它有效地声明应用到这个类[class]的一个对象[object]的 reader 广义函数的结果类型. 尝试去存储一个不符合一个槽[slot]的类型的值到这个槽[slot]中的后果是未定义的. 这个 :type 槽选项在章节 7.5.3 (槽和槽选项的继承) 中被进一步讨论.

            这个 :documentation 槽选项为这个槽[slot]提供一个文档字符串[documentation string]. :documentation 提供给一个槽[slot]最多一次.

        每个类选项是一个把这个类[class]当作整体的选项. 以下类选项是可用的:

            这个 :default-initargs 类选项后面跟着一个交替的初始化参数名字[name]和默认初始化值表达式形式的列表. 如果这些初始化参数中的任何一个没有出现在提供给 make-instance 的初始化列表中, 对应的默认初始值表达式形式就会被求值, 并且这个初始化参数名字[name]和这个表达式形式的值会在这个实例被创建前被添加到这个初始化参数列表的末尾; 见章节 7.1 (对象创建和初始化). 默认初始值表达式形式在每次被使用时都会求值. 这个表达式形式被求值时所在词法环境是 defclass 表达式形式被求值时所在词法环境. 而动态环境是 make-instance 被调用时所处的动态环境. 如果一个初始化参数名字[name]在一个 :default-initargs 槽选项中出现不止一次, 就会发出一个错误.

            这个 :documentation 类选项导致一个文档字符串[documentation string]被绑定到这个类[class]对象[object], 以及以 type 种类绑定到 class-name 上. :documentation 最多只能被提供一次.

            这个 :metaclass 类选项用于指定这个要被定义的类[class]的实例有着不同的元类, 而不是系统提供的默认值(类[class] standard-class).

        注意以下这些标准类[standard class]的 defclass 的规则:

            一个类[class]的超类[superclass]不需要在这个类[class]的 defclass 表达式形式被求值前被定义.

            一个类[class]的所有超类[superclass]必须在这个类[class]的一个实例[instance]被创建前被定义.

            一个类[class]必须在它被用作 defmethod 表达式形式中的参数特化符之前被定义.

        对象系统可以扩展, 以覆盖不遵守这些规则的情况.

        某些槽选项被一个类[class]从它的超类[superclass]中继承下来, 并且某些可以通过提供一个局部槽描述来遮蔽或修改. 除了 :default-initargs 以外没有其他类选项被继承. 关于槽[slot]和槽选项如何被继承的详情, 见章节 7.5.3 (槽和槽选项的继承).

        给 defclass 的选项可以被扩展. 如果一个具体实现发现一个类选项或一个槽选项没有被本地实现, 那么这个具体实现就需要去发出一个错误.

        为一个槽[slot]指定超过一个的 reader, writer, accessor, 或初始化参数是有效的. 没有其他槽选项可以在单个槽描述中出现超过一次, 否则就发出一个错误.

        如果没有为一个槽[slot]指定 reader, writer, 和 accessor, 那么这个槽[slot]只能通过函数[function] slot-value 来访问.

        如果一个 defclass 表达式形式[form]作为一个顶层表达式形式[top level form]出现, 编译器[compiler]必须使这个类[class]的名字[name]在后面的声明中(就像 deftype)被识别为一个有效的类型[type]名字[name], 被识别为一个 defmethod 的参数特化符[parameter specializer]的有效的类[class]的名字[name]并且可以用作后面的 defclass 的 :metaclass 选项. 当 find-class 的 environment 实参[argument]是作为一个宏[macro]的环境参数[environment parameter]接收到的值时, 编译器[compiler]必须使可用的类[class]定义能够被它返回.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果这里有任何槽名字重复, 就会发出一个 program-error 类型[type]的错误.

        如果一个初始化参数名字[name]不止一次出现在 :default-initargs 类选项中, 就会发出一个 program-error 类型[type]的错误.

        如果在单个槽描述中下面的任何一个槽选项出现超过一次, 就会发出一个 program-error 类型[type]的错误: :allocation, :initform, :type, :documentation.

        如果具体实现发现一个类选项或一个槽选项没有被本地实现, 所有这样的实现都需要去发出一个 program-error 类型[type]的错误.

* 参见(See Also):

        documentation, initialize-instance, make-instance, slot-value, 章节 4.3 (类), 章节 4.3.4 (继承), 章节 4.3.6 (重定义类), 章节 4.3.5 (确定类优先级列表), 章节 7.1 (对象创建和初始化)

* 注意(Notes): None. 


### <span id="M-DEFGENERIC">宏 DEFGENERIC</span>

* 语法(Syntax):

        defgeneric function-name gf-lambda-list [[option | {method-description}*]]
        => new-generic

        option::= (:argument-precedence-order parameter-name+) | 
                  (declare gf-declaration+) | 
                  (:documentation gf-documentation) | 
                  (:method-combination method-combination method-combination-argument*) | 
                  (:generic-function-class generic-function-class) | 
                  (:method-class method-class) 

        method-description::= (:method method-qualifier* specialized-lambda-list [[declaration* | documentation]] form*) 

* 参数和值(Arguments and Values):

        function-name---一个函数名字[function name].
        generic-function-class---命名一个类[class]的非 nil [non-nil]符号[symbol].
        gf-declaration---一个 optimize 声明指定符[declaration specifier]; 不允许其他声明指定符[declaration specifier].
        gf-documentation---一个字符串[string]; 不求值.
        gf-lambda-list---一个广义函数 lambda 列表[generic function lambda list].
        method-class---命名一个类[class]的非 nil [non-nil]符号[symbol].
        method-combination-argument---一个对象.
        method-combination-name---命名一个方法组合[method combination]类型[type]的符号[symbol].
        method-qualifiers, specialized-lambda-list, declarations, documentation, forms---根据 defmethod.
        new-generic---这个广义函数[generic function]对象[object].
        parameter-name---在 lambda-list 中命名一个必要参数[required parameter]的符号[symbol]. (如果 :argument-precedence-order 选项被指定, 在 lambda-list 中的每个必要参数[required parameter]必须必须被作为 parameter-name 准确使用一次.)

* 描述(Description):

        宏 defgeneric 被用于定义一个广义函数[generic function]或用来指定属于整个广义函数[generic function]的选项和声明.

        如果 function-name 是一个列表[list]那么它必须是 (setf symbol) 形式. 如果 (fboundp function-name) 是 false, 一个新的广义函数[generic function]就会被创建. 如果 (fdefinition function-name) 是一个广义函数[generic function], 那么这个广义函数[generic function]就会被修改. 如果 function-name 命名了一个普通函数[ordinary function], 一个宏[macro], 或者一个特殊操作符[special operator], 就会发出一个错误.

        这个 defgeneric 宏的效果就好像执行了下面三步: 首先, 通过前面的 defgeneric 表达式形式[form]定义的方法[method]会被移除; 其次, ensure-generic-function 会被调用; 最终, 通过当前 defgeneric 表达式形式[form]指定的方法[method]会被添加到这个广义函数[generic function]中.

        每个 method-description 在这个广义函数[generic function]上定义一个方法[method]. 每个方法[method]的 lambda 列表[lambda list]必须和 gf-lambda-list 选项指定的 lambda 列表[lambda list]一致. 如果没有指定方法[method]描述并且相同名字的广义函数[generic function]不存在, 一个没有方法[method]的广义函数[generic function]会被创建.

        defgeneric 的 gf-lambda-list 参数指定了这个广义函数[generic function]上的方法[method]的 lambda 列表[lambda list]的外形. 在产生的这个广义函数[generic function]上的所有方法[method]必须有着和这个外形一致的 lambda 列表[lambda list]. 如果一个 defgeneric 表达式形式被求值并且这个广义函数[generic function]的一些方法[method]有着和这个 defgeneric 表达式形式中被给定的不一致的 lambda 列表[lambda list], 就会发出一个错误. 关于方法一致性的详情, 见章节 7.6.4 (广义函数的所有方法的一致 Lambda-list).

        广义函数[generic function]把所有给它的参数值传递给方法[method], 并且只有那些参数; 不支持默认值. 注意, 方法定义中的可选参数和关键字参数可以有默认初始值表达式形式并且可以使用 supplied-p 参数.

        支持以下选项. 除非另有说明, 一个给定选项只能出现一次.

            在选择一个特定的方法[method]时, 这个 :argument-precedence-order 选项被用于指定在这个广义函数[generic function]的一个调用中检查必要参数特化度的顺序. 每个在 gf-lambda-list 参数中指定的必要参数, 必须作为一个 parameter-name 被包含一次, 这样才能提供完整且无歧义的优先级顺序. 如果这个条件没有满足, 就会出现一个错误.

            这个 declare 选项被用于指定属于这个广义函数[generic function]的声明.

            一个 optimize 声明指定符[declaration specifier]是允许的. 它指定了方法选择是否要对速度或空间进行优化, 但是它在方法[method]上无效. 为了控制一个方法[method]如何被优化, 一个 optimize 声明必须直接放置在 defmethod 表达式形式[form]或方法[method]描述中. 优化特性 speed 和 space 是这个标准要求的仅有的特性, 但是一个具体实现可以扩展这个对象系统来识别其他特性. 一个只有一种方法选择技术并且忽略 optimize 声明指定符[declaration specifier]的简单实现是有效的.

            special, ftype, function, inline, notinline, 以及 declaration 声明是不允许的. 个别具体实现可以去扩展这个 declare 选项来支持额外的声明. 如果一个具体实现注意到一个不支持的声明指定符[declaration specifier]并且没有在一个 declaration 公告[proclamation]中被声明为一个非标准声明标识符[declaration identifier]的名字, 它应该提出一个警告.

            这个 declare 选项可以被多次指定. 效果和这些声明指定符[declaration specifier]列表被一起追加到同一个列表中并指定单个 declare 选项是一样的.

            这个 :documentation 参数是一个绑定给这个广义函数[generic function]对象[object]的文档字符串[documentation string], 并且以 function 种类绑定给 function-name.

            这个 :generic-function-class 选项可以被用来指定这个广义函数[generic function]去拥有一个不一样的类, 而不是系统提供的默认值(类[class] standard-generic-function). 这个 class-name 参数是一个类[class]的名字, 这个类[class]可以是广义函数[generic function]的类[class]. 如果 function-name 指定了一个已存在的广义函数[generic function], 这个广义函数有着不同的 :generic-function-class 参数值并且这个新的广义函数类[class]和旧的兼容, 那么 change-class 会被调用来修改这个广义函数[generic function]的类[class]; 否则就发出一个错误.

            这个 :method-class 选项被用于指定这个广义函数[generic function]上的所有方法[method]都有着和提供提供的默认值(类[class] standard-method)不同的类[class]. 这个 class-name 参数是一个能够成为一个方法[method]类[method]的类[name]的名字.

            这个 :method-combination 选项后面跟着一个命名一个方法组合类型的符号. 跟在该符号后面的参数(如果有的话)取决于方法组合的类型. 注意, 标准方法组合类型不支持任何参数. 然而, 通过 define-method-combination 的短表达式形式定义的所有方法组合的类型都接受一个名为 order 的可选参数, 默认为 :most-specific-first, 在这里一个 :most-specific-last 的值在不影响辅助方法[method]顺序的情况下倒转主方法[method]的顺序.

        这个 method-description 参数定义了和这个广义函数[generic function]关联的方法[method]. 在一个方法描述中的 method-qualifier 和 specialized-lambda-list 参数和 defmethod 中的是一样的.

        这个 form 参数指定这个方法的主体(body). 这个方法[method]的主体闭合在一个隐式语句块[implicit block]中. 如果 function-name 是一个符号[symbol], 这个语句块就具有和这个广义函数[generic function]相同的名字. 如果 function-name 是一个 (setf symbol) 形式的一个列表, 这个语句块的名字就是 symbol.

        具体实现可以去扩展 defgeneric 来包含其他选项. 如果一个具体实现发现一个选项没有被本地实现, 它就需要去发出一个错误.

        defgeneric 不需要去执行任何编译时的副作用. 尤其是, 这些方法[method]不会为了在编译时调用而被设置. 一个具体实现[implementation]可以选择为了编译时错误检查的目的去存储关于这个广义函数[generic function]的信息 (比如在调用上检查参数数量, 或者记录这个函数名的定义已经出现过).

* 示例(Examples):

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 function-name 命名一个普通函数[ordinary function], 一个宏[macro], 或者一个特殊操作符[special operator], 就会发出一个 program-error 类型[type]的错误.

        每个必要参数, 如 gf-lambda-list 参数中所指定的, 必须作为一个 parameter-name 被准确包含一次, 否则就会发出一个 program-error 类型[type]的错误.

        通过一个 method-description 指定的每个方法[method]的 lambda 列表[lambda list]必须和 gf-lambda-list 选项指定的 lambda 列表[lambda list]一致, 否则就会发出一个 error 类型[type]的错误.

        如果一个 defgeneric 表达式形式被求值并且这个广义函数[generic function]的某些方法[method]拥有和这个 defgeneric 表达式形式中给定的不一致的 lambda 列表[lambda list], 就会发出一个 error 类型[type]的错误.

        一个给定的选项 option 只能出现一次, 否则就会发出一个 program-error 类型[type]的错误.

        如果 function-name 指定一个已存在且有着不同 :generic-function-class 参数的值的广义函数[generic function]而这个新的广义函数类[class]和旧的兼容, change-class 会被调用来改变这个广义函数[generic function]的类[class]; 否则就会发出一个 error 类型[type]的错误.

        具体实现可以去扩展 defgeneric 来包含其他选项. 如果一个具体实现发现一个选项没有被本地实现, 它就需要去发出一个 program-error 类型[type]的错误.

* 参见(See Also):

        defmethod, documentation, ensure-generic-function, generic-function, 章节 7.6.4 (广义函数的所有方法的一致 Lambda-list)

* 注意(Notes): None. 


### <span id="M-DEFMETHOD">宏 DEFMETHOD</span>

* 语法(Syntax):

        defmethod function-name {method-qualifier}* specialized-lambda-list [[declaration* | documentation]] form*
        => new-method

        function-name::= {symbol | (setf symbol)}

        method-qualifier::= non-list

        specialized-lambda-list::= ({var | (var parameter-specializer-name)}* 
                                    [&optional {var | (var [initform [supplied-p-parameter] ])}*] 
                                    [&rest var] 
                                    [&key{var | ({var | (keywordvar)} [initform [supplied-p-parameter] ])}*
                                        [&allow-other-keys] ] 
                                    [&aux {var | (var [initform] )}*] ) 
        parameter-specializer-name::= symbol | (eql eql-specializer-form)

* 参数和值(Arguments and Values):

        declaration---一个 declare 表达式[expression]; 不求值.
        documentation---一个字符串[string]; 不求值.
        var---一个变量[variable]名[name].
        eql-specializer-form---一个表达式形式[form].
        Form---一个表达式形式[form].
        Initform---一个表达式形式[form].
        Supplied-p-parameter---变量名.
        new-method---新的方法[method]对象[object].

* 描述(Description):

        宏 defmethod 在一个广义函数[generic function]上定义方法[method].

        如果 (fboundp function-name) 是 nil, 就会创建一个广义函数[generic function], 其中采用参数优先级顺序 (每个参数都比这个参数列表中它右边的参数更具体), 默认的广义函数的类 (类[slass] standard-generic-function), 方法的类 (类[class] standard-method), 方法组合类型 (标准方法组合类型) 的默认值. 这个广义函数[generic function]的 lambda 列表[lambda list]和这个被定义的方法[method]一致; 如果这个 defmethod 表达式形式提及关键字参数, 那么广义函数[generic function]的 lambda 列表[lambda list]也会提及 ..... key (但是没有关键字参数). 如果 function-name 命名一个普通函数[ordinary function], 一个宏[macro], 或者一个特殊操作符[special operator], 就会发出一个错误.

        如果 function-name 当前命名一个广义函数[generic function], 这个方法的 lambda 列表[lambda lsit]必须和这个广义函数[generic function]的一致. 如果不满足这个条件, 就会发出一个错误. 对于在这个上下文中的一致性定义, 见章节 7.6.4 (广义函数的所有方法的一致 Lambda-list).

        每个 method-qualifier 参数是一个被方法组合用于识别这个给定方法的对象[object]. 方法组合类型可能会进一步限制可以是哪些方法限定符[qualifier]. 标准方法组合类型允许非限定方法[unqualified method]和单个限定符[qualifier]是关键字 :before, :after, 或 :around 之一的方法[method].

        这个 specialized-lambda-list 参数和一个普通 lambda 列表[lambda list]类似, 除了必要参数的名字被特化参数替代. 一个特化参数是表达式形式 (var parameter-specializer-name) 的列表. 只有必要参数可以被特化. 如果 parameter-specializer-name 是一个符号[symbol], 它就命名一个类[class]; 如果它是一个列表[list], 它就是表达式形式 (eql eql-specializer-form). 这个参数特化符名字 (eql eql-specializer-form) 表示对应的参数必须和要被应用的这个方法[method]的 eql-specializer-form 的值对象[object]是 eql 的. 这个 eql-specializer-form 在这个 defmethod 宏展开被求值的时候被求值. 如果一个给定的必要参数没有指定参数特化符名字[parameter specializer name], 那么这个参数特化符[parameter specializer]默认是类[class] t. 关于进一步讨论, 见章节 7.6.2 (方法的介绍).

        这个 form 参数指定这个方法的主体. 这个方法[method]的主体被闭合在一个隐式语句块[implicit block]中. 如果 function-name 是一个符号[symbol], 这个语句块具有和这个广义函数[generic function]相同的名字[name]. 如果 function-name 是一个 (setf symbol) 形式的列表[list], 那么这个语句块的名字[name]是 symbol.

        这个被创建的方法[method]对象[object]的类[class]是这个方法[method]定义所在的广义函数[generic function]的方法类选项给定的.

        如果这个广义函数[generic function]已经有一个和要被定义的方法[method]在参数特化符[parameter specializer]和限定符[qualifier]上一样的方法[method], defmethod 用现在要被定义的那个来替换已存在的方法[method]. 关于这个上下文的一致性定义. 见章节 7.6.3 (关于参数特化符和限定符的一致性).

        这些参数特化符[parameter specializer]源自于章节 7.6.2 (方法的介绍) 中描述的参数特化符名字[parameter specializer name].

        这个 defmethod 宏的展开式 "引用" 每一个特化参数 (见 declare 描述中的 ignore 的描述). 这个包括拥有显式参数特化符名字[parameter specializer name] t 的参数. 这个就意味着, 如果这个方法[method]的主体没有引用一个特化的参数, 那么编译器不会发出警告, 而在这个方法[method]的主体没有引用一个未特化参数时可能发出警告. 出于这个原因, 在这个上下文中一个在 t 上特化的参数不太等同于一个未特化的参数.

        在这个方法体头部的应用于这个方法的 lambda 变量[lambda variable]的声明被当作是绑定声明[bound declaration], 它的作用域[scope]和对应绑定[binding]相同.

        在这个方法主体的头部应用于 call-next-method 或 next-method-p 的函数绑定的声明可应用于这个方法的主体表达式形式 forms 中对这个方法的引用. 任何更外部的函数名[function name]为 call-next-method 和 next-method-p 的绑定[binding], 以及和这样的绑定[binding]相关联的声明在这个方法主体表达式形式 forms 中都会被遮蔽[shadow].

        在这个方法主体的头部的自由声明[free declaration]的作用域[scope]是整个方法主体, 它包括任何隐式的局部方法定义但是不包括这些 lambda 变量[lambda list]的初始化表达式形式[initialization form].

        defmethod 不需要执行任何编译时副作用. 尤其是, 这个方法[method]不会为了在编译期间调用而被设置. 一个具体实现[implementation]可以选择为了编译时的错误检查去存储关于这个广义函数[generic function]的信息 (比如在调用上检查参数数量, 或者记录这个函数名的定义已经出现过).

        documentation 作为文档字符串[documentation string]关联给这个方法[method]对象[object].

* 示例(Examples): None.

* 受此影响(Affected By):

        引用的广义函数[generic function]的定义.

* 异常情况(Exceptional Situations):

        如果 function-name 命名一个普通函数[ordinary function], 一个宏[macro], 或者一个特殊操作符[special operator], 那么就会发出一个 error 类型[type]的错误.

        如果 function-name 当前命名一个广义函数[generic function], 那么这个方法[method]的 lambda 列表[lambda list]必须和这个广义函数[generic function]的一致, 否则就会发出一个 error 类型[type]的错误.

* 参见(See Also):

        defgeneric, documentation, 章节 7.6.2 (方法的介绍), 章节 7.6.4 (广义函数的所有方法的一致 Lambda-list), 章节 7.6.3 (关于参数特化符和限定符的一致性), 章节 3.4.11 (文档字符串和声明的语法交互)

* 注意(Notes): None. 


### <span id="A-FIND-CLASS">访问器 FIND-CLASS</span>

* 语法(Syntax):

        find-class symbol &optional errorp environment => class

        (setf (find-class symbol &optional errorp environment) new-class)

* 参数和值(Arguments and Values):

        symbol---一个符号[symbol].

        errorp---一个广义 boolean [generalized boolean]. 默认是 true.

        environment -- 和给宏展开函数的 &environment 参数一样并且被用于区分编译时和运行时环境. 这个 &environment 有着动态范围[dynamic extent]; 如果这个 &environment 参数在这个宏展开函数的动态范围[dynamic extent]之外被引用, 那么结果是未定义的.

        class---一个类[class]对象[object], 或 nil.

* 描述(Description):

        返回在这个环境 environment 中由符号 symbol 命名的类[class]对象[object]. 如果这里没有这样一个类[class], 如果 errorp 是 false 就返回 nil; 否则, 如果 errorp 是 true, 就会发出一个错误.

        这个和特定符号[symbol]关联的类[class]可以通过用 find-class 和 setf 去改变; 或者, 如果给 setf 的新的类[class]是 nil, 这个类[class]关联就会被移除 (但是这个类[class]对象[object]自身不会被影响). 如果用户尝试去改变或移除一个在这个标准中被定义为类型指定符[type specifier]的符号[symbol]所关联的类[class], 结果是未定义的. 见章节 4.3.7 (整合类和类型).

        当使用 find-class 的 setf 时, 任何 errorp 参数会为了效果被求值, 但是它返回的任何值[value]都会被忽略; 这个 errorp 形参[parameter]首先被允许, 这样就可以使用这个 environment 形参[parameter].

        这个环境 environment 可能被用于区分编译时环境和运行时环境.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果这里没有这样一个类[class]并且 errorp 是 true, find-class 会发出一个 error 类型[type]的错误.

* 参见(See Also):

        defmacro, 章节 4.3.7 (整合类和类型)

* 注意(Notes): None. 


### <span id="LF-NEXT-METHOD-P">局部函数 NEXT-METHOD-P</span>

* 语法(Syntax):

        next-method-p <no arguments> => generalized-boolean

* 参数和值(Arguments and Values):

        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        这个局部定义的函数 next-method-p 可以在一个方法定义表达式形式[method-defining form]所定义的主体表达式形式[form]中(而不是 lambda 列表[lambda list])被用来确定是否存在下一个方法[method].

        函数[function] next-method-p 有着词法作用域[lexical scope]和无限范围[indefinite extent].

        这个 next-method-p 在全局环境[global environment]中是否是 fbound 的依赖于具体实现[implementation-dependent]; 然而, 这个 next-method-p 的重定义和遮蔽上的限制和 COMMON-LISP 包中在全局环境[global environment]中被 fbound 的符号[symbol]一样. 尝试在一个方法定义表达式形式[method-defining form]外部使用 next-method-p 的后果是未定义的.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        call-next-method, defmethod, call-method

* 注意(Notes): None. 


### <span id="LM-CALL-METHOD-MAKE-METHOD">局部宏 CALL-METHOD, MAKE-METHOD</span>

* 语法(Syntax):

        call-method method &optional next-method-list => result*

        make-method form => method-object

* 参数和值(Arguments and Values):

        method---一个方法[method]对象[object], 或者一个列表[list] (见下方); 不求值.
        method-object---一个方法[method]对象[object].
        next-method-list---一个方法对象的列表[list]; 不求值.
        results---这个方法[method]调用返回的值[value].

* 描述(Description):

        宏 call-method 被用于方法组合. 它隐藏了依赖于具体实现[implementation-dependent]的方法[method]如何被调用的细节. 宏 call-method 有词法作用域[lexical scope]并且只能在有效方法[effective method]表达式形式[form]中被使用.

        call-method 在全局环境[global environment]中是否为 fbound 依赖于具体实现[implementation-dependent]; 然而, 在 call-method 的重定义和遮蔽上的限制和那些 COMMON-LISP 包中在全局环境[global environment]里是 fbound 的符号[symbol]一样. 尝试在一个有效方法[effective method]表达式形式[form]外部使用 call-method 的后果是未定义的.

        宏 call-method 调用指定的方法[method], 把参数还有 call-next-method 和 next-method-p 的定义提供给它. 如果这个 call-method 的调用词法上在 make-method 的内部, 参数是提供给那个方法[method]的那些. 否则参数是提供给那个广义函数的那些. 这个 call-next-method 和 next-method-p 的定义依赖指定的 next-method-list.

        如果 method 是一个列表[list], 那么这个列表[list]的第一个元素必须是 make-method 并且第二个元素必须是一个表达式形式[form]. 这样一个列表[list]指定了一个方法[method]函数的主体为给定表达式形式[form]的方法[method]对象[object].

        这个 next-method-list 可以包含多个方法[method]对象[object]或列表[list], 这个列表的第一个元素必须是 make-method 并且第二个元素必须是一个表达式形式[form].

        那些是仅有的可以使用 make-method 的两处位置. 和 make-method 一起使用的那个表达式形式[form]在空词法环境[null lexical environment]中被求值, 这个空词法环境被一个 call-method 的局部宏定义和 COMMON-LISP-USER 包中不是可访问[accessible]符号所命名的绑定所扩展.

        对方法 method 可用的 call-next-method 会调用 next-method-list 中的第一个方法[method]. 在那个方法[method]中可用的 call-next-method 函数依次会调用 next-method-list 中的第二个方法[method], 以此类推, 直到下一个方法[method]的列表耗尽.

        如果没有提供 next-method-list, 对 method 可用的 call-next-method 函数发出一个 control-error 类型[type]的错误并且对 method 可用的这个 next-method-p 函数返回 nil.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        call-next-method, define-method-combination, next-method-p

* 注意(Notes): None. 


### <span id="LF-CALL-NEXT-METHOD">局部函数 CALL-NEXT-METHOD</span>

* 语法(Syntax):

        call-next-method &rest args => result*

* 参数和值(Arguments and Values):

        arg---一个对象[object].
        results---由它调用的方法[method]所返回的值[value].

* 描述(Description):

        函数[function] call-next-method 可以在一个通过方法定义表达式形式[method-defining form]定义的方法[method]的主体表达式形式[form]中(但不包括 lambda 列表[lambda list])被用来调用下一个方法[next method].

        如果没有下一个方法[method], 那么广义函数 no-next-method 会被调用.

        使用的方法组合的类型决定哪些方法[method]可以调用 call-next-method. 标准方法组合[method combination]类型允许 call-next-method 在主方法[method]和 around 方法[around method]中被使用. 对于使用通过 define-method-combination 的短表达式形式定义的方法组合类型的方法, call-next-method 只能被用于 around 方法[around method].

        当 call-next-method 以无参数的情况被调用, 它传递当前方法[method]的原始参数给下一个方法[method]. 不管是参数缺省, 还是使用 setq, 或者重新绑定与方法[method]参数相同名字[name]变量, 都不会影响 call-next-method 传递给它所调用的方法[method]的值.

        当用参数调用 call-next-method 时, 会用这些参数来调用下一个方法[next method].

        如果用参数调用了 call-next-method 但是省略了可选参数, 那么省略那些参数来调用下一个方法[next method].

        函数[function] call-next-method 返回下一个方法[next method]返回的任何值[value].

        函数[function] call-next-method 有着词法作用域[lexical scope]和无限范围[indefinite extent]并且只能在一个通过方法定义表达式形式[method-defining form]定义的方法[method]的主体中被使用.

        这个 call-next-method 在全局环境[global environment]中是否为 fbound 依赖于具体实现[implementation-dependent]; 然而, 在 call-next-method 的重定义和遮蔽上的约束和 COMMON-LISP 包里在全局环境[global environment]中被 fbound 的方法[method]一样. 尝试在一个方法定义表达式形式[method-defining form]的外部去使用 call-next-method 的后果是不确定的.

* 示例(Examples): None.

* 受此影响(Affected By):

        defmethod, call-method, define-method-combination.

* 异常情况(Exceptional Situations):

        当给 call-next-method 提供参数时, 下面的规则必须被满足, 否则就会发出一个 error 类型[type]的错误: 对于 call-next-method 的一个被改变的参数集的可应用方法[applicable method]有序集必须和这个广义函数[generic function]的原始参数的可应用方法[applicable method]有序集相同. 错误检查的优化是可以的, 但是它们不能改变 call-next-method 的语义.

* 参见(See Also):

        define-method-combination, defmethod, next-method-p, no-next-method, call-method, 章节 7.6.6 (方法选择和组合), 章节 7.6.6.2 (标准方法组合), 章节 7.6.6.4 (内建的方法组合类型)

* 注意(Notes): None. 


### <span id="SGF-COMPUTE-APPLICABLE-METHODS">标准广义函数 COMPUTE-APPLICABLE-METHODS</span>

* 语法(Syntax):

        compute-applicable-methods generic-function function-arguments => methods

* 方法签名(Method Signatures):

        compute-applicable-methods (generic-function standard-generic-function)

* 参数和值(Arguments and Values):

        generic-function---一个广义函数[generic function].
        function-arguments---这个广义函数 generic-function 的参数列表[list].
        methods---一个方法[method]对象[object]列表[list].

* 描述(Description):

        给定一个 generic-function 和一个 function-arguments 集合, 函数 compute-applicable-methods 返回可应用于这些根据优先级顺序排序后的参数的方法[method]集合. 见章节 7.6.6 (方法选择和组合).

* 受此影响(Affected By):

        defmethod

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        章节 7.6.6 (方法选择和组合)

* 注意(Notes): None. 


### <span id="M-DEFINE-METHOD-COMBINATION">宏 DEFINE-METHOD-COMBINATION</span>

* 语法(Syntax):

        define-method-combination name [[short-form-option]]
        => name

        define-method-combination name lambda-list (method-group-specifier*) [(:arguments . args-lambda-list)] [(:generic-function generic-function-symbol)] [[declaration* | documentation]] form*
        => name

        short-form-option::= :documentation documentation |  
                            :identity-with-one-argument identity-with-one-argument | 
                            :operator operator 

        method-group-specifier::= (name {qualifier-pattern+ | predicate} [[long-form-option]]) 

        long-form-option::= :description description | 
                            :order order | 
                            :required required-p 

* 参数和值(Arguments and Values):

        args-lambda-list---一个 define-method-combination 参数 lambda 列表[define-method-combination arguments lambda list].
        declaration---一个 declare 表达式形式[expression]; 不求值.
        description---一个格式化控制[format control].
        documentation---一个字符串[string]; 不求值.
        forms---一个必须计算并返回指定这些方法[method]如何组合的表达式形式[form]的隐式的 progn [implicit progn], 这也就是说, 那个有效方法[effective method].
        generic-function-symbol---一个符号[symbol].
        identity-with-one-argument---一个广义 boolean [generalized boolean].
        lambda-list---普通 lambda 列表[ordinary lambda list].
        name---一个符号[symbol]. 通常使用非关键字[keyword], 非 nil [non-nil]的符号[symbol].
        operator---一个操作符[operator]. 这个名字 name 和操作符 operator 经常是相同[same]符号[symbol]. 这是默认的, 但不是必须的.
        order---:most-specific-first 或 :most-specific-last; 求值的.
        predicate---命名一个单参数并返回一个广义 boolean [generalized boolean]的函数[function]的一个符号[symbol].
        qualifier-pattern---一个列表[list], 或者符号[symbol] *.
        required-p---一个广义 boolean [generalized boolean].

* 描述(Description):

        宏 define-method-combination 被用于定义新的方法组合类型.

        这里有两个 define-method-combination 形式. 短表达式形式是一个简单的工具, 用于最常见的情况. 长表达式形式更强大但也更繁琐. 它类似于 defmacro , 其中的主体是一个表达式, 通常使用反引号, 那个表达式计算一个表达式形式[form]. 因此可以实现任意控制结构. 长表达式形式也允许任意方法限定符[qualifier]的处理.

        短表达式形式

            当 define-method-combination 的第二个子表达式形式[subform]是非 nil [non-nil]的符号或不存在时, 确认为它的短表达式形式语法. 当使用这个短表达式形式时, 名字 name 被定义为一个产生一个 Lisp 表达式形式 (operator method-call method-call ...) 的方法组合类型 . 这个 operator 是一个符号[symbol], 它可以是一个函数[function], 宏[macro], 或者特殊操作符[special operator]的名字. 这个 operator 可以通过一个关键字选项来提供; 它默认为 name.

            以下是短表达式形式的关键字选项:

                这个 :documentation 选项被用于记录这个 method-combination 类型; 参见下面的长表达式形式的描述.

                这个 :identity-with-one-argument 选项在它的值为 true 时(默认是 false)时启用一个优化. 如果这里只有一个可应用方法并且它是一个主方法, 那个方法当作有效方法并且操作符 operator 不会被调用. 这个优化避免去创建一个新的有效方法并且避免了一个方法[function]调用的开销. 这个选项被设计来和 progn, and, +, 和 max 这样的操作符一起使用.

                这个 :operator 选项指定这个操作符的名字[name]. 这个操作符 operator 参数是一个符号[symbol], 这个符号可以为一个函数[function], 宏[macro], 或特殊表达式形式[special form]的名字[name].

            这些方法组合的类型必须一个方法一个限定符[qualifier]. 如果这里这里存在无限定符[qualifier]或有着这个方法组合类型不支持的限定符[qualifier], 就会发出一个错误.

            以这种方法定义的一个方法组合过程识别两种角色的方法. 一个方法, 当它的一个限定符[qualifier]是命名这个方法组合类型的符号时, 这个方法被定义为一个主方法. 至少一个主方法必须是可应用的, 否则就会发出一个错误. 一个限定符[qualifier]为 :around 的方法是一个辅助方法, 它表现地和标准方法组合类型中的 around 方法[around method]一样. 函数[function] call-next-method 只能被用于 around 方法[around method]中; 它不能被用于 define-method-combination 宏的短表达式形式定义的主方法中.

            以这种方式定义的一个方法组合过程接受一个名为 order 的可选参数, 它默认为 :most-specific-first. 一个 :most-specific-last 值在不影响辅助方法顺序的情况下倒转这个主方法的顺序.

            这个短表达式形式自动包括错误检查和 around 方法[around method]的支持.

            对于一个内建方法组合类型的讨论, 见章节 7.6.6.4 (内建的方法组合类型).

        长表达式形式

            当 define-method-combination 的第二个子表达式形式[subform]为一个列表时, 确认为它的长表达式形式语法.

            这个 lambda-list 接受给 defgeneric 的 :method-combination 选项中的方法组合类型的名字[name]后面的任何参数.

            后面是一个方法组指定符的列表. 每个指定符选择可应用方法的子集来扮演特定的角色, 通过匹配某些模式的限定符[qualifier], 或者使用一个断言 predicate 来测试它们的限定符[qualifier]. 这些方法组指定符定义了所有可以和这个方法组合类型一起使用的方法限定符[qualifier].

            每个 method-group-specifier 的 car 是一个命名一个变量[variable]的符号[symbol]. 在 define-method-combination 的主体中的表达式形式[form]的执行期间, 这个变量[variable]被绑定为这个方法组中的一个方法[method]列表. 这个列表中的方法[method]以 :order 选项指定的顺序出现.

            如果限定符模式 qualifier-pattern 是一个符号[symbol]那么它必须是 *. 如果一个方法的限定符[qualifier]列表和一个限定符模式 qualifier-pattern 是 equal 的(在一个 qualifier-pattern 中除了这个符号 * 是匹配任何东西), 那么这个方法匹配这个限定符模式 qualifier-pattern. 因此一个 qualifier-pattern 可以是以下之一: 空列表[empty list], 它匹配非限定方法[unqualified method]; 符号[symbol] *, 它匹配所有方法; 一个真实的列表, 它匹配带有和这个列表长度相同数量限定符[qualifier]的方法, 并且其中每个限定符[qualifier]匹配这个列表的元素; 或者一个以 * 结尾的点对列表(这个 * 匹配任何数量的额外限定符[qualifier]).

            每个可应用方法都是根据限定符模式 qualifier-patterns 和断言 predicate 以从左到右的顺序来检测. 在一个 qualifier-pattern 匹配后或一个断言 predicate 返回 true, 这个方法就成为对应方法组的一个成员并且不会做进一步检测. 因此如果一个方法可以是超过一个方法组的一个成员, 它只加入到第一个这样的组中. 如果一个方法组有超过一个限定符模式 qualifier-pattern, 一个方法只需要返回这些 qualifier-patterns 中的一个就可以称为这个组的成员.

            一个断言 predicate 函数的名字[name]可以出现在一个方法组指定符中, 替换限定符模式  qualifier-patterns. 这个断言 predicate 被每一个没有被赋给一个更早的方法组的方法所调用; 它用一个参数来调用, 那个方法的限定符[qualifier]列表[list]. 如果那个方法是这个方法组的一个成员, 那么这个 predicate 应该返回 true. 一个断言 predicate 可以和一个限定符模式 qualifier-pattern 区分开来因为它是一个符号[symbol]而不是 nil 或 *.

            如果这里有一个不属于任何方法组的可应用方法, 那么函数[function] invalid-method-error 会被调用.

            方法组指定符可以有关键字选项跟在这些限定符[qualifier]模式或断言后. 关键字选项有别于额外限定符[qualifier]模式因为它们既不是列表也不是符号 *. 这些关键字选项如下:

                这个 :description 选项被用于提供这个方法组中方法角色的描述. 编程环境工具使用 (apply #'format stream format-control (method-qualifiers method)) 来打印这个描述, 预计会很简介. 这个关键字选项允许一个方法限定符[qualifier]的描述被定义在定义这个方法限定符[qualifier]的意义的相同模块中. 大部分情况下, 格式化控制 format-control 不会包含任何 format 指令, 但是普遍上它们是可用的. 如果没有提供 :description, 会生成一个基于这个变量名和限定符[qualifier]模式还有这个方法组是否包含非限定方法[unqualified method]的默认描述.

                这个 :order 选项指定了这些方法的顺序. 这个 order 参数是一个求值为 :most-specific-first 或 :most-specific-last 的表达式形式[form]. 如果它求值为任何其他值, 就会发出一个错误. 如果没有提供 :order, 它默认为 :most-specific-first.

                这个 :required 选项指定这个方法组中是否至少需要一个方法. 如果它的值为 true 而这个方法组是空的 (也就是说, 没有匹配这个限定符[qualifier]模式或满足这个断言的可应用方法), 就会发出一个错误. 如果没有提供 :required, 它默认为 nil.

            这个方法组指定符的使用提供了一个方便的语法来选择方法, 来把它们划分给可能的角色, 并且去执行必要的错误检查. 在主体表达式形式[form]中通过使用正常的列表处理操作和函数[function] method-qualifiers 和 invalid-method-error 来执行方法的进一步过滤是可能的. 允许在方法组指定符中命名的变量上使用 setq, 也允许去绑定额外的变量. 绕开这个方法组指定符机制并在主体表达式形式[form]中执行任何操作都是可能的. 这个通过写一个单个方法组来完成, 其中 * 作为它仅有的限定符模式 qualifier-pattern; 这个变量接下来以最具体优先的顺序绑定为所有这些可应用方法[applicable method]的列表[list].

            主体表达式形式 forms 计算并返回指定这些方法如何组合的表达式形式[form], 换言之, 有效方法. 这个有效方法在一个空词法环境[null lexical environment]中被求值, 这个环境用 call-method 的局部宏定义和不是 COMMON-LISP-USER 包中可访问[accessible]的符号命名的绑定所扩充. 给定一个在由这些方法组指定符产生的其中一个列表[list]中的方法对象和一个下一个方法(next method)的列表[list], call-method 会调用那个方法, 这样 call-next-method 有可用的下一个方法(next method).

            当一个有效方法除了调用一个单独的方法之外没有其他效果, 一些具体实现采用一个优化, 使用这个单个的方法直接作为这个有效方法, 因此避免了创建一个新的有效方法的需要. 当有效方法表达式形式完全由一个 call-method 宏的调用组成, 并且它的第一个子表达式形式[subform]是一个方法对象而第二个子表达式形式是 nil 或未提供的, 那么这个优化就会被启用. 如果需要这种优化, 那么每个 define-method-combination 主体有责任去去除多余的 progn, and, multiple-value-prog1, 诸如此类的调用.

            列表 (:arguments . lambda-list) 可以出现在任何声明或文档字符串[documentation string]之前. 当这个方法组合类型执行一些特定的行为来作为组合方法的一部分并且这个行为需要访问给这个广义函数[generic function]的参数时, 这个表达式形式是很有用的. 每个由 lambda-list 定义的参数变量被绑定到一个表达式形式[form], 这个表达式形式可以被插入到这个有效方法中. 当这个表达式形式[form]在这个有效方法的执行期间被求值时, 它的值就是给这个广义函数[generic function]的对应参数; 在一个 setf 表达式形式[form]中使用这样一个表达式形式[form]作为一个位置 place 的后果是未定义的. 参数的匹配通过划分这个 :arguments 的 lambda-list 还有广义函数[generic function]的 lambda-list 为三个部分来计算: 必要参数[required parameter], 可选参数[optional parameter], 还有关键字[keyword]和剩余参数[rest parameter]. 为特定调用[call]提供给广义函数[generic function]的实参[argument]也被划分为三个部分; 必要实参[argument]部分包括这个广义函数[generic function]所拥有的必要参数[required parameter]相同数量的实参, 可选实参[argument]部分包含了这个广义函数[generic function]拥有的可选参数[optional parameter]数量相同的实参[argument], 以及关键字/剩余实参[argument]部分包含了剩余的参数. :arguments lambda-list 的必要和可选部分的每个形参[parameter]访问这些实参[argument]的对应部分中相同位置的参数. 如果 :arguments 的 lambda-list 的部分更短, 那么额外的实参[argument]就会被忽略. 如果这个 :arguments 的 lambda-list 的部分更长, 超出的必要参数[required parameter]绑定给求值为 nil 的表达式形式而超出的可选参数[optional parameter]被绑定[bound]给它们的初始化表达式形式. :arguments lambda-list 中的关键字参数[keyword parameter]和剩余参数[rest parameter]访问这些实参[argument]的关键字/剩余部分. 如果这个 :arguments 的 lambda-list 包含了 &key, 它表现为就好像它也包含了 &allow-other-keys.

            另外, &whole var 可以被放置在 :arguments lambda-list 的第一个. 这个导致 var 被绑定[bound]给一个表达式形式[form], 这个表达式形式求值[evaluate]为一个提供给这个广义函数[generic function]的所有实参[argument]的列表[list]. 这个和 &rest 不同因为它访问所有这些参数, 不只是关键字/剩余参数[argument].

            被这个主体检测到的错误状况应该使用 method-combination-error 或 invalid-method-error 来报告; 这些函数[function]添加任何必要的上下文信息给这个错误信息并且会发出一个合适的错误.

            这个主体表达式形式 forms 在这个 lambda 列表[lambda list]和方法组指定符创建的绑定[binding]中求值. 位于主体头部的声明直接位于 lambda 列表[lambda list]创建的绑定[binding]内部以及方法组变量绑定[binding]的外部. 因此方法组变量不能以这种方式声明. 但是 locally 可以在这个主体周围使用.

            在主体表达式形式 forms 中, generic-function-symbol 被绑定到这个广义函数[generic function]对象[object].

            Documentation 作为一个文档字符串[documentation string]关联到 name (作为 method-combination 种类) 以及这个方法组合[method combination]对象[object].

            注意, 两个有着相同特化符但是限定符[qualifier]不同的方法, 不会被章节 7.6.6 (方法选择和组合) 中描述方法选择和组合处理的步骤 2 中描述的算法所排序. 通常这两个方法在这个有效方法中扮演着不同的角色因为它们有不同的限定符[qualifier], 不管在那个步骤 2 的结果中如何被排序, 这个有效方法是相同的. 如果这两个方法扮演着相同的角色并且它们的顺序很重要, 就会发出一个错误. 这是在 define-method-combination 中匹配的限定符[qualifier]模式的一部分.

        如果一个 define-method-combination 表达式形式[form]作为顶层表达式形式[top level form]出现, 编译器[compiler]必须使这个方法组合[method combination]名字[name]在后续的 defgeneric 表达式形式中被识别为一个有效方法组合[method combination]名字[name]. 然而, 方法组合[method combination]执行的时间不早于 define-method-combination 表达式形式[form]被执行的时间, 并且可能在使用这个方法组合[method combination]的广义函数[generic function]执行的时候执行.

* 示例(Examples):

        define-method-combination 的长表达式形式的大多数例子也说明了作为声明式方法组合工具的一部分提供的相关函数[function]的使用.

    ```LISP
    ;;; Examples of the short form of define-method-combination
    
    (define-method-combination and :identity-with-one-argument t) 
      
    (defmethod func and ((x class1) y) ...)
    
    ;;; The equivalent of this example in the long form is:
    
    (define-method-combination and 
            (&optional (order :most-specific-first))
            ((around (:around))
              (primary (and) :order order :required t))
      (let ((form (if (rest primary)
                      `(and ,@(mapcar #'(lambda (method)
                                          `(call-method ,method))
                                      primary))
                      `(call-method ,(first primary)))))
        (if around
            `(call-method ,(first around)
                          (,@(rest around)
                            (make-method ,form)))
            form)))
      
    ;;; Examples of the long form of define-method-combination
    
    ;The default method-combination technique
    (define-method-combination standard ()
            ((around (:around))
              (before (:before))
              (primary () :required t)
              (after (:after)))
      (flet ((call-methods (methods)
                (mapcar #'(lambda (method)
                            `(call-method ,method))
                        methods)))
        (let ((form (if (or before after (rest primary))
                        `(multiple-value-prog1
                            (progn ,@(call-methods before)
                                  (call-method ,(first primary)
                                                ,(rest primary)))
                            ,@(call-methods (reverse after)))
                        `(call-method ,(first primary)))))
          (if around
              `(call-method ,(first around)
                            (,@(rest around)
                              (make-method ,form)))
              form))))
      
    ;A simple way to try several methods until one returns non-nil
    (define-method-combination or ()
            ((methods (or)))
      `(or ,@(mapcar #'(lambda (method)
                          `(call-method ,method))
                      methods)))
      
    ;A more complete version of the preceding
    (define-method-combination or 
            (&optional (order ':most-specific-first))
            ((around (:around))
              (primary (or)))
      ;; Process the order argument
      (case order
        (:most-specific-first)
        (:most-specific-last (setq primary (reverse primary)))
        (otherwise (method-combination-error "~S is an invalid order.~@
        :most-specific-first and :most-specific-last are the possible values."
                                              order)))
      ;; Must have a primary method
      (unless primary
        (method-combination-error "A primary method is required."))
      ;; Construct the form that calls the primary methods
      (let ((form (if (rest primary)
                      `(or ,@(mapcar #'(lambda (method)
                                          `(call-method ,method))
                                      primary))
                      `(call-method ,(first primary)))))
        ;; Wrap the around methods around that form
        (if around
            `(call-method ,(first around)
                          (,@(rest around)
                            (make-method ,form)))
            form)))
      
    ;The same thing, using the :order and :required keyword options
    (define-method-combination or 
            (&optional (order ':most-specific-first))
            ((around (:around))
              (primary (or) :order order :required t))
      (let ((form (if (rest primary)
                      `(or ,@(mapcar #'(lambda (method)
                                          `(call-method ,method))
                                      primary))
                      `(call-method ,(first primary)))))
        (if around
            `(call-method ,(first around)
                          (,@(rest around)
                            (make-method ,form)))
            form)))
      
    ;This short-form call is behaviorally identical to the preceding
    (define-method-combination or :identity-with-one-argument t)
    
    ;Order methods by positive integer qualifiers
    ;:around methods are disallowed to keep the example small
    (define-method-combination example-method-combination ()
            ((methods positive-integer-qualifier-p))
      `(progn ,@(mapcar #'(lambda (method)
                            `(call-method ,method))
                        (stable-sort methods #'<
                          :key #'(lambda (method)
                                    (first (method-qualifiers method)))))))
    
    (defun positive-integer-qualifier-p (method-qualifiers)
      (and (= (length method-qualifiers) 1)
            (typep (first method-qualifiers) '(integer 0 *))))
      
    ;;; Example of the use of :arguments
    (define-method-combination progn-with-lock ()
            ((methods ()))
      (:arguments object)
      `(unwind-protect
            (progn (lock (object-lock ,object))
                  ,@(mapcar #'(lambda (method)
                                `(call-method ,method))
                            methods))
          (unlock (object-lock ,object))))
    ```

* 受此影响(Affected By): None.

* 副作用(Side Effects):

        编译器[compiler]不需要去执行任何编译时的副作用.

* 异常情况(Exceptional Situations):

        用短表达式形式定义的方法组合类型需要每个方法一个限定符[qualifier]. 如果这里有一些可应用的方法没有限定符[qualifier]或者有着这个方法组合类型不支持的限定符[qualifier], 就会发出一个 error 类型[type]的错误. 至少一个主方法必须是可应用的否则就会发出一个 error 类型[type]的错误.

        如果一个可应用的方法不属于任何方法组, 系统会发出一个 error 类型[type]的错误, 表示这个方法对于使用的这个方法组合的种类是非法的.

        如果这个 :required 选项的值是 true 并且这个方法组是空的 (这也就是说, 没有可应用方法匹配这个限定符[qualifier]模式或满足这个断言), 那么就会发出一个 error 类型[type]的错误.

        如果 :order 选项求值为一个不是 :most-specific-first 或 :most-specific-last 的值, 就会发出一个 error 类型[type]的错误.

* 参见(See Also):

        call-method, call-next-method, documentation, method-qualifiers, method-combination-error, invalid-method-error, defgeneric, 章节 7.6.6 (方法选择和组合), 章节 7.6.6.4 (内建的方法组合类型), 章节 3.4.11 (文档字符串和声明的语法交互)

* 注意(Notes):

        这个 defgeneric 的 :method-combination 选项被用于指定一个广义函数[generic function]应该使用一个特殊的方法组合类型. 给 :method-combination 的第一个参数是一个方法组合的名字[name]而剩下的参数是这个类型的选项. 


### <span id="">标准广义函数 FIND-METHOD</span>

* 语法(Syntax):

        find-method generic-function method-qualifiers specializers &optional errorp
        => method

* 方法签名(Method Signatures):

        find-method (generic-function standard-generic-function) method-qualifiers specializers &optional errorp

* 参数和值(Arguments and Values):

        generic-function---一个广义函数[generic function].
        method-qualifiers---一个列表[list].
        specializers---一个列表[list].
        errorp---一个广义 boolean [generalized boolean]. 默认值是 true.
        method---一个方法[method]对象[object], 或 nil.

* 描述(Description):

        广义函数[generic function] find-method 接受一个广义函数[generic function]并且返回限定符[qualifier]和参数特化符[parameter specializer]与 find-method 参数中的 method-qualifiers 和 specializers 一致的方法[method]对象[object]. method-qualifiers 包含了这个方法[method]的方法限定符[qualifier]. 这些方法限定符[qualifier]的顺序是有意义的. 对于在这个上下文中一致性的定义, 见章节 7.6.3 (关于参数特化符和限定符的一致性).

        这些特化符 specializers 参数包含了这个方法[method]的参数特化符. 它必须和这个广义函数[generic function]的必要参数的数量对应, 否则就会发出一个错误. 这个意味着为了获取一个给定广义函数 generic-function 上的默认方法[method], 需要给定一个元素为类[class] t 的列表[list].

        如果这里没有这样一个方法[method]并且 errorp 是 true, find-method 会发出一个错误. 如果这里没有这样一个方法[method]而 errorp 是 false, find-method 返回 nil.

* 示例(Examples):

    ```LISP
    (defmethod some-operation ((a integer) (b float)) (list a b))
    =>  #<STANDARD-METHOD SOME-OPERATION (INTEGER FLOAT) 26723357>
    (find-method #'some-operation '() (mapcar #'find-class '(integer float)))
    =>  #<STANDARD-METHOD SOME-OPERATION (INTEGER FLOAT) 26723357>
    (find-method #'some-operation '() (mapcar #'find-class '(integer integer)))
    >>  Error: No matching method
    (find-method #'some-operation '() (mapcar #'find-class '(integer integer)) nil)
    =>  NIL
    ```

* 受此影响(Affected By):

        add-method, defclass, defgeneric, defmethod

* 异常情况(Exceptional Situations):

        如果这些特化符 specializers 参数不对应广义函数 generic-function 必要参数的数量, 就会发出一个 error 类型[type]的错误.

        如果这里没有这样一个方法[method]并且 errorp 是 true, find-method 发出一个 error 类型[type]的错误.

* 参见(See Also):

        章节 7.6.3 (关于参数特化符和限定符的一致性)

* 注意(Notes): None. 


### <span id="SGF-ADD-METHOD">标准广义函数 ADD-METHOD</span>

* 语法(Syntax):

        add-method generic-function method => generic-function

* 方法签名(Method Signatures):

        add-method (generic-function standard-generic-function) (method method)

* 参数和值(Arguments and Values):

        generic-function---一个广义函数[generic function]对象[object].
        method---一个方法[method]对象[object].

* 描述(Description):

        广义函数 add-method 添加一个方法[method]到广义函数[generic function].

        如果方法 method 和广义函数 generic-function 中一个已存在的方法[method]在参数特化符[parameter specializer]和限定符[qualifier]上一致, 那个存在的方法[method]就会被替换.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        方法 method 的方法函数的 lambda 列表[lambda list]必须和广义函数[generic-function]的 lambda 列表[lambda list]一致, 否则就会发出一个 error 类型[type]的错误.

        如果 method 是另一个广义函数[generic function]的方法[method]对象[object], 就会发出一个 error 类型[type]的错误.

* 参见(See Also):

        defmethod, defgeneric, find-method, remove-method, 章节 7.6.3 (关于参数特化符和限定符的一致性)

* 注意(Notes): None. 


### <span id="SGF-INITIALIZE-INSTANCE">标准广义函数 INITIALIZE-INSTANCE</span>

* 语法(Syntax):

        initialize-instance instance &rest initargs &key &allow-other-keys => instance

* 方法签名(Method Signatures):

        initialize-instance (instance standard-object) &rest initargs

* 参数和值(Arguments and Values):

        instance---一个对象[object].
        initargs---一个默认初始化参数列表.

* 描述(Description):

        由 make-instance 调用来初始化新创建的实例[instance]. 这个广义函数用这个新的实例 instance 和默认初始化参数列表[defaulted initialization argument list]来调用.

        系统提供的 initialize-instance 主方法[method]根据初始化参数 initargs 和槽[slot]的 :initform 表达式形式的值来初始化实例 instance 的槽[slot]. 它通过使用以下参数调用广义函数 shared-initialize 来完成这个: 这个实例 instance, t (这个表示所有没有提供初始化参数的槽[slot]应该根据它们的 :initform 表达式形式来初始化), 还有初始化参数 initargs.

        程序员可以为 initialize-instance 定义方法[method]来指定在一个实例被初始化时采取的动作. 如果只定义了 after 方法[after method], 它们会在系统提供的用于初始化的主方法[method]之后被运行, 因此不会影响到 initialize-instance 的默认行为.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        shared-initialize, make-instance, slot-boundp, slot-makunbound, 章节 7.1 (对象创建和初始化), 章节 7.1.4 (初始化参数的规则), 章节 7.1.2 (声明初始化参数的有效性)

* 注意(Notes): None. 


### <span id="SGF-CLASS-NAME">标准广义函数 CLASS-NAME</span>

* 语法(Syntax):

        class-name class => name

* 方法签名(Method Signatures):

        class-name (class class)

* 参数和值(Arguments and Values):

        class---一个类[class]对象[object].

        name---一个符号[symbol].

* 描述(Description):

        返回给定类 class 的名字.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        find-class, 章节 4.3 (类)

* 注意(Notes):

        如果 S 是一个符号[symbol], 其中 S =(class-name C) 并且 C =(find-class S), 那么 S 是 C 的一个专有名字. 关于进一步讨论, 见章节 4.3 (类).

        一个匿名类[class]的名字是 nil. 


### <span id="SGF-SETF-CLASS-NAME">标准广义函数 (SETF CLASS-NAME)</span>

* 语法(Syntax):

        (setf class-name) new-value class => new-value

* 方法签名(Method Signatures):

        (setf class-name) new-value (class class)

* 参数和值(Arguments and Values):

        new-value---一个符号[symbol].
        class---一个类[class].

* 描述(Description):

        广义函数 (setf class-name) 设置一个类 class 对象的名字.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        find-class, proper name, 章节 4.3 (类)

* 注意(Notes): None. 


### <span id="F-CLASS-OF">函数 CLASS-OF</span>

* 语法(Syntax):

        class-of object => class

* 参数和值(Arguments and Values):

        object---一个对象[object].
        class---一个类[class]对象[object].

* 描述(Description):

        返回一个类[class], 这个对象 object 为这个类的直接实例[direct instance].

* 示例(Examples):

    ```LISP
    (class-of 'fred) =>  #<BUILT-IN-CLASS SYMBOL 610327300>
    (class-of 2/3) =>  #<BUILT-IN-CLASS RATIO 610326642>
    
    (defclass book () ()) =>  #<STANDARD-CLASS BOOK 33424745>
    (class-of (make-instance 'book)) =>  #<STANDARD-CLASS BOOK 33424745>
    
    (defclass novel (book) ()) =>  #<STANDARD-CLASS NOVEL 33424764>
    (class-of (make-instance 'novel)) =>  #<STANDARD-CLASS NOVEL 33424764>

    (defstruct kons kar kdr) =>  KONS
    (class-of (make-kons :kar 3 :kdr 4)) =>  #<STRUCTURE-CLASS KONS 250020317>
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        make-instance, type-of

* 注意(Notes): None. 


### <span id="CT-UNBOUND-SLOT">状况类型 UNBOUND-SLOT</span>

* 类优先级列表(Class Precedence List):

        unbound-slot, cell-error, error, serious-condition, condition, t

* 描述(Description):

        这个持有未绑定槽的对象[object]由 make-condition 的 :instance 初始化参数来初始化, 并且通过函数[function] unbound-slot-instance 来访问.

        这个存储格(cell)(见 cell-error)的名字是这个槽的名字.

* 参见(See Also):

        cell-error-name, unbound-slot-object, 章节 9.1 (状况系统的概念) 


### <span id="F-UNBOUND-SLOT-INSTANCE">函数 UNBOUND-SLOT-INSTANCE</span>

* 语法(Syntax):

        unbound-slot-instance condition => instance

* 参数和值(Arguments and Values):

        condition---一个类型[type] unbound-slot 的状况[condition].
        instance---一个对象[object].

* 描述(Description):

        返回这个 condition 所表示的情况[situation]下有着未绑定槽的实例.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        cell-error-name, unbound-slot, 章节 9.1 (状况系统的概念)

* 注意(Notes): None. 


# 8. 结构体

## 8.1 结构体的字典

> * [宏 DEFSTRUCT](#MacroDEFSTRUCT)
> * [函数 COPY-STRUCTURE](#FunctionCOPYSTRUCTURE)

### <span id="MacroDEFSTRUCT">宏 DEFSTRUCT</span>

* 语法(Syntax):

        defstruct name-and-options [documentation] {slot-description}*
        => structure-name

        name-and-options::= structure-name | (structure-name [[options]]) 

        options::= conc-name-option | 
                  {constructor-option}* | 
                  copier-option | 
                  include-option | 
                  initial-offset-option | 
                  named-option | 
                  predicate-option | 
                  printer-option | 
                  type-option 

        conc-name-option::= :conc-name | (:conc-name) | (:conc-name conc-name) 

        constructor-option::= :constructor | 
                              (:constructor) | 
                              (:constructor constructor-name) | 
                              (:constructor constructor-name constructor-arglist) 

        copier-option::= :copier | (:copier) | (:copier copier-name) 

        predicate-option::= :predicate | (:predicate) | (:predicate predicate-name) 

        include-option::= (:include included-structure-name {slot-description}*) 

        printer-option::= print-object-option | print-function-option 

        print-object-option::= (:print-object printer-name) | (:print-object) 

        print-function-option::= (:print-function printer-name) | (:print-function) 

        type-option::= (:type type) 

        named-option::= :named 

        initial-offset-option::= (:initial-offset initial-offset) 

        slot-description::= slot-name |  
                            (slot-name [slot-initform [[slot-option]]]) 

        slot-option::= :type slot-type |  
                      :read-only slot-read-only-p 

* 参数和值(Arguments and Values):

        conc-name---一个字符串标识符[string designator].
        constructor-arglist---一个 boa lambda 列表[boa lambda list].
        constructor-name---一个符号[symbol].
        copier-name---一个符号[symbol].
        included-structure-name---一个已经定义的结构体名字[structure name]. 注意, 派生类型[derived type]是不允许的, 即使它会展开成一个结构体名称[structure name].
        initial-offset---一个非负整数[integer].
        predicate-name---一个符号[symbol].
        printer-name---一个函数名字[function name]或一个 lambda 表达式[lambda expression].
        slot-name---一个符号[symbol].
        slot-initform---一个表达式形式[form].
        slot-read-only-p---一个广义的 boolean [generalized boolean].
        structure-name---一个符号[symbol].
        type---类型指定符[type specifier] list, vector, 或者 (vector size) 之一, 或者其他某个具体实现[implementation]定义为合适的类型指定符[type specifier].
        documentation---一个字符串[string]; 不求值.

* 描述(Description):

        defstruct 定义一个结构化的类型[type], 名为 structure-type, 并带有由槽选项 slot-options 指定的已命名槽.

        defstruct 为槽定义读取器[reader]并且为 setf 能在这样的读取器[reader]函数上正常工作做准备. 而且, 除非被重写, 它都会定义一个名为 name-p 的断言, 定义一个名为 make-constructor-name 的构造函数, 并且定义一个名为 copy-constructor-name 的复制函数. 所有这些自动创建的函数的名字可能被自动声明为 inline (由具体实现[implementation]决定).

        如果提供了文档 documentation, 它会作为 structure 种类的文档字符串[documentation string]绑定给 structure-name, 并且除非使用了 :type, 这个 documentation 也作为 type 种类的文档字符串[documentation string]绑定给 structure-name 并且作为文档字符串[documentation string]绑定给名为 structure-name 的类[class]的类[class]对象[object].

        defstruct 定义一个构造函数被用于创建由 defstruct 创建的结构体的实例. 默认名字是 make-structure-name. 可以通过给 constructor 选项传递名字作为参数来提供一个不同的名字. nil 表示没有构造函数会被创建.

        在一个新的结构体类型被定义后, 那个类型的实例通常可以使用这个类型的构造函数来创建. 一个对构造函数的调用如下:

        (constructor-function-name
        slot-keyword-1 form-1
        slot-keyword-2 form-2
        ...)

        给这个构造函数的参数都是关键字参数. 每个槽关键字参数必须是一个名字对应一个结构体槽名字的关键字. 所有这些关键字 keywords 和表达式形式 forms 被求值. 如果一个槽没有以这种方式被初始化, 它会在构造函数被调用时通过求值槽描述中的槽初始化表达式形式 slot-initform 来初始化. 如果没有提供槽初始化表达式形式 slot-initform 而在显式赋值前去尝试读取这个槽的值, 结果是未定义的.

        为一个 defstruct 组件提供的每个槽初始化表达式形式 slot-initform, 当被构造函数用于其他未提供的组件时, 在每个对这个构造函数的调用上被再次求值. 这个 slot-initform 不被求值除非在一个特定结构体实例的创建中需要它. 如果从不需要它, 即便指定了这个槽的类型[type], 这里也可以没有类型不匹配的错误; 在这个情况下应该没有发出警告. 比如, 在下面顺序中, 只有最后一个调用是一个错误.

    ```LISP
    (defstruct person (name 007 :type string)) 
    (make-person :name "James")
    (make-person)
    ```

        它就好像 slot-initforms 被用作这个构造函数的关键字参数[keyword parameter]的初始化表达式形式[initialization form].

        命名槽的这些符号[symbol]一定不能被具体实现[implementation]用作这个构造函数中 lambda 变量[lambda variable]的名字[name], 因为这些符号[symbol]中的一个或多个可能已经被公告为 special 或可能被定义为一个常变量[constant variable]的名字. 这个槽默认初始化表达式形式在这个 defstruct 表达式形式出现的词法环境[lexical environment]中以及对这个构造函数调用所出现的动态环境[dynamic environment]中被求值.

        比如, 如果表达式形式 (gensym) 被用作一个初始化表达式形式, 不管是在构造函数调用中或是作为 defstruct 的默认初始化表达式形式, 每个对这个构造函数的调用都会调用 gensym 来产生一个新的符号[symbol].

        在 defstruct 中的每个槽描述 slot-description 都可以指定 0 个或多个槽选项 slot-options. 一个槽选项 slot-option 由一个关键字和值(它不是一个要被求值的表达式形式, 而是值本身)的对组成. 比如:

    ```LISP
    (defstruct ship
      (x-position 0.0 :type short-float)
      (y-position 0.0 :type short-float)
      (x-velocity 0.0 :type short-float)
      (y-velocity 0.0 :type short-float)
      (mass *default-ship-mass* :type short-float :read-only t))
    ```

        这个指定了每个槽总是包含一个短浮点数[short float], 并且一旦一个 ship 被构造最后一个槽不能被修改.

        可用的槽选项是:

            :type type

                这个指定了这个槽的内容总是为 type 类型. 这完全类似于一个变量或函数的声明; 它有效地声明这个读取器[reader]函数的结果类型. 在初始化一个槽或者对它赋值时类型[type]是否被检测依赖于具体实现[implementation-dependent]. 这个 type 不求值; 它必须是一个有效的类型指定符[type specifier].

            :read-only x

                当 x 是 true 时, 这个指定了这个槽不能被修改; 它总是会包含构造时提供的值. setf 不会接受这个槽的读取器[reader]函数. 如果 x 是 false, 这个 slot-option 就没有效果. x 不会被求值.

                当这个选项是 false 或没提供时, 写入[write]这个槽的能力是通过一个 setf 函数[setf function]还是一个 setf 展开器[setf expander]实现的依赖于具体实现[implementation-dependent].

        下面的关键字选项可用于 defstruct. 一个 defstruct 选项可以是一个关键字或一个关键字和它的参数的列表[list]; 单独指定关键字相当于指定一个包含关键字和无参数的列表. 这个 defstruct 选项的语法有别于槽选项使用的语法. 这些选项的任何部分都不会被求值.

            :conc-name

                这个为读取器[reader] (或访问[access])函数的名字提供自动前缀. 默认行为是一个结构体的所有读取器[reader]函数的名字都以这个结构体的名字后面跟着连字符开始.

                :conc-name 提供一个要被使用的替代前缀, 如果一个连字符被用作分隔符, 它必须作为这个前缀的部分被提供. 如果 :conc-name 是 nil 或没有提供参数, 那么没有前缀被使用; 而这个读取器[reader]函数的名字就和槽的名字相同. 如果提供一个非 nil 前缀, 每个槽的这个读取器[reader]函数[function]的名字由这个前缀和槽的名字拼接构造而成, 并且在这个 defstruct 表达式形式被展开的当前包[package]中捕捉产生的符号[symbol].

                注意, 无论为 :conc-name 提供了什么, 匹配槽名字的没有关联前缀的槽关键字和构造函数一起使用. 这个读取器函数名可以和 setf 一起使用. 这里有一个例子:

                (defstruct (door (:conc-name dr-)) knob-color width material) =>  DOOR
                (setq my-door (make-door :knob-color 'red :width 5.0)) 
                =>  #S(DOOR :KNOB-COLOR RED :WIDTH 5.0 :MATERIAL NIL)
                (dr-width my-door) =>  5.0
                (setf (dr-width my-door) 43.7) =>  43.7
                (dr-width my-door) =>  43.7

                不管这个 :conc-name 选项是非被显式提供, 下面规则决定了生成的读取器[reader] (或访问器[accessor])名字的名称冲突: 对于任何有着名为 X1 的一个名为 R 的读取器[reader]函数的结构体[structure]类型[type] S1, 它被另一个结构体[structure]类型[type] S2 继承，而 S2 的名为 X2 的槽有着相同名字 R 的读取器[reader]函数, S2 的定义不会为 R 生成定义; 反而, 这个 R 的定义从 S1 的定义继承而来. (在这种情况下, 如果 X1 和 X2 是不同的槽, 具体实现[implementation]可能会发出一个风格警告.)

            :constructor

                这个选项接受 0 个, 1 个或 2 个参数. 如果至少提供了一个参数并且第一个参数不是 nil, 那么那个参数是一个指定这个构造函数名字的符号[symbol]. 如果这个参数没有被提供 (或者如果这个选项自身就没有被提供), 那么这个构造器的名字通过字符串 "MAKE-" 和这个结构体的名字拼接而成, 在 defstruct 被展开时当前包[package]中捕捉这个名字. 如果提供了这个参数并且是 nil, 那么没有构造函数被定义.

                如果 :constructor 以 (:constructor name arglist) 这种形式给定, 那么代替创建一个关键字驱动的构造函数, defstruct 会定义一个 "位置参数(positional)" 构造函数, 接受的参数的意义由这个参数的位置来决定, 也可能由关键字决定. 参数列表 arglist 被用于描述给这个构造器的参数. 在像 (:constructor make-foo (a b c)) 这样最简单的情况中, 它定义了 make-foo 为一个三参数的构造函数, 这个构造函数的参数被用于初始化名为 a, b, 和 c 的槽.

                由于一个这个类型构造器 "根据参数的顺序(By Order of Arguments)" 来操作, 它有时也被认为是一个 "boa 构造器".

                关于一个 "boa 构造器" 的这个参数列表 arglist 如何被处理, 见章节 3.4.6 (Boa Lambda 列表).

                允许不止一次使用 :constructor 选项, 这样你可以定义多个不同的构造函数, 每一个都接收不同的参数.

                当且仅当没有指定显式的 :constructor 选项或者这个 :constructor 选项被指定但没有 name 参数时, defstruct 创建这个默认命名的关键字构造函数.

                只有在这里没有指定其他 :constructor 选项时, 这个 (:constructor nil) 是有意义的. 它阻止 defstruct 产生任何构造器.

                否则, defstruct 对应每个提供的 :constructor 选项创建一个构造函数. 允许指定多个关键字构造函数以及多个"boa 构造函数".

            :copier

                这个选项接受一个参数, 一个符号[symbol], 它指定了这个复制函数的名字. 如果没有提供这个参数或者没有提供这个选项, 这个复制器的名字由字符串 "COPY-" 和这个结构体的名字拼接而成, 在 defstruct 被展开时当前包[package]中捕捉这个名字. 如果提供的这个参数是 nil, 那么没有复制函数被定义.

                自动定义的这个赋值函数是一个单个实参[argument]的函数, 这个参数一定是要被定义的结构体类型. 这个赋值函数创建一个有着和它的实参[argument]相同类型[type]的新[fresh]结构体, 并且有着和原始结构体相同的成员值; 也就是说, 成员值不会被递归拷贝. 如果这个 defstruct :type 选项没有被使用, 下面的等价性适用:

                (copier-name x) = (copy-structure (the structure-name x))

            :include

                这个选项被用于构建一个新的结构体定义, 作为另一个结构体定义的扩展. 比如:

                (defstruct person name age sex)

                为了创建一个有着 name, age, 和 sex 属性以及在 person 结构体上操作的函数[function]的新的结构体 astronaut, astronaut 使用 :include 按如下定义:

                (defstruct (astronaut (:include person)
                                      (:conc-name astro-))
                    helmet-size
                    (favorite-beverage 'tang))

                :include 导致这个要被定义的结构体有着和被包含结构体相同的槽. 这样做使得被包括结构体的读取器[reader]函数也可以工作在要被定义的结构体上. 因此在此例中, 一个 astronaut 有五个槽: 三个在 person 中定义而两个在 astronaut 自身中定义. 通过 person 结构体定义的这些读取器[reader]函数可以被应用于这个 astronaut 结构体的实例, 并且它们会正常工作. 此外, astronaut 有着它自己的对于由 person 结构体定义的组件的读取器函数. 下面例子说明了 astronaut 结构体的使用:

                (setq x (make-astronaut :name 'buzz
                                        :age 45.
                                        :sex t
                                        :helmet-size 17.5))
                (person-name x) =>  BUZZ
                (astro-name x) =>  BUZZ
                (astro-favorite-beverage x) =>  TANG

                (reduce #'+ astros :key #'person-age) ; obtains the total of the ages 
                                                      ; of the possibly empty
                                                      ; sequence of astros

                读取器[reader]函数 person-name 和 astro-name 的区别是 person-name 可以准确应用于任何 person, 包括 astronaut, 而 astro-name 只能被应用于一个 astronaut. 一个具体实现可以检查读取器[reader]函数的不正确使用.

                在一个 defstruct 中最多只能提供一个 :include. 给 :include 的参数是必须的并且一定是某个之前定义的结构体的名字. 这个这个要被定义的结构体没有 :type 选项, 那么这个被包含的结构体也必须没有给它提供的 :type 选项. 如果这个要被定义的结构体有一个 :type 选项, 那么这个被包含的结构体必须用一个指定相同表示类型[type]的 :type 选项来声明.

                如果没有涉及 :type 选项, 那么这个被包含的结构体定义的结构体名字成为一个数据类型[data type]的名字, 因此一个有效的类型指定符[type specifier]被 typep 所识别; 它成为被包含结构体的一个子类型[subtype]. 在上述例子中, astronaut 是 person 的一个子类型[subtype]; 因此

                (typep (make-astronaut) 'person) =>  true

                表示 person 上的所有操作也可以工作在 astronaut 上.

                使用 :include 的结构体可以为包括的槽指定和被包含的结构体指定的不一样的默认值或槽选项, 通过像这样给定 :include 选项:

                (:include included-structure-name slot-description*)

                每个槽描述 slot-description 必须有一个和被包含的结构体中的某个槽相同的槽名字. 如果一个槽描述 slot-description 没有槽初始化表达式形式 slot-initform, 那么在这个新的结构体中那个槽就没有初始值. 否则它的初始值表达式形式就会被 slot-description 中的槽初始化表达式形式 slot-initform 替代. 一个普通的可写槽可以变为只读的. 如果一个槽在被包含的结构体中是只读的, 那么它在包含的结构体中也必须如此. 如果为一个槽提供了类型[type], 它必须是这个被包含的结构体中指定的类型[type]的子类型[subtype].

                比如, 如果一个 astronaut 中默认 age 是 45, 那么就是

                (defstruct (astronaut (:include person (age 45)))
                    helmet-size
                    (favorite-beverage 'tang))

                如果 :include 和 :type 选项一起使用, 那么效果是, 首先跳过表示被包含结构所需要的一样多的表示元素, 接着跳过任何 :initial-offset 选项提供的额外元素, 然后从这一点开始分配元素. 比如:

                (defstruct (binop (:type list) :named (:initial-offset 2))
                  (operator '? :type symbol)   
                  operand-1
                  operand-2) =>  BINOP
                (defstruct (annotated-binop (:type list)
                                            (:initial-offset 3)
                                            (:include binop))
                  commutative associative identity) =>  ANNOTATED-BINOP
                (make-annotated-binop :operator '*
                                      :operand-1 'x
                                      :operand-2 5
                                      :commutative t
                                      :associative t
                                      :identity 1)
                  =>  (NIL NIL BINOP * X 5 NIL NIL NIL T T 1)

                前两个 nil 元素源于 binop 定义中为 2 的 :initial-offset. 接下来的四个元素包含了结构体名字和 binop 的三个槽. 接下来的三个 nil 元素源自 annotated-binop 定义中 3 的 :initial-offset. 最后三个列表元素包含了 annotated-binop 的额外的槽.

            :initial-offset

                :initial-offset 指导 defstruct 在它开始分配这个主体中描述的槽之前去跳过一个确定的槽的数量. 这个选项的参数是 defstruct 应该跳过的槽的数量. :initial-offset 只能在 :type 也被提供时使用.

                :initial-offset 允许从一个具象元素开始分配槽而不是在第一个. 比如, 这个表达式形式

                (defstruct (binop (:type list) (:initial-offset 2))
                  (operator '? :type symbol)
                  operand-1
                  operand-2) =>  BINOP

                会导致以下 make-binop 的行为:

                (make-binop :operator '+ :operand-1 'x :operand-2 5)
                =>  (NIL NIL + X 5)
                (make-binop :operand-2 4 :operator '*)
                =>  (NIL NIL * NIL 4)

                选择器函数 binop-operator, binop-operand-1, 和 binop-operand-2 本质上分别等价于 third, fourth, 和 fifth. 类似的, 表达式形式

                (defstruct (binop (:type list) :named (:initial-offset 2))
                  (operator '? :type symbol)
                  operand-1
                  operand-2) =>  BINOP

                会导致以下 make-binop 的行为:

                (make-binop :operator '+ :operand-1 'x :operand-2 5) =>  (NIL NIL BINOP + X 5)
                (make-binop :operand-2 4 :operator '*) =>  (NIL NIL BINOP * NIL 4)

                前两个 nil 元素源自 binop 的定义中 2 的 :initial-offset. 接下来四个元素包含这个结构体的名字和三个 binop 的槽.

            :named

                :named 指定这个结构体是已命名的. 如果没有提供 :type, 那么结构体总是已命名的.

                例如:

                (defstruct (binop (:type list))
                  (operator '? :type symbol)
                  operand-1
                  operand-2) =>  BINOP

                这个定义了一个构造函数 make-binop 和三个选择器函数, 也就是 binop-operator, binop-operand-1, 和 binop-operand-2. (然而它不会定义一个断言 binop-p, 出于下面解释的原因.)

                这个 make-binop 的效果仅仅是构造一个长度 3 的列表:

                (make-binop :operator '+ :operand-1 'x :operand-2 5) =>  (+ X 5)  
                (make-binop :operand-2 4 :operator '*) =>  (* NIL 4)

                它就像是函数 list, 除了它接受关键字参数并且执行适合于 binop 概念数据类型的槽默认值初始化. 同样地, 选择器函数 binop-operator, binop-operand-1, and binop-operand-2 本质上分别等价于 car, cadr, 和 caddr. 它们可能不是完全等价, 比如由于一个具体实现完全可以添加错误检测代码来确保给每个选择器函数的实参是长度为 3 的列表.

                binop 是一个概念数据类型, 由于它不是 Common Lisp 类型系统的一部分. typep 不识别 binop 为一个类型指定符[type specifier], 并且当给定一个 binop 结构体时 type-of 返回 list. 这里没有方法去区分一个 make-binop 构造的数据类型和其他具有正确结构的列表[list].

                这里没有任何方式去从 make-binop 创建的一个结构体中重新获得这个结构体名字 binop. 只有在这个结构被命名时才可以这样做. 已命名结构具有这样的属性: 给定这个结构体的一个实例, 可以可靠地重新获得结构体名称(它命名这个类型). 对于不带有 :type 选项来定义的的结构体, 这个结构体名字实际上成为 Common Lisp 数据类型系统的一部分. type-of, 当应用于这样一个结构体时, 返回这个结构体的名字作为这个对象[object]的类型[type]; typep 识别这个结构体名字为一个有效的类型指定符[type specifier].

                对于使用一个 :type 选项定义的结构体, type-of 返回一个类型指定符[type specifier], 比如 list 或 (vector t), 取决于提供给这个 :type 选项的类型. 这个结构体名字不会称为一个有效类型指定符[type specifier]. 然而, 如果这个 :named 选项也被提供, 那么这个结构体(通过 defstruct 构造函数创建的)的第一个组件总是包含这个结构体的名字. 这允许这个结构体的名字从这个结构体的一个实例中被重新获取并且允许去为这个概念类型定义一个合理的断言: 自动定义的这个结构体的断言 name-p 通过首先检测它的参数为适当的类型 (list, (vector t), 或者诸如此类) 然后检测第一个组件是否包含了这个适当的类型名字.

                细想上面展示的 binop 例子, 仅修改为包含 :named 选项:

                (defstruct (binop (:type list) :named)
                  (operator '? :type symbol)
                  operand-1
                  operand-2) =>  BINOP

                和之前一样, 这个定义一个构造函数 make-binop 和三个选择器函数 binop-operator, binop-operand-1, 和 binop-operand-2. 它也定义了断言 binop-p. 现在 make-binop 的效果是构造一个长度 4 的列表:

                (make-binop :operator '+ :operand-1 'x :operand-2 5) =>  (BINOP + X 5)
                (make-binop :operand-2 4 :operator '*) =>  (BINOP * NIL 4)

                这个结构体和之前有着相同的布局除了这个结构体名字被包含作为第一个列表元素. 选择器函数 binop-operator, binop-operand-1, 和 binop-operand-2 本质上分别等价于 cadr, caddr, 和 cadddr. 断言 binop-p 或多或少等价于这个定义:

                (defun binop-p (x)
                  (and (consp x) (eq (car x) 'binop))) =>  BINOP-P

                名字 binop 对于 typep 仍然不是一个有效的可识别的类型指定符[type specifier], 但是至少这里有一种区分 binop 和其他类似定义的结构体的方法.

            :predicate

                这个选项接受一个参数, 它表示这个类型断言的名字. 如果这个参数没有被提供或者这个选项自身没有被提供, 这个断言的名字通过拼接这个结构体的名字到字符串 "-P" 来完成, 在 defstruct 被展开的当前包[package]中捕获这个名字. 如果提供了这个参数并且是 nil, 那么没有断言会被定义. 当且仅当这个结构体是已命名的时候一个断言可以被定义; 如果提供了 :type 而 :named 没有被提供, 那么 :predicate 必须是未提供的或者值为 nil.

            :print-function, :print-object

                这个 :print-function 和 :print-object 选项指定了应该为类型 structure-name 的结构体[structure]生成一个 print-object 方法[method]. 这些选项不是同义词, 而是执行类似的服务; 选择使用哪一个选项 (:print-function 或 :print-object) 影响这个名为 printer-name 的函数如何被调用. 这些选项只有一个可以被使用, 并且这些选项只能在 :type 没有被提供时使用.

                如果这个 :print-function 选项被使用, 那么当一个类型 structure-name 的结构体要被打印时, 指定的这个打印函数在三个实参[argument]上被调用:

                    要被打印的结构体 (一个普通的 structure-name 的实例[generalized instance]).

                    一个要打印到的流[stream].

                    一个表示当前深度的整数[integer]. 这个整数的大小可能在不同的具体实现[implementation]之间有所不同; 但是, 它可以可靠地与 *print-level* 进行比较, 以确定深度缩写(depth abbreviation)是否合适.

                指定 (:print-function printer-name) 近似等价于指定:

                (defmethod print-object ((object structure-name) stream)
                  (funcall (function printer-name) object stream <<current-print-depth>>))

                其中这个 <<current-print-depth>> 表示这个打印器对当前打印深度的判断. <<current-print-depth>> 是否总是为 0 以及 *print-level* 如果非 nil [non-nil]的话是否随着打印递归递减陆续会被重新绑定到更小的值依赖于具体实现[implementation-dependent], 或者说 current-print-depth 的值随着打印递归递减是否会改变而 *print-level* 在相同的遍历过程中是否保持不变依赖于具体实现[implementation-dependent].

                如果使用了这个 :print-object 选项, 那么当一个类型 structure-name 的结构体要被打印时, 指定的打印函数会在两个参数上被调用:

                    要被打印的结构体.

                    要打印到的流.

                指定 (:print-object printer-name) 等价于指定:

                (defmethod print-object ((object structure-name) stream)
                  (funcall (function printer-name) object stream))

                如果没有提供 :type 选项, 并且提供一个 :print-function 或一个 :print-object 选项, 也没有提供 printer-name, 那么会生成一个为 structure-name 特化[specialized]的 print-object 方法[method], 它使用 #S 标记实现了结构体的默认打印行为; 见章节 22.1.3.12 (打印结构体).

                如果既没有提供一个 :print-function 选项也没有提供一个 :print-object 选项, 那么 defstruct 不会生成一个为 structure-name 特化[specialized]的 print-object 方法[method], 而是从一个 :include 选项中的已命名结构体或从打印结构体的默认行为中继承某个默认行为; 见函数[function] print-object 和章节 22.1.3.12 (打印结构体).

                当 *print-circle* 是 true 时, 一个用户定义的打印函数可以使用 write, prin1, princ, or format 来打印对象[object]到提供的流[stream]中并且认为循环会被检测并且通过 #n# 语法打印. 这个应用于 print-object 上的方法[method], 除了 :print-function 选项. 如果用户提供的打印函数打印到一个流[stream]而不是提供的那个, 那么为这个流[stream]重新开始循环检测. 见变量[variable] *print-circle*.

            :type

                :type 显式指定了这个结构体要使用的表示法. 它的参数必须是以下类型[type]之一:

                vector

                    这个和指定 (vector t) 产生相同的结果. 这个结构体被表示为普通的向量[vector], 把组件存储为向量元素. 如果这个结构体是 :named 那么第一个组件是向量元素 1, 否则就是元素 0.

                (vector element-type)

                    这个结构体被表示为一个 (可能是特化的) 向量[vector], 把组件存储为向量元素. 每个组件必须是可以存储到指定类型[type]的向量[vector]中的类型[type]. 如果这个结构体是 :named 那么第一个组件是 vector 的元素 1, 否则就是元素 0. 当且仅当这个类型 symbol 是提供的 element-type 的一个子类型[subtype]时, 这个结构体可以是 :named.

                list

                    这个结构体被表示为一个列表[list]. 如果这个结构体是 :named 那么第一个元素就是 cadr 那个, 如果不是 :named 那么就是 car 那个.

                指定这个选项的效果是, 强制一个特定的表示, 并强制将组件按照在 defstruct 中指定的顺序存储到指定的表示法的相应连续元素中. 它还可以防止结构名称成为 typep 所识别的有效类型指定符[type specifier].

                比如:

                (defstruct (quux (:type list) :named) x y)

                应该产生一个构造器, 它构造一个列表[list], 就像是 list 创建的一样, 其中 quux 作为它的 car.

                如果这个类型如下定义:

                (deftype quux () '(satisfies quux-p))

                那么这个表达式形式

                (typep (make-quux) 'quux)

                应该准确返回下面这个所做的结果

                (typep (list 'quux nil nil) 'quux)

                如果没有提供 :type, 这个结构体被表示为一个 structure-object 类型[type]的对象[object].

                没有 :type 选项的 defstruct 定义一个类[class], 其中这个结构体的名字作为它的名字. 结构体实例[instance]的元类[metaclass]是 structure-class.

        重定义一个 defstruct 结构体的后果是未定义的.

        在没有提供 defstruct 选项的情况下, 以下函数会被自动定义, 用来操作这个新的结构体的实例:

            断言(Predicate)

                定义一个名为 structure-name-p 的断言, 用来测试这个结构体类型中的从属关系. 如果一个对象 object 是这个类型[type]的, 那么断言 (structure-name-p object) 就是 true; 否则它就是 false. typep 也可以和这个新类型[type]的名字一起使用来检测一个对象[object]是否为这个类型[type]. 这样一个函数调用的形式为 (typep object 'structure-name).

            组件读取器函数(Component reader functions)

                定义读取器[reader]函数, 用来读取这个结构体的组件. 对于每个槽的名字, 这里有一个对应的名为 structure-name-slot-name 的读取器[reader]函数. 这个函数读取[read]那个槽的内容. 每个读取器[reader]函数接收一个参数, 它是这个结构体类型的一个实例. setf 可以和这些读取器[reader]函数中的任何一个一起使用来修改槽的内容.

            构造函数(Constructor function)

                定义一个名为 make-structure-name 的构造函数. 这个函数创建并返回这个结构体类型的新的实例.

            复制函数(Copier function)

                定义一个名为 copy-structure-name 的复制函数. 这个赋值函数接收一个该结构体类型的对象并创建一个相同类型的新的对象, 它是第一个对象的复制. 复制函数使用和原始相同的组件条目来创建一个新的结构体. 两个结构体实例的对应组件是 eql 的.

          如果一个 defstruct 表达式形式[form]作为顶层表达式形式[top level form]出现, 编译器[compiler]必须使这个结构体[structure]类型[type]名字在后续的声明中(比如 deftype)可以被识别为一个有效类型[type]名字并且使得结构体槽的读取器[reader]函数被 setf 识别. 另外, 编译器[compiler]必须保存足够的关于结构体[structure]类型[type]的信息以便在同一个文件[file]的后续的 deftype 中的进一步结构体定义可以使用 :include 来引用这个结构体[structure]类型[type]的名字. defstruct 产生的函数不会定义在编译时环境, 虽然编译器[compiler]可能保存足够的关于这个函数的信息来把后续的调用编码为 inline 的. 这个 #S 读取器宏[reader macro]在编译时可能或可能不会识别这个新定义的结构体[structure]类型[type].

* 示例(Examples):

        一个结构体定义的示例如下:

    ```LISP
    (defstruct ship
      x-position
      y-position
      x-velocity
      y-velocity
      mass)
    ```

        这个声明每一个 ship 是一个带有五个已命名组件的对象[object]. 这个表达式形式的求值做了以下这些事:

            它定义 ship-x-position 为一个函数, 接受一个参数, 一个 ship, 返回这个 ship 的 x-position; ship-y-position 和其他组件都给定了类似的函数定义. 这些函数被称为访问[access]函数, 由于它们被用来访问[access]这个结构体的元素.

            ship 成为一个类型[type]的名字, ship 的实例就是这个类型的元素. ship 变得可应用于 typep, 比如; 如果 x 是一个 ship 那么 (typep x 'ship) 是 true, 如果 x 是除了 ship 以外的任何对象[object]那么就是 false.

            一个名为 ship-p 的单参数函数被定义; 这是一个断言, 如果它的参数是一个 ship 那么就是 true 否则就是 false.

            一个名为 make-ship 函数会被定义, 当被调用时, 创建一个带有五个组件的数据结构, 和访问[access]函数一起使用是合适的. 因此执行

            (setq ship2 (make-ship))

            设置 ship2 为一个新创建的 ship 对象[object]. 在一个 make-ship 的调用中可以通过下面这种方式使用关键字参数来提供任何想要的组件的初始值:

            (setq ship2 (make-ship :mass *default-ship-mass*
                                    :x-position 0
                                    :y-position 0))

            这个构造一个新的 ship 并且初始化它的组件中的三个. 这个函数也被称作 "构造函数(constructor function)" 因为它构造一个新的结构体.

            一个名为 copy-ship 的单参数函数被定义, 当给定一个 ship 对象[object]时, 创建一个新的 ship 对象[object], 这个对象是给定的那个的一个复制. 这个函数被称作 "复制函数(copier function)".

        setf 可以被用于修改一个 ship 的组件:

        (setf (ship-x-position ship2) 100)

        这个修改 ship2 的 x-position 为 100. 这个可以工作是因为 defstruct 表现得就好像它为每个访问[access]函数生成了一个合适的 defsetf.

    ```LISP
    ;;;
    ;;; Example 1
    ;;; define town structure type
    ;;; area, watertowers, firetrucks, population, elevation are its components
    ;;;
    (defstruct town
                area
                watertowers
                (firetrucks 1 :type fixnum)    ;an initialized slot
                population 
                (elevation 5128 :read-only t)) ;a slot that can't be changed
    =>  TOWN
    ;create a town instance
    (setq town1 (make-town :area 0 :watertowers 0)) =>  #S(TOWN...)
    ;town's predicate recognizes the new instance
    (town-p town1) =>  true
    ;new town's area is as specified by make-town
    (town-area town1) =>  0
    ;new town's elevation has initial value
    (town-elevation town1) =>  5128
    ;setf recognizes reader function
    (setf (town-population town1) 99) =>  99
    (town-population town1) =>  99
    ;copier function makes a copy of town1
    (setq town2 (copy-town town1)) =>  #S(TOWN...)
    (= (town-population town1) (town-population town2))  =>  true
    ;since elevation is a read-only slot, its value can be set only
    ;when the structure is created
    (setq town3 (make-town :area 0 :watertowers 3 :elevation 1200))
    =>  #S(TOWN...)
    ;;;
    ;;; Example 2
    ;;; define clown structure type
    ;;; this structure uses a nonstandard prefix
    ;;;
    (defstruct (clown (:conc-name bozo-))
                (nose-color 'red)         
                frizzy-hair-p polkadots) =>  CLOWN
    (setq funny-clown (make-clown)) =>  #S(CLOWN)
    ;use non-default reader name
    (bozo-nose-color funny-clown) =>  RED        
    (defstruct (klown (:constructor make-up-klown) ;similar def using other
                (:copier clone-klown)              ;customizing keywords
                (:predicate is-a-bozo-p))
                nose-color frizzy-hair-p polkadots) =>  klown
    ;custom constructor now exists
    (fboundp 'make-up-klown) =>  true
    ;;;
    ;;; Example 3
    ;;; define a vehicle structure type
    ;;; then define a truck structure type that includes 
    ;;; the vehicle structure
    ;;;
    (defstruct vehicle name year (diesel t :read-only t)) =>  VEHICLE
    (defstruct (truck (:include vehicle (year 79)))
                load-limit                          
                (axles 6)) =>  TRUCK
    (setq x (make-truck :name 'mac :diesel t :load-limit 17))
    =>  #S(TRUCK...)
    ;vehicle readers work on trucks
    (vehicle-name x)
    =>  MAC
    ;default taken from :include clause 
    (vehicle-year x)
    =>  79 
    (defstruct (pickup (:include truck))     ;pickup type includes truck
                camper long-bed four-wheel-drive) =>  PICKUP
    (setq x (make-pickup :name 'king :long-bed t)) =>  #S(PICKUP...)
    ;:include default inherited
    (pickup-year x) =>  79
    ;;;
    ;;; Example 4
    ;;; use of BOA constructors
    ;;;
    (defstruct (dfs-boa                      ;BOA constructors
                  (:constructor make-dfs-boa (a b c)) 
                  (:constructor create-dfs-boa
                    (a &optional b (c 'cc) &rest d &aux e (f 'ff))))
                a b c d e f) =>  DFS-BOA
    ;a, b, and c set by position, and the rest are uninitialized
    (setq x (make-dfs-boa 1 2 3)) =>  #(DFS-BOA...)
    (dfs-boa-a x) =>  1
    ;a and b set, c and f defaulted
    (setq x (create-dfs-boa 1 2)) =>  #(DFS-BOA...)
    (dfs-boa-b x) =>  2
    (eq (dfs-boa-c x) 'cc) =>  true
    ;a, b, and c set, and the rest are collected into d
    (setq x (create-dfs-boa 1 2 3 4 5 6)) =>  #(DFS-BOA...)
    (dfs-boa-d x) =>  (4 5 6)
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果任何两个槽的名字(不管是直接出现或是通过 :include 选项继承)在 string= 下是相同的[same], defstruct 应该发出一个 program-error 类型[type]的错误.

        如果这个 included-structure-name 没有命名一个结构体[structure]类型[type], 那么结果是未定义的.

* 参见(See Also):

        documentation, print-object, setf, subtypep, type-of, typep, 章节 3.2 (编译)

* 注意(Notes):

        这个 printer-name 应该观察像 *print-escape* 这样的打印控制变量的值.

        对于 slot-initform 和对应槽的 :type 选项的类型不匹配引起的一个警告的约束是有必要的, 因为为了指定槽选项一个 slot-initform 必须被指定; 在某些情况下, 可能不存在合适的默认项.

        defstruct 安排槽访问器和 setf 是可用的机制依赖于具体实现[implementation-dependent]; 比如, 它可能使用 setf 函数[setf function], setf 展开器[setf expander], 或者某个依赖于具体实现的[implementation-dependent]对该具体实现[implementation]的 setf 代码[code]是已知的其他机制. 


### <span id="FunctionCOPYSTRUCTURE">函数 COPY-STRUCTURE</span>

* 语法(Syntax):

        copy-structure structure => copy

* 参数和值(Arguments and Values):

        structure---一个结构体[structure].
        copy---一个结构体 structure 的赋值.

* 描述(Description):

        返回这个结构体 structure 的一个复制体[copy[6]].

        只有这个结构体 structure 本身被赋值; 这些槽的值不会.

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        defstruct 的这个 :copier 选项

* 注意(Notes):

        这个复制体和给定的结构体 structure 在 equalp 下是相同的, 但是在 equal 下是不同的. 

# 9. 状况

> * 9.1 [状况系统的概念](#ConditionSystemConcepts)
> * 9.2 [状况字典](#ConditionsDictionary)

## 9.1 <span id="ConditionSystemConcepts">状况系统的概念</span>

描述 Common Lisp 构造的不仅仅是它们旨在被使用情况下的行为 (见每个操作符[operator]声明的 "描述(Description)" 部分), 还有其他所有情况 (见每个操作符[operator]说明的 "异常情况(Exceptional Situations)").

一个情况(situation)是一个表达式在一个特定上下文中的求值. 一个状况[condition]是表示一个已经被检测到的特定情况的一个对象[object]. 状况[condition]是类[class] condition 的一个广义实例[generalized instance]. 在 Common Lisp 定义了一个状况[condition]类的层次结构. 一个状况[condition]有槽[slot], 可以包含这个状况[condition]所表示的情况的相关数据.

一个错误(error)是在一个没有某个形式的干预下(不管是由用户交互还是在程序控制下), 正常程序不能继续正确执行下去的情况. 不是所有错误都被检测到. 当一个错误未被检测到, 它的效果可以是依赖于具体实现的[implementation-dependent], 具体实现定义的[implementation-defined], 未指定(unspecified), 或者未定义(undefined)的. 见章节 1.4 (定义). 所有检测到的错误可以由状况[condition]表示, 但不是所有状况[condition]都表示错误.

发送(Signaling) 是一个过程, 一个状况[condition]可以通过这个过程来修改一个程序中的控制流, 通过提升这个接下来可以被处理的状况[condition]. 函数 error, cerror, signal, 还有 warn 被用于发出状况[condition].

这个发送的过程涉及从一组活跃[active]处理者[handler]中选择和调用一个处理者[handler]. 一个处理者[handler]是一个单参数(也就是这个状况[condition])的函数[function], 它被调用来处理一个状况[condition]. 每个处理者[handler]都和一个状况[condition]类型[type]关联, 并且一个处理者[handler]只有在这个处理者[condition]关联类型[type]的状况[condition]上被调用.

活跃[active]处理者[handler]被动态地建立 (见 handler-bind 或 handler-case). 处理者[handler]在和这个发送者(signaler)所处的等价动态环境[dynamic environment]中被调用, 除了这个活跃的处理者集合只包含在这个要被调用的处理者被建立时活跃的那些. 发出一个状况[condition]在这个状况[condition]上没有副作用, 并且这里没有动态的状态被包含在一个状况[condition]中.

如果一个处理者[handler]被调用, 它可以通过以下三种方式来处理这个情况[situation]:

拒绝(Decline)

    它可以拒绝去处理[handle]这个状况[condition]. 这个方式通过简单地返回而不是转移控制来完成. 当这个发生的时候, 由这个处理者返回的任何值都会被忽略并且下一个最近被建立的处理者会被调用. 如果这里没有这样的处理者并且发送函数是 error 或 cerror, 那么在这个发送者的动态环境[dynamic environment]中进入调试器. 如果这里没有这样的处理者并且发送函数是 signal 或 warn, 那么这个发送函数简单地返回 nil.

处理(Handle)

    它可以通过执行一个控制的非局部转移来处理[handle]这个状况[condition]. 这个可以通过简单地使用 go, return, throw 来完成, 或者通过使用例如 abort 或 invoke-restart 函数更抽象地完成.

推迟(Defer)

    它可以推迟一个关于是否处理[handle]或拒绝[decline]的决定, 通过任何一种动作, 但是最常见的是通过发送另一个状况, 重发相同的状况, 或者强制进入调试器.

> * 9.1.1 [状况类型](#ConditionTypes)
> * 9.1.2 [创建状况](#CreatingConditions)
> * 9.1.3 [打印状况](#PrintingConditions)
> * 9.1.4 [发送和处理状况](#SignalingHandlingConditions)
> * 9.1.5 [断言](#Assertions)
> * 9.1.6 [关于状况系统的背景的注意事项](#NotesConditionSystemBackground)


### 9.1.1 <span id="ConditionTypes">状况类型</span>

下一段中列出了标准[standardized]状况[condition]类型[type]. 额外的状况[condition]类型[type]可以通过使用 define-condition 来定义.

    arithmetic-error                  floating-point-overflow   simple-type-error   
    cell-error                        floating-point-underflow  simple-warning      
    condition                         package-error             storage-condition   
    control-error                     parse-error               stream-error        
    division-by-zero                  print-not-readable        style-warning       
    end-of-file                       program-error             type-error          
    error                             reader-error              unbound-slot        
    file-error                        serious-condition         unbound-variable    
    floating-point-inexact            simple-condition          undefined-function  
    floating-point-invalid-operation  simple-error              warning             

    Figure 9-1. 标准状况类型

所有状况[condition]类型[type]都是类型[type] condition 的子类型[subtype]. 这也就是说, 当且仅当 c 是一个状况[condition]时以下形式成立

```LISP
(typep c 'condition) =>  true
```

具体实现[implementation]必须定义所有指定的子类型[subtype]关系. 除非特别注解, 本文档中所示的所有子类型[subtype]关系都不是相互排斥的. 一个状况[condition]继承它的超类型[supertype]的结构.

类[class] condition 的元类没有被指定. 状况[condition]类型[type]的名字[name]可能被用于指定 define-condition 中的超类型[supertype]关系, 但是如果去尝试使用一个状况[condition]类型[type]作为一个 defclass 表达式形式[form]中的一个超类[superclass], 那么结果是未定义的.

下面这段中展示了定义状况[condition]类型[type]和创建状况[condition]的操作符[operator].

    define-condition  make-condition    

    Figure 9-2. 定义和创建状况的操作符.

下面这段展示了读取状况[condition]槽[slot]的值[value]的操作符[operator].

    arithmetic-error-operands   simple-condition-format-arguments  
    arithmetic-error-operation  simple-condition-format-control    
    cell-error-name             stream-error-stream                
    file-error-pathname         type-error-datum                   
    package-error-package       type-error-expected-type           
    print-not-readable-object   unbound-slot-instance              

    Figure 9-3. 读取状况槽的操作符.

#### 9.1.1.1 严重状况

一个严重状况[serious condition]是一个严重到如果没有处理就需要交互式干预的状况[condition]. 严重状况[serious condition]典型地通过 error 或 cerror 发出; 非严重状况[condition]通常用 signal 或 warn 发出. 

### 9.1.2 <span id="CreatingConditions">创建状况</span>

函数 make-condition 可以被用于显式构造一个状况[condition]对象[object]. 像 error, cerror, signal, 还有 warn 这样的函数在状况[condition]上操作并且可能隐式创建状况[condition]对象[object]. 像 ccase, ctypecase, ecase, etypecase, check-type, 还有 assert 这样的宏也可能隐式地创建 (以及发送[signal]) 状况[condition].

#### 9.1.2.1 状况标识符

状况系统中的许多函数都采用被标识为状况标识符[condition designator]的参数. 按照惯例, 那些参数被记作

    datum &rest arguments

合起来, 这个 datum 和 arguments 是 "一个默认类型 default-type 状况[condition]的标识符[designator]". 表示的状况[condition]如何被计算取决于这个 datum 的类型:

* 如果这个 datum 是一个命名状况[condition]类型[type]的符号[symbol] ...

    表示的状况[condition]是下面这个的结果

     (apply #'make-condition datum arguments)

* 如果这个 datum 是一个格式化控制[format control] ...

    表示的状况[condition]是下面这个的结果

     (make-condition defaulted-type 
                     :format-control datum
                     :format-arguments arguments)

    其中 defaulted-type 是 default-type 的一个子类型[subtype].

* 如果这个 datum 是一个状况[condition] ...

    这个表示的状况[condition]就是这个 datum 自身. 在这个情况下, 除非这个讨论中的操作符[operator]描述中另有说明, 否则实参[argument]必须为 null; 这也就是说, 如果提供了任何其他实参 arguments 那么结果是未定义的.

注意, 这个 default-type 只有在 datum 字符串[string]被提供的情况下才被使用. 在其他情况中, 产生的状况不必是类型[type] default-type.

这里有一些说明, 关于不同的状况标识符[condition designator]如何表示等价的状况[condition]对象[object]:

```LISP
(let ((c (make-condition 'arithmetic-error :operator '/ :operands '(7 0))))
  (error c))
==  (error 'arithmetic-error :operator '/ :operands '(7 0))

(error "Bad luck.")
==  (error 'simple-error :format-control "Bad luck." :format-arguments '())
```

### 9.1.3 <span id="PrintingConditions">打印状况</span>

如果使用了给 define-condition 的 :report 参数, 就会定义一个打印函数, 无论何时当 \*print-escape\* 的值为 false 而且定义的状况[condition]要被打印时, 它会被调用. 这个函数被称为状况汇报器[condition reporter]; 它输出的文本被称为一个报告消息[report message].

当一个状况[condition]被打印并且 \*print-escape\* 是 false, 这个状况[condition]的状况汇报器[condition reporter]会被调用. 使用像 invoke-debugger, break, 和 warn 这样的函数来自动打印状况[condition].

当 \*print-escape\* 是 true 时, 这个对象[object]应该根据这个具体实现的风格以一种简短的方式打印 (比如, print-unreadable-object). 没有要求一个状况[condition]可以通过读取它的打印表示来重新构造.

没有为直接访问或调用状况汇报器[condition reporter]提供函数[function].

#### 9.1.3.1 状况汇报中的推荐风格

为了在向用户呈现报告消息[report message]时确保正确美观的结果, 推荐一些风格的惯例.

关于由状况汇报器[condition reporter]输出的消息内容, 有一些风格上的建议, 但是在那些程序[program]上没有正式的需求. 如果一个程序[program]违反了某些消息的建议, 这条消息的显示可能没有遵循指导方针的那样美观, 但是这个程序[program]仍然被认为是符合规范的程序[conforming program].

这个要求在一个调用状况汇报器[condition reporter]的程序[program]或具体实现[implementation]上更为强烈. 必须允许一个符合规范的程序[conforming program]假设如果遵循这些样式准则, 将保持适当的美观. 在适当的情况下, 关于此类程序的任何具体要求都在下面明确提到.

> * 9.1.3.1.1 [在状况汇报中的大写和标点符号](#CPCR)
> * 9.1.3.1.2 [在状况汇报中领导和尾随的新行](#LTNCR)
> * 9.1.3.1.3 [在状况汇报中内嵌的新行](#ENCR)
> * 9.1.3.1.4 [关于在状况汇报中的 tab 的注意事项](#NTCR)
> * 9.1.3.1.5 [在状况汇报中提及包含函数](#MCFCR)

##### 9.1.3.1.1 <span id="CPCR">在状况汇报中的大写和标点符号</span>

一个报告消息[report message]建议为一个完整的句子, 以适当的大小写并且加标点. 在英语中, 比如, 这个意味着第一个字符应该为大写, 并且这里应该有一个尾部的句号.

```LISP
(error "This is a message")  ; Not recommended
(error "this is a message.") ; Not recommended

(error "This is a message.") ; Recommended instead
```

##### 9.1.3.1.2 <span id="LTNCR">在状况汇报中领导和尾随的新行</span>

一个报告消息[report message]不建议以任何引导文本开始, 像 "Error:" 或 "Warning:" 这样或仅为 freshline 或 newline. 如果对于这个上下文合适, 这样的文本由调用这个状况汇报器[condition reporter]的程序来添加.

一个报告消息[report message]不建议跟着一个尾部的 freshline 或 newline. 如果对于这个上下文合适, 这样的文本由调用这个状况汇报器[condition reporter]的程序来添加.

```LISP
(error "This is a message.~%")   ; Not recommended
(error "~&This is a message.")   ; Not recommended
(error "~&This is a message.~%") ; Not recommended

(error "This is a message.")     ; Recommended instead
```

##### 9.1.3.1.3 <span id="ENCR">在状况汇报中内嵌的新行</span>

如果报告消息[report message]尤其的长, 那么它包含一个或多个内嵌的换行[newline]是允许且适当的.

如果调用程序在消息的第一行中插入了一些额外的前缀(像 "Error:" 或 ";; Error:") , 它也必须确保一个合适的前缀会被添加到这个输出的后续每一行中, 这样一来被状况汇报器[condition reporter]输出的信息的左边界始终会是正确对齐的.

```LISP
(defun test ()
  (error "This is an error message.~%It has two lines."))

;; Implementation A
(test)
This is an error message.
It has two lines.

;; Implementation B
(test)
;; Error: This is an error message.
;;        It has two lines.

;; Implementation C
(test)
>> Error: This is an error message. 
          It has two lines.
```

##### 9.1.3.1.4 <span id="NTCR">关于在状况汇报中的 tab 的注意事项</span>

因为报告消息[report message]的缩进可能会以任意数量转移到右边或左边, 应该对这个不完全标准的字符 <Tab> 特别关注(在支持这样的一个字符[character]的那些具体实现[implementation]中). 除非这个具体实现[implementation]在这个上下文中特别定义了它的行为, 否则应该避免它的使用. 

##### 9.1.3.1.5 <span id="MCFCR">在状况汇报中提及包含函数</span>

这个包含函数的名字通常不应该在报告消息[report message]中被提及. 假定调试器将在必要和适当的情况下使这些信息可访问. 

### 9.1.4 <span id="SignalingHandlingConditions">发送和处理状况</span>

状况系统的操作依赖于活跃的可应用处理者[applicable handler]的顺序, 从最近的到最久远的.

每个处理者[handler]和一个类型指定符[type specifier]相关联, 这个指定符必须指定一个类型[type] condition 的子类型[subtype]. 如果一个状况[condition]是由关联的那个类型指定符[type specifier]指定的类型[type], 那么就说这个处理者[handler]对于这个状况[condition]是可应用的[application].

活跃[active]处理者[handler]通过使用 handler-bind (或者一个基于 handler-bind 的简写, 比如 handler-case 或 ignore-errors) 来建立.

活跃[active]处理者[handler]可以被建立在其他活跃[active]处理者[handler]的动态作用域中. 在程序执行期间的任何点, 这里都有一组活跃[active]处理者[handler]. 当发出一个状况[condition]时, 针对这个状况[condition]的最新近[most recent]的活跃可应用处理者[applicable handler]会从这个组中被选择出来. 给定一个状况[condition], 活跃可应用处理者[applicable handler]的最新近顺序通过下面两条规则来定义:

1. 如果在活跃处理者集合 H1 中的那些处理者被建立时处理者集合 H2 中的那些处理者是活跃的, 那么 H1 中的每个处理者比 H2 中的更新近.

2. 使 h1 和 h2 是相同表达式形式[form]建立的两个可应用的活跃处理者. 如果在这个建立它们的表达式形式[form]中 h1 被定义在 h2 的左边, 那么 h1 比 h2 更新近.

一旦一个处理者绑定表达式形式[form] (例如 handler-bind 或 handler-case) 中的一个处理者被选择, 那个表达式形式[form]中的所有处理者变成对于这个发送过程的剩余部分是非活跃的. 当这个选择的处理者[handler]运行时, 那个表达式形式[form]建立的其他处理者[handler]没有是活跃的. 这也就是说, 如果这个处理者[handler]拒绝处理, 那个表达式形式[form]建立的其他处理者不会被考虑为可能的调用.

下面这一段中展示了和处理状况[condition]相关的操作符[operator].

    handler-bind  handler-case  ignore-errors  

    Figure 9-4. 状况处理相关的操作符.

> * 9.1.4.1 [发送](#Signaling)
> * 9.1.4.2 [重启动](#Restarts)

#### 9.1.4.1 <span id="Signaling">发送</span>

当发送一个状况[condition]时, 最新近的可应用的活跃[active]处理者[handler]会被调用. 有时候一个处理者会通过没有控制转移的简单返回来拒绝. 在这样的情况下, 下一个最新近的活跃可应用的处理者会被调用.

如果对于一个被发送的状况[condition]这里没有可应用的处理者, 或者如果所有可应用的处理者都拒绝了, 那么这个状况[condition]就是未处理的.

如果发送的状况[condition]没有被处理, 不管它们的类型[type], 那么函数 cerror 和 error 调用这个交互式的状况[condition]处理者 (就是这个调试器) 而不是返回. 相比之下, 如果发送的状况[condition]没有被处理, 不管它们的类型[type], signal 就返回 nil.

变量[variable] \*break-on-signals\* 可以被用于在这个发送过程开始前进入调试器.

下面这段展示了和状况[condition]的发送相关的已定义的名字[defined name].

    *break-on-signals*  error   warn  
    cerror              signal        

    Figure 9-5. 状况的发送相关的定义的名字.

##### 9.1.4.1.1 重发一个状况

在一个特定的状况[condition]对象[object]的发送过程的动态范围[dynamic extent]期间, 当且仅当两种情况下表示的情况[situation]相同时允许再次发送同一个状况[condition]对象[object].

比如, 一个处理者[handler]可能合理地发送[signal]这个作为它的实参[argument]的状况[condition]对象[object]来允许更外部的处理者[handler]第一时机去处理[handler]这个状况. (这样一个处理者[handler]有时被称作 "默认处理者(default handler)".) 这个行为是允许的因为第二个发送过程处理的情况[situation]确实是相同的情况[situation].

另一方面, 在一个使用 signal 调用来打断用户进程进而实现异步键盘事件的具体实现[implementation]中, 不允许两个不同的异步键盘事件在同一时间对不同情况发送[signal]相同[identical]状况[condition]. 

#### 9.1.4.2 <span id="Restarts">重启动</span>

交互式状况处理者只通过非局部控制转移到专门定义的重启动[restart]来退出, 这个重启动可以通过系统或用户代码来设置. 转移控制到一个重启动被称为 "调用" 这个重启动. 类似于处理者, 活跃的重启动[restart]也被动态地确立, 并且只有活跃的重启动[restart]可以被调用. 一个活跃的重启动[restart]可以被用户从调试器中或者被程序使用 invoke-restart 来调用.

一个重启动[restart]包含一个在这个重启动[restart]被调用时要被调用的函数[function], 一个被用于查找或调用这个重启动[restart]的可选名字, 以及一个用于调试器来使户手动调用一个重启动[restart]的可选交互式信息集合.

一个重启动[restart]的名字被 invoke-restart 使用. 只能在调试器中调用的重启动[restart]不需要名字.

重启动[restart]可以通过使用 restart-bind, restart-case, 和 with-simple-restart 来建立. 一个重启动[restart]函数自身可以调用任何其他的在这个函数所属的重启动[restart]建立时是活跃的重启动[restart].

通过一个 restart-bind 表达式形式[form], 一个 restart-case 表达式形式[form], 或者一个 with-simple-restart 表达式形式[form]建立的重启动[restart]有着动态范围[dynamic extent], 这个范围延伸到这个表达式形式[form]执行期间.

相同名字的重启动[restart]可以根据下面两条规则来从最久到最近排序:

1. 如果活跃的重启动集合 R1 中的那些重启动[restart]被建立时集合 R2 中的重启动[restart]是活跃的, 那么 R1 中的每个重启动[restart]都比 R2 中的每个重启动[restart]更近.

2. 使 r1 和 r2 为相同表达式形式[form]建立的两个相同名字的活跃重启动[restart]. 如果在建立它们的表达式形式[form]中 r1 被定义在 r2 的左边, 那么 r1 比 r2 更新近.

如果一个重启动[restart]被调用但是没有转移控制, 那么这个重启动[restart]函数产生的值会被调用这个重启动的函数返回, 不管是 invoke-restart 还是 invoke-restart-interactively.

> * 9.1.4.2.1 [重启动的交互式使用](#InteractiveUseRestarts)
> * 9.1.4.2.2 [重启动的接口](#InterfacesRestarts)
> * 9.1.4.2.3 [重启动测试](#RestartTests)
> * 9.1.4.2.4 [关联重启动和状况](#AssociatingRestartCondition)

##### 9.1.4.2.1 <span id="InteractiveUseRestarts">重启动的交互式使用</span>

关于交互式处理, 一个重启动[restart]需要两个信息: 一个汇报函数和一个交互式函数.

这个汇报函数被一个例如调试器的程序使用来呈现这个重启动[restart]会采取的动作的描述. 这个汇报函数是通过给 restart-bind 的 :report-function 关键字或者给 restart-case 的 :report 关键字来指定和建立.

这个交互式函数可以通过给 restart-bind 的 :interactive-function 关键字或给 restart-case 的 :interactive 关键字来指定, 它在重启动[restart]被交互式调用时, 例如从调试器中, 会被用来产生一个合适的参数列表.

invoke-restart 调用和给 invoke-restart 的第一个参数相同名字的最近建立的重启动[restart]. 如果一个重启动被调试器交互式调用并且没有转移控制而是返回值, 那么这个调试器在这些值上的准确动作是由具体实现定义的[implementation-defined]. 

##### 9.1.4.2.2 <span id="InterfacesRestarts">重启动的接口</span>

一些重启动[restart]有着函数接口, 例如 abort, continue, muffle-warning, store-value, 还有 use-value. 它们是内部使用 find-restart 和 invoke-restart 的普通函数, 有着和它们操纵的重启动[restart]相同的名字, 并且简单地出于标记方便而被提供.

下面这段中展示了和重启动[restart]相关的已定义的名字[defined name].

    abort             invoke-restart-interactively  store-value          
    compute-restarts  muffle-warning                use-value            
    continue          restart-bind                  with-simple-restart  
    find-restart      restart-case                                       
    invoke-restart    restart-name                                       

    Figure 9-6. 重启动相关的定义的名字. 

##### 9.1.4.2.3 <span id="RestartTests">重启动测试</span>

每个重启动[restart]都有一个关联的测试, 它是一个单参数(一个状况[condition]或者 nil)的函数, 如果这个重启动[restart]在当前情况[situation]下应该是可见的就返回 true. 这个测试通过给 restart-bind 的 :test-function 选项或者给 restart-case 的 :test 选项创建. 

##### 9.1.4.2.4 <span id="AssociatingRestartCondition">关联重启动和状况</span>

一个重启动[restart]可以通过 with-condition-restarts 来和一个状况[condition]显式关联, 或者通过 restart-case 来隐式关联. 因此一个关联有着动态范围[dynamic extent].

一个单个重启动[restart]可以同时和多个状况[condition]关联. 一个单独状况[condition]同时也可以和多个重启动[restart]关联.

和一个特定状况[condition]关联的活跃重启动可以通过调用例如 find-restart 函数[function]并提供这个状况[condition]作为 condition 实参[argument]来检测. 没有任何关联状况的活跃重启动也可以通过以无 condition 实参[argument]或者为这个实参[argument]提供 nil 值来调用这样一个函数来检测.

### 9.1.5 <span id="Assertions">断言</span>

基于键匹配, 表达式形式求值, 以及类型[type]的状况[condition]的条件发送由断言操作符[operator]处理. 下一段中展示了和断言相关的操作符[operator].

    assert  check-type  ecase      
    ccase   ctypecase   etypecase  

    Figure 9-7. 断言相关的操作符. 


### 9.1.6 <span id="NotesConditionSystemBackground">关于状况系统的背景的注意事项</span>

有关本节中详细描述的抽象概念的背景引用, 见 Exceptional Situations in Lisp. 尽管这篇论文的详情对这份文档没有约束力, 但可能有助于为理解这种资料建立概念基础. 


## 9.2 <span id="ConditionsDictionary">状况字典</span>

> * [状况类型 CONDITION](#CT-CONDITION)
> * [状况类型 WARNING](#CT-WARNING)
> * [状况类型 STYLE-WARNING](#CT-STYLE-WARNING)
> * [状况类型 SERIOUS-CONDITION](#CT-SERIOUS-CONDITION)
> * [状况类型 ERROR](#CT-ERROR)
> * [状况类型 CELL-ERROR](#CT-CELL-ERROR)
> * [函数 CELL-ERROR-NAME](#F-CELL-ERROR-NAME)
> * [状况类型 PARSE-ERROR](#CT-PARSE-ERROR)
> * [状况类型 STORAGE-CONDITION](#CT-STORAGE-CONDITION)
> * [宏 ASSERT](#M-ASSERT)
> * [函数 ERROR](#F-ERROR)
> * [函数 CERROR](#F-CERROR)
> * [宏 CHECK-TYPE](#M-CHECK-TYPE)
> * [状况类型 SIMPLE-ERROR](#CT-SIMPLE-ERROR)
> * [函数 INVALID-METHOD-ERROR](#F-INVALID-METHOD-ERROR)
> * [函数 METHOD-COMBINATION-ERROR](#F-METHOD-COMBINATION-ERROR)
> * [函数 SIGNAL](#F-SIGNAL)
> * [状况类型 SIMPLE-CONDITION](#CT-SIMPLE-CONDITION)
> * [函数 SIMPLE-CONDITION-FORMAT-CONTROL, SIMPLE-CONDITION-FORMAT-ARGUMENTS](#F-SCFC-SCFA)
> * [函数 WARN](#F-WARN)
> * [状况类型 SIMPLE-WARNING](#CT-SIMPLE-WARNING)
> * [函数 INVOKE-DEBUGGER](#F-INVOKE-DEBUGGER)
> * [函数 BREAK](#F-BREAK)
> * [变量 *DEBUGGER-HOOK*](#V-DEBUGGER-HOOK)
> * [变量 *BREAK-ON-SIGNALS*](#V-BREAK-ON-SIGNALS)
> * [宏 HANDLER-BIND](#M-HANDLER-BIND)
> * [宏 HANDLER-CASE](#M-HANDLER-CASE)
> * [宏 IGNORE-ERRORS](#M-IGNORE-ERRORS)
> * [宏 DEFINE-CONDITION](#M-DEFINE-CONDITION)
> * [函数 MAKE-CONDITION](#F-MAKE-CONDITION)
> * [系统类 RESTART](#SC-RESTART)
> * [函数 COMPUTE-RESTARTS](#F-COMPUTE-RESTARTS)
> * [函数 FIND-RESTART](#F-FIND-RESTART)
> * [函数 INVOKE-RESTART](#F-INVOKE-RESTART)
> * [函数 INVOKE-RESTART-INTERACTIVELY](#F-INVOKE-RESTART-INTERACTIVELY)
> * [宏 RESTART-BIND](#M-RESTART-BIND)
> * [宏 RESTART-CASE](#M-RESTART-CASE)
> * [函数 RESTART-NAME](#F-RESTART-NAME)
> * [宏 WITH-CONDITION-RESTARTS](#M-WITH-CONDITION-RESTARTS)
> * [宏 WITH-SIMPLE-RESTART](#M-WITH-SIMPLE-RESTART)
> * [重启动 ABORT](#R-ABORT)
> * [重启动 CONTINUE](#R-CONTINUE)
> * [重启动 MUFFLE-WARNING](#R-MUFFLE-WARNING)
> * [重启动 STORE-VALUE](#R-STORE-VALUE)
> * [重启动 USE-VALUE](#R-USE-VALUE)
> * [函数 ABORT, CONTINUE, MUFFLE-WARNING, STORE-VALUE, USE-VALUE](#F-ABORT-CONTINUE-MW-SV-UV)


### <span id="CT-CONDITION">状况类型 CONDITION</span>

* 类优先级列表(Class Precedence List):

        condition, t

* 描述(Description):

        所有状况[condition]类型, 不管是错误或是非错误, 必须继承自这个类型[type].

        在指定的类型[type] condition 的子类型[subtype]中不允许额外的子类型[subtype]关系, 除非在这个文本中明确提及; 然而具体实现允许去引入一些额外类型[type]并且这些类型[type]中的一个可以是类型[type] condition 任何数量子类型[subtype]的一个子类型[subtype].

        一个用户定义的状况[condition]类型[type]是否有着可以被 with-slots 访问的槽[slot]是依赖于具体实现的[implementation-dependent]. 此外, 即便在一个具体实现[implementation]中用户定义的状况[condition]类型[type]有着槽[slot], 但是这个文档中定义的任何状况[condition]类型[type]是否有着槽是依赖于具体实现的[implementation-dependent], 如果它们确实有, 那么它们的名字[name]也是依赖于具体实现的[implementation-dependent]; 只有这个规范中记录的读取器函数可以被可移植代码所依赖.

        符合规范的代码[conforming code]必须遵守下面这个和状况[condition]相关的约束:

        * define-condition, 而不是 defclass, 必须被用于定义新的状况[condition]类型[type].

        * make-condition, 而不是 make-instance, 必须被用于显式创建状况[condition]对象[object].

        * 必须使用 define-condition 的这个 :report 选项, 而不是 print-object 的 defmethod, 来定义一个状况汇报器.

        * slot-value, slot-boundp, slot-makunbound, 和 with-slots 一定不能在状况[condition]对象[object]上使用. 反而, 应该使用合适的访问器函数 (通过 define-condition 定义). 


### <span id="CT-WARNING">状况类型 WARNING</span>

* 类优先级列表(Class Precedence List):

        warning, condition, t

* 描述(Description):

        类型[type] warning 包含所有警告的类型.

* 参见(See Also):

        style-warning 


### <span id="CT-STYLE-WARNING">状况类型 STYLE-WARNING</span>

* 类优先级列表(Class Precedence List):

        style-warning, warning, condition, t

* 描述(Description):

        类型[type] style-warning 包括那些表示代码[code]是符合规范的代码[conforming code]但是仍然被认为是错误的或者不符合标准的情况[situation]的状况[condition].

* 参见(See Also):

        muffle-warning

* 注意(Notes):

        如果一个具体实现[implementation]遇到使用废弃特性的代码[code]或者不美观的或无效的代码[code], 它可能发出这样一个状况[condition].

        一个 '没有被使用的变量(unused variable)' 警告必须是 style-warning 类型[type].

        一般而言, 代码是错误的还是不合规范的问题是由处理代码[code]的工具做出的一个主观决定. 这样的意图是, 无论何时这样的一个工具想在主观理由上抱怨代码, 它应该使用这个状况[condition]类型[type], 以便那些希望去重定向或者抑制多余警告的用户可以做这些而不用担心他们被重定向或抑制其他更严重的警告. 

### <span id="CT-SERIOUS-CONDITION">状况类型 SERIOUS-CONDITION</span>

* 类优先级列表(Class Precedence List):

serious-condition, condition, t

* 描述(Description):

        所有严重到如果没被处理就需要交互式干预的状况[condition]应该继承自类型[type] serious-condition. 提供这种状况类型主要是为了使它可以被包含作为其他状况[condition]类型[type]的超类[superclass]; 它不打算被直接发送.

* 注意(Notes):

        发送一个严重状况[serious condition]自身不会强制进入调试器. 然而, 除非在程序员可以确保处理[handle]不了严重状况[serious condition]不会造成伤害的不寻常情况下, 否则这样一个状况[condition]通常使用 error 来发送而不是 signal, 进而确保这个程序在没有处理这个状况[condition]的情况下不会继续下去. (但反之, 使用 signal 而不是 error 去发送非严重状况[serious condition]的状况是传统做法, 因为正常情况下, 处理不了非严重情况并不是进入调试器的原因.) 


### <span id="CT-ERROR">状况类型 ERROR</span>

* 类优先级列表(Class Precedence List):

        error, serious-condition, condition, t

* 描述(Description):

        这个类型[type] error 由所有表示错误[error]的状况[condition]组成. 


### <span id="CT-CELL-ERROR">状况类型 CELL-ERROR</span>

* 类优先级列表(Class Precedence List):

        cell-error, error, serious-condition, condition, t

* 描述(Description):

        类型[type] cell-error 由发生在位置访问[eccess]期间的错误状况组成. 违规的存储格(cell)的名字由 make-condition 的 :name 初始化参数来初始化, 通过函数[function] cell-error-name 来访问.

* 参见(See Also):

        cell-error-name 


### <span id="F-CELL-ERROR-NAME">函数 CELL-ERROR-NAME</span>

* 语法(Syntax):

        cell-error-name condition => name

* 参数和值(Arguments and Values):

        condition---一个 cell-error 类型[type]的状况[condition].
        name---一个对象[object].

* 描述(Description):

        返回那个状况 condition 所表示的情况[situation]中违规的存储格(cell)的名字[name].

        结果的性质取决于状况 condition 具体类型. 比如, 如果这个状况 condition 是 unbound-variable 类型[type], 那么这个结果是那个要被访问的未绑定变量[unbound variable]的名字[name], 如果这个状况 condition 是 undefined-function 类型[type], 那么这个就是那个要被访问的未绑定函数[undefined function ]的名字[name], 而当这个状况 condition 是 unbound-slot 类型[type], 这个就是要被访问的槽[slot]的名字[name].

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        cell-error, unbound-slot, unbound-variable, undefined-function, 章节 9.1 (状况系统的概念)

* 注意(Notes): None. 


### <span id="CT-PARSE-ERROR">状况类型 PARSE-ERROR</span>

* 类优先级列表(Class Precedence List):

        parse-error, error, serious-condition, condition, t

* 描述(Description):

        类型[type] parse-error 由解析相关的错误状况组成.

* 参见(See Also):

        parse-namestring, reader-error 


### <span id="CT-STORAGE-CONDITION">状况类型 STORAGE-CONDITION</span>

* 类优先级列表(Class Precedence List):

        storage-condition, serious-condition, condition, t

* 描述(Description):

        类型 storage-condition 由内存管理问题相关的严重状况组成, 这些状况可能是由于依赖于具体实现[implementation-dependent]的限制而不是符合规范的程序[conforming program]中的语义错误, 并且如果没有被处理通常需要进入到调试器中. 根据具体实现[implementation]的细节, 这些可能包括堆栈溢出, 内存区域溢出和存储耗尽等问题.

* 注意(Notes):

        尽管由于一些 Common Lisp 操作符被定义用来创建对象[object], 可能会发出存储状况[storage-condition], 但是那些不是被定义用来创建对象[object]的操作符是否会创建它们并且是否也可能发出存储状况[storage-condition]是未指定的. 同样的, 求值器自身也可能创建对象[object]并且因此可能发出 storage-condition. (自然的假设可能是, 这样的对象[object]创建自然是低效的, 但即使这样做也是依赖于具体实现的[implementation-dependent].) 通常, 存储分配如何完成的整个问题都是依赖于具体实现的[implementation-dependent], 因此任何操作符在任何时间都可能发出 storage-condition. 由于这样一个状况[condition]是具体实现[implementation]或镜像限制的象征而不是一个程序[program]中的错误, 因此类型[type] storage-condition 的对象[object]不是类型[type] error. 


### <span id="M-ASSERT">宏 ASSERT</span>

* 语法(Syntax):

        assert test-form [(place*) [datum-form argument-form*]]

=> nil

* 参数和值(Arguments and Values):

        test-form---一个表达式形式[form]; 总是求值的.
        place---一个位置[place]; 如果发出一个错误就求值.
        datum-form---一个求值为一个数据 datum 的表达式形式[form]. 每次要发出一个错误就求值, 如果没有错误发出就一次都不求值.
        argument-form---求值为一个参数 argument 的一个表达式形式[form]. 每次要发出一个错误就求值, 如果没有错误发出就一次都不求值.
        datum, arguments---一个默认类型 error 的状况[condition]的标识符[designator]. (这些标识符[designator]是求值数据表达式形式 datum-form 和每个参数表达式形式 argument-form 的结果.)

* 描述(Description):

        assert 确保这个 test-form 求值为 true. 如果 test-form 求值为 false, assert 发出一个可校正的[correctable]错误[error] (用 datum 和 arguments 来表示). 从这个错误中使用 continue 重启动[restart]来继续下去使得用户在 assert 再一次求值 test-form 之前修改位置 places 的值成为可能. 如果这个 test-form 的值不是 nil [non-nil], assert 返回 nil.

        这些位置 places 是 test-form 所依赖的对数据的广义引用[generalized reference], 在试图校正这个错误时, 用户可以改变它们的值. 每个位置 place 的子表达式形式[subform]只有在一个错误被发出时被求值, 并且在这个错误被再次发出时可能被再次求值 (在没有实际修正这个问题的情况下继续之后). 这些位置 places 的求值顺序没有被指定; 见章节 5.1.1.1 (位置的子表达式形式求值). 如果一个被提供的位置 place 表达式形式[form]产生值的数量超出了这些存储变量的数量, 额外的值会被忽略. 如果提供的这个表达式形式[form]产生的值的数量少于这些存储变量, 那么缺少的值被设置为 nil.

* 示例(Examples):

    ```LISP
    (setq x (make-array '(3 5) :initial-element 3))
    =>  #2A((3 3 3 3 3) (3 3 3 3 3) (3 3 3 3 3))
    (setq y (make-array '(3 5) :initial-element 7))
    =>  #2A((7 7 7 7 7) (7 7 7 7 7) (7 7 7 7 7))
    (defun matrix-multiply (a b)
      (let ((*print-array* nil))
        (assert (and (= (array-rank a) (array-rank b) 2)
                      (= (array-dimension a 1) (array-dimension b 0)))
                (a b)
                "Cannot multiply ~S by ~S." a b)
                (really-matrix-multiply a b))) =>  MATRIX-MULTIPLY
    (matrix-multiply x y)
    >>  Correctable error in MATRIX-MULTIPLY: 
    >>  Cannot multiply #<ARRAY ...> by #<ARRAY ...>.
    >>  Restart options:
    >>   1: You will be prompted for one or more new values.
    >>   2: Top level.
    >>  Debug> :continue 1
    >>  Value for A: x
    >>  Value for B: (make-array '(5 3) :initial-element 6)
    =>  #2A((54 54 54 54 54)
          (54 54 54 54 54)
          (54 54 54 54 54)
          (54 54 54 54 54)
          (54 54 54 54 54))

    (defun double-safely (x) (assert (numberp x) (x)) (+ x x))
    (double-safely 4) 
    =>  8
    
    (double-safely t)
    >>  Correctable error in DOUBLE-SAFELY: The value of (NUMBERP X) must be non-NIL.
    >>  Restart options:
    >>   1: You will be prompted for one or more new values.
    >>   2: Top level.
    >>  Debug> :continue 1
    >>  Value for X: 7
    =>  14
    ```

* 受此影响(Affected By):

        *break-on-signals*

        活跃的状况处理者集合.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        check-type, error, 章节 5.1 (广义引用)

* 注意(Notes):

        调试器不需要在错误信息中包含这个 test-form , 并且这些位置 places 也不应该被包含在这个信息中, 但是它们应该供用户查看. 如果用户给了  "continue" 命令, 那么任何这些引用的值都能被修改. 这个细节取决于具体实现的用户接口风格. 


### <span id="F-ERROR">函数 ERROR</span>

* 语法(Syntax):

        error datum &rest arguments =>|

* 参数和值(Arguments and Values):

        datum, arguments---一个默认类型 simple-error 的状况[condition]的标识符[designator].

* 描述(Description):

        error 实际上在表示的状况[condition]上调用 signal.

        如果这个状况[condition]没有被处理, (invoke-debugger condition) 就会被执行. 作为调用 invoke-debugger 的后果, error 不能直接返回; 从 error 中仅有的退出方式可以通过在一个处理者中非局部转移控制或使用交互式调试命令来实现.

* 示例(Examples):

    ```LISP
    (defun factorial (x)
      (cond ((or (not (typep x 'integer)) (minusp x))
              (error "~S is not a valid argument to FACTORIAL." x))
            ((zerop x) 1)
            (t (* x (factorial (- x 1))))))
    =>  FACTORIAL
    (factorial 20)
    =>  2432902008176640000
    (factorial -1)
    >>  Error: -1 is not a valid argument to FACTORIAL.
    >>  To continue, type :CONTINUE followed by an option number:
    >>   1: Return to Lisp Toplevel.
    >>  Debug> 

    (setq a 'fred)
    =>  FRED
    (if (numberp a) (1+ a) (error "~S is not a number." A))
    >>  Error: FRED is not a number.
    >>  To continue, type :CONTINUE followed by an option number:
    >>   1: Return to Lisp Toplevel.
    >>  Debug> :Continue 1
    >>  Return to Lisp Toplevel.
    
    (define-condition not-a-number (error) 
                      ((argument :reader not-a-number-argument :initarg :argument))
      (:report (lambda (condition stream)
                  (format stream "~S is not a number."
                          (not-a-number-argument condition)))))
    =>  NOT-A-NUMBER
    
    (if (numberp a) (1+ a) (error 'not-a-number :argument a))
    >>  Error: FRED is not a number.
    >>  To continue, type :CONTINUE followed by an option number:
    >>   1: Return to Lisp Toplevel.
    >>  Debug> :Continue 1
    >>  Return to Lisp Toplevel.
    ```

* 副作用(Side Effects):

        那个指定的状况的那些处理者[handler], 如果存在, 会被调用并且可能有副作用. 程序执行可能停止, 并且可能进入到调试器中.

* 受此影响(Affected By):

        已存在的处理者绑定.

        *break-on-signals*

* 异常情况(Exceptional Situations): 

        如果 datum 和 arguments 不是一个状况[condition]的标识符[designator], 就发出一个类型[type] type-error 的错误.

* 参见(See Also):

        cerror, signal, format, ignore-errors, *break-on-signals*, handler-bind, 章节 9.1 (状况系统的概念)

* 注意(Notes):

        某些具体实现可能为从单独的堆栈结构中交互式返回提供调试器命令. 然而, 程序员应该有信心去编写像下面这样的代码:

        (defun wargames:no-win-scenario ()
          (if (error "pushing the button would be stupid."))
          (push-the-button))

        在这种情况下, error 不可能返回, 按钮不会被按下.

        虽然这个程序的意义是明确的, 并且它可能被正式的定理证明是"安全的", 但是这样的证明并不能保证程序的执行是安全的. 众所周知, 编译器有bug, 计算机有信号故障, 而人类则以不可能预测的方式进行手动干预. 这些种类的错误, 虽然超出了状况系统对于正式建模的范围, 但它不会超出编写代码时应该认真考虑的范围, 而这些代码可能会有本例所暗示的那种广泛的影响. 


### <span id="F-CERROR">函数 CERROR</span>

* 语法(Syntax):

        cerror continue-format-control datum &rest arguments => nil

* 参数和值(Arguments and Values):

        Continue-format-control---一个格式化控制字符串[format control].
        datum, arguments---一个默认类型 simple-error 的状况[condition]的标识符[designator].

* 描述(Description):

        cerror 实际上在名为 datum 的状况[condition]上调用 error. 就像任何隐式调用 error 的函数一样, 如果这个状况[condition]没有被处理, (invoke-debugger condition) 会被执行. 正在发送中, 以及在调试器中, 如果到达的话, 使用 continue 重启动[restart]来继续代码的执行(换句话说, 从 cerror 中返回)是可能的.

        如果 datum 是一个状况[condition], 可以提供 arguments, 但是要和格式化控制 continue-format-control 一起使用.

* 示例(Examples):

    ```LISP
    (defun real-sqrt (n)
      (when (minusp n)
        (setq n (- n))
        (cerror "Return sqrt(~D) instead." "Tried to take sqrt(-~D)." n))
      (sqrt n))

    (real-sqrt 4)
    =>  2.0

    (real-sqrt -9)
    >>  Correctable error in REAL-SQRT: Tried to take sqrt(-9).
    >>  Restart options:
    >>   1: Return sqrt(9) instead.
    >>   2: Top level.
    >>  Debug> :continue 1
    =>  3.0
    
    (define-condition not-a-number (error)
      ((argument :reader not-a-number-argument :initarg :argument))
      (:report (lambda (condition stream)
                  (format stream "~S is not a number." 
                          (not-a-number-argument condition)))))
    
    (defun assure-number (n)
      (loop (when (numberp n) (return n))
            (cerror "Enter a number."
                    'not-a-number :argument n)
            (format t "~&Type a number: ")
            (setq n (read))
            (fresh-line)))

    (assure-number 'a)
    >>  Correctable error in ASSURE-NUMBER: A is not a number.
    >>  Restart options:
    >>   1: Enter a number.
    >>   2: Top level.
    >>  Debug> :continue 1
    >>  Type a number: 1/2
    =>  1/2

    (defun assure-large-number (n)
      (loop (when (and (numberp n) (> n 73)) (return n))
            (cerror "Enter a number~:[~; a bit larger than ~D~]."
                    "~*~A is not a large number." 
                    (numberp n) n)
            (format t "~&Type a large number: ")
            (setq n (read))
            (fresh-line)))
    
    (assure-large-number 10000)
    =>  10000

    (assure-large-number 'a)
    >>  Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.
    >>  Restart options:
    >>   1: Enter a number.
    >>   2: Top level.
    >>  Debug> :continue 1
    >>  Type a large number: 88
    =>  88

    (assure-large-number 37)
    >>  Correctable error in ASSURE-LARGE-NUMBER: 37 is not a large number.
    >>  Restart options:
    >>   1: Enter a number a bit larger than 37.
    >>   2: Top level.
    >>  Debug> :continue 1
    >>  Type a large number: 259
    =>  259
    
    (define-condition not-a-large-number (error)
      ((argument :reader not-a-large-number-argument :initarg :argument))
      (:report (lambda (condition stream)
                  (format stream "~S is not a large number." 
                          (not-a-large-number-argument condition)))))
    
    (defun assure-large-number (n)
      (loop (when (and (numberp n) (> n 73)) (return n))
            (cerror "Enter a number~3*~:[~; a bit larger than ~*~D~]."
                    'not-a-large-number
                    :argument n 
                    :ignore (numberp n)
                    :ignore n
                    :allow-other-keys t)
            (format t "~&Type a large number: ")
            (setq n (read))
            (fresh-line)))
    

    (assure-large-number 'a)
    >>  Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.
    >>  Restart options:
    >>   1: Enter a number.
    >>   2: Top level.
    >>  Debug> :continue 1
    >>  Type a large number: 88
    =>  88
    
    (assure-large-number 37)
    >>  Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.
    >>  Restart options:
    >>   1: Enter a number a bit larger than 37.
    >>   2: Top level.
    >>  Debug> :continue 1
    >>  Type a large number: 259
    =>  259
    ```

* 受此影响(Affected By):

        *break-on-signals*.

        已存在的处理者绑定.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        error, format, handler-bind, *break-on-signals*, simple-type-error

* 注意(Notes):

        如果 datum 是一个状况[condition]类型[type]而不是一个字符串[string], format 指令 ~* 在 continue-format-control 中用来忽略初始化参数列表[initialization argument list]中的关键字[keyword]可能特别有用. 比如:

        (cerror "enter a new value to replace ~*~s" 
                'not-a-number
                :argument a)



### <span id="M-CHECK-TYPE">宏 CHECK-TYPE</span>

* 语法(Syntax):

        check-type place typespec [string] => nil

* 参数和值(Arguments and Values):

        place---一个位置[place].
        typespec---一个类型指定符[type specifier].
        string---一个字符串[string]; 求值的.

* 描述(Description):

        如果这个位置 place 的内容不是类型 typespec, 那么 check-type 发出一个类型[type] type-error 的可校正[correctable]错误[error].

        当且仅当 store-value 重启动[restart]被调用, 不管是显式地从一个处理者还是隐式地作为调试器提供的其中一个选项, check-type 可以返回. 如果这个 store-value 重启动[restart]被调用, check-type 存储给这个重启动[restart]调用的参数(或者是通过调试器交互式提示的那个)作为新值到位置 place 并重新开始, 检测这个新值的类型并且如果它仍然不是要求的类型[type]就会发出另一个错误.

        第一次位置 place 被求值时, 它通过正常的求值规则来求值. 如果类型检测失败并且使用了这个 store-value 重启动[restart]那么它接下来被求值为一个位置[place]; 见章节 5.1.1.1 (位置的子表达式形式求值).

        字符串[string]应该是这个类型的一个英语描述, 以一个不定冠词开始 ("a" 或者 "an"). 如果没有提供字符串[string], 它就会自动通过 typespec 来计算. 这个自动生成的信息提及了位置 place, 它的内容和要求的类型. 如果一个具体实现把这个位置 place 识别为一个特定形式, 例如给名为 check-type 的函数的其中一个参数, 这个具体实现可能选择去生成一个措词有点不同的错误信息. 字符串 string 是允许的, 因为 check-type 的一些应用可能需要一个比从 typespec 自动生成的更具体的关于需要什么的描述.

* 示例(Examples):

    ```LISP
    (setq aardvarks '(sam harry fred))
    =>  (SAM HARRY FRED)
    (check-type aardvarks (array * (3)))
    >>  Error: The value of AARDVARKS, (SAM HARRY FRED),
    >>         is not a 3-long array.
    >>  To continue, type :CONTINUE followed by an option number:
    >>   1: Specify a value to use instead.
    >>   2: Return to Lisp Toplevel.
    >>  Debug> :CONTINUE 1
    >>  Use Value: #(SAM FRED HARRY)
    =>  NIL
    aardvarks
    =>  #<ARRAY-T-3 13571>
    (map 'list #'identity aardvarks)
    =>  (SAM FRED HARRY)
    (setq aardvark-count 'foo)
    =>  FOO
    (check-type aardvark-count (integer 0 *) "A positive integer")
    >>  Error: The value of AARDVARK-COUNT, FOO, is not a positive integer.
    >>  To continue, type :CONTINUE followed by an option number:
    >>   1: Specify a value to use instead.
    >>   2: Top level.
    >>  Debug> :CONTINUE 2

    (defmacro define-adder (name amount)
      (check-type name (and symbol (not null)) "a name for an adder function")
      (check-type amount integer)
      `(defun ,name (x) (+ x ,amount)))
      
    (macroexpand '(define-adder add3 3))
    =>  (defun add3 (x) (+ x 3))
    
    (macroexpand '(define-adder 7 7))
    >>  Error: The value of NAME, 7, is not a name for an adder function.
    >>  To continue, type :CONTINUE followed by an option number:
    >>   1: Specify a value to use instead.
    >>   2: Top level.
    >>  Debug> :Continue 1
    >>  Specify a value to use instead.
    >>  Type a form to be evaluated and used instead: 'ADD7
    =>  (defun add7 (x) (+ x 7))
    
    (macroexpand '(define-adder add5 something))
    >>  Error: The value of AMOUNT, SOMETHING, is not an integer.
    >>  To continue, type :CONTINUE followed by an option number:
    >>   1: Specify a value to use instead.
    >>   2: Top level.
    >>  Debug> :Continue 1
    >>  Type a form to be evaluated and used instead: 5
    =>  (defun add5 (x) (+ x 5))
    ```

        控制被转移到一个处理者.

* 副作用(Side Effects):

        可能进入到调试器中.

* 受此影响(Affected By):

        *break-on-signals*

        这个具体实现.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        章节 9.1 (状况系统的概念)

* 注意(Notes):

    ```LISP
    (check-type place typespec)
    ==  (assert (typep place 'typespec) (place)
                'type-error :datum place :expected-type 'typespec)
    ```

### <span id="CT-SIMPLE-ERROR">状况类型 SIMPLE-ERROR</span>

* 类优先级列表(Class Precedence List):

        simple-error, simple-condition, error, serious-condition, condition, t

* 描述(Description):

        当提供了一个格式化控制字符串[format control]作为 error 或 cerror 的第一个参数时, 类型 simple-error 由通过 error 或 cerror 发出的状况组成. 


### <span id="F-INVALID-METHOD-ERROR">函数 INVALID-METHOD-ERROR</span>

* 语法(Syntax):

        invalid-method-error method format-control &rest args => implementation-dependent

* 参数和值(Arguments and Values):

        method---一个方法[method].
        format-control---一个格式化控制字符串[format control].
        args---格式化控制字符串 format-control 的格式化参数[format argument].

* 描述(Description):

        当这里有一个可应用方法[method]的方法组合类型的限定符[qualifier]不合法时, 使用函数[function] invalid-method-error 来发出一个 error 类型[type]的错误. 错误信息通过使用适用于 format 的格式化控制字符串 format-control 以及给它的任何参数 arg 组成. 由于一个具体实现可能需要给错误信息添加额外的上下文信息, invalid-method-error 应该只在一个方法组合函数的动态范围中被调用.

        当一个方法[method]不满足一个 define-method-combination 表达式形式[form]中的每个限定符[qualifier]模式和断言, 那么函数[function] invalid-method-error 被自动调用. 如果一个强加额外限制的方法组合函数遇到一个它不能接受的方法[method], 那么这个方法组合函数应该显式调用 invalid-method-error.

        invalid-method-error 是返回到它的调用者还是通过 throw 退出是依赖于具体实现的[implementation-dependent].

* 示例(Examples): None.

* 副作用(Side Effects):

        可能会进入调试器中.

* 受此影响(Affected By):

        *break-on-signals*

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        define-method-combination

* 注意(Notes): None. 


### <span id="F-METHOD-COMBINATION-ERROR">函数 METHOD-COMBINATION-ERROR</span>

* 语法(Syntax):

        method-combination-error format-control &rest args => implementation-dependent

* 参数和值(Arguments and Values):

        format-control---一个格式化控制字符串[format control].
        args---格式化控制字符串 format-control 的格式化参数[format argument].

* 描述(Description):

        函数[function] method-combination-error 被用于在方法组合中发出一个错误.

        错误信息通过使用适用于 format 的格式化控制字符串 format-control 以及给它的任何参数 arg 组成. 由于一个具体实现可能需要给错误信息添加额外的上下文信息, method-combination-error 应该只在一个方法组合函数的动态范围中被调用.

        method-combination-error 是返回到它的调用者还是通过 throw 退出是依赖于具体实现的[implementation-dependent].

* 示例(Examples): None.

* 副作用(Side Effects):

        可能进入到调试器中.

* 受此影响(Affected By):

        *break-on-signals*

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        define-method-combination

* 注意(Notes): None. 


### <span id="F-SIGNAL">函数 SIGNAL</span>

* 语法(Syntax):

        signal datum &rest arguments => nil

* 参数和值(Arguments and Values):

        datum, arguments---一个默认类型 simple-condition 的状况[condition]的标识符[designator].

* 描述(Description):

        发出[signal]这个给定的 datum 和 arguments 表示的状况[condition]. 如果这个状况[condition]没有被处理, signal 就返回 nil.

* 示例(Examples):

    ```LISP
    (defun handle-division-conditions (condition)
      (format t "Considering condition for division condition handling~%")
      (when (and (typep condition 'arithmetic-error)
                  (eq '/ (arithmetic-error-operation condition)))
        (invoke-debugger condition)))
    HANDLE-DIVISION-CONDITIONS
    (defun handle-other-arithmetic-errors (condition)
      (format t "Considering condition for arithmetic condition handling~%")
      (when (typep condition 'arithmetic-error)
        (abort)))
    HANDLE-OTHER-ARITHMETIC-ERRORS
    (define-condition a-condition-with-no-handler (condition) ())
    A-CONDITION-WITH-NO-HANDLER
    (signal 'a-condition-with-no-handler)
    NIL
    (handler-bind ((condition #'handle-division-conditions)
                      (condition #'handle-other-arithmetic-errors))
      (signal 'a-condition-with-no-handler))
    Considering condition for division condition handling
    Considering condition for arithmetic condition handling
    NIL
    (handler-bind ((arithmetic-error #'handle-division-conditions)
                      (arithmetic-error #'handle-other-arithmetic-errors))
      (signal 'arithmetic-error :operation '* :operands '(1.2 b)))
    Considering condition for division condition handling
    Considering condition for arithmetic condition handling
    Back to Lisp Toplevel
    ```

* 副作用(Side Effects):

        可能由于 *break-on-signals* 进入到调试器中.

        要被发送的状况的处理者可能转移控制.

* 受此影响(Affected By):

        已存在的处理者绑定.

        *break-on-signals*

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        *break-on-signals*, error, simple-condition, 章节 9.1.4 (发送和处理状况)

* 注意(Notes):

        如果 (typep datum *break-on-signals*) 产生[yield] true, 那么在这个发送过程开始前进入调试器. 这个 continue 重启动[restart]可以被用于继续这个发送过程. 对于所有应该, 可能, 或者必须发送[signal]状况[condition]的其他函数[function]和宏[macro], 这个也是对的. 


### <span id="CT-SIMPLE-CONDITION">状况类型 SIMPLE-CONDITION</span>

* 类优先级列表(Class Precedence List):

        simple-condition, condition, t

* 描述(Description):

        每当一个格式化控制字符串 format-control 作为第一个参数提供给 signal 函数时, 类型[type] simple-condition 表示由这个 signal 发出的状况[condition]. 这个格式化控制[format control]和格式化参数[format argument]使用提供给 make-condition 的名为 :format-control 和 :format-arguments 的初始化参数来初始化, 并且可以通过函数[function] simple-condition-format-control 和 simple-condition-format-arguments 来访问. 如果格式化参数没有提供给 make-condition, 那么 nil 就被用作默认值.

* 参见(See Also):

        simple-condition-format-control, simple-condition-format-arguments 


### <span id="F-SCFC-SCFA">函数 SIMPLE-CONDITION-FORMAT-CONTROL, SIMPLE-CONDITION-FORMAT-ARGUMENTS</span>

* 语法(Syntax):

        simple-condition-format-control condition => format-control

        simple-condition-format-arguments condition => format-arguments

* 参数和值(Arguments and Values):

        condition---一个 simple-condition 类型[type]的状况.
        format-control---一个格式化控制字符串[format control].
        format-arguments---一个列表[list].

* 描述(Description):

        simple-condition-format-control 返回处理这个状况 condition 的格式化参数[format argument]所需要的格式化控制字符串[format control].

        simple-condition-format-arguments 返回一个处理这个状况 condition 的格式化控制字符串[format control]所需要的格式化参数[format argument]的列表[list].

* 示例(Examples):

    ```LISP
    (setq foo (make-condition 'simple-condition
                              :format-control "Hi ~S"
                              :format-arguments '(ho)))
    =>  #<SIMPLE-CONDITION 26223553>
    (apply #'format nil (simple-condition-format-control foo)
                        (simple-condition-format-arguments foo))
    =>  "Hi HO"
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        simple-condition, 章节 9.1 (状况系统的概念)

* 注意(Notes): None. 


### <span id="F-WARN">函数 WARN</span>

* 语法(Syntax):

        warn datum &rest arguments => nil

* 参数和值(Arguments and Values):

        datum, arguments---一个默认类型 simple-warning 的状况[condition]的标识符[designator].

* 描述(Description):

        发送[signal]一个类型[type] warning 的状况[condition]. 如果这个状况[condition]没有被处理, 报告这个状况[condition]到错误输出[error output].

        警告的精确机制如下:

        这个 warning 状况被发出

            当这个 warning 状况[condition]要被发送时, 这个 muffle-warning 重启动[restart]会为了被一个处理者[handler]使用而被建立. 如果被调用了, 这个重启动[restart]绕开 warn 的进一步动作, 这个反过来导致了 warn 立即返回 nil.

        如果没有找到这个 warning 状况的处理者

            如果没有找到这个 warning 状况的处理者, 或者这些处理者都拒绝了, 那么这个状况[condition]会通过 warn 以一种依赖于具体实现[implementation-dependent]的格式被报告到错误输出[error output].

        返回了 nil

            如果 warn 返回的是 nil 那么这个值就被 warn 返回.

* 示例(Examples):

    ```LISP
      (defun foo (x)
        (let ((result (* x 2)))
          (if (not (typep result 'fixnum))
              (warn "You're using very big numbers."))
          result))
    =>  FOO
    
      (foo 3)
    =>  6
    
      (foo most-positive-fixnum)
    >>  Warning: You're using very big numbers.
    =>  4294967294
    
      (setq *break-on-signals* t)
    =>  T
    
      (foo most-positive-fixnum)
    >>  Break: Caveat emptor.
    >>  To continue, type :CONTINUE followed by an option number.
    >>   1: Return from Break.
    >>   2: Abort to Lisp Toplevel.
    >>  Debug> :continue 1
    >>  Warning: You're using very big numbers.
    =>  4294967294
    ```

* 副作用(Side Effects):

        发出一个警告. 可能进入到调试器中.

* 受此影响(Affected By):

        已存在的处理者绑定.

        *break-on-signals*, *error-output*.

* 异常情况(Exceptional Situations):

        如果 datum 是一个状况[condition]并且这个状况[condition]不是类型[type] warning, 或者参数 arguments 不是 nil [non-nil], 会发出一个类型[type] type-error 的错误.

        如果 datum 是一个状况类型, (apply #'make-condition datum arguments) 的结果必须是类型[type] warning, 否则发出一个类型[type] type-error 的错误.

* 参见(See Also):

        *break-on-signals*, muffle-warning, signal

* 注意(Notes): None. 


### <span id="CT-SIMPLE-WARNING">状况类型 SIMPLE-WARNING</span>

* 类优先级列表(Class Precedence List):

        simple-warning, simple-condition, warning, condition, t

* 描述(Description):

        每当一个格式化控制字符串[format control]作为第一个参数提供给 warn 时, 类型[type] simple-warning 表示 warn 发送的状况[condition]. 


### <span id="F-INVOKE-DEBUGGER">函数 INVOKE-DEBUGGER</span>

* 语法(Syntax):

        invoke-debugger condition =>|

* 参数和值(Arguments and Values):

        condition---一个状况[condition]对象[object].

* 描述(Description):

        invoke-debugger 尝试带状况 condition 进入这个调试器.

        如果 *debugger-hook* 不是 nil, 它应该是一个在进入标准调试器之前要被调用的函数[function] (或者一个函数[name]的名字). 随着 *debugger-hook* 绑定为 nil 这个函数[function]被调用, 并且这个函数[function]必须接受两个参数: 这个状况 condition 和这个 *debugger-hook* 被绑定为 nil 之前的值. 如果这个函数[function]正常返回, 就进入标准调试器.

        标准调试器从不直接返回. 只有通过一个例如使用重启动函数的非局部转移才可能返回.

* 示例(Examples):

    ```LISP
    (ignore-errors ;Normally, this would suppress debugger entry
      (handler-bind ((error #'invoke-debugger)) ;But this forces debugger entry
        (error "Foo.")))
    Debug: Foo.
    To continue, type :CONTINUE followed by an option number:
    1: Return to Lisp Toplevel.
    Debug>
    ```

* 副作用(Side Effects):

        *debugger-hook* 被绑定为 nil, 程序执行不会继续, 然后就进入到调试器中.

* 受此影响(Affected By):

        *debug-io* 和 *debugger-hook*.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        error, break

* 注意(Notes): None. 


### <span id="F-BREAK">函数 BREAK</span>

* 语法(Syntax):

        break &optional format-control &rest format-arguments => nil

* 参数和值(Arguments and Values):

        format-control---一个格式化控制字符串[format control]. 默认值是依赖于具体实现的[implementation-dependent].
        format-arguments---这个格式化控制字符串 format-control 的格式化参数[format argument].

* 描述(Description):

        break 格式化[format] format-control 和 format-arguments, 然后在不可能被任何程控的错误处理工具拦截的情况下直接进入调试器中.

        如果在这个调试器中使用了这个 continue 重启动[restart], break 在没有采取任何不寻常的恢复动作的情况下立即返回 nil.

        break 在尝试进入调试器之前把 *debugger-hook* 绑定为 nil.

* 示例(Examples):

    ```LISP
    (break "You got here with arguments: ~:S." '(FOO 37 A))
    >>  BREAK: You got here with these arguments: FOO, 37, A.
    >>  To continue, type :CONTINUE followed by an option number:
    >>   1: Return from BREAK.
    >>   2: Top level.
    >>  Debug> :CONTINUE 1
    >>  Return from BREAK.
    =>  NIL
    ```

* 副作用(Side Effects):

        进入到调试器中.

* 受此影响(Affected By):

        *debug-io*.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        error, invoke-debugger.

* 注意(Notes):

        在一个程序中 break 被用作临时插入调试"断点(breakpoints)"的方式, 而不是作为发送错误的方式. 由于这个原因, break 不接受这个 cerror 接受的 continue-format-control 实参[argument]. 这个以及通过状况处理拦截可能性的缺失是 break 和 cerror 之间仅有的程序可见的区别.

        break 和 cerror 的用户接口方面允许更广泛的变化, 来适应这个具体实现[implementation]的接口需求. 比如, 对于一个 Lisp read-eval-print 循环[Lisp read-eval-print loop]允许通过 break 而不是常规的调试器来进入.

        break 可以通过下面这样定义:

    ```LISP
    (defun break (&optional (format-control "Break") &rest format-arguments)
      (with-simple-restart (continue "Return from BREAK.")
        (let ((*debugger-hook* nil))
          (invoke-debugger
              (make-condition 'simple-condition
                              :format-control format-control
                              :format-arguments format-arguments))))
      nil)
    ```

### <span id="V-DEBUGGER-HOOK">变量 *DEBUGGER-HOOK*</span>

* 值类型(Value Type):

        一个两实参[argument]函数[function] (一个状况[condition]和进入调试器之前 *debugger-hook* 的值[value]) 的标识符[designator], 或者 nil.

* 初始值(Initial Value):

        nil.

* 描述(Description):

        当这个 *debugger-hook* 的值[value]非 nil [non-nil], 它在正常进入调试器前被调用, 不管是由于调用 invoke-debugger 或是从一个带有未处理状况的 error 或 cerror 调用中进入调试器. 这个函数[function]可能处理这个状况[condition] (转移控制) 或者正常返回 (允许这个标准调试器来运行). 为了最小化调试期间的递归错误, *debugger-hook* 在调用这个函数[function]前被 invoke-debugger 被绑定为 nil.

* 示例(Examples):

    ```LISP
    (defun one-of (choices &optional (prompt "Choice"))
      (let ((n (length choices)) (i))
        (do ((c choices (cdr c)) (i 1 (+ i 1)))
            ((null c))
          (format t "~&[~D] ~A~%" i (car c)))
        (do () ((typep i `(integer 1 ,n)))
          (format t "~&~A: " prompt)
          (setq i (read))
          (fresh-line))
        (nth (- i 1) choices)))

    (defun my-debugger (condition me-or-my-encapsulation)
      (format t "~&Fooey: ~A" condition)
      (let ((restart (one-of (compute-restarts))))
        (if (not restart) (error "My debugger got an error."))
        (let ((*debugger-hook* me-or-my-encapsulation))
          (invoke-restart-interactively restart))))
    
    (let ((*debugger-hook* #'my-debugger))
      (+ 3 'a))
    >>  Fooey: The argument to +, A, is not a number.
    >>   [1] Supply a replacement for A.
    >>   [2] Return to Cloe Toplevel.
    >>  Choice: 1
    >>   Form to evaluate and use: (+ 5 'b)
    >>   Fooey: The argument to +, B, is not a number.
    >>   [1] Supply a replacement for B.
    >>   [2] Supply a replacement for A.
    >>   [3] Return to Cloe Toplevel.
    >>  Choice: 1
    >>   Form to evaluate and use: 1
    =>  9
    ```

* 受此影响(Affected By):

        invoke-debugger

* 参见(See Also): None.

* 注意(Notes):

        在求值用户交互式输入的代码时, 有时候, 让钩子函数绑定 *debugger-hook* 到它的第二个参数的函数[function]是很有用的, 这样就可以使用相同的交互式工具来处理递归错误了. 


### <span id="V-BREAK-ON-SIGNALS">变量 *BREAK-ON-SIGNALS*</span>

* 值类型(Value Type):

        一个类型指定符[type specifier].

* 初始值(Initial Value):

        nil.

* 描述(Description):

        当 (typep condition *break-on-signals*) 返回 true 时, 对 signal, 以及其他像 error 这样隐式调用 signal 的操作符[operator]的调用, 在发送这个状况[condition]前进入到调试器中.

        当 *break-on-signals* 导致一个发送中断时, 这个 continue 重启动[condition]可以被用于继续这个正常的发送过程.

* 示例(Examples):

    ```LISP
    *break-on-signals* =>  NIL
    (ignore-errors (error 'simple-error :format-control "Fooey!"))
    =>  NIL, #<SIMPLE-ERROR 32207172>

    (let ((*break-on-signals* 'error))
      (ignore-errors (error 'simple-error :format-control "Fooey!")))
    >>  Break: Fooey!
    >>  BREAK entered because of *BREAK-ON-SIGNALS*.
    >>  To continue, type :CONTINUE followed by an option number:
    >>   1: Continue to signal.
    >>   2: Top level.
    >>  Debug> :CONTINUE 1
    >>  Continue to signal.
    =>  NIL, #<SIMPLE-ERROR 32212257>

    (let ((*break-on-signals* 'error))
      (error 'simple-error :format-control "Fooey!"))
    >>  Break: Fooey!
    >>  BREAK entered because of *BREAK-ON-SIGNALS*.
    >>  To continue, type :CONTINUE followed by an option number:
    >>   1: Continue to signal.
    >>   2: Top level.
    >>  Debug> :CONTINUE 1
    >>  Continue to signal.
    >>  Error: Fooey!
    >>  To continue, type :CONTINUE followed by an option number:
    >>   1: Top level.
    >>  Debug> :CONTINUE 1
    >>  Top level.
    ```

* 受此影响(Affected By): None.

* 参见(See Also):

        break, signal, warn, error, typep, 章节 9.1 (状况系统的概念)

* 注意(Notes):

        *break-on-signals* 主要用于调试那些执行发送的代码. 当设置了 *break-on-signals* 时, 鼓励用户去选择满足的最限制的规格. 设置 *break-on-signals* 实际上违反了状况[condition]发送的模块化处理. 事实上, 设置 *break-on-signals* 的完整影响在某些方面可能是不可预测的, 因为用户可能没有意识到在附带调用的代码中对 signal 调用的种类和数量.

        *break-on-signals* 允许早期进入调试器, 但是这样的一个进入不会阻止例如 error 和 cerror 操作下额外进入调试器. 


### <span id="M-HANDLER-BIND">宏 HANDLER-BIND</span>

* 语法(Syntax):

        handler-bind ({binding}*) form* => result*

        binding::= (type handler) 

* 参数和值(Arguments and Values):

        type---一个类型指定符[type specifier].
        handler---一个表达式形式[form]; 求值来产生一个处理者函数 handler-function.
        handler-function---一个单实参[argument]函数[function]的标识符[designator].
        forms---一个隐式的 progn [implicit progn].
        results---由这些表达式形式[forms]返回的那些值[value].

* 描述(Description):

        在指示的处理者 handler 绑定[binding]生效的一个动态环境[dynamic environment]中执行那些表达式形式 forms.

        每个处理者 handler 应该被求值为一个处理者函数 handler-function, 它被用于在执行这些表达式形式 forms 期间处理给定类型 type 的状况[condition]. 这个函数[function]应该接收一个单独的参数, 就是要被发送的这个状况[condition].

        如果提供了超过一个处理者 handler 绑定[binding], 从上到下依次搜索这些处理者 handler 绑定[binding]来寻找匹配项 (通过使用 typecase 来做视觉类比). 如果找到一个合适的类型[type], 关联的处理者在一个这些处理者绑定都不可见的动态环境[dynamic environment]中运行 (来避免递归错误). 如果这个处理者[handler]拒绝[decline]了, 就继续搜索另一个处理者[handler].

        如果没有找到合适的处理者[handler], 那么在动态闭合边界中寻找其他处理者[handler]. 如果在外边没有找到处理者[handler], 那么 signal 返回或者 error 进入到调试器中.

* 示例(Examples):

        在以下代码中, 如果在这个主体中被发送一个"未绑定的变量"的错误 (并且没有被一个介入的处理者所处理), 第一个函数会被调用.

    ```LISP
    (handler-bind ((unbound-variable #'(lambda ...))
                    (error #'(lambda ...)))
      ...)
    ```

        如果任何其他种类的错误被发送, 第二个函数会被调用. 不论发生何种情况, 在执行相关函数的代码期间这些处理者都不是活跃的.

    ```LISP
    (defun trap-error-handler (condition)
      (format *error-output* "~&~A~&" condition)
      (throw 'trap-errors nil))

    (defmacro trap-errors (&rest forms)
      `(catch 'trap-errors
          (handler-bind ((error #'trap-error-handler))
            ,@forms)))
    
    (list (trap-errors (signal "Foo.") 1)
          (trap-errors (error  "Bar.") 2)
          (+ 1 2))
    >>  Bar.
    =>  (1 NIL 3)
    ```

        注意, 这个 "Foo." 不会被打印, 因为这个 signal 发送的状况是一个简单状况[simple-condition], 它不是类型[type] error, 所以它不会触发由 trap-errors 设置的 error 的处理者.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        handler-case

* 注意(Notes): None. 


### <span id="M-HANDLER-CASE">宏 HANDLER-CASE</span>

* 语法(Syntax):

        handler-case expression [[{error-clause}* | no-error-clause]] => result*

        clause::= error-clause | no-error-clause 

        error-clause::= (typespec ([var]) declaration* form*) 

        no-error-clause::= (:no-error lambda-list declaration* form*) 

* 参数和值(Arguments and Values):

        expression---一个表达式形式[form].
        typespec---一个类型指定符[type specifier].
        var---一个变量[variable]名字[name].
        lambda-list---一个普通 lambda 列表[ordinary lambda list].
        declaration---一个 declare 表达式[expression]; 不求值的.
        form---一个表达式形式[form].
        results---在正常的情况下, 返回的值是表达式 expression 求值的那些结果; 在这个当控制被转移到一个子句 clause 中的异常情况中, 那个 clause 中的最后一个表达式形式 form 的值会被返回.

* 描述(Description):

        handler-case 在一个各种处理者都活跃的动态环境[dynamic environment]中执行表达式 expression. 每个错误子句 error-clause 指定了如何去处理匹配表示的类型指定符 typespec 的一个状况[condition]. 如果控制正常返回, 那么一个 no-error-clause 允许指定特定的操作.

        如果在表达式 expression 求值期间发出一个有着合适的错误子句 error-clause 的状况[condition] (换句话说, (typep condition 'typespec) 返回 true) 并且如果这里没有这个类型[type]的状况[condition]的中介处理者, 那么控制被转移到这个相关 error-clause 的主体当中. 在这个情况下, 这个动态的状态被解开 (这样在表达式 expression 周围建立的这些处理者不再是活跃的), 并且 var 被绑定为这个已经被发送的状况[condition]. 如果提供了不止一个情况(case), 这些情况可以平行访问. 这也就是说, 在下面这个表达式形式中

          (handler-case form
            (typespec1 (var1) form1)
            (typespec2 (var2) form2))

        如果第一个子句 (包括 form1) 已经被选择了, 第二个的处理者不再是可见的 (反之亦然).

        这些子句依次从上倒下被搜索. 如果在这些 typespecs 之间有类型[type]重叠, 那么就选择这些子句 clause 中更早的那个.

        如果不需要 var, 它可以被省略. 这也就是说, 一个像这样的子句:

          (typespec (var) (declare (ignore var)) form)

        可以被写为 (typespec () form).

        如果选择的子句 clause 中没有表达式形式 form, 那么这个情况, 以及 handler-case, 返回 nil. 如果表达式 expression 的执行正常返回并且不存在 no-error-clause, 表达式 expression 返回的值会被 handler-case 返回. 如果表达式 expression 的执行正常返回并且存在一个 no-error-clause, 返回的值作为参数给一个函数, 这个函数通过从 no-error-clause 构造 (lambda lambda-list form*) 来描述, 并且这个函数调用的值[value]会被 handler-case 返回. 在这个调用时, 在表达式 expression 周围建立的处理者不再是活跃的.

* 示例(Examples):

    ```LISP
    (defun assess-condition (condition)
      (handler-case (signal condition)
        (warning () "Lots of smoke, but no fire.")
        ((or arithmetic-error control-error cell-error stream-error)
            (condition)
          (format nil "~S looks especially bad." condition))
        (serious-condition (condition)
          (format nil "~S looks serious." condition))
        (condition () "Hardly worth mentioning.")))
    =>  ASSESS-CONDITION
    (assess-condition (make-condition 'stream-error :stream *terminal-io*))
    =>  "#<STREAM-ERROR 12352256> looks especially bad."
    (define-condition random-condition (condition) () 
      (:report (lambda (condition stream)
                  (declare (ignore condition))
                  (princ "Yow" stream))))
    =>  RANDOM-CONDITION
    (assess-condition (make-condition 'random-condition))
    =>  "Hardly worth mentioning."
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        handler-bind, ignore-errors, 章节 9.1 (状况系统的概念)

* 注意(Notes):

    ```LISP
    (handler-case form
      (type1 (var1) . body1)
      (type2 (var2) . body2) ...)
    ```

        大约等价于:

    ```LISP
    (block #1=#:g0001
      (let ((#2=#:g0002 nil))
        (tagbody
          (handler-bind ((type1 #'(lambda (temp)
                                          (setq #1# temp)
                                          (go #3=#:g0003)))
                          (type2 #'(lambda (temp)
                                          (setq #2# temp)
                                          (go #4=#:g0004))) ...)
          (return-from #1# form))
            #3# (return-from #1# (let ((var1 #2#)) . body1))
            #4# (return-from #1# (let ((var2 #2#)) . body2)) ...)))
    ```

    ```LISP
    (handler-case form
      (type1 (var1) . body1)
      ...
      (:no-error (varN-1 varN-2 ...) . bodyN))
    ```

        大约等价于:

    ```LISP
    (block #1=#:error-return
      (multiple-value-call #'(lambda (varN-1 varN-2 ...) . bodyN)
        (block #2=#:normal-return
          (return-from #1#
            (handler-case (return-from #2# form)
              (type1 (var1) . body1) ...)))))
    ```

### <span id="M-IGNORE-ERRORS">宏 IGNORE-ERRORS</span>

* 语法(Syntax):

        ignore-errors form* => result*

* 参数和值(Arguments and Values):

        forms---一个隐式的 progn [implicit progn].
        results---在正常情况下, 这些表达式形式[form]的值[value]被返回; 在异常情况中, 返回两个值: nil 和这个状况[condition].

* 描述(Description):

        ignore-errors 被用于防止 error 类型[type]的状况[condition]导致进入调试器.

        具体的说, ignore-errors 在一个 error 类型[type]的状况[condition]的处理者[handler]被建立的动态环境[dynamic environment]中执行[execute]这些表达式形式[form]; 如果被调用了, 它通过从 ignore-errors 表达式形式[form]中返回两个值[value], nil 和这个被发送的状况[condition], 来处理这样的状况[condition].

        如果发生了一个从这些表达式形式[form]的正常返回[normal return], 那么返回的任何值[value]都被 ignore-errors 返回.

* 示例(Examples):

    ```LISP
    (defun load-init-file (program)
      (let ((win nil))
        (ignore-errors ;if this fails, don't enter debugger
          (load (merge-pathnames (make-pathname :name program :type :lisp)
                                  (user-homedir-pathname)))
          (setq win t))
        (unless win (format t "~&Init file failed to load.~%"))
        win))
    
    (load-init-file "no-such-program")
    >>  Init file failed to load.
    NIL
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        handler-case, 章节 9.1 (状况系统的概念)

* 注意(Notes):

        (ignore-errors . forms)

        等价于:

        (handler-case (progn . forms)
          (error (condition) (values nil condition)))

        由于第二个返回值是在异常情况中的一个状况[condition], 通常(但不是必须)在正常情况下第二个返回值被安排为缺失的或者 nil, 这样这两个情况就可以被区分开来. 


### <span id="M-DEFINE-CONDITION">宏 DEFINE-CONDITION</span>

* 语法(Syntax):

        define-condition name (parent-type*) ({slot-spec}*) option*
        => name

        slot-spec::= slot-name | (slot-name slot-option) 

        slot-option::= [[{:reader symbol}* |  
                      {:writer function-name}* |  
                      {:accessor symbol}* |  
                      {:allocation allocation-type} |  
                      {:initarg symbol}* |  
                      {:initform form} |  
                      {:type type-specifier} ]] 

        option::= [[(:default-initargs . initarg-list) |  
                  (:documentation string) |  
                  (:report report-name) ]] 

        function-name::= {symbol | (setf symbol)} 

        allocation-type::= :instance | :class 

        report-name::= string | symbol | lambda expression 

* 参数和值(Arguments and Values):

        name---一个符号[symbol].
        parent-type---命名一个状况[condition]类型[type]的符号[symbol]. 如果没有提供 parent-types, 这个 parent-types 默认是 (condition).
        default-initargs---一个键值对[keyword/value pair]的列表.
        slot-spec -- 一个槽[slot]的名字[name]或者一个由槽名字 slot-name 后面跟着零个或多个槽选项 slot-options 构成的列表[list].
        slot-name -- 一个槽名字 (一个符号[symbol]), 一个槽名字的列表[list], 或者槽名/槽表达式形式对(slot name/slot form pair)的列表[list].

        option -- 任意下面这些选项:

        :reader

            :reader 对于一个给定的槽[slot]可以被提供超过一次并且不能是 nil.

        :writer

            :writer 对于一个给定的槽[slot]可以被提供超过一次并且必须命名一个广义函数[generic function].

        :accessor

            :accessor 对于一个给定的槽[slot]可以被提供超过一次但是不能是 nil.

        :allocation

            :allocation 对于一个给定的槽[slot]可以被提供最多一次. 如果 :allocation 没有被提供那么默认值就是 :instance.

        :initarg

            :initarg 对于一个给定的槽[slot]可以被提供超过一次.

        :initform

            :initform 对于一个给定的槽[slot]可以被提供最多一次.

        :type

            :type 对于一个给定的槽[slot]可以被提供最多一次.

        :documentation

            :documentation 对于一个给定的槽[slot]可以被提供最多一次.

        :report

            :report 可以被提供最多一次.

* 描述(Description):

        define-condition 定义一个名为 name 的新的状况类型, 它是由 parent-type 命名的那个类型[type]或那些类型[type]的一个子类型[subtype]. 每个 parent-type 参数为这个新的状况[condition]指定一个直接的超类型[supertype]. 这个新的状况[condition]从它的每个超类型[supertype]中继承槽[slot]和方法[method], 以此类推.

        如果提供了一个槽名/槽表达式形式对(slot name/slot form pair), 这个槽表达式形式是一个在没有显式提供值时被 make-condition 求值来提供一个默认值的表达式形式[form]. 如果没有提供槽表达式形式, 这个槽slot 的内容以一种依赖于具体实现[implementation-dependent]的方式来初始化.

        如果要被定义的类型[type]和某个它继承的其他类型[type]有着相同名字的槽, 那么只有一个槽会被分配在这个状况[condition]中, 但是这个提供的槽表达式形式重写从 parent-type 中继承而来的任何槽表达式形式. 如果没有提供槽表达式形式, 继承的槽表达式形式(如果存在的话)始终是可见的.

        访问器根据 defclass 所使用的相同规则来创建.

        槽选项 slot-options 的一个描述如下:

        :reader

            这个 :reader 槽选项指定了一个非限定方法[unqualified method]来读取这个给定槽[slot]的名字, 这个非限定方法要被定义在给 :reader 的参数命名的这个广义函数[generic function]上的.

        :initform

            这个 :initform 槽选项被用来提供一个在这个槽[slot]的初始化中使用的默认初始值表达式形式. 这个表达式形式[form]在每次被用来初始化这个槽[slot]的时候被求值. 这个表达式形式求值所在的词法环境[lexical environment]是这个 define-condition 表达式形式被求值所在的词法环境[lexical environment]. 注意, 这个词法环境[lexical environment]同时引用了变量和函数[function]. 对于局部槽[local slot], 动态环境[dynamic environment]是那个 make-condition 被调用时所在的动态环境[dynamic environment]; 对于共享槽[shared slot], 动态环境[dynamic environment]是那个 define-condition 表达式形式被求值时所在的动态环境[dynamic environment].

            没有具体实现被允许去扩展 define-condition 的语法来允许 (slot-name form) 作为 (slot-name :initform form) 的一个简写.

        :initarg

            这个 :initarg 槽选项声明了一个由它的符号[symbol]参数命名的初始化参数并且指定这个初始化参数初始化给定的槽[slot]. 如果这个初始化参数在对 initialize-instance 的调用中有一个值, 那么这个值就被存储在给定槽[slot]中, 并且这个槽的 :initform 槽选项如果存在的话, 就不会被求值. 如果为一个给定槽[slot]指定的初始化参数都没有值, 这个槽[slot]就根据这个 :initform 槽选项来初始化, 如果指定的话.

        :type

            这个 :type 槽选项指定了这个槽[slot]的内容总是为给定的类型[type]. 它有效的声明了应用到这个状况[condition]类型的对象[object]上的读取器广义函数的结果类型. 尝试去存储一个不满足这个槽[slot]的类型的值到这个槽[slot]中的后果是未定义的.

        :default-initargs

            这个选项的处理和 defclass 中一样.

        :documentation

            这个 :documentation 槽选项为这个槽[slot]提供了一个文档字符串[documentation string].

        :report

            状况[condition]报告是通过那个成问题的状况[condition]类型的 print-object 方法来调节的, 此时 *print-escape* 总是为 nil. 在一个状况类型 C 的定义中指定 (:report report-name) 等价于:

            (defmethod print-object ((x c) stream)
              (if *print-escape* (call-next-method) (report-name x stream)))

            如果通过 :report (report-name) 参数提供的值是一个符号[symbol]或者一个 lambda 表达式[lambda expression], 它对于 function 必须是可接受的. (function report-name) 在当前词法环境[lexical environment]中被求值. 它应该返回一个两个参数的函数[function], 两个参数是一个状况[condition]和一个流[stream], 这个函数把这个状况[condition]的一个描述打印到这个流[stream]中. 每当这个状况[condition]被打印并且 *print-escape* 是 nil, 这个函数[function]就会被调用.

            如果 report-name 是一个字符串[stream], 它是下面这个的一个简写

            (lambda (condition stream)
              (declare (ignore condition))
              (write-string report-name stream))

            这个选项在这个新的状况[condition]类型创建后被处理, 所以在这个 :report 函数中使用这个槽 slot 的访问器是允许的. 如果没有提供这个选项, 关于如何去报告这个类型的状况[condition]的信息从 parent-type 继承而来.

        如果尝试去读取[read]一个没有被显式初始化并且没有给定一个默认值的槽, 那么结果是未指定的.

        如果尝试去使用 setf 对这些槽 slots 赋值, 那么结果也是未指定的.

        如果一个 define-condition 表达式形式[form]作为一个顶层表达式形式[top level form]出现, 编译器[compiler]必须使名字 name 成为一个可识别的有效类型[type]的名字, 并且被编译的这个文件[file]后面的其他状况[condition]类型[type]的 define-condition 表达式形式[form]可以作为 parent-type 来引用这个状况[condition]类型[type].

* 示例(Examples):

        下面表达式形式定义了类型 peg/hole-mismatch 的状况[condition], 它继承自名为 blocks-world-error 的状况:

    ```LISP
    (define-condition peg/hole-mismatch 
                      (blocks-world-error)
                      ((peg-shape  :initarg :peg-shape
                                  :reader peg/hole-mismatch-peg-shape)
                      (hole-shape :initarg :hole-shape
                                  :reader peg/hole-mismatch-hole-shape))
      (:report (lambda (condition stream)
                (format stream "A ~A peg cannot go in a ~A hole."
                        (peg/hole-mismatch-peg-shape  condition)
                        (peg/hole-mismatch-hole-shape condition)))))
    ```

        这个新类型有着槽 peg-shape 和 hole-shape, 因此 make-condition 接受 :peg-shape 和 :hole-shape 关键字. 读取器[reader] peg/hole-mismatch-peg-shape 和 peg/hole-mismatch-hole-shape 应用于这个类型的对象, 就像那个 :report 信息中阐述的那样.

        下面这个表达式形式定义了名为 machine-error 的状况[condition]类型, 它继承自 error:

    ```LISP
    (define-condition machine-error 
                      (error)
                      ((machine-name :initarg :machine-name
                                    :reader machine-error-machine-name))
      (:report (lambda (condition stream)
                (format stream "There is a problem with ~A."
                        (machine-error-machine-name condition)))))
    ```

        这个定义的基础上, 一个新的错误状况可以被定义, 它是 machine-error 的一个子类型], 在机器不可用时被使用:

    ```LISP
    (define-condition machine-not-available-error (machine-error) ()
      (:report (lambda (condition stream)
                (format stream "The machine ~A is not available."
                        (machine-error-machine-name condition)))))
    ```

        这个定义了一个更具体的状况, 在 machine-not-available-error 的基础上, 它为 machine-name 提供了一个槽初始化表达式形式但是它没有提供任何新的槽或者报告消息. 它只是给 machine-name 槽一个默认初始化:

    ```LISP
    (define-condition my-favorite-machine-not-available-error
                      (machine-not-available-error)
      ((machine-name :initform "mc.lcs.mit.edu")))
    ```

        注意, 由于没有给定 :report 子句, 从 machine-not-available-error 继承来的信息被用来报告这个状况的类型.

    ```LISP
    (define-condition ate-too-much (error) 
        ((person :initarg :person :reader ate-too-much-person)
          (weight :initarg :weight :reader ate-too-much-weight)
          (kind-of-food :initarg :kind-of-food
                        :reader :ate-too-much-kind-of-food)))
    =>  ATE-TOO-MUCH
    (define-condition ate-too-much-ice-cream (ate-too-much)
      ((kind-of-food :initform 'ice-cream)
        (flavor       :initarg :flavor
                      :reader ate-too-much-ice-cream-flavor
                      :initform 'vanilla ))
      (:report (lambda (condition stream)
                  (format stream "~A ate too much ~A ice-cream"
                          (ate-too-much-person condition)
                          (ate-too-much-ice-cream-flavor condition)))))
    =>  ATE-TOO-MUCH-ICE-CREAM
    (make-condition 'ate-too-much-ice-cream
                    :person 'fred
                    :weight 300
                    :flavor 'chocolate)
    =>  #<ATE-TOO-MUCH-ICE-CREAM 32236101>
    (format t "~A" *)
    >>  FRED ate too much CHOCOLATE ice-cream
    =>  NIL
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        make-condition, defclass, 章节 9.1 (状况系统的概念)

* 注意(Notes): None. 


### <span id="F-MAKE-CONDITION">函数 MAKE-CONDITION</span>

* 语法(Syntax):

        make-condition type &rest slot-initializations => condition

* 参数和值(Arguments and Values):

        type---一个类型指定符[type specifier] (condition 的一个子类型[subtype]).
        slot-initializations---一个初始化参数列表[initialization argument list].
        condition---一个状况[condition].

* 描述(Description):

        使用槽初始值的 slot-initializations 来构造并返回一个 type 类型的状况[condition]. 新创建的状况[condition]会被返回.

* 示例(Examples):

    ```LISP
    (defvar *oops-count* 0)

    (setq a (make-condition 'simple-error
                            :format-control "This is your ~:R error."
                            :format-arguments (list (incf *oops-count*))))
    =>  #<SIMPLE-ERROR 32245104>
    
    (format t "~&~A~%" a)
    >>  This is your first error.
    =>  NIL
    
    (error a)
    >>  Error: This is your first error.
    >>  To continue, type :CONTINUE followed by an option number:
    >>   1: Return to Lisp Toplevel.
    >>  Debug> 
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        已定义的状况[condition]类型[type]的集合.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        define-condition, 章节 9.1 (状况系统的概念)

* 注意(Notes): None. 


### <span id="SC-RESTART">系统类 RESTART</span>

* 类优先级列表(Class Precedence List):

        restart, t

* 描述(Description):

        一个类型[type] restart 的对象[object]表示一个可以被调用来执行一些恢复动作的表达式形式的函数[function], 通常是到运行的程序中的一个更外部的点的控制转移.

        一个具体实现[implementation]可以自由地以任何最方便的方式实现重启动[restart]; 一个重启动[restart]只有和建立[establish]它的绑定表达式形式[form]的作用域相关的动态范围[dynamic extent]. 


### <span id="F-COMPUTE-RESTARTS">函数 COMPUTE-RESTARTS</span>

* 语法(Syntax):

        compute-restarts &optional condition => restarts

* 参数和值(Arguments and Values):

        condition---一个状况[condition]对象[object], 或者 nil.
        restarts---一个重启动[restart]列表[list].

* 描述(Description):

        compute-restarts 使用这个程序的动态状态来计算一个当前是活跃的重启动[restart]列表[list].

        产生的列表[list]是有序的, 因此最内部(较新建立的)的重启动较接近这个列表[list]的头部.

        当状况 condition 非 nil [non-nil], 只有和那个状况 condition 显式关联的或者没有和任何状况[condition]关联的那些重启动[restart]会被考虑; 这也就是说, 排除在外的重启动[restart]是和一个不包含给定状况 condtion 的非空状况集合相关联的那些. 如果状况 condition 是 nil, 所有重启动[restart]会被考虑.

        compute-restarts 返回所有可应用重启动[applicable restart], 包括匿名的那些, 即便当给定一个符号[symbol]参数时, 它们中的一部分有着和其他重启动相同的名字并且因此不会被 find-restart 找到.

        在相同的动态环境中时, 具体实现被允许, 但没有被要求对 compute-restarts 的重复调用去返回不同的[distinct]列表[list]. 如果 compute-restarts 返回的列表[list]被修改那么结果是未定义的.

* 示例(Examples):

    ```LISP
    ;; One possible way in which an interactive debugger might present
    ;; restarts to the user.
    (defun invoke-a-restart ()
      (let ((restarts (compute-restarts)))
        (do ((i 0 (+ i 1)) (r restarts (cdr r))) ((null r))
          (format t "~&~D: ~A~%" i (car r)))
        (let ((n nil) (k (length restarts)))
          (loop (when (and (typep n 'integer) (>= n 0) (< n k))
                  (return t))
                (format t "~&Option: ")
                (setq n (read))
                (fresh-line))
          (invoke-restart-interactively (nth n restarts)))))

    (restart-case (invoke-a-restart)
      (one () 1)
      (two () 2)
      (nil () :report "Who knows?" 'anonymous)
      (one () 'I)
      (two () 'II))
    >>  0: ONE
    >>  1: TWO
    >>  2: Who knows?
    >>  3: ONE
    >>  4: TWO
    >>  5: Return to Lisp Toplevel.
    >>  Option: 4
    =>  II
    
    ;; Note that in addition to user-defined restart points, COMPUTE-RESTARTS
    ;; also returns information about any system-supplied restarts, such as
    ;; the "Return to Lisp Toplevel" restart offered above.
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        已存在的重启动.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        find-restart, invoke-restart, restart-bind

* 注意(Notes): None. 


### <span id="F-FIND-RESTART">函数 FIND-RESTART</span>

* 语法(Syntax):

        find-restart identifier &optional condition

        restart

* 参数和值(Arguments and Values):

        identifier---一个非 nil [non-nil]符号[symbol], 或者是一个重启动[restart].
        condition---一个状况[condition]对象[object], 或者 nil.
        restart---一个重启动[restart]或者 nil.

* 描述(Description):

        find-restart 在当前动态环境[dynamic environment]中搜索一个特定的重启动[restart].

        当状况 condition 非 nil [non-nil]时, 只有和那个状况 condition 显式关联或者没有和任何状况[condition]关联的那些重启动[restart]会被考虑; 这也就是说, 排除在外的重启动[restart]是和一个不包含给定状况 condition 的非空状况集合相关联的那些. 如果这个状况 condition 是 nil, 所有重启动[restart]都会被考虑.

        如果 identifier 是一个符号[symbol], 那么最内部 (最近建立的) 带有那个名字[name]的可应用重启动[applicable restart]会被返回. 如果没有找到这样的重启动就返回 nil.

        如果 identifier 是一个当前活跃的重启动, 那么它就被返回. 否则, 返回 nil.

* 示例(Examples):

    ```LISP
    (restart-case
        (let ((r (find-restart 'my-restart)))
          (format t "~S is named ~S" r (restart-name r)))
      (my-restart () nil))
    >>  #<RESTART 32307325> is named MY-RESTART
    =>  NIL
    (find-restart 'my-restart)
    =>  NIL
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        已存在的重启动.

        restart-case, restart-bind, with-condition-restarts.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        compute-restarts

* 注意(Notes):

        (find-restart identifier)
        ==  (find identifier (compute-restarts) :key :restart-name)

        虽然匿名重启动由一个 nil 的名字, 如果 nil 被给定用作一个 identifier 那么结果是未指定的. 偶尔, 程序员叹息 nil 不允许用作一个 identifier 参数. 在大部分这样的情况下, compute-restarts 可能被用来模拟预期的效果. 


### <span id="F-INVOKE-RESTART">函数 INVOKE-RESTART</span>

* 语法(Syntax):

        invoke-restart restart &rest arguments => result*

* 参数和值(Arguments and Values):

        restart---一个重启动标识符[restart designator].
        argument---一个对象[object].
        results---和重启动 restart 关联的函数[function]返回的值[value], 如果那个函数[function]返回的话.

* 描述(Description):

        调用和重启动 restart 关联的函数[function], 传递参数 arguments 给它. 重启动 restart 在当前动态环境[dynamic environment]中必须是有效的.

* 示例(Examples):

    ```LISP
    (defun add3 (x) (check-type x number) (+ x 3))
    
    (foo 'seven)
    >>  Error: The value SEVEN was not of type NUMBER.
    >>  To continue, type :CONTINUE followed by an option number:
    >>   1: Specify a different value to use.
    >>   2: Return to Lisp Toplevel.
    >>  Debug> (invoke-restart 'store-value 7)
    =>  10
    ```

* 副作用(Side Effects):

        一个非局部控制转移可能被这个重启动完成.

* 受此影响(Affected By):

        已存在的重启动.

* 异常情况(Exceptional Situations):

        如果重启动 restart 是无效的, 就会发出一个类型[type] control-error 的错误.

* 参见(See Also):

        find-restart, restart-bind, restart-case, invoke-restart-interactively

* 注意(Notes):

        invoke-restart 的最常见的使用是在一个处理者[handler]中. 它可能被显式使用, 或者隐式地通过 invoke-restart-interactively 或一个重启动函数[restart function]来使用.

        重启动函数[restart function]调用 invoke-restart, 但反之则不行. 这也就是说, invoke-restart 提供基本功能, 而重启动函数[restart function]是非必须的"语法糖".


### <span id="F-INVOKE-RESTART-INTERACTIVELY">函数 INVOKE-RESTART-INTERACTIVELY</span>

* 语法(Syntax):

        invoke-restart-interactively restart => result*

* 参数和值(Arguments and Values):

        restart---一个重启动标识符[restart designator].
        results---和重启动 restart 关联的函数[function]返回的值[value], 如果这个函数[function]返回的话.

* 描述(Description):

        invoke-restart-interactively 调用和重启动 restart 关联的函数[function], 提示任何必要参数. 如果重启动 restart 是一个名字, 它必须在当前动态环境[dynamic environment]中是有效的.

        invoke-restart-interactively 通过执行提供给 restart-case 的 :interactive 关键字或者给 restart-bind 的 :interactive-function 关键字中的代码来提示参数.

        如果没有在对应 restart-bind 或 restart-case 中提供对应选项, 如果这个重启动 restart 接收必要参数那么结果是未定义的. 如果参数是可选的, 一个 nil 参数列表会被使用.

        一旦这些参数已经被确定了, invoke-restart-interactively 执行以下代码:

        (apply #'invoke-restart restart arguments)

* 示例(Examples):

    ```LISP
    (defun add3 (x) (check-type x number) (+ x 3))
    
    (add3 'seven)
    >>  Error: The value SEVEN was not of type NUMBER.
    >>  To continue, type :CONTINUE followed by an option number:
    >>   1: Specify a different value to use.
    >>   2: Return to Lisp Toplevel.
    >>  Debug> (invoke-restart-interactively 'store-value)
    >>  Type a form to evaluate and use: 7
    =>  10
    ```

* 副作用(Side Effects):

        如果参数提示是必要的, 可能发生某个打印输出 (在查询 I/O [query I/O]上).

        这个重启动可能完成一个非局部控制转移.

* 受此影响(Affected By):

        *query-io*, 活跃的重启动[restart]

* 异常情况(Exceptional Situations):

        如果重启动 restart 是无效的, 就会发出一个类型[type] control-error 的错误.

* 参见(See Also):

        find-restart, invoke-restart, restart-case, restart-bind

* 注意(Notes):

        invoke-restart-interactively 被调试器内部使用并且在实现其他可移植的交互式调试工具时可能也是有用的. 


### <span id="M-RESTART-BIND">宏 RESTART-BIND</span>

* 语法(Syntax):

        restart-bind ({(name function {key-val-pair}*)}) form*
        => result*

        key-val-pair::= :interactive-function interactive-function |  
                        :report-function report-function |  
                        :test-function test-function 

* 参数和值(Arguments and Values):

        name---一个符号[symbol]; 不求值的.
        function---一个表达式形式[form]; 求值的.
        forms---一个隐式 progn [implicit progn].
        interactive-function---一个表达式形式[form]; 求值的.
        report-function---一个表达式形式[form]; 求值的.
        test-function---一个表达式形式[form]; 求值的.
        results---这些表达式形式[form]返回的值[value].

* 描述(Description):

        restart-bind 在给定名字 names 的重启动[restart]是生效的动态环境[dynamic environment]中执行表达式形式 forms 的主体.

        如果一个名字 name 是 nil, 它表示一个匿名的重启动; 如果一个名字 name 是一个非 nil [non-nil]符号[symbol], 它表示一个已命名的重启动.

        这个函数 function, 交互式函数 interactive-function, 以及报告函数 report-function 在当前的词法和动态环境中在主体被求值前被无条件求值. 这些表达式形式[form]的每一个都必须求值为一个函数[function].

        如果 invoke-restart 在这个重启动上被执行, 那么在那个 invoke-restart 的动态环境[dynamic environment]中, 使用传递给 invoke-restart 的实参[argument]作为参数来调用求值 function 所产生的函数[function].

        如果这个重启动从调试器中被交互式地调用(使用 invoke-restart-interactively), 这些参数通过调用求值 interactive-function 所产生的函数[function]来缺省. 在调用这个重启动时, 那个函数[function]可以在查询 I/O [query I/O]上选择性地提示, 并且应该返回一个要被 invoke-restart-interactively 使用的参数列表[list].

        如果一个重启动被交互式调用但是没有使用交互式函数 interactive-function, 那么一个 nil 的参数列表会被使用. 在这个情况下, 函数必须和一个空参数列表兼容.

        如果这个重启动交互式地出现 (比如, 通过这个调试器), 通过调用求值 report-function 产生的函数来完成这个重启动. 这个函数[function]必须是一个单参数的函数[function], 这个参数为一个流[stream]. 它被期望打印这个重启动采取的操作的描述到那个流[stream]中. 当 *print-escape* 是 nil 时, 每次这个重启动被打印这个函数[function]会被调用.

        在交互式调用的情况下, 结果依赖于如下所述的 :interactive-function 的值.

        :interactive-function

            值 value 在当前词法环境中被求值并且应该返回一个没有参数的函数[function], 它构造一个在调用这个重启动时要被 invoke-restart-interactively 使用的参数列表[list]. 如果有必要这个函数[function]可能使用查询 I/O [query I/O]来交互式地提示.

        :report-function

            值 value 在当前词法环境中被求值并且应该返回一个单参数的函数[function], 这个参数是一个流[stream], 这个函数打印这个重启动所采取动作的综述到这个流[stream]中. 每当这个重启动被报告(当 *print-escape* 是 nil 时是被打印)时这个函数[function]就会被调用. 如果没有提供 :report-function 选项, 这个重启动[restart]被报告的方式是依赖于具体实现的[implementation-dependent].

        :test-function

            值 value 在当前词法环境中被求值并且返回一个单参数的函数[function], 这个参数是一个状况[condition], 如果这个重启动被认为是可见的, 那么这个函数返回 true.

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        *query-io*.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        restart-case, with-simple-restart

* 注意(Notes):

        restart-bind 主要被用于实现 restart-case, 在实现其他宏的时候可能也是有用的. 程序员对使用 restart-case 还是 restart-bind 不确定的话, 应该更倾向 restart-case 因为它足够强大, 只有在普遍性是非常必要的情况下使用 restart-bind. 


### <span id="M-RESTART-CASE">宏 RESTART-CASE</span>

* 语法(Syntax):

        restart-case restartable-form {clause} => result*

        clause::= (case-name lambda-list  
                  [[:interactive interactive-expression | :report report-expression | :test test-expression]]  
                  declaration* form*) 

* 参数和值(Arguments and Values):

        restartable-form---一个表达式形式[form].
        case-name---一个符号[symbol]或 nil.
        lambda-list---一个普通 lambda 列表[ordinary lambda list].
        interactive-expression---一个符号[symbol]或一个 lambda 表达式[lambda expression].
        report-expression---一个字符串[string], 一个符号[symbol], 或一个 lambda 表达式[lambda expression].
        test-expression---一个符号[symbol]或 lambda 表达式[lambda expression].
        declaration---一个 declare 表达式[expression]; 不求值的.
        form---一个表达式形式[form].
        results---这个 restartable-form 的求值[evaluation]所产生的值, 或者在一个选定的子句 clause 中最后一个表达式形式 form 返回的值[value], 或者是 nil.

* 描述(Description):

        restart-case 在一个动态环境[dynamic environment]中求值 restartable-form, 这个环境中这些子句有着特殊的意义, 可以作为控制转移的点. 如果 restartable-form 结束执行并且返回任何值, 那么所有返回值都会被 restart-case 返回并且这个过程结束. 当 restartable-form 被执行时, 任何代码可以转移控制到这些子句的其中一个 (见 invoke-restart). 如果发生了一个转移, 那个子句的主体中的表达式形式会被求值并且最后一个这样的表达式形式返回的值会被 restart-case 返回. 在这个情况下, 在执行该子句之前, 动态状态被适当地解除(这样一来这些在 restartable-form 周围建立的重启动不再是活跃的).

        如果在选择的子句中没有表达式形式 forms, restart-case 就返回 nil.

        如果 case-name 是一个符号[symbol], 它就命名这个重启动.

        可能有超过一个子句使用相同的 case-name. 在这个情况下, 带有那个名字的第一个子句会被 find-restart 找到. 其他的子句使用 compute-restarts 也是可访问的.

        每个 arglist 都是在它对应的那些表达式形式 forms 执行期间要被绑定的一个普通 lambda 列表[ordinary lambda list]. 这些参数被 restart-case 子句用来从一个对 invoke-restart 的调用中接收任何必要的数据.

        默认情况下, invoke-restart-interactively 不传递参数并且所有参数必须是可选的, 为了适应交互式的重启动. 然而, 如果这个 :interactive 关键字已经被用来告知 invoke-restart-interactively 关于如何计算一个适当的参数列表, 那么这些参数不需要是可选的.

        关键字 keyword 有着以下这些选项.

        :interactive

            通过 :interactive 提供的值 value 必须是一个给 function 的合适的参数. (function value) 在当前词法环境中被求值. 它应该返回一个没有参数的函数, 这个函数被调用时返回要被 invoke-restart-interactively 使用的参数. 在任何重启动尝试之前在可用的动态环境中被调用 invoke-restart-interactively, 并且为用户交互使用查询 I/O [query I/O].

            如果一个重启动被交互式调用但是没有提供 :interactive 选项, 那么在这个调用中使用的参数列表是空列表.

        :report

            如果通过这个 :report 提供的值 value 是一个 lambda 表达式[lambda expression]或者一个符号[symbol], 它对于 function 必须是可接受的. (function value) 在当前词法环境中被求值. 它应该返回一个单参数的函数[function], 这个参数是一个流[stream], 这个函数应该在这个流[stream]上打印这个重启动的一个描述. 当 *print-escape* 是 nil 时, 无论何时这个重启动被打印, 这个函数[function]都会被调用.

            如果值 value 是一个字符串[string], 它就是下面这个的一个缩写

            (lambda (stream) (write-string value stream))

            如果请求一个已命名的重启动来报告但是没有提供报告消息, 这个重启动的名字被用来产生默认的报告文本.

            当 *print-escape* 是 nil 时, 打印器就使用一个重启动的报告消息. 例如, 一个调试器可能通过下面这个来宣布输入一个"continue"命令的动作:

            (format t "~&~S -- ~A~%" ':continue some-restart)

            它可能显示像这样的内容:

            :CONTINUE -- Return to command level

            如果指定一个未命名的重启动但是没有提供 :report 选项, 那么结果是未指定的.

        :test

            通过 :test 提供的值 value 必须是一个给 function 的合适的参数. (function value) 在当前词法环境中被求值. 它应该返回一个单实参[argument]的函数[function], 这个参数是这个状况[condition], 如果这个重启动要被认为是可见的, 这个函数就返回 true.

            这个选项的默认值等价于 (lambda (c) (declare (ignore c)) t).

        如果这个 restartable-form 是一个 car 部分是 signal, error, cerror, or warn 其中一个符号[symbol]的列表[list] (或者是一个宏展开为这样一个列表[list]的宏表达式形式[macro form]), 那么 with-condition-restarts 会被用来隐式地关联这个表示的重启动[restart]和这个要被发送的状况[condition].

* 示例(Examples):

    ```LISP
    (restart-case
        (handler-bind ((error #'(lambda (c)
                                (declare (ignore condition))
                                (invoke-restart 'my-restart 7))))
          (error "Foo."))
      (my-restart (&optional v) v))
    =>  7

    (define-condition food-error (error) ())
    =>  FOOD-ERROR
    (define-condition bad-tasting-sundae (food-error) 
      ((ice-cream :initarg :ice-cream :reader bad-tasting-sundae-ice-cream)
        (sauce :initarg :sauce :reader bad-tasting-sundae-sauce)
        (topping :initarg :topping :reader bad-tasting-sundae-topping))
      (:report (lambda (condition stream)
                  (format stream "Bad tasting sundae with ~S, ~S, and ~S"
                          (bad-tasting-sundae-ice-cream condition)
                          (bad-tasting-sundae-sauce condition)
                          (bad-tasting-sundae-topping condition)))))
    =>  BAD-TASTING-SUNDAE
    (defun all-start-with-same-letter (symbol1 symbol2 symbol3)
      (let ((first-letter (char (symbol-name symbol1) 0)))
        (and (eql first-letter (char (symbol-name symbol2) 0))
              (eql first-letter (char (symbol-name symbol3) 0)))))
    =>  ALL-START-WITH-SAME-LETTER
    (defun read-new-value ()
      (format t "Enter a new value: ")
      (multiple-value-list (eval (read))))
    =>  READ-NEW-VALUE
    (defun verify-or-fix-perfect-sundae (ice-cream sauce topping)
      (do ()
          ((all-start-with-same-letter ice-cream sauce topping))
        (restart-case
          (error 'bad-tasting-sundae
                  :ice-cream ice-cream
                  :sauce sauce
                  :topping topping)
          (use-new-ice-cream (new-ice-cream)
            :report "Use a new ice cream."
            :interactive read-new-value  
            (setq ice-cream new-ice-cream))
          (use-new-sauce (new-sauce)
            :report "Use a new sauce."
            :interactive read-new-value
            (setq sauce new-sauce))
          (use-new-topping (new-topping)
            :report "Use a new topping."
            :interactive read-new-value
            (setq topping new-topping))))
      (values ice-cream sauce topping))
    =>  VERIFY-OR-FIX-PERFECT-SUNDAE
    (verify-or-fix-perfect-sundae 'vanilla 'caramel 'cherry)
    >>  Error: Bad tasting sundae with VANILLA, CARAMEL, and CHERRY.
    >>  To continue, type :CONTINUE followed by an option number:
    >>   1: Use a new ice cream.
    >>   2: Use a new sauce.
    >>   3: Use a new topping.
    >>   4: Return to Lisp Toplevel.
    >>  Debug> :continue 1
    >>  Use a new ice cream.
    >>  Enter a new ice cream: 'chocolate
    =>  CHOCOLATE, CARAMEL, CHERRY
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        restart-bind, with-simple-restart.

* 注意(Notes):

    ```LISP
    (restart-case expression
        (name1 arglist1 ...options1... . body1)
        (name2 arglist2 ...options2... . body2))
    ```

        大约等价于

    ```LISP
    (block #1=#:g0001
      (let ((#2=#:g0002 nil))
            (tagbody
            (restart-bind ((name1 #'(lambda (&rest temp)
                                    (setq #2# temp)
                                    (go #3=#:g0003))
                              ...slightly-transformed-options1...)
                          (name2 #'(lambda (&rest temp)
                                    (setq #2# temp)
                                    (go #4=#:g0004))
                              ...slightly-transformed-options2...))
            (return-from #1# expression))
              #3# (return-from #1#
                      (apply #'(lambda arglist1 . body1) #2#))
              #4# (return-from #1#
                      (apply #'(lambda arglist2 . body2) #2#)))))
    ```

        未命名的重启动通常只有在交互式的情况下有用, 并且一个没有描述的交互式选项没有什么价值. 如果使用了一个未命名的重启动并且在编译时没有提供报告消息的话, 鼓励具体实现去发出警告. 在运行时, 在进入调试器时可能会注意到这个错误. 由于发出一个错误可能会导致递归进入调试器中 (导致另一个递归错误, 等等), 因此建议调试器在出现这些问题时打印出一些指示, 而不是实际上发出这些错误.

    ```LISP
    (restart-case (signal fred)
      (a ...)
      (b ...))
    == 
    (restart-case
        (with-condition-restarts fred 
                                  (list (find-restart 'a) 
                                        (find-restart 'b))
          (signal fred))
      (a ...)
      (b ...))
    ```

### <span id="F-RESTART-NAME">函数 RESTART-NAME</span>

* 语法(Syntax):

        restart-name restart => name

* 参数和值(Arguments and Values):

        restart---一个重启动[restart].
        name---一个符号[symbol].

* 描述(Description):

        返回这个重启动 restart 的名字, 如果这个重启动 restart 没有被命名就返回 nil.

* 示例(Examples):

    ```LISP
    (restart-case 
        (loop for restart in (compute-restarts)
                  collect (restart-name restart))
      (case1 () :report "Return 1." 1)
      (nil   () :report "Return 2." 2)
      (case3 () :report "Return 3." 3)
      (case1 () :report "Return 4." 4))
    =>  (CASE1 NIL CASE3 CASE1 ABORT)
    ;; In the example above the restart named ABORT was not created
    ;; explicitly, but was implicitly supplied by the system.
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        compute-restarts find-restart

* 注意(Notes): None. 


### <span id="M-WITH-CONDITION-RESTARTS">宏 WITH-CONDITION-RESTARTS</span>

* 语法(Syntax):

        with-condition-restarts condition-form restarts-form form*
        => result*

* 参数和值(Arguments and Values):

        condition-form---一个表达式形式[form]; 求值来产生一个状况 condition.
        condition---从 condition-form 的求值[evaluation]中产生的一个状况[condition]对象[object].
        restart-form---一个表达式形式[form]; 求值来产生一个重启动列表 restart-list.
        restart-list---从重启动表达式形式 restart-form 的求值[evaluation]中产生的一个重启动[restart]对象[object]的列表[list].
        forms---一个隐式 progn [implicit progn]; 求值的.
        results---由这些表达式形式[form]返回的值[value].

* 描述(Description):

        首先, 这个 condition-form 和 restarts-form 以正常从左到右的顺序求值; 这些求值[evaluation]产生的那些主值[primary value]分别称为 condition 和 restart-list.

        然后, 这些表达式形式 forms 在一个动态环境[dynamic environment]中被求值, 在这个环境中每个在 restart-list 中的重启动[restart]都和这个状况 condition 关联. 见章节 9.1.4.2.4 (关联重启动和状况).

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        restart-case

* 注意(Notes):

        通常这个宏[macro]不会在代码中被显式调用, 因为 restart-case 以一种语法上更简洁的方式处理大多数常见的情况. 


### <span id="M-WITH-SIMPLE-RESTART">宏 WITH-SIMPLE-RESTART</span>

* 语法(Syntax):

        with-simple-restart (name format-control format-argument*) form*
        => result*

* 参数和值(Arguments and Values):

        name---一个符号[symbol].
        format-control---一个格式化控制字符串[format control].
        format-argument---一个对象[object] (换句话说, 一个格式化参数[format argument]).
        forms---一个隐式 progn [implicit progn].
        results---在正常情况中, 就是那些表达式形式 forms 返回的值[value]; 在名为 name 的重启动[restart]被调用的异常情况中, 就是两个值---nil 和 t.

* 描述(Description):

        with-simple-restart 建立一个重启动.

        如果由名称 name 表示的重启动没有在执行表达式形式 forms 期间被调用, 这些表达式形式 forms 的最后一个返回的所有值都会被返回. 如果由名称 name 表示的重启动被调用了, 那么控制会转移到 with-simple-restart, 它返回两个值, nil 和 t.

        如果 name 是 nil, 就会建立一个匿名的重启动.

        这个 format-control 和 format-arguments 被用于报告这个重启动[restart].

* 示例(Examples):

    ```LISP
    (defun read-eval-print-loop (level)
      (with-simple-restart (abort "Exit command level ~D." level)
        (loop
          (with-simple-restart (abort "Return to command level ~D." level)
            (let ((form (prog2 (fresh-line) (read) (fresh-line))))
              (prin1 (eval form)))))))
    =>  READ-EVAL-PRINT-LOOP
    (read-eval-print-loop 1)
    (+ 'a 3)
    >>  Error: The argument, A, to the function + was of the wrong type.
    >>         The function expected a number.
    >>  To continue, type :CONTINUE followed by an option number:
    >>   1: Specify a value to use this time.
    >>   2: Return to command level 1.
    >>   3: Exit command level 1.
    >>   4: Return to Lisp Toplevel.

    (defun compute-fixnum-power-of-2 (x)
      (with-simple-restart (nil "Give up on computing 2^~D." x)
        (let ((result 1))
          (dotimes (i x result)
            (setq result (* 2 result))
            (unless (fixnump result)
              (error "Power of 2 is too large."))))))
    COMPUTE-FIXNUM-POWER-OF-2
    (defun compute-power-of-2 (x)
      (or (compute-fixnum-power-of-2 x) 'something big))
    COMPUTE-POWER-OF-2
    (compute-power-of-2 10)
    1024
    (compute-power-of-2 10000)
    >>  Error: Power of 2 is too large.
    >>  To continue, type :CONTINUE followed by an option number.
    >>   1: Give up on computing 2^10000.
    >>   2: Return to Lisp Toplevel
    >>  Debug> :continue 1
    =>  SOMETHING-BIG
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        restart-case

* 注意(Notes):

        with-simple-restart 是 restart-case 最常见使用的一个简写.

        with-simple-restart 可以被定义为:

    ```LISP
    (defmacro with-simple-restart ((restart-name format-control
                                                  &rest format-arguments)
                                    &body forms)
      `(restart-case (progn ,@forms)
          (,restart-name ()
              :report (lambda (stream)
                        (format stream ,format-control ,@format-arguments))
            (values nil t))))
    ```

        由于在异常的情况下第二个返回值是 t, 通常 (但不是必须) 安排在正常情况下第二个返回值为缺失的或者是 nil, 这样两种情况就可以被区分. 


### <span id="R-ABORT">重启动 ABORT</span>

* 必要数据参数(Data Arguments Required):

        None.

* 描述(Description):

        这个 abort 重启动的意图是允许返回到最里边的"命令层级(command level)". 鼓励实现者去确保在用户代码周围总是有一个名为 abort 的重启动, 这样用户代码可以在任何时间调用 abort 并且期待发生一些合理的事情; 究竟什么是合理的可能会有所不同. 典型地, 在一个交互式的监听器中, abort 的调用返回到 Lisp read-eval-print 循环的 Lisp 读取器[Lisp reader]阶段, 尽管在某个批处理或多进程情况中, 可能会有这样的情况: 让它杀死运行的过程更合适.

* 参见(See Also):

        章节 9.1.4.2 (重启动), 章节 9.1.4.2.2 (重启动的接口), invoke-restart, abort (function) 


### <span id="R-CONTINUE">重启动 CONTINUE</span>

* 必要数据参数(Data Arguments Required):

        None.

* 描述(Description):

        这个 continue 重启动通常是协议的一部分, 这个协议有一个单独的"明显"的方式来继续, 比如在 break 和 cerror 中. 一些用户定义的协议也可能出于类似的原因希望将其合并. 一般而言, 然而, 更可靠的方法是设计一个名称更适合于特定应用程序的特殊用途的重启动.

* 示例(Examples):

    ```LISP
    (let ((x 3))
      (handler-bind ((error #'(lambda (c)
                                (let ((r (find-restart 'continue c)))
                                  (when r (invoke-restart r))))))
        (cond ((not (floatp x))
                (cerror "Try floating it." "~D is not a float." x)
                (float x))
              (t x)))) =>  3.0
    ```

* 参见(See Also):

        章节 9.1.4.2 (重启动), 章节 9.1.4.2.2 (重启动的接口), invoke-restart, continue (function), assert, cerror 


### <span id="R-MUFFLE-WARNING">重启动 MUFFLE-WARNING</span>

* 必要数据参数(Data Arguments Required):

        没有.

* 描述(Description):

        这个重启动[restart]由 warn 建立, 这样一来 warning 状况[condition]的处理者[handler]就有一种途径去通知 warn 一个警告已经被处理并且不需要采取进一步的行动.

* 示例(Examples):

    ```LISP
    (defvar *all-quiet* nil) =>  *ALL-QUIET*
    (defvar *saved-warnings* '()) =>  *SAVED-WARNINGS*
    (defun quiet-warning-handler (c)
      (when *all-quiet*
        (let ((r (find-restart 'muffle-warning c)))
          (when r 
            (push c *saved-warnings*)
            (invoke-restart r)))))
    =>  CUSTOM-WARNING-HANDLER
    (defmacro with-quiet-warnings (&body forms)
      `(let ((*all-quiet* t)
              (*saved-warnings* '()))
          (handler-bind ((warning #'quiet-warning-handler))
            ,@forms
            *saved-warnings*)))
    =>  WITH-QUIET-WARNINGS
    (setq saved
      (with-quiet-warnings
        (warn "Situation #1.")
        (let ((*all-quiet* nil))
          (warn "Situation #2."))
        (warn "Situation #3.")))
    >>  Warning: Situation #2.
    =>  (#<SIMPLE-WARNING 42744421> #<SIMPLE-WARNING 42744365>)
    (dolist (s saved) (format t "~&~A~%" s))
    >>  Situation #3.
    >>  Situation #1.
    =>  NIL
    ```

* 参见(See Also):

        章节 9.1.4.2 (重启动), 章节 9.1.4.2.2 (重启动的接口), invoke-restart, muffle-warning (函数[function]), warn 


### <span id="R-STORE-VALUE">重启动 STORE-VALUE</span>

* 必要数据参数(Data Arguments Required):

        使用的代替值 (在持续的基础上).

* 描述(Description):

        这个 store-value 重启动[restart]通常被处理者[handler]用于尝试从例如 cell-error 或 type-error 这样类型[type]的错误中恢复过来, 它可以希望去提供一个替换的数据来持久地存储.

* 示例(Examples):

    ```LISP
    (defun type-error-auto-coerce (c)
      (when (typep c 'type-error)
        (let ((r (find-restart 'store-value c)))
          (handler-case (let ((v (coerce (type-error-datum c)
                                          (type-error-expected-type c))))
                          (invoke-restart r v))
            (error ()))))) =>  TYPE-ERROR-AUTO-COERCE
    (let ((x 3))
      (handler-bind ((type-error #'type-error-auto-coerce))
        (check-type x float)
        x)) =>  3.0
    ```

* 参见(See Also):

        章节 9.1.4.2 (重启动), 章节 9.1.4.2.2 (重启动的接口), invoke-restart, store-value (函数[function]), ccase, check-type, ctypecase, use-value (函数[function]和[restart]) 


### <span id="R-USE-VALUE">重启动 USE-VALUE</span>

* 必要数据参数(Data Arguments Required):

        使用的代替值 (一次).

* 描述(Description):

        这个 use-value 重启动[restart]通常被处理者[handler]用来尝试从例如 cell-error 这样类型[type]的错误中恢复过来, 在这里这个处理者可能希望去提供一个替代的数据用于单次使用.

* 参见(See Also):

        章节 9.1.4.2 (重启动), 章节 9.1.4.2.2 (重启动的接口), invoke-restart, use-value (函数[function]), store-value (函数[function]和重启动[restart]) 


### <span id="F-ABORT-CONTINUE-MW-SV-UV">函数 ABORT, CONTINUE, MUFFLE-WARNING, STORE-VALUE, USE-VALUE</span>

* 语法(Syntax):

        abort &optional condition =>|

        continue &optional condition => nil

        muffle-warning &optional condition =>|

        store-value value &optional condition => nil

        use-value value &optional condition => nil

* 参数和值(Arguments and Values):

        value---一个对象[object].
        condition---一个状况[condition]对象[object], 或者 nil.

* 描述(Description):

        转移控制到最新建立的有着和这个函数相同名字的可应用重启动[applicable restart]. 这也就是说, 函数[function] abort 搜索一个可应用的[applicable] abort 重启动[restart], 函数[function] continue 搜索一个可应用的[applicable] continue 重启动[restart], 以此类推.

        如果不存在这样的重启动[restart], 函数 continue, store-value, 和 use-value 返回 nil, 并且函数 abort 和 muffle-warning 发出一个 control-error 类型[type]的错误.

        当状况 condition 不是 nil [non-nil], 只有那些和那个状况 condition 显式关联的或者没有和任何状况[condition]关联的重启动[restart]会被考虑; 这也就是说, 没有包含的重启动[restart]是那些和一个不包含给定状况 condition 的非空状况[condition]集合关联的重启动[restart]. 如果状况 condition 是 nil, 那么所有的重启动[restart]都会被考虑.

* 示例(Examples):

    ```LISP
    ;;; Example of the ABORT retart

    (defmacro abort-on-error (&body forms)
      `(handler-bind ((error #'abort))
          ,@forms)) =>  ABORT-ON-ERROR
    (abort-on-error (+ 3 5)) =>  8
    (abort-on-error (error "You lose."))
    >>  Returned to Lisp Top Level.

    ;;; Example of the CONTINUE restart

    (defun real-sqrt (n)
      (when (minusp n)
        (setq n (- n))
        (cerror "Return sqrt(~D) instead." "Tried to take sqrt(-~D)." n))
      (sqrt n))

    (real-sqrt 4) =>  2
    (real-sqrt -9)
    >>  Error: Tried to take sqrt(-9).
    >>  To continue, type :CONTINUE followed by an option number:
    >>   1: Return sqrt(9) instead.
    >>   2: Return to Lisp Toplevel.
    >>  Debug> (continue)
    >>  Return sqrt(9) instead.
    =>  3
    
    (handler-bind ((error #'(lambda (c) (continue))))
      (real-sqrt -9)) =>  3

    ;;; Example of the MUFFLE-WARNING restart

    (defun count-down (x)
      (do ((counter x (1- counter)))
          ((= counter 0) 'done)
        (when (= counter 1)
          (warn "Almost done"))
        (format t "~&~D~%" counter)))
    =>  COUNT-DOWN
    (count-down 3)
    >>  3
    >>  2
    >>  Warning: Almost done
    >>  1
    =>  DONE
    (defun ignore-warnings-while-counting (x)
      (handler-bind ((warning #'ignore-warning))
        (count-down x)))
    =>  IGNORE-WARNINGS-WHILE-COUNTING
    (defun ignore-warning (condition)
      (declare (ignore condition))
      (muffle-warning))
    =>  IGNORE-WARNING
    (ignore-warnings-while-counting 3)
    >>  3
    >>  2
    >>  1
    =>  DONE

    ;;; Example of the STORE-VALUE and USE-VALUE restarts

    (defun careful-symbol-value (symbol)
      (check-type symbol symbol)
      (restart-case (if (boundp symbol)
                        (return-from careful-symbol-value 
                                      (symbol-value symbol))
                        (error 'unbound-variable
                                :name symbol))
        (use-value (value)
          :report "Specify a value to use this time."
          value)
        (store-value (value)
          :report "Specify a value to store and use in the future."
          (setf (symbol-value symbol) value))))
    (setq a 1234) =>  1234
    (careful-symbol-value 'a) =>  1234
    (makunbound 'a) =>  A
    (careful-symbol-value 'a)
    >>  Error: A is not bound.
    >>  To continue, type :CONTINUE followed by an option number.
    >>   1: Specify a value to use this time.
    >>   2: Specify a value to store and use in the future.
    >>   3: Return to Lisp Toplevel.
    >>  Debug> (use-value 12)
    =>  12
    (careful-symbol-value 'a)
    >>  Error: A is not bound.
    >>  To continue, type :CONTINUE followed by an option number.
    >>    1: Specify a value to use this time.
    >>    2: Specify a value to store and use in the future.
    >>    3: Return to Lisp Toplevel.
    >>  Debug> (store-value 24)
    =>  24
    (careful-symbol-value 'a)
    =>  24

    ;;; Example of the USE-VALUE restart

    (defun add-symbols-with-default (default &rest symbols)
      (handler-bind ((sys:unbound-symbol
                        #'(lambda (c)
                            (declare (ignore c)) 
                            (use-value default))))
        (apply #'+ (mapcar #'careful-symbol-value symbols))))
    =>  ADD-SYMBOLS-WITH-DEFAULT
    (setq x 1 y 2) =>  2
    (add-symbols-with-default 3 'x 'y 'z) =>  6
    ```

* 副作用(Side Effects):

        如果一个合适的重启动[restart]是可用的, 那么可能发生一个控制转移, 否则 (在函数[functioni] abort 或者函数[function] muffle-warning 的情况下) 执行可能被停止.

* 受此影响(Affected By):

        这些函数中的每一个可以被一个相同名字的重启动[restart]的出现所影响.

* 异常情况(Exceptional Situations):

        如果对于函数[function] abort 一个合适的 abort 重启动[restart]是不可用的, 或者对于函数[function] muffle-warning 一个合适的 muffle-warning 重启动[restart]是不可用的, 那么就会发出一个类型[type] control-error 的错误.

* 参见(See Also):

        invoke-restart, 章节 9.1.4.2 (重启动), 章节 9.1.4.2.2 (重启动的接口), assert, ccase, cerror, check-type, ctypecase, use-value, warn

* 注意(Notes):

    ```LISP
    (abort condition) ==  (invoke-restart 'abort)
    (muffle-warning)  ==  (invoke-restart 'muffle-warning)
    (continue)        ==  (let ((r (find-restart 'continue))) (if r (invoke-restart r)))
    (use-value x) ==  (let ((r (find-restart 'use-value))) (if r (invoke-restart r x)))
    (store-value x) ==  (let ((r (find-restart 'store-value))) (if r (invoke-restart r x)))
    ```

        这个规范中没有定义需要去提供一个 use-value 重启动[restart]的函数. 


# 10. 符号

> * 10.1 [符号概念](#SymbolConcepts)
> * 10.2 [符号字典](#TheSymbolsDictionary)

## 10.1 <span id="SymbolConcepts">符号概念</span>

下面这段列出了一些可应用于符号[symbol]的属性列表[property list]的已定义名字[defined name].

    get  remprop  symbol-plist  

    Figure 10-1. 属性列表已定义的名字

下一段列出了一些可应用于创建和查询符号[symbol]的已定义名字[defined name].

    copy-symbol  keywordp     symbol-package  
    gensym       make-symbol  symbol-value    
    gentemp      symbol-name                  

    Figure 10-2. 符号创建和查询的已定义名字


## 10.2 <span id="TheSymbolsDictionary">符号字典</span>

> * [系统类 SYMBOL](#SC-SYMBOL)
> * [类型 KEYWORD](#T-KEYWORD)
> * [函数 SYMBOLP](#F-SYMBOLP)
> * [函数 KEYWORDP](#F-KEYWORDP)
> * [函数 MAKE-SYMBOL](#F-MAKE-SYMBOL)
> * [函数 COPY-SYMBOL](#F-COPY-SYMBOL)
> * [函数 GENSYM](#F-GENSYM)
> * [变量 *GENSYM-COUNTER*](#V-GENSYM-COUNTER)
> * [函数 GENTEMP](#F-GENTEMP)
> * [访问器 SYMBOL-FUNCTION](#A-SYMBOL-FUNCTION)
> * [函数 SYMBOL-NAME](#F-SYMBOL-NAME)
> * [函数 SYMBOL-PACKAGE](#F-SYMBOL-PACKAGE)
> * [访问器 SYMBOL-PLIST](#A-SYMBOL-PLIST)
> * [访问器 SYMBOL-VALUE](#A-SYMBOL-VALUE)
> * [访问器 GET](#A-GET)
> * [函数 REMPROP](#F-REMPROP)
> * [函数 BOUNDP](#F-BOUNDP)
> * [函数 MAKUNBOUND](#F-MAKUNBOUND)
> * [函数 SET](#F-SET)
> * [状况类型 UNBOUND-VARIABLE](#CT-UNBOUND-VARIABLE)


### <span id="SC-SYMBOL">系统类 SYMBOL</span>

* 类优先级列表(Class Precedence List):

        symbol, t

* 描述(Description):

        符号[symbol]用于它们的对象[object]标识来命名 Common Lisp 中不同的实体, 包括 (但不限于) 像变量[variable]和函数[function]这样的语言实体.

        符号[symbol]可以被一起收集到包[package]中. 如果一个符号[symbol]在一个包[package]中是可访问的[accessible]就说那个符号[symbol]被捕捉[interned]到那个包[package]中; 相同符号[symbol]可以被捕捉[interned]到不止一个包[package]中. 如果一个符号[symbol]没有被捕捉[interned]到任何包[package]中, 就说它是未捕捉的[uninterned].

        一个被捕捉的[interned]符号[symbol]在它可访问的[accessible]任何包[package]中根据它的名称[name]是唯一可识别的.

        符号[symbol]有着以下属性. 出于历史原因, 它们有时作为存储格[cell]被引用, 虽然符号[symbol]和它们的属性的实际内部表示是依赖于具体实现的[implementation-dependent].

        名字(Name)

            一个符号[symbol]的名字[name]是用于标识这个符号[symbol]的一个字符串[string]. 每个符号[symbol]有一个名字[name], 如果那个名字[name]被修改那么结果是未定义的. 这个名字[name]被用作这个符号[symbol]的外部打印表示的一部分; 见章节 2.1 (字符语法). 函数[function] symbol-name 返回一个给定符号[symbol]的名字[name]. 一个符号[symbol]的名字[name]中可能有任何字符[character].

        包(Package)

            在这个存储格[cell]的这个对象[object]被称为这个符号[symbol]的 home 包[home package]. 如果这个 home 包[home package]是 nil, 那么有时就说这个符号[symbol]没有 home 包[home package].

            当一个符号[symbol]被首次创建, 它没有 home 包[home package]. 当它第一次被捕捉[interned]时, 最初被捕捉[interned]时所在的包[package]成为它的 home 包[home package]. 一个符号[symbol]的 home 包[home package]可以通过函数[function] symbol-package 来访问.

            如果一个符号[symbol]从它的 home 包[home package]中被解除捕捉[uninterned], 它的 home 包[home package]会被设置为 nil. 这个符号[symbol]是否为一个未被捕捉[uninterned]的符号[symbol]取决于这个符号[symbol]是否被捕捉[interned]到另一个包[package]中. 一个没有 home 包[home package]的符号[symbol]因此被称为是显然未捕捉的[apparently uninterned].

            如果尝试去修改在 COMMON-LISP 包或者 KEYWORD 包中的一个外部符号[symbol]的 home 包[home package], 那么结果是未定义的.

        属性列表(Property list)

            一个符号[symbol]的属性列表[property list]为关联已命名属性和那个符号[symbol]提供了一个机制. 关于添加和移除的操作对于这个属性列表[property list]是破坏性的[destructive]. Common Lisp 提供了操作符[operator]来直接操作属性列表[property list]对象[object] (比如, 见 getf, remf, 和 symbol-plist) 以及通过引用一个符号[symbol]来隐式操作这个符号[symbol]的属性列表[property list] (比如, 见 get 和 remprop). 和一个新[fresh]符号[symbol]关联的属性列表[property list]被初始化为空[null].

        值(Value)

            如果一个符号有一个值属性, 它就被称为是绑定的[bound], 并且这个事实可以通过函数[function] boundp 来检测. 被包含在一个绑定的[bound]符号[symbol]的值存储格[value cell]中的对象[object]是那个符号[symbol]命名的全局变量[global variable]的值[value], 并且可以通过函数[function] symbol-value 来访问. 一个符号[symbol]可以通过函数[function] makunbound 变为未绑定的[unbound].

            如果尝试去修改一个命名常变量[constant variable]的符号[symbol]的值[value]或者使这样一个符号[symbol]变为未绑定的[unbound], 那么后果是未定义的.

        函数(Function)

            如果一个符号有一个函数属性, 它就被称为是 fbound 的, 并且这个事实可以通过函数[function] fboundp 来检测. 如果这个符号[symbol]是一个全局环境[global environment]中的函数[function]的名字[name], 这个函数存储格[function cell]就包含了那个函数[function], 并且可以通过函数[function] symbol-function 来访问. 如果这个符号[symbol]是全局环境[global environment]中的一个宏[macro] (见 macro-function) 或者一个特殊操作符[special operator] (见 special-operator-p) 的名字[name], 那么这个符号[symbol]就是 fbound 的, 并且可以通过函数[function] symbol-function 来访问, 但是那个函数存储格[function cell]所包含的对象的类型[type]和目的依赖于具体实现[implementation-dependent]. 一个符号[symbol]可以通过函数[function] fmakunbound 来变为 funbound 的.

            如果尝试去修改命名一个特殊表达式形式[special form]的符号[symbol]的函数值[functional value], 那么后果是未定义的.

        在一个符号[symbol]的值存储格[value cell]和函数存储格[function cell]上的操作有时被描述为对符号[symbol]自身的影响, 但是用户应该注意在那些存储格[cell]的内容分别和全局变量[global variable]或全局函数[function]定义之间存在一个紧密的关系.

        符号[symbol]被用作词法变量[lexical variable]和词法函数[function]定义的标识, 但是在那个角色中, 只有它们的对象标识才是重要的. Common Lisp 没有在一个符号[symbol]上提供在一个词法变量[lexical variable]或一个词法函数[function]定义上有任何效果的操作符.

* 参见(See Also):

        章节 2.3.4 (符号标记), 章节 2.3.1.1 (潜在数字作为标记), 章节 22.1.3.3 (打印符号)


### <span id="T-KEYWORD">类型 KEYWORD</span>

* 超类型(Supertypes):

        keyword, symbol, t

* 描述(Description):

        类型[type] keyword 包括所有被捕捉[interned]在 KEYWORD 包中的符号[symbol].

        捕捉一个符号[symbol]到 KEYWORD 包中有三个必然的影响:

        1. 它导致这个符号[symbol]被绑定到它自身.
        2. 它导致这个符号[symbol]变为这个 KEYWORD 包的外部符号[external symbol].
        3. 它导致这个符号[symbol]变为一个常变量[constant variable].

* 参见(See Also):

        keywordp


### <span id="F-SYMBOLP">函数 SYMBOLP</span>

* 语法(Syntax):

        symbolp object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义的 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 symbol 类型[type]的就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (symbolp 'elephant) =>  true
    (symbolp 12) =>  false
    (symbolp nil) =>  true
    (symbolp '()) =>  true
    (symbolp :test) =>  true
    (symbolp "hello") =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):  None.

* 参见(See Also):

        keywordp, symbol, typep

* 注意(Notes):

        (symbolp object) ==  (typep object 'symbol)


 ### <span id="F-KEYWORDP">函数 KEYWORDP</span>

 * 语法(Syntax):

        keywordp object => generalized-boolean

 * 参数和值(Arguments and Values):

        object---一个对象[symbol].
        generalized-boolean---一个广义 boolean [generalized boolean].

 * 描述(Description):

        如果对象 object 是一个关键字[keyword[1]]就返回 true; 否则, 返回 false.

 * 示例(Examples):

    ```LISP
      (keywordp 'elephant) =>  false
      (keywordp 12) =>  false
      (keywordp :test) =>  true
      (keywordp ':test) =>  true
      (keywordp nil) =>  false
      (keywordp :nil) =>  true
      (keywordp '(:test)) =>  false
      (keywordp "hello") =>  false
      (keywordp ":hello") =>  false
      (keywordp '&optional) =>  false
    ```

 * 副作用(Side Effects): None.

 * 受此影响(Affected By): None.

 * 异常情况(Exceptional Situations):  None.

 * 参见(See Also):

        constantp, keyword, symbolp, symbol-package

 * 注意(Notes): None.


### <span id="F-MAKE-SYMBOL">函数 MAKE-SYMBOL</span>

* 语法(Syntax):

        make-symbol name => new-symbol

* 参数和值(Arguments and Values):

        name---一个字符串[string].
        new-symbol---一个新的[fresh], 未捕捉的[uninterned]符号[symbol].

* 描述(Description):

        make-symbol 创建并返回一个新的[fresh], 未捕捉的[uninterned]符号[symbol], 它的名字[name]为给定的名字 name. 这个新符号 new-symbol 既没有被绑定[bound]也没有被 fbound 并且有一个空[null]属性列表[property list].

        成为这个新符号 new-symbol 的名字[name]的字符串[string]是那个给定的名字 name 还是它的拷贝依赖于具体实现[implementation-dependent]. 一旦一个字符串[string]已经被给定作为给 make-symbol 的 name 实参[argument], 如果后面去修改这个字符串[string]那么后果是未定义的.

* 示例(Examples):

    ```LISP
    (setq temp-string "temp") =>  "temp"
    (setq temp-symbol (make-symbol temp-string)) =>  #:|temp|
    (symbol-name temp-symbol) =>  "temp"
    (eq (symbol-name temp-symbol) temp-string) =>  implementation-dependent
    (find-symbol "temp") =>  NIL, NIL
    (eq (make-symbol temp-string) (make-symbol temp-string)) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): 

        如果名字 name 不是一个字符串[string]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        copy-symbol

* 注意(Notes):

        make-symbol 不会尝试去转换这个名字[name]的大小写为大写的. 对于符号[symbol]发生的仅有的大小写转换是通过 Lisp 读取器[Lisp reader]完成的. 对于符号[symbol]创建的编程接口保留大小写, 并且对于捕捉符号的编程接口是大小写敏感的.


### <span id="F-COPY-SYMBOL">函数 COPY-SYMBOL</span>

* 语法(Syntax):

        copy-symbol symbol &optional copy-properties => new-symbol

* 参数和值(Arguments and Values):

        symbol---一个符号[symbol].
        copy-properties---一个广义的 boolean [generalized boolean]. 默认是 false.
        new-symbol---一个新的[fresh], 未捕捉的[uninterned]符号[symbol].

* 描述(Description):

        copy-symbol 返回一个新的[fresh], 未被捕捉的[uninterned]符号[symbol], 它的名字[name]和给定符号 symbol 的名字[name]是 string= 的或者可能是一样的[same].

        如果 copy-properties 是 false, 这个新符号 new-symbol 即没有被绑定[bound]也没有被 fbound 并且有一个空[null]属性列表[property list]. 如果 copy-properties 是 true, 那么这个新符号 new-symbol 的初始值[value]是那个符号 symbol 的值[value], 这个新符号的初始函数[function]定义是那个符号 symbol 的函数值[functional value], 并且那个新符号 new-symbol 的属性列表[property list]是符号 symbol 的属性列表[property list]的一个拷贝[copy[2]].

* 示例(Examples):

    ```LISP
    (setq fred 'fred-smith) =>  FRED-SMITH
    (setf (symbol-value fred) 3) =>  3
    (setq fred-clone-1a (copy-symbol fred nil)) =>  #:FRED-SMITH
    (setq fred-clone-1b (copy-symbol fred nil)) =>  #:FRED-SMITH
    (setq fred-clone-2a (copy-symbol fred t))   =>  #:FRED-SMITH
    (setq fred-clone-2b (copy-symbol fred t))   =>  #:FRED-SMITH
    (eq fred fred-clone-1a) =>  false
    (eq fred-clone-1a fred-clone-1b) =>  false
    (eq fred-clone-2a fred-clone-2b) =>  false
    (eq fred-clone-1a fred-clone-2a) =>  false
    (symbol-value fred) =>  3
    (boundp fred-clone-1a) =>  false
    (symbol-value fred-clone-2a) =>  3
    (setf (symbol-value fred-clone-2a) 4) =>  4
    (symbol-value fred) =>  3
    (symbol-value fred-clone-2a) =>  4
    (symbol-value fred-clone-2b) =>  3
    (boundp fred-clone-1a) =>  false
    (setf (symbol-function fred) #'(lambda (x) x)) =>  #<FUNCTION anonymous>
    (fboundp fred) =>  true
    (fboundp fred-clone-1a) =>  false
    (fboundp fred-clone-2a) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): 

        如果 symbol 不是一个符号[symbol], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        make-symbol

* 注意(Notes):

        鼓励实现者不要去不必要地复制那个是符号[symbol]名字[name]的字符串[string]. 除非这里有一个好的理由去做这个, 对于这个新符号 new-symbol 的名字[name]的正常的实现策略是和给定符号 symbol 的名字[name]是相同的[identical].


### <span id="F-GENSYM">函数 GENSYM</span>

* 语法(Syntax):

        gensym &optional x => new-symbol

* 参数和值(Arguments and Values):

        x---一个字符串[string]或者一个非负整数[integer]. 复杂的默认行为; 见下文.
        new-symbol---一个新的[fresh], 未捕捉的[uninterned]符号[symbol].

* 描述(Description):

        创建并返回一个新的[fresh], 未捕捉的[uninterned]符号[symbol], 就像是通过调用 make-symbol 的一样. (gensym 和 make-symbol 仅有的区别在于如何决定这个新符号 new-symbol 的名字[name].)

        这个新符号 new-symbol 的名字[name]由一个默认为 "G" 的前缀和一个默认为 *gensym-counter* 值[value]的十进制表示的后缀拼接而成.

        如果提供了 x, 并且是一个字符串[string], 那么这个字符串[string]仅在这个对 gensym 的调用中替换 "G" 作为前缀.

        如果提供了 x, 并且是一个整数[ingeter], 那么这个整数[ingeter]仅在这个对 gensym 的调用中替换 *gensym-counter* 的值[value]被用作后缀.

        当且仅当没有提供显式后缀时, *gensym-counter* 在它被使用后递增.

* 示例(Examples):

    ```LISP
    (setq sym1 (gensym)) =>  #:G3142
    (symbol-package sym1) =>  NIL
    (setq sym2 (gensym 100)) =>  #:G100
    (setq sym3 (gensym 100)) =>  #:G100
    (eq sym2 sym3) =>  false
    (find-symbol "G100") =>  NIL, NIL
    (gensym "T") =>  #:T3143
    (gensym) =>  #:G3144
    ```

* 副作用(Side Effects):

        可能递增 *gensym-counter*.

* 受此影响(Affected By):

        *gensym-counter*

* 异常情况(Exceptional Situations): 

        如果 x 不是一个字符串[string]也不是一个非负整数[integer], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        gentemp, *gensym-counter*

* 注意(Notes):

        传递一个数字参数给 gensym 的能力已经被废弃了; 显示绑定 *gensym-counter* 目前语法上是首选的. (关于可选参数的一些巴洛克式的惯例本质上是历史性的, 并且主要是为了支持较老版本的 Lisp 方言的兼容性. 在现代代码中, 建议仅有的参数种类是一个字符串前缀. 通常, 为了获取这个新符号 new-symbol 的名字的更灵活的控制, 考虑使用 make-symbol.)


### <span id="V-GENSYM-COUNTER">变量 *GENSYM-COUNTER*</span>

* 值类型(Value Type):

        一个非负整数[integer].

* 初始值(Initial Value):

        依赖于具体实现[implementation-dependent].

* 描述(Description):

        用来构造由函数[function] gensym 生成的下一个符号[symbol]名字[name]的一个数字.

        *gensym-counter* 可以在任何时间被赋值或绑定[bound], 但是它的值必须总是为一个非负整数[integer].

* 示例(Examples): None.

* 受此影响(Affected By):

        gensym.

* 参见(See Also):

        gensym

* 注意(Notes):

        传递一个数字参数给 gensym 的能力已经被废弃了; 显式绑定[binding] *gensym-counter* 目前是语法上首选的.


### <span id="F-GENTEMP">函数 GENTEMP</span>

* 语法(Syntax):

        gentemp &optional prefix package => new-symbol

* 参数和值(Arguments and Values):

        prefix---一个字符串[string]. 默认为 "T".
        package---一个包标识符[package designator]. 默认是当前包[current package].
        new-symbol---一个新的[fresh], 被捕捉的[interned]符号[symbol].

* 描述(Description):

        gentemp 创建并返回一个新的[fresh]符号[symbol], 被捕捉[interned]在指定的包 package 中. 这个符号[symbol]保证不是一个之前在包 package 中可访问的[accessible]符号. 它既没有被绑定[bound]也没有被 fbound, 并且有一个空[null]属性列表[property list].

        这个新符号 new-symbol 的名字[name]是一个前缀 prefix 和后缀拼接而成, 这个后缀取自一个只有 gentemp 使用的内部计数器. (如果这个名字的一个符号[symbol]在包 package 中已经是可访问的[accessible], 这个计数器递增必要的次数来产生一个之前在这个包 package 中不是一个可访问[accessible]符号[symbol]的名字.)

* 示例(Examples):

    ```LISP
    (gentemp) =>  T1298
    (gentemp "FOO") =>  FOO1299
    (find-symbol "FOO1300") =>  NIL, NIL
    (gentemp "FOO") =>  FOO1300
    (find-symbol "FOO1300") =>  FOO1300, :INTERNAL
    (intern "FOO1301") =>  FOO1301, :INTERNAL
    (gentemp "FOO") =>  FOO1302
    (gentemp) =>  T1303
    ```

* 副作用(Side Effects):

        它的内部计数器被递增一次或多次.
        在包 package 中捕捉[intern]这个新符号 new-symbol.

* 受此影响(Affected By):

        它的内部计数器的当前状态, 以及这个包 package 的当前状态.

* 异常情况(Exceptional Situations): 

        如果前缀 prefix 不是一个字符串[string]那么应该发出一个 type-error 类型[type]的错误. 如果 package 不是一个包标识符[package designator]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        gensym

* 注意(Notes):

        函数 gentemp 被废弃了.

        如果包 package 是 KEYWORD 包, 那么结果是包 package 的一个外部符号[external symbol]. 否则, 结果就是一个包 package 的一个内部符号[internal symbol].

        这个 gentemp 内部计数器独立于 gensym 使用的计数器 *gensym-counter*. 这里没有用于访问这个 gentemp 内部计数器的措施.

        只是因为 gentemp 创建一个之前不存在的符号[symbol]并不意味着这样一个符号[symbol]在未来可能不会出现 (比如, 在一个数据文件中---可能由另一个会话中的相同程序创建). 因此, 这个符号并不像 gensym 一样是唯一的. 特别地, 自动代码生成的程序应该注意不要将全局属性附加到这些生成的符号[symbol]上 (比如, special 声明[declaration]) 并且把它们写到一个文件中, 因为这样的全局属性可能在不同的会话中, 最终会应用到其他符号[symbol]上, 这些符号[symbol]是在另一天自动生成用于其他目的.


### <span id="A-SYMBOL-FUNCTION">访问器 SYMBOL-FUNCTION</span>

* 语法(Syntax):

        symbol-function symbol => contents

        (setf (symbol-function symbol) new-contents)

* 参数和值(Arguments and Values):

        symbol---一个符号[symbol].

        contents--- 如果这个符号 symbol 是一个全局定义的宏[macro]或者特殊操作符[special operator], 那么就返回一个性质和标识依赖于具体实现[implementation-dependent]的对象[object]. 如果这个符号 symbol 没有被全局定义为一个宏[macro]或一个特殊操作符[special operator], 并且这个符号 symbol 被 fbound 了, 返回一个函数[function]对象[object].

        new-contents---一个函数.

* 描述(Description):

        访问[access]这个符号[symbol]的函数存储格[function cell].

* 示例(Examples):

    ```LISP
    (symbol-function 'car) =>  #<FUNCTION CAR>
    (symbol-function 'twice) is an error   ;because TWICE isn't defined.
    (defun twice (n) (* n 2)) =>  TWICE
    (symbol-function 'twice) =>  #<FUNCTION TWICE>
    (list (twice 3)
          (funcall (function twice) 3)
          (funcall (symbol-function 'twice) 3))
    =>  (6 6 6)
    (flet ((twice (x) (list x x)))
      (list (twice 3)
            (funcall (function twice) 3)
            (funcall (symbol-function 'twice) 3)))
    =>  ((3 3) (3 3) 6)   
    (setf (symbol-function 'twice) #'(lambda (x) (list x x)))
    =>  #<FUNCTION anonymous>
    (list (twice 3)
          (funcall (function twice) 3)
          (funcall (symbol-function 'twice) 3))
    =>  ((3 3) (3 3) (3 3))
    (fboundp 'defun) =>  true
    (symbol-function 'defun)
    =>  implementation-dependent
    (functionp (symbol-function 'defun))
    =>  implementation-dependent
    (defun symbol-function-or-nil (symbol)
      (if (and (fboundp symbol)
                (not (macro-function symbol))
                (not (special-operator-p symbol)))
          (symbol-function symbol)
          nil)) =>  SYMBOL-FUNCTION-OR-NIL
    (symbol-function-or-nil 'car) =>  #<FUNCTION CAR>
    (symbol-function-or-nil 'defun) =>  NIL
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        defun

* 异常情况(Exceptional Situations): 

        如果 symbol 不是一个符号[symbol]那么应该发出一个 type-error 类型[type]的错误.

        如果 symbol 没有被 fbound 并且尝试去读取[read]它的定义那么应该发出一个 undefined-function 类型的错误. (在尝试去写入[write]它的定义时不会发出这样的错误.)

* 参见(See Also):

        fboundp, fmakunbound, macro-function, special-operator-p

* 注意(Notes):

        symbol-function 不能访问[access]由 flet 或 labels 产生的词法函数名的值; 它只能访问[access]全局函数值.

        当这个符号[symbol]的函数定义不表示一个特殊操作符[special operator]时, setf 可以和 symbol-function 一起使用来替换一个全局函数定义.

        (symbol-function symbol) ==  (fdefinition symbol)

        然而, fdefinition 接受的参数不仅仅是符号[symbol].


### <span id="F-SYMBOL-NAME">函数 SYMBOL-NAME</span>

* 语法(Syntax):

        symbol-name symbol => name

* 参数和值(Arguments and Values):

        symbol---一个符号[symbol].
        name---一个字符串[string].

* 描述(Description):

        symbol-name 返回符号 symbol 的名字[name]. 如果名字 name 被修改那么后果是未定义的.

* 示例(Examples):

    ```LISP
    (symbol-name 'temp) =>  "TEMP"
    (symbol-name :start) =>  "START"
    (symbol-name (gensym)) =>  "G1234" ;for example
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): 

        如果 symbol 不是一个符号[symbol]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also): None.

* 注意(Notes): None.


### <span id="F-SYMBOL-PACKAGE">函数 SYMBOL-PACKAGE</span>

* 语法(Syntax):

        symbol-package symbol => contents

* 参数和值(Arguments and Values):

        symbol---一个符号[symbol].
        contents---一个包[package]对象[object]或者 nil.

* 描述(Description):

        返回这个符号 symbol 的 home 包[home package].

* 示例(Examples):

    ```LISP
    (in-package "CL-USER") =>  #<PACKAGE "COMMON-LISP-USER">
    (symbol-package 'car) =>  #<PACKAGE "COMMON-LISP">
    (symbol-package 'bus) =>  #<PACKAGE "COMMON-LISP-USER">
    (symbol-package :optional) =>  #<PACKAGE "KEYWORD">
    ;; Gensyms are uninterned, so have no home package.
    (symbol-package (gensym)) =>  NIL
    (make-package 'pk1) =>  #<PACKAGE "PK1">
    (intern "SAMPLE1" "PK1") =>  PK1::SAMPLE1, NIL
    (export (find-symbol "SAMPLE1" "PK1") "PK1") =>  T
    (make-package 'pk2 :use '(pk1)) =>  #<PACKAGE "PK2">
    (find-symbol "SAMPLE1" "PK2") =>  PK1:SAMPLE1, :INHERITED
    (symbol-package 'pk1::sample1) =>  #<PACKAGE "PK1">
    (symbol-package 'pk2::sample1) =>  #<PACKAGE "PK1">
    (symbol-package 'pk1::sample2) =>  #<PACKAGE "PK1">
    (symbol-package 'pk2::sample2) =>  #<PACKAGE "PK2">
    ;; The next several forms create a scenario in which a symbol
    ;; is not really uninterned, but is "apparently uninterned",
    ;; and so SYMBOL-PACKAGE still returns NIL.
    (setq s3 'pk1::sample3) =>  PK1::SAMPLE3
    (import s3 'pk2) =>  T
    (unintern s3 'pk1) =>  T
    (symbol-package s3) =>  NIL
    (eq s3 'pk2::sample3) =>  T
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        import, intern, unintern

* 异常情况(Exceptional Situations): 

        如果 symbol 不是一个符号[symbol]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        intern

* 注意(Notes): None.


### <span id="A-SYMBOL-PLIST">访问器 SYMBOL-PLIST</span>

* 语法(Syntax):

        symbol-plist symbol => plist

        (setf (symbol-plist symbol) new-plist)

* 参数和值(Arguments and Values):

        symbol---一个符号[symbol].
        plist, new-plist---一个属性列表[property list].

* 描述(Description):

        访问[access]符号 symbol 的属性列表[property list].

* 示例(Examples):

    ```LISP
    (setq sym (gensym)) =>  #:G9723
    (symbol-plist sym) =>  ()
    (setf (get sym 'prop1) 'val1) =>  VAL1
    (symbol-plist sym) =>  (PROP1 VAL1)
    (setf (get sym 'prop2) 'val2) =>  VAL2
    (symbol-plist sym) =>  (PROP2 VAL2 PROP1 VAL1)
    (setf (symbol-plist sym) (list 'prop3 'val3)) =>  (PROP3 VAL3)
    (symbol-plist sym) =>  (PROP3 VAL3)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): 

        如果 symbol 不是一个符号[symbol]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        get, remprop

* 注意(Notes):

        应该避免使用 setf, 因为一个符号[symbol]的属性列表[property list]是一个全局资源, 它可以包含相同 Lisp 镜像[Lisp image]中由不相关的程序建立和依赖的信息.


### <span id="A-SYMBOL-VALUE">访问器 SYMBOL-VALUE</span>

* 语法(Syntax):

        symbol-value symbol => value

        (setf (symbol-value symbol) new-value)

* 参数和值(Arguments and Values):

        symbol---必须有一个值[value]的符号[symbol].
        value, new-value---一个对象[object].

* 描述(Description):

        访问[access]这个符号[symbol]的值存储格[value cell].

* 示例(Examples):

    ```LISP
    (setf (symbol-value 'a) 1) =>  1
    (symbol-value 'a) =>  1
    ;; SYMBOL-VALUE cannot see lexical variables.
    (let ((a 2)) (symbol-value 'a)) =>  1
    (let ((a 2)) (setq a 3) (symbol-value 'a)) =>  1
    ;; SYMBOL-VALUE can see dynamic variables.
    (let ((a 2))
      (declare (special a))
      (symbol-value 'a)) =>  2
    (let ((a 2))
      (declare (special a))
      (setq a 3)
      (symbol-value 'a)) =>  3
    (let ((a 2))
      (setf (symbol-value 'a) 3)
      a) =>  2
    a =>  3
    (symbol-value 'a) =>  3
    (let ((a 4))
      (declare (special a))
      (let ((b (symbol-value 'a)))
        (setf (symbol-value 'a) 5)
        (values a b))) =>  5, 4
    a =>  3
    (symbol-value :any-keyword) =>  :ANY-KEYWORD
    (symbol-value 'nil) =>  NIL
    (symbol-value '()) =>  NIL
    ;; The precision of this next one is implementation-dependent.
    (symbol-value 'pi) =>  3.141592653589793d0  
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        makunbound, set, setq

* 异常情况(Exceptional Situations): 

        如果 symbol 不是一个符号[symbol]那么应该发出一个 type-error 类型[type]的错误.

        如果符号 symbol 被解绑[unbound]并且尝试去读取[read]它的值[value], 那么应该发出 unbound-variable 类型的错误. (在尝试去写入[write]它的值[value]时不会发出这样的错误.)

* 参见(See Also):

        boundp, makunbound, set, setq

* 注意(Notes):

        symbol-value 可以被用于获取一个常变量[constant variable]的值. symbol-value 不能访问一个词法变量[lexical variable]的值[value].


### <span id="A-GET">访问器 GET</span>

* 语法(Syntax):

        get symbol indicator &optional default => value

        (setf (get symbol indicator &optional default) new-value)

* 参数和值(Arguments and Values):

        symbol---一个符号[symbol].
        indicator---一个对象[object].
        default---一个对象[object]. 默认为 nil.
        value---如果表示的属性存在, 就是它的值[value]对象[object]; 否则, 就是指定的默认值 default.
        new-value---一个对象[object].

* 描述(Description):

        get 在符号 symbol 的属性列表[property list[2]]中找到一个属性指示符[property indicator]和指示符 indicator 一样[identical]的属性, 并且返回它对应的属性值[property value]. 如果这里有多个属性[property[1]]带有那个属性指示符[property indicator], get 使用第一个这样的属性[property]. 如果没有带有那个属性指示符[property indicator]的属性[property], 返回默认值 default.

        get 的 setf 可以被用于关联一个新对象[object]和一个存在于那个符号 symbol 的属性列表[property list]中的指示符, 如果不存在就创建一个新的关联. 如果这里有多个属性[property[1]]带有那个属性指示符[property indicator], get 的 setf 关联那个新值 new-value 到第一个这样的属性[property[1]]. 当一个 get 表达式形式[form]被用作一个 setf 的位置 place 时, 任何提供的默认值 default 都根据正常从左到右的求值规则被求值, 但是它的值会被忽略.

* 示例(Examples):

    ```LISP
    (defun make-person (first-name last-name)
      (let ((person (gensym "PERSON")))
        (setf (get person 'first-name) first-name)
        (setf (get person 'last-name) last-name)
        person)) =>  MAKE-PERSON
    (defvar *john* (make-person "John" "Dow")) =>  *JOHN*
    *john* =>  #:PERSON4603
    (defvar *sally* (make-person "Sally" "Jones")) =>  *SALLY*
    (get *john* 'first-name) =>  "John"
    (get *sally* 'last-name) =>  "Jones"
    (defun marry (man woman married-name)
      (setf (get man 'wife) woman)
      (setf (get woman 'husband) man)
      (setf (get man 'last-name) married-name)
      (setf (get woman 'last-name) married-name)
      married-name) =>  MARRY
    (marry *john* *sally* "Dow-Jones") =>  "Dow-Jones"
    (get *john* 'last-name) =>  "Dow-Jones"
    (get (get *john* 'wife) 'first-name) =>  "Sally"
    (symbol-plist *john*)
    =>  (WIFE #:PERSON4604 LAST-NAME "Dow-Jones" FIRST-NAME "John")
    (defmacro age (person &optional (default ''thirty-something))
      `(get ,person 'age ,default)) =>  AGE
    (age *john*) =>  THIRTY-SOMETHING
    (age *john* 20) =>  20
    (setf (age *john*) 25) =>  25
    (age *john*) =>  25
    (age *john* 20) =>  25
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): 

        如果 symbol 不是一个符号[type]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        getf, symbol-plist, remprop

* 注意(Notes):

        (get x y) ==  (getf (symbol-plist x) y)

        在可移植的代码中不推荐数字[number]和字符[character]被用作指示符 indicator, 因为 get 使用 eq 来测试而不是使用 eql, 因此使用这样的指示符的影响是依赖于具体实现的[implementation-dependent].

        使用 get 没法去区分一个缺省的属性和值为默认值 default 的属性. 但是, 见 get-properties.


### <span id="F-REMPROP">函数 REMPROP</span>

* 语法(Syntax):

        remprop symbol indicator => generalized-boolean

* 参数和值(Arguments and Values):

        symbol---一个符号[symbol].
        indicator---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        remprop 从符号 symbol 的属性列表[property list[2]]中移除一个带有和指示符 indicator 一样[identical]属性指示符[property indicator]的属性[property[1]]. 如果这里有多个带有相同[identical]键的属性[property[1]], remprop 只移除第一个这样的属性[property[1]]. 如果没有找到这样的属性[property]那么 remprop 返回 false, 如果找到一个属性就返回 true.

        这个属性指示符[property indicator]和对应属性值[property value]通过破坏性地拼接这个属性列表以一种未定义的顺序被移除. 可允许的副作用相当于 remf 允许的那些, 如此这般:

        (remprop x y) ==  (remf (symbol-plist x) y)

* 示例(Examples):

    ```LISP
    (setq test (make-symbol "PSEUDO-PI")) =>  #:PSEUDO-PI
    (symbol-plist test) =>  ()
    (setf (get test 'constant) t) =>  T
    (setf (get test 'approximation) 3.14) =>  3.14
    (setf (get test 'error-range) 'noticeable) =>  NOTICEABLE
    (symbol-plist test)
    =>  (ERROR-RANGE NOTICEABLE APPROXIMATION 3.14 CONSTANT T)
    (setf (get test 'approximation) nil) =>  NIL
    (symbol-plist test)
    =>  (ERROR-RANGE NOTICEABLE APPROXIMATION NIL CONSTANT T)
    (get test 'approximation) =>  NIL
    (remprop test 'approximation) =>  true
    (get test 'approximation) =>  NIL
    (symbol-plist test)
    =>  (ERROR-RANGE NOTICEABLE CONSTANT T)
    (remprop test 'approximation) =>  NIL
    (symbol-plist test)
    =>  (ERROR-RANGE NOTICEABLE CONSTANT T)
    (remprop test 'error-range) =>  true
    (setf (get test 'approximation) 3) =>  3
    (symbol-plist test)
    =>  (APPROXIMATION 3 CONSTANT T)
    ```

* 副作用(Side Effects):

        符号 symbol 的属性列表[property list]被修改.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): 

        如果 symbol 不是一个符号[symbol]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        remf, symbol-plist

* 注意(Notes):

        在可移植的代码中不推荐数字[number]和字符[character]被用作指示符 indicator 因为 remprop 使用 eq 来测试而不是 eql, 因此使用这样的指示符的影响是依赖于具体实现的[implementation-dependent]. 当然, 如果你想要移除这样的属性[property], 你没有太多选择---考虑这个问题的时间就是当你使用 get 的 setf 来建立这个属性[property]的时候.


### <span id="F-BOUNDP">函数 BOUNDP</span>

* 语法(Syntax):

        boundp symbol => generalized-boolean

* 参数和值(Arguments and Values):

        symbol---一个符号[symbol].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果符号 symbol 被绑定[bound]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (setq x 1) =>  1
    (boundp 'x) =>  true
    (makunbound 'x) =>  X
    (boundp 'x) =>  false
    (let ((x 2)) (boundp 'x)) =>  false
    (let ((x 2)) (declare (special x)) (boundp 'x)) =>  true
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): 

        如果 symbol 不是一个符号[symbol]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        set, setq, symbol-value, makunbound

* 注意(Notes):

        函数[function] bound 只决定一个符号[symbol]在全局环境[global environment]中是否有一个值; 任何词法绑定[lexical binding]都被忽略.


### <span id="F-MAKUNBOUND">函数 MAKUNBOUND</span>

* 语法(Syntax):

        makunbound symbol => symbol

* 参数和值(Arguments and Values):

        symbol---一个符号[symbol]

* 描述(Description):

        使这个符号 symbol 变为未绑定的[unbound], 不管之前它是否被绑定[bound].

* 示例(Examples):

    ```LISP
    (setf (symbol-value 'a) 1)
    (boundp 'a) =>  true
    a =>  1
    (makunbound 'a) =>  A
    (boundp 'a) =>  false
    ```

* 副作用(Side Effects):

        符号 symbol 的值存储格[value cell]会被求值.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): 

        如果 symbol 不是一个符号[symbol]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        boundp, fmakunbound

* 注意(Notes): None.


### <span id="F-SET">函数 SET</span>

* 语法(Syntax):

        set symbol value => value

* 参数和值(Arguments and Values):

        symbol---一个符号[symbol].
        value---一个对象[object].

* 描述(Description):

        set 改变符号[symbol]的值存储格[value cell]的内容为给定的值[value].

        (set symbol value) ==  (setf (symbol-value symbol) value)

* 示例(Examples):

    ```LISP
    (setf (symbol-value 'n) 1) =>  1
    (set 'n 2) =>  2
    (symbol-value 'n) =>  2
    (let ((n 3))
      (declare (special n))
      (setq n (+ n 1))
      (setf (symbol-value 'n) (* n 10))
      (set 'n (+ (symbol-value 'n) n))
      n) =>  80
    n =>  2
    (let ((n 3))
      (setq n (+ n 1))
      (setf (symbol-value 'n) (* n 10))
      (set 'n (+ (symbol-value 'n) n))
      n) =>  4
    n =>  44
    (defvar *n* 2)
    (let ((*n* 3))
      (setq *n* (+ *n* 1))
      (setf (symbol-value '*n*) (* *n* 10))
      (set '*n* (+ (symbol-value '*n*) *n*))
      *n*) =>  80
      *n* =>  2
    (defvar *even-count* 0) =>  *EVEN-COUNT*
    (defvar *odd-count* 0) =>  *ODD-COUNT*
    (defun tally-list (list)
      (dolist (element list)
        (set (if (evenp element) '*even-count* '*odd-count*)
              (+ element (if (evenp element) *even-count* *odd-count*)))))
    (tally-list '(1 9 4 3 2 7)) =>  NIL
    *even-count* =>  6
    *odd-count* =>  20
    ```

* 副作用(Side Effects):

        符号 symbol 的值[value]被改变.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):  None.

* 参见(See Also):

        setq, progv, symbol-value

* 注意(Notes):

        函数 set 已经被废弃.

        set 不能修改一个词法变量[lexical variable]的值.


### <span id="CT-UNBOUND-VARIABLE">状况类型 UNBOUND-VARIABLE</span>

* 类优先级列表(Class Precedence List):

        unbound-variable, cell-error, error, serious-condition, condition, t

* 描述(Description):

        类型[type] unbound-variable 由表示尝试去读取[read]一个未绑定变量[unbound variable]的值[value]的错误[error]状况[condition]组成.

        这个存储格 (见 cell-error) 的名字是这个未绑定[unbound]变量[variable]的名字[name].

* 参见(See Also):

        cell-error-name


# 11. 包

> * 11.1 [包概念](#PackageConcepts)
> * 11.2 [包字典](#ThePackagesDictionary)

## 11.1 <span id="PackageConcepts">包概念</span>

> * 11.1.1 [包的介绍](#IntroductionPackages)
> * 11.1.2 [标准包](#StandardizedPackages)

### 11.1.1 <span id="IntroductionPackages">包的介绍</span>

一个包[package]建立一个从名字到符号[symbol]的映射. 在给定的任何时间, 都有一个包[package]是当前的. 当前包[current package]是 \*package\* 的值[value]的那个包. 当使用 Lisp 读取器[Lisp reader]时, 可以去引用非当前包[package]中的符号[symbol], 通过在那个符号[symbol]的打印表示中使用包前缀[package prefixe].

下面这段列出了一些可应用于包[package]的已定义的名字[defined name]. 在一个操作符[operator]接收一个符号[symbol]或一个符号[symbol]列表[list]作为参数的地方, 一个 nil 参数被当作是一个空的符号[symbol]列表[list]. 任何包 package 参数可能是一个字符串[string], 一个符号[symbol], 或者一个包[package]. 如果提供了一个符号[symbol], 它的名字会被用作这个包[package]的名字.

    *modules*            import                     provide           
    *package*            in-package                 rename-package    
    defpackage           intern                     require           
    do-all-symbols       list-all-packages          shadow            
    do-external-symbols  make-package               shadowing-import  
    do-symbols           package-name               unexport          
    export               package-nicknames          unintern          
    find-all-symbols     package-shadowing-symbols  unuse-package     
    find-package         package-use-list           use-package       
    find-symbol          package-used-by-list                         

    Figure 11-1. 一些和包相关的已定义的名字

> * 11.1.1.1 [包名和别名](#PackageNamesNicknames)
> * 11.1.1.2 [一个包中的符号](#SymbolsInPackage)

#### 11.1.1.1 <span id="PackageNamesNicknames">包名和别名</span>

每个包[package]都有一个名字[name] (一个字符串[string]) 并且或许有一些别名[nickname] (也是字符串[string]). 在这个包被创建时它们被赋值并且可以在后面更改.

这里有一个包[package]的单独的命名空间. 函数[function] find-package 把一个包的名字[name]或别名[nickname]转换为关联的包[package]. 函数[function] package-name 返回一个包[package]的名字[name]. 函数[function] package-nicknames 返回一个包[package]的所有别名[nickname]的列表[list]. rename-package 移除一个包[package]的当前名字[name]和别名[nickname]并且用调用者指定的新的那些替换它们. 

#### 11.1.1.2 <span id="SymbolsInPackage">一个包中的符号</span>

> * 11.1.1.2.1 [内部和外部符号](#InternalExternalSymbols)
> * 11.1.1.2.2 [包的继承](#PackageInheritance)
> * 11.1.1.2.3 [一个包中符号的可访问性](#AccessSymbolsPackage)
> * 11.1.1.2.4 [查找一个包中的一个符号](#LocatingSymbolPackage)
> * 11.1.1.2.5 [包中的名字冲突的避免](#PreventionNameConflictsPackages)

##### 11.1.1.2.1 <span id="InternalExternalSymbols">内部和外部符号</span>

在一个包[package]中的映射被分为两类, 外部的和内部的. 这些不同的映射所针对的符号[symbol]被称为这个包[package]的外部符号[external symbol]和内部符号[internal symbol]. 在一个包[package]中, 一个名字引用一个符号[symbol]或者没有引用; 如果它确实引用一个符号[symbol], 那么它可能是那个包中的外部符号或内部符号, 但是不可能都是. 外部符号[external symbol]是这个包对于其他包[package]的公共接口部分. 如果符号[symbol]从一个给定包[package]中被导出[export], 那么它们就是这个包[package]的外部符号[external symbol].

一个符号[symbol]不管出现[present]在哪个包[package]中它都有着相同的名字, 但是它可能是某些包[package]的一个外部符号[external symbol], 其他包的内部符号[internal symbol]. 

##### 11.1.1.2.2 <span id="PackageInheritance">包的继承</span>

包[package]可以分层构建. 从某个角度, 一个包[package]是一个从字符串[string]到内部符号[internal symbol]和外部符号[external symbol]的映射的单独集合. 然而, 这些映射中的一部分可能在这个包[package]自身中被建立, 而其他映射可能通过 use-package 从其他包[package]中继承而来. 如果一个映射是在那个包[package]自身中的并且不是从某个其他地方继承来的, 就说一个符号[symbol]出现[present]在一个包[package]中.

这里没有方法去继承另一个包[package]的内部符号[internal symbol]; 在使用 Lisp 读取器[Lisp reader]时, 为了引用一个内部符号[internal symbol], 包含这个符号[symbol]的包[package]一定是当前包[current package], 或者一定使用一个包前缀[package prefix], 或者这个符号[symbol]一定被导入到当前包[current package]中. 

##### 11.1.1.2.3 <span id="AccessSymbolsPackage">一个包中符号的可访问性</span>

如果一个包[package]在一个符号[symbol]被创建时是它的 home 包[home package], 或者它被导入到这个包[package]中, 或者通过 use-package 继承, 那么这个符号[symbol]在这个包[package]中就是可访问的[accessible].

如果一个符号[symbol]在一个包[package]中是可访问的[accessible], 当那个包[package]是当前包[current package]时用 Lisp 读取器, 它可以在不带包前缀[package prefix]的情况下被引用, 不管它是出现[present]在那个包中还是继承的.

来自一个包[package]中的符号[symbol]可以用两种方式使得它在另一个包[package]中可访问[accessible].

-- 任何单独符号[symbol]可以通过使用 import 被添加到一个包[package]中. 在这个对 import 的调用后那个符号[symbol]就出现[present]在那个导入的包[package]中. 在这个符号[symbol]来源的包[package]中(如果有的话)的该符号[symbol]的状态是不会被改变, 并且这个符号[symbol]的 home 包[home package]没有被改变. 一旦被导入, 一个符号[symbol]就出现[present]在那个导入的包[package]中并且只能通过调用 unintern 来移除.

    一个符号[symbol]被某个包中的另一个符号[symbol]所遮蔽[shadow[3]], 如果第二个符号没有出现第一个符号[symbol]通过继承是可访问[accessible]的话. 见 shadowing-import.

-- 使一个包[package]中的符号[symbol]在另一个包中是可访问[accessible]的第二种机制是由 use-package 提供的. 那个被使用的包[package]中的所有外部符号[external package]都被那个使用的包[package]所继承. 函数[function] unuse-package 撤销一个之前的 use-package 的影响. 

##### 11.1.1.2.4 <span id="LocatingSymbolPackage">查找一个包中的一个符号</span>

当要在一个给定的包中查找一个符号时会发生以下情况:

-- 对这个包[package]的外部符号[external package]和内部符号[internal symbol]进行搜索来查找这个符号[symbol].
-- 所使用的包[package]的外部符号[external package]会以某个未指定的顺序进行搜索. 顺序无关紧要; 见下面列出的用于处理名字冲突的规则. 

##### 11.1.1.2.5 <span id="PreventionNameConflictsPackages">包中的名字冲突的避免</span>

在一个包[package]中, 任何独有的名字最多只能引用一个符号[symbol]. 当这里有超过一个候选符号[symbol]时就说发生了名字冲突. 任何一个名字冲突将要发生时, 就会发出一个可校正的[correctable]错误[error].

以下规则应用于名字冲突:

-- 当名字冲突成为可能时它们会被检测到, 就是说, 在这个包结构被修改时. 在每次名字查找时名字冲突不会被检测.

-- 如果对于一个包[package]相同[same]符号[symbol]可以通过超过一种途径访问, 那么这里没有名字冲突. 一个符号[symbol]不能和自身冲突. 名字冲突只发生在有着相同名字(在 string= 下)的不同[distinct]符号[symbol]之间.

-- 每个包[package]都有一个遮蔽符号[symbol]的列表. 一个遮蔽符号[symbol]优先于其他在那个包[package]中可访问的[accessible]任何相同名字的符号[symbol]. 一个涉及到遮蔽符号的名字冲突总是在没有发出一个错误的情况下, 以选择遮蔽符号的形式得到解决 (除了一个涉及 import 的例外情况). 见 shadow 和 shadowing-import.

-- 函数 use-package, import, 和 export 检测名字冲突.

-- shadow 和 shadowing-import 从不发出一个名字冲突的错误.

-- unuse-package 和 unexport 不需要去做任何名字冲突的检测. unintern 只有在一个被解除捕捉[uninterned]的符号[symbol]是一个遮蔽符号[shadowing symbol]时执行名字冲突检测.

-- 给 unintern 传递一个遮蔽符号可以发现一个之前通过遮蔽解决的名字冲突.

-- 包函数在对包结构做任何改动之前发出一个 package-error 类型[type]的名称冲突错误. 当需要进行多次更改时, 允许具体实现分别处理每一个更改. 比如, 当 export 给定一个符号[symbol]的列表[list]时, 从列表[list]中第二个符号[symbol]导致的名字冲突终止可能仍然会导出这个列表[list]的第一个符号[symbol]. 然而, 一个由单个符号的 export 导致的名字冲突错误会在在任何包[package]中那个符号[symbol]的可访问性[accessibility]被改变之前被发出.

-- 从一个名字冲突错误中的继续必须为用户提供一个机会去选择任意一个候选符号来解决名字冲突. 包[package]结构应该通过 shadowing-import, unintern, 或 unexport 被修改, 以反映名字冲突的解决方案.

-- 这个 use-package 中, 出现[present]在使用的包[package]中的符号[symbol]和被使用包中的外部符号[external symbol]之间的名字冲突, 通过使第一个符号[symbol]变为遮蔽符号[symbol]进而选择第一个符号或者通过从使用的包[package]中解绑第一个符号[symbol]进而选择第二个符号[symbol]来解决.

-- 在 export 或 unintern 中由于一个包[package]从两个其他包[package]中继承相同[same]名字[name] (在 string= 下)的不同[dictinct]符号[symbol]而导致的一个名字冲突, 可以通过把任意一个符号[symbol]导入到使用的包[package]中并且使它成为一个遮蔽符号[shadowing symbol]来解决, 就像使用 use-package 一样. 

### 11.1.2 <span id="StandardizedPackages">标准包</span>

这个章节描述了在每个符合规范的实现[conforming implementation]中都是可用的包[package]. 下面这段中提供了这些标准[standardized]包[package]的名字[name]和别名[nickname]的汇总.

    名称              别名  
    COMMON-LISP       CL         
    COMMON-LISP-USER  CL-USER    
    KEYWORD           none       

    Figure 11-2. 标准包名称

> * 11.1.2.1 [COMMON-LISP 包](#COMMON-LISP-Package)
> * 11.1.2.2 [COMMON-LISP-USER 包](#COMMON-LISP-USER-Package)
> * 11.1.2.3 [KEYWORD 包](#KEYWORD-Package)
> * 11.1.2.4 [依赖于具体实现的包](#Implementation-Defined-Packages)

#### 11.1.2.1 <span id="COMMON-LISP-Package">COMMON-LISP 包</span>

这个 COMMON-LISP 包包含了这个规范定义的 Common Lisp 系统的基础. 它的外部符号[external symbol]包含了出现在 Common Lisp 系统中的所有已定义的名字[defined name] (除了 KEYWORD 包中已定义的名字[defined name]外), 例如 car, cdr, \*package\*, 等等. 这个 COMMON-LISP 有着别名[nickname] CL.

这个 COMMON-LISP 包有着章节 1.9 (COMMON-LISP 包中的符号) 中枚举的那些外部符号[external symbol], 没有其他的. 这些外部符号[external symbol]出现[present]在 COMMON-LISP 包中但是它们的 home 包[home package]不需要是 COMMON-LISP 包.

比如, 符号 HELP 不能是 COMMON-LISP 包的一个外部符号[external symbol]因为它没有在章节 1.9 (COMMON-LISP 包中的符号) 中被提及. 与此相反, 符号[symbol] variable 必须是 COMMON-LISP 包的一个外部符号[external symbol]即便它没有定义, 因为它在那个章节中被列出来了 (为了支持它作为给函数[function] documentation 的第二个有效实参[argument]的使用).

这个 COMMON-LISP 包有着额外的内部符号[internal symbol].


##### 11.1.2.1.1 符合规范的具体实现的 COMMON-LISP 包的约束

在一个符合规范的具体实现[conforming implementation]中, 这个 COMMON-LISP 包的一个外部符号[external symbol]可以有一个函数[function], 宏[macro], 或者特殊操作符[special operator]定义, 一个全局变量[global variable]定义 (或者由于一个 special 公告[proclamation]作为一个动态变量[dynamic variable]的其他状态), 或者只有在这个标准中显式允许时可以是一个类型[type]定义. 比如, fboundp 对于 COMMON-LISP 包的任何不是一个标准[standardized]函数[function], 宏[macro]或特殊操作符[special operator]的名字[name]的外部符号[external symbol]产生[yield] false, 而 boundp 对于 COMMON-LISP 包中的任何不是标准[standardized]全局变量[global variable]名字的外部符号[external symbol]返回 false. 此外, 符合规范的程序[conforming program]可以使用 COMMON-LISP 包的外部符号[external symbol]作为局部词法变量[lexical variable]的名字[name], 并相信这些名字[name]没有被具体实现全局声明为 special, 除非这些符号[symbol]是标准[standardized]全局变量[global variable]的名字[name].

一个符合规范的具体实现[conforming implementation]一定不能用任何标准[standardized]包[package]的外部符号[external symbol]或者 COMMON-LISP-USER 包中可访问[accessible]符号[symbol]作为属性指示符[property indicator]在 COMMON-LISP 包的外部符号[external symbol]上放置任何属性[property].

##### 11.1.2.1.2 符合规范的程序的 COMMON-LISP 包的约束

除了显式允许的地方, 如果在一个 COMMON-LISP 包的外部符号[external symbol]上执行以下任何动作, 后果都是未定义的:

1. 绑定[binding]或修改它的值 (词法地或动态地). (下面记录一些异常情况.)

2. 定义, 解除定义, 或者绑定[binding]它为一个函数[function]. (下面记录一些异常情况.)

3. 定义, 解除定义, 或绑定[binding]它为一个宏[macro]或编译器宏[compiler macro]. (下面记录一些异常情况.)

4. 定义它为一个类型指定符[type specifier] (通过 defstruct, defclass, deftype, define-condition).

5. 定义它为一个结构体 (通过 defstruct).

6. 使用 declaration 全局声明[proclamation]定义它为一个声明[declaration].

7. 定义它为一个符号宏[symbol macro].

8. 修改它的 home 包[home package].

9. 追踪它 (通过 trace).

10. 声明或全局声明它为 special (通过 declare, declaim, 或 proclaim).

11. 声明或全局声明它的 type 或 ftype (通过 declare, declaim, or proclaim). (下面记录一些异常情况.)

12. 从 COMMON-LISP 包中移除它.

13. 为它定义一个 setf 展开器[setf expander] (提供 defsetf 或 define-setf-method).

14. 定义, 解除定义, 或绑定它的 setf 函数名[setf function name].

15. 定义它为一个方法组合类型[method combination] (通过 define-method-combination).

16. 使用它作为给 find-class 的 setf 的 class-name 参数.

17. 绑定它为一个捕捉标记[catch tag].

18. 绑定它为一个重启动[restart]名字[name].

19. 为标准[standardized]广义函数[generic function]定义一个当所有实参[argument]都是标准化[standardized]类[class]的直接实例[direct instance]时可应用[applicable]的方法[method].


###### 11.1.2.1.2.1 符合规范的程序的 COMMON-LISP 包的约束的一些异常

如果 COMMON-LISP 包的一个外部符号[external symbol]没有被全局定义为一个标准[standardized]动态变量[dynamic variable]或常变量[constant variable], 那么允许词法上绑定[bind]它并且声明那个绑定[binding]的 type, 并且允许去局部地把它建立[establish]为一个符号宏[symbol macro] (比如, 使用 symbol-macrolet).

除非显式指定, 否则如果一个 COMMON-LISP 包的外部符号[external symbol]被全局定义为一个标准[standardized]动态变量[dynamic variable], 允许去绑定[bind]或赋值[assign]那个动态变量[dynamic variable], 前提是保持这个动态变量的 "值类型(Value Type)" 约束, 并且那个变量[variable]的新值[value]和该变量[variable]声明的目的一致.

如果一个 COMMON-LISP 包的外部符号[external symbol]没有被定义为一个标准[standardized]函数[function], 宏[macro], 或特殊操作符[special operator], 允许词法上把它绑定[bind]为一个函数[function] (比如, 使用 flet), 去声明那个绑定[binding]的 ftype, 并且去追踪(trace)那个绑定[binding] (在提供了执行这个的能力的具体实现中) .

如果一个 COMMON-LISP 包的外部符号[external symbol]没有被定义为一个标准[standardized]函数[function], 宏[macro], 或特殊操作符[special operator], 允许去词法上把它绑定[bind]为一个宏[macro] (比如, 使用 macrolet).

如果一个 COMMON-LISP 包的外部符号[external symbol]没有被定义为一个标准[standardized]函数[function], 宏[macro], 或特殊操作符[special operator], 允许去词法上把它的 setf 函数名[setf function name]绑定[bind]为一个函数[function], 并且去声明那个绑定[binding]的 ftype. 


#### 11.1.2.2 <span id="COMMON-LISP-USER-Package">COMMON-LISP-USER 包</span>

在 Common Lisp 系统启动时, 这个 COMMON-LISP-USER 包是当前包[current package]. 这个包[package]使用[use]了 COMMON-LISP 包. 这个 COMMON-LISP-USER 包有着别名[nickname] CL-USER. 这个 COMMON-LISP-USER 包可以有捕捉在它内部的额外符号; 它可以使用[use]其他具体实现定义[implementation-defined]的包[package]. 


#### 11.1.2.3 <span id="KEYWORD-Package">KEYWORD 包</span>

这个 KEYWORD 包包含了称之为关键字[keyword[1]]的符号[symbol], 通常被用作程序[program]以及它们关联的数据表达式[expression[1]]中的特殊标记.

以一个包标记[package marker]开始的符号[symbol]标记[token]被 Lisp 读取器[Lisp reader]解析为 KEYWORD 包中的符号[symbol]; 见章节 2.3.4 (符号标记). 这使得在不同包[package]中的程序之间进行通信时使用关键字[keyword]变得方便. 比如, 在调用[call]中传递关键字参数[keyword parameter]的机制使用关键字[keywords[1]]来命名相应的实参[argument]; 见章节 3.4.1 (普通 lambda 列表).

在 KEYWORD 包中的符号[symbol]按照定义是 keyword 类型[type]的.


##### 11.1.2.3.1 在 KEYWORD 包中捕捉一个符号

KEYWORD 包的处理方式与其他包[package]不同, 因为一个符号[symbol]被捕捉[interned]到其中时, 会采取特殊的操作. 特别地, 当一个符号[symbol]被捕捉[interned]到 KEYWORD 包中时, 它自动成为一个外部符号[external symbol]并且自动成为一个以它自身作为值[value]的常变量[constant variable]. 

##### 11.1.2.3.2 KEYWORD 包的注意点

一般情况下, 最好将关键字的使用限制在存在要被选择的有限可枚举的名称集合的情况下. 比如, 如果一个亮度切换有两个状态, 它们可能被称作 :on 和 :off.

在这个名称集合不是有限可枚举的情况下 (也就是说, 可能发生名字冲突的情况下) 最好去使用某个不是 KEYWORD 的包中的符号[symbol], 这样冲突自然会被避免. 比如, 一个程序[program]使用一个关键字[keyword[1]]作为属性指示符[property indicator]通常是不明智的, 因为如果这里有另一个程序[program]做了相同的事, 每一个都会把另一个的数据重写掉. 


#### 11.1.2.4 <span id="Implementation-Defined-Packages">依赖于具体实现的包</span>

其他的, 具体实现定义[implementation-defined]的包[package]可能出现在最初的 Common Lisp 环境中.

一个符合规范的具体实现[conforming implementation]的文档建议但不是必须去包含一个最初出现在那个具体实现[implementation]但没有在这个规范中指定的所有包名的列表. (也见函数[function] list-all-packages.) 


## 11.2 <span id="ThePackagesDictionary">包字典</span>

> * [系统类 PACKAGE](#SC-PACKAGE)
> * [函数 EXPORT](#F-EXPORT)
> * [函数 FIND-SYMBOL](#F-FIND-SYMBOL)
> * [函数 FIND-PACKAGE](#F-FIND-PACKAGE)
> * [函数 FIND-ALL-SYMBOLS](#F-FIND-ALL-SYMBOLS)
> * [函数 IMPORT](#F-IMPORT)
> * [函数 LIST-ALL-PACKAGES](#F-LIST-ALL-PACKAGES)
> * [函数 RENAME-PACKAGE](#F-RENAME-PACKAGE)
> * [函数 SHADOW](#F-SHADOW)
> * [函数 SHADOWING-IMPORT](#F-SHADOWING-IMPORT)
> * [函数 DELETE-PACKAGE](#F-DELETE-PACKAGE)
> * [函数 MAKE-PACKAGE](#F-MAKE-PACKAGE)
> * [宏 WITH-PACKAGE-ITERATOR](#M-WITH-PACKAGE-ITERATOR)
> * [函数 UNEXPORT](#F-UNEXPORT)
> * [函数 UNINTERN](#F-UNINTERN)
> * [宏 IN-PACKAGE](#M-IN-PACKAGE)
> * [函数 UNUSE-PACKAGE](#F-UNUSE-PACKAGE)
> * [函数 USE-PACKAGE](#F-USE-PACKAGE)
> * [宏 DEFPACKAGE](#M-DEFPACKAGE)
> * [宏 DO-SYMBOLS, DO-EXTERNAL-SYMBOLS, DO-ALL-SYMBOLS](#M-DS-DES-DAS)
> * [函数 INTERN](#F-INTERN)
> * [函数 PACKAGE-NAME](#F-PACKAGE-NAME)
> * [函数 PACKAGE-NICKNAMES](#F-PACKAGE-NICKNAMES)
> * [函数 PACKAGE-SHADOWING-SYMBOLS](#F-PACKAGE-SHADOWING-SYMBOLS)
> * [函数 PACKAGE-USE-LIST](#F-PACKAGE-USE-LIST)
> * [函数 PACKAGE-USED-BY-LIST](#F-PACKAGE-USED-BY-LIST)
> * [函数 PACKAGEP](#F-PACKAGEP)
> * [变量 *PACKAGE*](#V-PACKAGE)
> * [状况类型 PACKAGE-ERROR](#CT-PACKAGE-ERROR)
> * [函数 PACKAGE-ERROR-PACKAGE](#F-PACKAGE-ERROR-PACKAGE)


### <span id="SC-PACKAGE">系统类 PACKAGE</span>

* 类优先级列表(Class Precedence List):

        package, t

* 描述(Description):

        一个包[package]是一个映射符号[symbol]名称[name]到符号[symbol]的命名空间[namespace]; 见章节 11.1 (包概念).

* 参见(See Also):

        章节 11.1 (包概念), 章节 22.1.3.13 (打印其他对象), 章节 2.3.4 (符号标记) 


### <span id="F-EXPORT">函数 EXPORT</span>

* 语法(Syntax):

        export symbols &optional package => t

* 参数和值(Arguments and Values):

        symbols---一个符号[symbol]列表[list]的标识符[designator].
        package---一个包标识符[package designator]. 默认是当前包[current package].

* 描述(Description):

        export 使一个或多个在这个包 package 中可访问[accessible]的符号 symbol (不管是直接访问还是通过继承的) 变为包 package 的外部符号[external symbol].

        如果这些符号 symbols 中的任何一个已经是包 package 中可访问[accessible]的外部符号[external symbol], export 在那个符号[symbol]上没有效果. 如果那个符号 symbol 是作为一个内部符号出现在包 package 中, 它就被简单地改为外部状态. 如果它通过 use-package 作为一个内部符号[internal symbol]是可访问的[accessible], 它首先被导入到包 package 中, 然后再被导出[exported]. (不管接下来包 package 是否继续使用那个最初继承符号[symbol]的包[package], 这个符号 symbol 接下来都会出现[package]在包 package 中.)

        export 使得这里的每个符号 symbol 对于使用了包 package 的所有包[package]都是可访问的[accessible]. 所有这些包[package]都会检测命名冲突: (export s p) 为每一个在 (package-used-by-list p) 中的包执行 (find-symbol (symbol-name s) q). 注意, 在通常情况下, 一个包的最初定义期间使用 export, package-used-by-list 的结果是 nil 并且名字冲突检测需要的时间忽略不计. 当执行了多次更改时, 比如当提供给 export 这些符号 symbols 的一个列表时, 允许具体实现去单独处理每一个更改, 这样一来除了这个列表中的第一个符号以外, 其他任何符号导致的名字冲突的中止都不会取消这个列表中的第一个符号的导出. 然而, 一个由这些符号 symbols 中的其中一个导致的名字冲突错误的中止不会让那个符号[symbol]对于某些包[package]是可访问的[accessible]但对于其他是不可访问的[inaccessible]; 对于每一个被处理的符号 symbols, export 的表现就好像它是一个原子操作一样.

        在 export 中, 要被导出的符号 symbols 的其中一个和已经出现[present]在会继承那个新导出符号[symbol]的包[package]中的符号[symbol]之间的名字冲突, 可以通过解除捕捉另一个来选择导出的符号[symbol], 或者通过使那个已存在的符号[symbol]变为一个遮蔽符号来选择那个已存在的符号.

* 示例(Examples):

    ```LISP
    (make-package 'temp :use nil) =>  #<PACKAGE "TEMP">
    (use-package 'temp) =>  T
    (intern "TEMP-SYM" 'temp) =>  TEMP::TEMP-SYM, NIL
    (find-symbol "TEMP-SYM") =>  NIL, NIL
    (export (find-symbol "TEMP-SYM" 'temp) 'temp) =>  T
    (find-symbol "TEMP-SYM") =>  TEMP-SYM, :INHERITED
    ```

* 副作用(Side Effects):

        这个包系统被修改.

* 受此影响(Affected By):

        可访问[accessible]的符号[symbol].

* 异常情况(Exceptional Situations): 

        如果这些符号 symbols 中的任何一个在包 package 中是不可访问[accessible], 会发出一个 package-error 类型[type]的错误, 通过允许用户[user]去交互式地指定是否应该导入该符号[symbol], 这是可校正的[correctable].

* 参见(See Also):

        import, unexport, 章节 11.1 (包概念)

* 注意(Notes): None. 


### <span id="F-FIND-SYMBOL">函数 FIND-SYMBOL</span>

* 语法(Syntax):

        find-symbol string &optional package => symbol, status

* 参数和值(Arguments and Values):

        string---一个字符串[string].
        package---一个包标识符[package designator]. 默认是当前包[current package].
        symbol---在包 package 中可访问的一个符号[symbol], 或者 nil.
        status---:inherited, :external, :internal 其中之一, 或 nil.

* 描述(Description):

        find-symbol 在一个包[packge]中查找名称[name]为字符串 string 的符号[symbol]. 如果在包 package 中找到名为字符串 string 的一个符号[symbol], 不管是直接地或是通过继承, 找到的符号会作为第一个值被返回; 第二个值如下:

        :internal

            如果这个符号[symbol]是作为一个内部符号[internal symbol]出现[present]在包 package 中的话.

        :external

            如果这个符号[symbol]是作为一个外部符号[external symbol]出现[present]在包 package 中的话.

        :inherited

            如果这个符号[symbol]是被包 package 通过 use-package 继承而来, 但是不是出现[present]在包 package 中的话.

        如果在包 package 中没有这样的可访问[accessible]的符号[symbol], 两个值都是 nil.

* 示例(Examples):

    ```LISP
    (find-symbol "NEVER-BEFORE-USED") =>  NIL, NIL
    (find-symbol "NEVER-BEFORE-USED") =>  NIL, NIL
    (intern "NEVER-BEFORE-USED") =>  NEVER-BEFORE-USED, NIL
    (intern "NEVER-BEFORE-USED") =>  NEVER-BEFORE-USED, :INTERNAL
    (find-symbol "NEVER-BEFORE-USED") =>  NEVER-BEFORE-USED, :INTERNAL
    (find-symbol "never-before-used") =>  NIL, NIL
    (find-symbol "CAR" 'common-lisp-user) =>  CAR, :INHERITED
    (find-symbol "CAR" 'common-lisp) =>  CAR, :EXTERNAL
    (find-symbol "NIL" 'common-lisp-user) =>  NIL, :INHERITED
    (find-symbol "NIL" 'common-lisp) =>  NIL, :EXTERNAL
    (find-symbol "NIL" (prog1 (make-package "JUST-TESTING" :use '())
                              (intern "NIL" "JUST-TESTING")))
    =>  JUST-TESTING::NIL, :INTERNAL
    (export 'just-testing::nil 'just-testing)
    (find-symbol "NIL" 'just-testing) =>  JUST-TESTING:NIL, :EXTERNAL
    (find-symbol "NIL" "KEYWORD")
    =>  NIL, NIL
    OR=>  :NIL, :EXTERNAL
    (find-symbol (symbol-name :nil) "KEYWORD") =>  :NIL, :EXTERNAL
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        intern, import, export, use-package, unintern, unexport, unuse-package

* 异常情况(Exceptional Situations):  None.

* 参见(See Also):

        intern, find-all-symbols

* 注意(Notes):

        find-symbol 操作上等价于 intern, 除了它从不创建一个新的符号[symbol]. 


### <span id="F-FIND-PACKAGE">函数 FIND-PACKAGE</span>

* 语法(Syntax):

        find-package name => package

* 参数和值(Arguments and Values):

        name---一个字符串标识符[string designator]或者一个包[package]对象[object].
        package---一个包[package]对象[object]或者 nil.

* 描述(Description):

        如果名字 name 是一个字符串标识符[string designator], find-package 查找并返回这个名字或别名为 name 的包[package]. 这个查找是大小写敏感的. 如果这里没有这样的包[package], find-package 返回 nil.

        如果 name 是一个包[package]对象[object], 那么就返回那个包[package]对象[object].

* 示例(Examples):

    ```LISP
    (find-package 'common-lisp) =>  #<PACKAGE "COMMON-LISP">
    (find-package "COMMON-LISP-USER") =>  #<PACKAGE "COMMON-LISP-USER">
    (find-package 'not-there) =>  NIL
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        这个具体实现[implementation]创建的包[package]的集合.

        defpackage, delete-package, make-package, rename-package

* 异常情况(Exceptional Situations):  None.

* 参见(See Also):

        make-package

* 注意(Notes): None. 


### <span id="F-FIND-ALL-SYMBOLS">函数 FIND-ALL-SYMBOLS</span>

* 语法(Syntax):

        find-all-symbols string => symbols

* 参数和值(Arguments and Values):

        string---一个字符串标识符[string designator].
        symbols---一个符号[symbol]列表[list].

* 描述(Description):

        find-all-symbols 在每一个已注册包[registered package]中搜索有着和字符串 string 相同名字[name] (在 string= 下)的符号[symbol]. 返回一个所有这样符号[symbol]的列表[list]. 这个列表[list]是否排序或如何排序是依赖于具体实现的[implementation-dependent].

* 示例(Examples):

    ```LISP
    (find-all-symbols 'car)
    =>  (CAR)
    OR=>  (CAR VEHICLES:CAR)
    OR=>  (VEHICLES:CAR CAR)
    (intern "CAR" (make-package 'temp :use nil)) =>  TEMP::CAR, NIL
    (find-all-symbols 'car)
    =>  (TEMP::CAR CAR)
    OR=>  (CAR TEMP::CAR)
    OR=>  (TEMP::CAR CAR VEHICLES:CAR)
    OR=>  (CAR TEMP::CAR VEHICLES:CAR)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):  None.

* 参见(See Also):

        find-symbol

* 注意(Notes): None. 


### <span id="F-IMPORT">函数 IMPORT</span>

* 语法(Syntax):

        import symbols &optional package => t

* 参数和值(Arguments and Values):

        symbols---一个符号[symbol]列表[list]的标识符[designator].
        package---一个包标识符[package designator]. 默认是当前包[current package].

* 描述(Description):

        import 添加 symbol 或 symbols 到包 package 的内部, 和出现[present]在包 package 中的或者可访问[accessible]的已存在符号[symbol]检查名字冲突. 一旦这些符号 symbols 已经被导入, 在使用 Lisp 读取器[Lisp reader]时, 它们可以在导入的包中被直接引用而不使用包前缀[package prefix].

        在 import 中, 这个要被导入的符号 symbol 和从某个其他包[package]中继承而来的符号之间的名字冲突, 可以通过使这个要被导入的符号 symbol 为遮蔽符号来选择这个要被导入的符号 symbol , 或者不执行这个 import 来选择已经可访问[accessible]的那个符号[symbol]来解决. 在 import 中, 和已经出现[present]在包 package 的符号[symbol]之间的名字冲突可以通过解除捕捉那个符号[symbol]或者不执行这个 import 来解决.

        这个导入的符号[symbol]不会被自动从这个当前包[current package]中导出, 但是如果它已经出现[present]在包中并且是外部的, 那么它是外部的这个事实不会被改变. 如果要被导入的任何符号[symbol]没有 home 包 (也就是说, (symbol-package symbol) => nil), import 会设置这个符号 symbol 的 home 包[home package]为包 package.

        如果这个符号 symbol 已经出现[present]在这个导入的包中, import 就没有效果.

* 示例(Examples):

    ```LISP
    (import 'common-lisp::car (make-package 'temp :use nil)) =>  T
    (find-symbol "CAR" 'temp) =>  CAR, :INTERNAL
    (find-symbol "CDR" 'temp) =>  NIL, NIL 
    ```

        表达式形式 (import 'editor:buffer) 取出 EDITOR 包中名为 buffer 的外部符号 (当这个表达式形式被 Lisp 读取器读取时这个符号会被查找) 并且作为一个内部符号[internal symbol]添加到当前包[current package]中. 然后这个符号 buffer 就会出现[present]在当前包[current package]中.

* 副作用(Side Effects):

        这个包系统会被修改.

* 受此影响(Affected By):

        这个包系统的当前状态.

* 异常情况(Exceptional Situations): 

        如果这些要被导入的符号 symbols 中的任何一个和包 package 中某个已经可以访问[accessible]的不同(在 eql 下)符号[symbol]有着相同[same]的名字[name] (在 string= 下), 那么 import 发出一个 package-error 类型[type]的可校正[correctable]错误, 即便这个冲突是和包 package 中的一个遮蔽符号[shadowing symbol].

* 参见(See Also):

        shadow, export

* 注意(Notes): None. 


### <span id="F-LIST-ALL-PACKAGES">函数 LIST-ALL-PACKAGES</span>

* 语法(Syntax):

        list-all-packages <no arguments> => packages

* 参数和值(Arguments and Values):

        packages---一个包[package]对象[object]列表[list].

* 描述(Description):

        list-all-packages 返回所有已注册包[registered package]的新[fresh]列表[list].

* 示例(Examples):

    ```LISP
    (let ((before (list-all-packages)))
        (make-package 'temp)
        (set-difference (list-all-packages) before)) =>  (#<PACKAGE "TEMP">)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        defpackage, delete-package, make-package

* 异常情况(Exceptional Situations):  None.

* 参见(See Also): None.

* 注意(Notes): None. 


### <span id="F-RENAME-PACKAGE">函数 RENAME-PACKAGE</span>

* 语法(Syntax):

        rename-package package new-name &optional new-nicknames => package-object

* 参数和值(Arguments and Values):

        package---一个包标识符[package designator].
        new-name---一个包标识符[package designator].
        new-nicknames---一个字符串标识符[string designator]列表[list]. 默认是空列表[empty list].
        package-object---重命名的包 package 对象[object].

* 描述(Description):

        替换包 package 的名字和别名. 包 package 的旧名字和所有旧别名会被消除并且被替换为 new-name 和 new-nicknames.

        如果 new-name 或任何 new-nickname 和任何已存在包名冲突, 那么后果是未定义的.

* 示例(Examples):

    ```LISP
    (make-package 'temporary :nicknames '("TEMP")) =>  #<PACKAGE "TEMPORARY">
    (rename-package 'temp 'ephemeral) =>  #<PACKAGE "EPHEMERAL">
    (package-nicknames (find-package 'ephemeral)) =>  ()
    (find-package 'temporary) =>  NIL
    (rename-package 'ephemeral 'temporary '(temp fleeting))
    =>  #<PACKAGE "TEMPORARY">
    (package-nicknames (find-package 'temp)) =>  ("TEMP" "FLEETING")
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):  None.

* 参见(See Also):

        make-package

* 注意(Notes): None. 


### <span id="F-SHADOW">函数 SHADOW</span>

* 语法(Syntax):

        shadow symbol-names &optional package => t

* 参数和值(Arguments and Values):

        symbol-names---一个 string 标识符列表的标识符.
        package---一个包标识符[package designator]. 默认是当前包[current package].

* 描述(Description):

        shadow 确保带有这些符号名 symbol-names 给定的名字的那些符号[symbol]出现在包 package 中.

        特别地, 搜索包 package 中带有那些符号名 symbol-names 中所提供名字[name]的那些符号[symbol]. 对于每一个这样的名字[name], 如果一个对应的符号[symbol]没有出现[present]在包 package 中 (直接地, 或者通过继承), 那么会用这个名字[name]创建一个对应符号[symbol], 并且作为一个内部符号[internal symbol]插入到包 package 中. 这个对应的符号[symbol], 不管是之前存在的或是新创建的, 如果没有出现在那个包 package 中就会被添加到包 package 的遮蔽符号列表[shadowing symbols list]中.

* 示例(Examples):

    ```LISP
    (package-shadowing-symbols (make-package 'temp)) =>  NIL
    (find-symbol 'car 'temp) =>  CAR, :INHERITED
    (shadow 'car 'temp) =>  T
    (find-symbol 'car 'temp) =>  TEMP::CAR, :INTERNAL
    (package-shadowing-symbols 'temp) =>  (TEMP::CAR)

    (make-package 'test-1) =>  #<PACKAGE "TEST-1">
    (intern "TEST" (find-package 'test-1)) =>  TEST-1::TEST, NIL
    (shadow 'test-1::test (find-package 'test-1)) =>  T
    (shadow 'TEST (find-package 'test-1)) =>  T
    (assert (not (null (member 'test-1::test (package-shadowing-symbols
                                                (find-package 'test-1))))))
    
    (make-package 'test-2) =>  #<PACKAGE "TEST-2">
    (intern "TEST" (find-package 'test-2)) =>  TEST-2::TEST, NIL
    (export 'test-2::test (find-package 'test-2)) =>  T
    (use-package 'test-2 (find-package 'test-1))    ;should not error
    ```

* 副作用(Side Effects):

        shadow 以这样一种方式更改包系统的状态, 即包一致性规则在更改期间不保持不变.

* 受此影响(Affected By):

        这个包系统的当前状态.

* 异常情况(Exceptional Situations):  None.

* 参见(See Also):

        package-shadowing-symbols, 章节 11.1 (包概念)

* 注意(Notes):

        如果带有 symbol-names 中的一个名字的符号[symbol]已经存在于包 package 中, 但是是通过继承而来的, 这个继承的符号会被一个新创建的内部符号[internal symbol]所遮蔽[shadow[3]]. 


### <span id="F-SHADOWING-IMPORT">函数 SHADOWING-IMPORT</span>

* 语法(Syntax):

        shadowing-import symbols &optional package => t

* 参数和值(Arguments and Values):

        symbols---一个符号[symbol]列表[list]的标识符[designator].
        package ---一个包标识符[package designator]. 默认是当前包[current package].

* 描述(Description):

        shadowing-import 就像是 import, 但是即便一个符号[symbol]的导入会遮蔽某个在包 package 中已经可访问[accessible]的某个符号[symbol], 它也不会发出一个错误.

        shadowing-import 将这些符号 symbols 中的每一个作为内部符号插入到包 package 中, 不管另一个相同名字的符号[symbol]是否被这个动作遮蔽. 如果一个相同名字的不同符号[symbol]已经出现[present]在包 package 中, 那么该符号[symbol]首先被从包 package 中解除捕捉[uninterned]. 这个新的符号[symbol]会被添加到包 package 的遮蔽符号列表中.

        shadowing-import 对这个范围执行名称冲突检测, 它检测一个相同名字的不同的已存在符号[symbol]是否可访问[accessible]; 如果这样, 它被这个新符号[symbol]所遮蔽, 这意味着如果它出现[present]在包 package 中它必须被解除捕捉.

* 示例(Examples):

    ```LISP
    (in-package "COMMON-LISP-USER") =>  #<PACKAGE "COMMON-LISP-USER">
    (setq sym (intern "CONFLICT")) =>  CONFLICT
    (intern "CONFLICT" (make-package 'temp)) =>  TEMP::CONFLICT, NIL
    (package-shadowing-symbols 'temp) =>  NIL
    (shadowing-import sym 'temp) =>  T 
    (package-shadowing-symbols 'temp) =>  (CONFLICT)
    ```

* 副作用(Side Effects):

        shadowing-import 以这样一种方式更改包系统的状态, 即一致性规则在更改期间不保持不变.

        包 package 的遮蔽符号列表会被修改.

* 受此影响(Affected By):

        这个包系统的当前状态.

* 异常情况(Exceptional Situations):  None.

* 参见(See Also):

        import, unintern, package-shadowing-symbols

* 注意(Notes): None. 


### <span id="F-DELETE-PACKAGE">函数 DELETE-PACKAGE</span>

* 语法(Syntax):

        delete-package package => generalized-boolean

* 参数和值(Arguments and Values):

        package---一个包标识符[package designator].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        delete-package 从所有包系统数据结构中删除包 package. 如果这个操作成功, delete-package 返回 true, 否则就是 nil. 这个 delete-package 的效果是包 package 的名字和别名不再被识别为包名. 这个包对象[object]仍然是个包[package] (换句话说, packagep 对于它是 true 的) 但是 package-name 返回 nil. 删除这个 COMMON-LISP 包或 KEYWORD 包的后果是未定义的. 一旦包 package 被删除, 在这个包上调用任何其他包操作的后果是未指定的. 尤其, 如果在 *package* 被绑定为那个删除的包 package 或者用那个删除的包 package 作为参数的情况下调用 find-symbol, intern 和其他在一个包[package]中查找符号名的函数的后果是未指定的.

        如果包 package 是一个已经被删除的包[package]对象[object], delete-package 立即返回 nil.

        在这个操作完成后, 之前 home 包[home package]为包 package 的符号[symbol]的 home 包[home package]是依赖于具体实现的[implementation-dependent]. 除了这个, 在包 package 中可访问[accessible]的符号[symbol]不会以其他任何方式被修改; home 包[home package]不是包 package 的符号[symbol]保持不变.

* 示例(Examples):

    ```LISP
    (setq *foo-package* (make-package "FOO" :use nil))
    (setq *foo-symbol*  (intern "FOO" *foo-package*))
    (export *foo-symbol* *foo-package*)

    (setq *bar-package* (make-package "BAR" :use '("FOO")))
    (setq *bar-symbol*  (intern "BAR" *bar-package*))
    (export *foo-symbol* *bar-package*)
    (export *bar-symbol* *bar-package*)

    (setq *baz-package* (make-package "BAZ" :use '("BAR")))

    (symbol-package *foo-symbol*) =>  #<PACKAGE "FOO">
    (symbol-package *bar-symbol*) =>  #<PACKAGE "BAR">

    (prin1-to-string *foo-symbol*) =>  "FOO:FOO"
    (prin1-to-string *bar-symbol*) =>  "BAR:BAR"

    (find-symbol "FOO" *bar-package*) =>  FOO:FOO, :EXTERNAL

    (find-symbol "FOO" *baz-package*) =>  FOO:FOO, :INHERITED
    (find-symbol "BAR" *baz-package*) =>  BAR:BAR, :INHERITED

    (packagep *foo-package*) =>  true
    (packagep *bar-package*) =>  true
    (packagep *baz-package*) =>  true

    (package-name *foo-package*) =>  "FOO"
    (package-name *bar-package*) =>  "BAR"
    (package-name *baz-package*) =>  "BAZ"

    (package-use-list *foo-package*) =>  ()
    (package-use-list *bar-package*) =>  (#<PACKAGE "FOO">)
    (package-use-list *baz-package*) =>  (#<PACKAGE "BAR">)

    (package-used-by-list *foo-package*) =>  (#<PACKAGE "BAR">)
    (package-used-by-list *bar-package*) =>  (#<PACKAGE "BAZ">)
    (package-used-by-list *baz-package*) =>  ()

    (delete-package *bar-package*)
    >>  Error: Package BAZ uses package BAR.
    >>  If continued, BAZ will be made to unuse-package BAR,
    >>  and then BAR will be deleted.
    >>  Type :CONTINUE to continue.
    >>  Debug> :CONTINUE
    =>  T

    (symbol-package *foo-symbol*) =>  #<PACKAGE "FOO">
    (symbol-package *bar-symbol*) is unspecified

    (prin1-to-string *foo-symbol*) =>  "FOO:FOO"
    (prin1-to-string *bar-symbol*) is unspecified

    (find-symbol "FOO" *bar-package*) is unspecified

    (find-symbol "FOO" *baz-package*) =>  NIL, NIL
    (find-symbol "BAR" *baz-package*) =>  NIL, NIL

    (packagep *foo-package*) =>  T
    (packagep *bar-package*) =>  T
    (packagep *baz-package*) =>  T

    (package-name *foo-package*) =>  "FOO"
    (package-name *bar-package*) =>  NIL
    (package-name *baz-package*) =>  "BAZ"

    (package-use-list *foo-package*) =>  ()
    (package-use-list *bar-package*) is unspecified
    (package-use-list *baz-package*) =>  ()

    (package-used-by-list *foo-package*) =>  ()
    (package-used-by-list *bar-package*) is unspecified
    (package-used-by-list *baz-package*) =>  ()
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): 

        如果这个 package 标识符[designator]是一个当前没有命名一个包[package]的名字, 就会发出一个 package-error 类型[type]的可校正错误. 如果尝试了校正, 就不会尝试去做删除动作; 反而, delete-package 立即返回 nil.

        如果包 package 被其他包[package]所使用, 就会发出一个 package-error 类型[type]的可校正[correctable]错误. 如果尝试了校正, unuse-package 会被调用来移除任何依赖, 导致包 package 的外部符号[external symbol]对于那些使用了包 package 的包[package]不再是可访问的[accessible]. delete-package 接下来删除包 package, 就好像已经没有包[package]在使用它一样.

* 参见(See Also):

        unuse-package

* 注意(Notes): None. 


### <span id="F-MAKE-PACKAGE">函数 MAKE-PACKAGE</span>

* 语法(Syntax):

        make-package package-name &key nicknames use => package

* 参数和值(Arguments and Values):

        package-name---一个字符串标识符[string designator].
        nicknames---一个字符串标识符[string designator]列表[list]. 默认是空列表[empty list].
        use---一个包标识符[package designator]列表[list]. 默认是具体实现定义的[implementation-defined].
        package---一个包[package].

* 描述(Description):

        创建一个名为 package-name 的新包[package].

        别名 nicknames 是可以被用于引用这个新的包[package]的额外的名字[name].

        这个 use 指定了 0 个或多个包[package], 它们的外部符号[external package]会被这个新包[package]所继承. 见函数[function] use-package.

* 示例(Examples):

    ```LISP
    (make-package 'temporary :nicknames '("TEMP" "temp")) =>  #<PACKAGE "TEMPORARY">
    (make-package "OWNER" :use '("temp")) =>  #<PACKAGE "OWNER">
    (package-used-by-list 'temp) =>  (#<PACKAGE "OWNER">)
    (package-use-list 'owner) =>  (#<PACKAGE "TEMPORARY">)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        在这个系统中其他包[package]的存在.

* 异常情况(Exceptional Situations): 

        如果 use 指定的包[package]不存在, 那么后果是未指定的.

        如果包名 package-name 或这些别名 nicknames 中的任何一个已经是一个已存在的包的包名[name]或别名[nickname]那么就会发出一个可校正[correctable]错误.

* 参见(See Also):

        defpackage, use-package

* 注意(Notes):

        在要被使用的包[package]包含了会冲突的符号的情况下, 有必要先用 :use '() 来创建这个包, 然后使用 shadow 或 shadowing-import 来定位这些冲突, 在这之后一旦这些冲突已经被定位就使用 use-package.

        当要被创建的包是一个程序的静态定义的一部分而不是动态地被程序创建, 在文体上更适合使用 defpackage 而不是 make-package. 


### <span id="M-WITH-PACKAGE-ITERATOR">宏 WITH-PACKAGE-ITERATOR</span>

* 语法(Syntax):

        with-package-iterator (name package-list-form &rest symbol-types) declaration* form*
        => result*

* 参数和值(Arguments and Values):

        name---一个符号[symbol].
        package-list-form---一个表达式形式[form]; 求值一次来产生 package-list.
        package-list---一个包标识符[package designator]列表的标识符[designator].
        symbol-type---符号[symbol] :internal, :external, 或 :inherited 的其中之一.
        declaration---一个 declare 表达式[expression]; 不求值.
        forms---一个隐式 progn [implicit progn].
        results---这些表达式形式 forms 的值[value].

* 描述(Description):

        在这个主体表达式形式 forms 的词法作用域中, 这个名字 name 是通过 macrolet 定义的, 这么一来后续的 (name) 调用会返回一个接一个来自 package-list 中包[package]的符号[symbol].

        从多个包[package]中继承的符号[symbol]是否会被返回不止一次是未指定的. 返回符号[symbol]的顺序没有必要反映 package-list 中包[package]的顺序. 当 package-list 有着不止一个元素时, 重复符号[symbol]会被返回一次还是不止一次是未指定的.

        如下的这些符号类型 symbol-types 控制一个包[package]中可访问[accessible]的哪些符号[symbol]会被返回:

        :internal

            出现[present]在包[package]中但是没有被导出[exported]的符号[symbol].

        :external

            出现[present]在包[package]中并且被导出[exported]的符号[symbol].

        :inherited

            被使用的包[package]导出[exported]并且没有被遮蔽的符号[symbol].

        当为符号类型 symbol-types 提供了超过一个参数时, 如果一个符号[symbol]的可访问性[accessibility]符合提供的其中一个 symbol-type, 它就会被返回. 具体实现可能通过识别额外的符号可访问性类型来扩展这个语法.

        一个 (name) 调用返回如下四个值:

        1. 表示一个符号[symbol]是否被返回的一个标志 (true 表示一个符号[symbol]被返回).
        2. 一个在指定的包[package]中是可访问[accessible]的符号[symbol].
        3. 那个符号[symbol]的可访问性类型; 换句话说, 就是符号 :internal, :external, 或 :inherited 的其中一个.
        4. 这个符号[symbol]所取自的包[package]. 这个包[package]是 package-list 中出现或命名的那些包[package]的其中一个.

        在所有符号[symbol]通过依次调用 (name) 已经被返回后, 然后只有一个值会被返回, 也就是 nil.

        第二, 第三, 和第四个值[value]的意义是, 返回的符号[symbol]在返回的包[package]中是可访问的[accessible], 其方式是由第二个返回值所指示的, 如下所示:

        :internal

            意味着出现[present]但未导出[exported].

        :external

            意味着出现[present]并导出[exported].

        :inherited

            意味着没有出现[present] (因此没有被遮蔽) 但是从某个使用的包[package]中继承.

        如果一个迭代的任何隐式的内部状态在这个 with-package-iterator 表达式形式的动态范围之外被返回, 比如通过在调用表达式形式[form]中返回某个闭包[closure], 那么会发生什么是不确定的.

        任何数量的 with-package-iterator 调用可以被嵌套, 并且最内部的那个的主体可以调用所有这些局部建立的宏[macro], 假设所有这些宏[macro]有着不同的名字.

* 示例(Examples):

        下面函数应该在任何包[package]上都返回 t, 如果这个 with-package-iterator 的使用和对应 do-symbols 的使用不一致就会发出一个错误.

    ```LISP
    (defun test-package-iterator (package)
      (unless (packagep package)
        (setq package (find-package package)))
      (let ((all-entries '())
            (generated-entries '()))
        (do-symbols (x package) 
          (multiple-value-bind (symbol accessibility) 
              (find-symbol (symbol-name x) package)
            (push (list symbol accessibility) all-entries)))
        (with-package-iterator (generator-fn package 
                                :internal :external :inherited)
          (loop     
            (multiple-value-bind (more? symbol accessibility pkg)
                (generator-fn)
              (unless more? (return))
              (let ((l (multiple-value-list (find-symbol (symbol-name symbol) 
                                                          package))))
                (unless (equal l (list symbol accessibility))
                  (error "Symbol ~S not found as ~S in package ~A [~S]"
                          symbol accessibility (package-name package) l))
                (push l generated-entries)))))
        (unless (and (subsetp all-entries generated-entries :test #'equal)
                      (subsetp generated-entries all-entries :test #'equal))
          (error "Generated entries and Do-Symbols entries don't correspond"))
        t))
    ```

        下面函数打印出每个出现[present]的符号[symbol] (可能不止一次):

    ```LISP
    (defun print-all-symbols () 
      (with-package-iterator (next-symbol (list-all-packages)
                              :internal :external)
        (loop
          (multiple-value-bind (more? symbol) (next-symbol)
            (if more? 
                (print symbol)
                (return))))))
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): 

        如果没有提供符号类型 symbol-types 或者提供了一个不被具体实现所识别的符号类型 symbol-type, 那么 with-package-iterator 会发出一个 program-error 类型[type]的错误.

        如果通过 with-package-iterator 建立的名为 name 的局部函数在它返回 false 作为它的主值[primary value]之后被调用, 那么后果是未定义的.

* 参见(See Also):

        章节 3.6 (遍历规则和副作用)

* 注意(Notes): None. 


### <span id="F-UNEXPORT">函数 UNEXPORT</span>

* 语法(Syntax):

        unexport symbols &optional package => t

* 参数和值(Arguments and Values):

        symbols---一个符号[symbol]列表[list]的标识符[designator].
        package---一个包标识符[package designator]. 默认是当前包[current package].

* 描述(Description):

        unexport 复原包 package 中的外部符号 symbols 为内部状态; 它撤销了 export 的效果.

        unexport 只工作在出现[present]在包 package 中的符号[symbol]上, 把它们转换回内部状态. 如果给 unexport 一个已经作为内部符号[internal symbol]出现[present]在包 package 的一个符号[symbol], 它什么都不做.

* 示例(Examples):

    ```LISP
    (in-package "COMMON-LISP-USER") =>  #<PACKAGE "COMMON-LISP-USER">
    (export (intern "CONTRABAND" (make-package 'temp)) 'temp) =>  T
    (find-symbol "CONTRABAND") =>  NIL, NIL 
    (use-package 'temp) =>  T 
    (find-symbol "CONTRABAND") =>  CONTRABAND, :INHERITED
    (unexport 'contraband 'temp) =>  T
    (find-symbol "CONTRABAND") =>  NIL, NIL
    ```

* 副作用(Side Effects):

        包系统会被修改.

* 受此影响(Affected By):

        包系统的当前状态

* 异常情况(Exceptional Situations): 

        如果给 unexport 一个在包 package 中不是可访问[accessible]的符号[symbol], 就会发出一个 package-error 类型[type]的错误.

        如果包 package 是 KEYWORD 包或者 COMMON-LISP 包, 那么后果是未定义的.

* 参见(See Also):

        export, 章节 11.1 (包概念)

* 注意(Notes): None. 


### <span id="F-UNINTERN">函数 UNINTERN</span>

* 语法(Syntax):

        unintern symbol &optional package => generalized-boolean

* 参数和值(Arguments and Values):

        symbol---一个符号[symbol].
        package---一个包标识符[package designator]. 默认是当前包[current package].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        unintern 从包 package 中移除符号 symbol. 如果符号 symbol 出现[present]在包 package 中, 它被从包 package 中被移除并且如果出现在包 package 的遮蔽符号列表[shadowing symbols list]中那么也从其中移除. 如果包 package 是这个符号 symbol 的 home 包[home package], 符号 symbol 会被变成没有 home 包[home package]. 符号 symbol 可能在包 package 中通过继承仍然是可访问的[accessible].

        unintern 的使用可以导致一个没有记录的 home 包[home package]的符号[symbol], 但是事实上在某个包[package]中是可访问的[accessible]. Common Lisp 没有检查这个异常情况, 并且这些符号[symbol]打印的前面总是有 #:.

        如果 unintern 移除了符号 symbol 那么它就返回 true, 否则就是 nil.

* 示例(Examples):

    ```LISP
    (in-package "COMMON-LISP-USER") =>  #<PACKAGE "COMMON-LISP-USER">
    (setq temps-unpack (intern "UNPACK" (make-package 'temp))) =>  TEMP::UNPACK 
    (unintern temps-unpack 'temp) =>  T
    (find-symbol "UNPACK" 'temp) =>  NIL, NIL 
    temps-unpack =>  #:UNPACK 
    ```

* 副作用(Side Effects):

        unintern 以这样一种方式更改包系统的状态, 即一致性规则在更改期间不保持不变.

* 受此影响(Affected By):

        包系统的当前状态

* 异常情况(Exceptional Situations): 

        给 unintern 一个遮蔽符号可以揭露一个之前通过遮蔽解决的名字冲突. 如果包 A 包 B 和 C, A 包含了一个遮蔽符号 x, 并且 B 和 C 每个都包含名为 x 的外部符号, 如果这两个符号[symbol]是不同的, 那么从 A 中移除这个遮蔽的符号会揭露一个在 b:x 和 c:x 之间的名字冲突. 在这个情况中 unintern 会发出一个错误.

* 参见(See Also):

        章节 11.1 (包概念)

* 注意(Notes): None. 


### <span id="M-IN-PACKAGE">宏 IN-PACKAGE</span>

* 语法(Syntax):

        in-package name => package

* 参数和值(Arguments and Values):

        name---一个字符串标识符[string designator]; 不求值.
        package---名为 name 的包[package].

* 描述(Description):

        导致这个名为 name 的包[package]成为当前包[current package]---这也就是说, 成为这个 *package* 的值[value]. 如果不存在这样的包[package], 那么就会发出一个 package-error 类型[type]的错误.

        如果这个 in-package 调用作为顶层表达式形式[top level form]出现, 那么 in-package 做的所有事也都在编译时执行.

* 示例(Examples): None.

* 副作用(Side Effects):

        变量[variable] *package* 会被赋值. 如果这个 in-package 表达式形式[form]是一个顶层表达式形式[top level form], 这个赋值也会在编译时发生.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): 

        如果这个指定的包[package]不存在, 就会发出一个 package-error 类型[type]的错误.

* 参见(See Also):

        *package*

* 注意(Notes): None. 


### <span id="F-UNUSE-PACKAGE">函数 UNUSE-PACKAGE</span>

* 语法(Syntax):

        unuse-package packages-to-unuse &optional package => t

* 参数和值(Arguments and Values):

        packages-to-unuse---一个包标识符[package designator]列表[list]的标识符[designator].
        package---一个包标识符[package designator]. 默认是当前包[current package].

* 描述(Description):

        unuse-package 导致包 package 不再从包 packages-to-unuse 中继承所有外部符号[external symbol]; unuse-package 撤销 use-package 的效果. 包 packages-to-unuse 从包 package 的使用列表[use list]中被移除.

        任何已经被导入到包 package 中的符号[symbol]仍然会出现[present]在包 package 中.

* 示例(Examples):

    ```LISP
    (in-package "COMMON-LISP-USER") =>  #<PACKAGE "COMMON-LISP-USER">
    (export (intern "SHOES" (make-package 'temp)) 'temp) =>  T
    (find-symbol "SHOES") =>  NIL, NIL
    (use-package 'temp) =>  T
    (find-symbol "SHOES") =>  SHOES, :INHERITED
    (find (find-package 'temp) (package-use-list 'common-lisp-user)) =>  #<PACKAGE "TEMP">
    (unuse-package 'temp) =>  T
    (find-symbol "SHOES") =>  NIL, NIL
    ```

* 副作用(Side Effects):

        包 package 的使用列表[use list]会被修改.

* 受此影响(Affected By):

        包系统的当前状态

* 异常情况(Exceptional Situations):  None.

* 参见(See Also):

        use-package, package-use-list

* 注意(Notes): None. 


### <span id="F-USE-PACKAGE">函数 USE-PACKAGE</span>

* 语法(Syntax):

        use-package packages-to-use &optional package => t

* 参数和值(Arguments and Values):

        packages-to-use---一个包标识符[package designator]列表[list]的标识符[designator]. 不能提供这个 KEYWORD 包.
        package---一个包标识符[package designator]. 默认是当前包[current package]. 这个包不能是 KEYWORD 包.

* 描述(Description):

        use-package 导致包 package 去继承包列表 packages-to-use 的所有外部符号[external symbol]. 这些继承的符号[symbol]成为包 package 中可访问[accessible]的内部符号[internal symbol].

        如果 packages-to-use 还没有出现在包 package 的使用列表[use list]中, 那么它会被添加到包 package 的使用列表[use list]中. 在 packages-to-use 中的所有外部符号[external symbol]都成为包 package 中可访问[accessible]的内部符号[internal symbol]. use-package 不会导致任何新的符号[symbol]出现[present]在包 package 中但是通过继承会使它们变为可访问的[accessible].

        use-package 检测那些新导入符号和包 package 中已经可访问[accessible]的符号之间的名字冲突. 在 use-package 中的两个被包 package 从 packages-to-use 继承而来的外部符号之间的一个名字冲突可以通过导入它们中的其中一个符号到包 package 中并使它成为一个遮蔽符号进而选择该符号[symbol]来解决.

* 示例(Examples):

    ```LISP
    (export (intern "LAND-FILL" (make-package 'trash)) 'trash) =>  T
    (find-symbol "LAND-FILL" (make-package 'temp)) =>  NIL, NIL
    (package-use-list 'temp) =>  (#<PACKAGE "TEMP">)
    (use-package 'trash 'temp) =>  T
    (package-use-list 'temp) =>  (#<PACKAGE "TEMP"> #<PACKAGE "TRASH">)
    (find-symbol "LAND-FILL" 'temp) =>  TRASH:LAND-FILL, :INHERITED
    ```

* 副作用(Side Effects):

        包 package 的使用列表[use list]会被修改.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):  None.

* 参见(See Also):

        unuse-package, package-use-list, 章节 11.1 (包概念)

* 注意(Notes):

        即便一个包[package] P2 已经使用[use]了包[package] P1, 仍然允许 P1 去使用[use] P2. 包[package]的使用不会被传递, 所以这个明显的循环不会导致问题. 


### <span id="M-DEFPACKAGE">宏 DEFPACKAGE</span>

* 语法(Syntax):

        defpackage defined-package-name [[option]] => package

        option::= (:nicknames nickname*)* |  
                  (:documentation string) |  
                  (:use package-name*)* |  
                  (:shadow {symbol-name}*)* |  
                  (:shadowing-import-from package-name {symbol-name}*)* |  
                  (:import-from package-name {symbol-name}*)* |  
                  (:export {symbol-name}*)* |  
                  (:intern {symbol-name}*)* |  
                  (:size integer) 

* 参数和值(Arguments and Values):

        defined-package-name---一个字符串标识符[string designator].
        package-name---一个包标识符[package designator].
        nickname---一个字符串标识符[string designator].
        symbol-name---一个字符串标识符[string designator].
        package---名为 package-name 的包[package].

* 描述(Description):

        defpackage 按照指定创建一个包[package]并且返回这个包[package].

        如果 defined-package-name 已经引用了一个已存在的包[package], 该名字的名字到包的映射不会被改变. 如果新的定义与该包[package]的当前状态不一致, 后果是未定义的; 一个具体实现可能选择去修改这个已存在的包[package]来反映这个新的定义. 如果 defined-package-name 是一个符号[symbol], 就使用它的名字[name].

        标准的选项在下面描述.

        :nicknames

            给 :nicknames 的参数设置这个包[package]的别名为提供的这个名字.

        :documentation

            给 :documentation 的参数指定一个文档字符串[documentation string]; 它会作为一个文档字符串[documentation string]附加给这个包[package]. 在单独的 defpackage 表达式形式[form]中最多出现一个 :documentation 选项.

        :use

            给 :use 的参数设置名为 package-name 的包[package]会继承的那些包[package]. 如果没有提供 :use, 默认是和给 make-package 的 :use 实参[argument]一样的依赖于具体实现[implementation-dependent]的值.

        :shadow

            给 :shadow 的参数, symbol-names, 命名要被定义的包[package]中要被创建的符号[symbol]. 事实上这些符号[symbol]会被添加到遮蔽符号[symbol]的列表中, 就像是通过 shadow 一样.

        :shadowing-import-from

            由参数 symbol-names 命名的符号[symbol]会在指定的 package-name 中被查找 (涉及到一个查找, 就像是通过 find-symbol 一样). 产生的符号[symbol]会被导入到要被定义的包[package]中, 然后放置到遮蔽符号列表中, 就像是通过 shadowing-import. 符号[symbol]不会创建在除了要被定义的包以外的任何包[package]中.

        :import-from

            由参数 symbol-names 命名的符号[symbol]会在名为 package-name 的包[package]中被查找并且导入到要被定义的包[package]中. 符号[symbol]不会创建在除了要被定义的包以外的任何包[package]中.

        :export

            由参数 symbol-names 命名的那些符号[symbol]会在要被定义的包[package]中被找到或创建并导出[exported]. 这个 :export 选项和 :use 选项相互作用, 因为继承的符号[symbol]可以被使用而不是新创建一个. 这个 :export 选项和 :import-from 还有 :shadowing-import-from 选项相互作用, 因为导入的符号可以被使用而不是新创建一个. 如果给 :export 选项的一个参数是通过 use-package 作为一个 (继承的) 内部符号[internal symbol]是可访问的[accessible], 那么这个名为 symbol-name 的符号[symbol]首先被导入到这个要被定义的包[package]中, 然后从那个包[package]中导出[exported].

        :intern

            由参数 symbol-names 命名的符号[symbol]会在那个要被定义的包[package]中被找到或创建. 这个 :intern 选项和 :use 选项相互作用, 因为可以使用继承的符号[symbol]而不是新创建一个.

        :size

            给 :size 选项的参数声明了期望出现在那个包[package]中的符号[symbol]的近似数量. 这只是一个效率暗示, 可能被一个具体实现所忽略.

        这些选项出现在一个 defpackage 表达式形式中的顺序是不相关的. 它们被执行的顺序如下所述:

        1. :shadow 和 :shadowing-import-from.
        2. :use.
        3. :import-from 和 :intern.
        4. :export.

        首先确立遮蔽, 因为在 :use 选项被处理时它们可能是阻止虚假名字冲突的必要条件. 这个 :use 选项接下来被执行, 这样一来 :intern 和 :export 选项可以正常引用继承的符号[symbol]. 这个 :export 选项最后执行, 这样一来它可以引用任何其他选项创建的符号[symbol]; 特别地, 遮蔽符号[shadowing symbol]和导入符号[symbol]可以变为外部的.

        如果一个 defpackage 表达式形式[form]作为一个顶层表达式形式[top level form]出现, 这个宏[macro]在加载时正常执行的所有动作在编译时也必须执行.

* 示例(Examples):

    ```LISP
    (defpackage "MY-PACKAGE"
      (:nicknames "MYPKG" "MY-PKG")
      (:use "COMMON-LISP")
      (:shadow "CAR" "CDR")
      (:shadowing-import-from "VENDOR-COMMON-LISP"  "CONS")
      (:import-from "VENDOR-COMMON-LISP"  "GC")
      (:export "EQ" "CONS" "FROBOLA")
      )
    
    
    (defpackage my-package
      (:nicknames mypkg :MY-PKG)  ; remember Common Lisp conventions for case
      (:use common-lisp)          ; conversion on symbols
      (:shadow CAR :cdr #:cons)                              
      (:export "CONS")            ; this is the shadowed one.
      )
    ```

* 受此影响(Affected By):

        已存在的包[package].

* 异常情况(Exceptional Situations): 

        如果提供的其中一个 :nicknames 已经引用了一个已存在的包[package], 就会发出一个 package-error 类型[type]的错误.

        如果 :size 或 :documentation 出现不止一次, 就会发出一个 package-error 类型[type]的错误.

        由于具体实现[implementation]可能允许去扩展选项 options, 如果一个出现的选项事实上不被主机的具体实现[implementation]所支持, 就会发出一个 program-error 类型[type]的错误.

        给选项 :shadow, :intern, :import-from, 和 :shadowing-import-from 的 symbol-name 参数集合必须是互斥的; 另外, 提供给 :export 和 :intern 的 symbol-name 参数也必须互斥. 在这个上下文中的互斥被定义为 symbol-names 中没有任何两个是 string= 的. 如果违反, 就会发出一个 program-error 类型[type]的错误.

        对于 :shadowing-import-from 和 :import-from 选项, 如果在由 package-name 命名的包[package]中对于参数 symbol-names 的其中一个没有可访问[accessible]的符号[symbol], 就会发出一个 program-error 类型[type]的可校正[correctable]错误[error].

        名字冲突错误会被 make-package, use-package, import, 和 export 的潜在调用所处理. 见章节 11.1 (包概念).

* 参见(See Also):

        documentation, 章节 11.1 (包概念), 章节 3.2 (编译)

* 注意(Notes):

        如果后续对 defpackage 的一个调用中(对于某个其他包[package])的 :import-from 或者 :shadowing-import-from 选项期望去找到这些可访问[accessible]的但没必要是外部的符号[symbol], 那么 :intern 选项是很有用的.

        建议整个包[package]定义放在一个单独的地方, 并且一个程序中所有的包[package]定义放在一个单独文件中. 这个文件在加载或编译任何其他依赖这些包[package]的东西之前被加载. 这样一个文件可以在 COMMON-LISP-USER 包中被读取, 避免任何初始化状态的问题.

        defpackage 不能用于创建两个 "相互递归" 的包, 比如:

        (defpackage my-package
          (:use common-lisp your-package)    ;requires your-package to exist first
          (:export "MY-FUN"))                
        (defpackage your-package
          (:use common-lisp)
          (:import-from my-package "MY-FUN") ;requires my-package to exist first
          (:export "MY-FUN"))

        然而, 没有措施可以在一个比较标准的 defpackage 的使用后阻止用户去使用一些包影响的函数去建立这样的联系, 例如 use-package, import, 和 export.

        这个 defpackage 的宏展开可以有效地把这些名字规范化为字符串[string], 这样一来即便一个源代码文件中的这个 defpackage 表达式形式有着随机的符号[symbol], 编译后的文件也只会包含字符串[string].

        依赖于具体实现[implementation-dependent]的额外选项经常接收一个由关键字[keyword]自身表示的关键字表达式形式作为列表 (keyword T) 的缩写; 这个语法在不支持它的具体实现中应该被报告为一个不识别选项. 


### <span id="M-DS-DES-DAS">宏 DO-SYMBOLS, DO-EXTERNAL-SYMBOLS, DO-ALL-SYMBOLS</span>

* 语法(Syntax):

        do-symbols (var [package [result-form]]) declaration* {tag | statement}*
        => result*

        do-external-symbols (var [package [result-form]]) declaration* {tag | statement}*
        => result*

        do-all-symbols (var [result-form]) declaration* {tag | statement}*
        => result*

* 参数和值(Arguments and Values):

        var---一个变量[variable]名[name]; 不求值.
        package---一个包标识符[package designator]; 求值. 在 do-symbols 和 do-external-symbols 中默认为当前包[current package].
        result-form---一个表达式形式[form]; 按如下所述求值. 默认为 nil.
        declaration---一个 declare 表达式[expression]; 不求值.
        tag---一个 go 标签[go tag]; 不求值.
        statement---一个复合表达式形式[compound form]; 按如下所述求值.
        results---如果发生了正常返回[normal return], 就是 result-form 返回的值[value], 否则如果发生一个显式返回[explicit return], 就是传递的那些值[value].

* 描述(Description):

        do-symbols, do-external-symbols, 和 do-all-symbols 遍历包[package]中的符号[symbol]. 对于每一个选择的包[package]集合中的符号[symbol], 这个 var 都会被绑定为那个符号[symbol], 然后在主体中的那些语句 statements 会被执行. 当所有符号[symbol]都已经被处理时, result-form 被求值并且并且作为这个宏的值被返回.

        do-symbols 遍历包 package 中可访问[accessible]的符号[symbol]. 对于从多个包[package]中继承的符号[symbol], 语句 statements 可能被执行不止一次.

        do-all-symbols 在每个已注册的包[registered package]上遍历. do-all-symbols 不会处理每个符号[symbol], 因为一个在任何已注册的包[registered package]中都不是可访问[accessible]的符号[symbol]不会被处理. do-all-symbols 可能导致一个出现[present]在多个包[package]中的符号[symbol]被处理不止一次.

        do-external-symbols 遍历包 package 中的外部符号.

        当 result-form 被求值时, var 被绑定并且值为 nil.

        一个名为 nil 的隐式语句块[implicit block]在整个 do-symbols, do-external-symbols, 或 do-all-symbols 表达式形式[form]周围. return 或 return-from 可能被用于提前终止这个迭代.

        如果主体的执行影响了被包含在正在被迭代的包[package]的集合中的符号[symbol], 除了使用 unintern 去移除 var 当前的值的符号[symbol]之外, 后果是未定义的.

        对于这些宏中的每一个, 名称绑定的作用域[scope]不包括任何初始值表达式形式, 但是包括了那个可选的结果表达式形式.

        在主体中的任何 tag 都和 tagbody 中一样被对待.

* 示例(Examples):

    ```LISP
    (make-package 'temp :use nil) =>  #<PACKAGE "TEMP">
    (intern "SHY" 'temp) =>  TEMP::SHY, NIL ;SHY will be an internal symbol
                                            ;in the package TEMP
    (export (intern "BOLD" 'temp) 'temp)  =>  T  ;BOLD will be external  
    (let ((lst ()))
      (do-symbols (s (find-package 'temp)) (push s lst))
      lst)
    =>  (TEMP::SHY TEMP:BOLD)
    OR=>  (TEMP:BOLD TEMP::SHY)
    (let ((lst ()))
      (do-external-symbols (s (find-package 'temp) lst) (push s lst))
      lst) 
    =>  (TEMP:BOLD)
    (let ((lst ()))                                                     
      (do-all-symbols (s lst)
        (when (eq (find-package 'temp) (symbol-package s)) (push s lst)))
      lst)
    =>  (TEMP::SHY TEMP:BOLD)
    OR=>  (TEMP:BOLD TEMP::SHY)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):  None.

* 参见(See Also):

        intern, export, 章节 3.6 (遍历规则和副作用)

* 注意(Notes): None. 


### <span id="F-INTERN">函数 INTERN</span>

* 语法(Syntax):

        intern string &optional package => symbol, status

* 参数和值(Arguments and Values):

        string---一个字符串[string].
        package---一个包指示符[package designator]. 默认为当前包[current package].
        symbol---一个符号[symbol].
        status---:inherited, :external, :internal, 或者 nil 的其中之一.

* 描述(Description):

        intern 把一个名为字符串 string 的符号[symbol]输入到包 package 中. 如果一个名字和字符串 string 相同的符号[symbol]在包 package 中已经是可访问[accessible]的了, 就把它返回. 如果在包 package 中没有这样的符号[symbol]可访问[accessible], 那么带有这个给定名字的新的符号[symbol]会被创建并输入到包 package 中作为一个内部符号[internal symbol], 如果包 package 是 KEYWROD 包就作为一个外部符号[external symbol]; 包 package 就成为创建的这个符号[symbol]的 home 包[home package].

        由 intern 返回的第一个值, symbol, 是这个被找到或者被创建的符号[symbol]. 第二个值[secondary value], status, 意义如下:

        :internal

            这个符号[symbol]被找到并且出现[present]在包 package 中作为一个内部符号[internal symbol].

        :external

            这个符号[symbol]被找到并且出现[present]在包 package 中作为一个外部符号[external symbol].

        :inherited

            这个符号[package]被找到并且是通过 use-package 继承而来 (这也意味着这个符号[symbol]是内部的).

        nil

            没有找到之前存在的符号[symbol], 所以创建一个.

        成为这个新符号[symbol]名字[name]的字符串[string]是给定的字符串 string 还是它的一个拷贝是依赖于具体实现的[implementation-dependent]. 在一个新符号[symbol]被创建的情况下, 一旦一个字符串[string]已经被给定作为给 intern 的 string 实参[argument], 如果后面尝试去修改这个字符串[string], 那么后果是未定义的.

* 示例(Examples):

    ```LISP
    (in-package "COMMON-LISP-USER") =>  #<PACKAGE "COMMON-LISP-USER">
    (intern "Never-Before") =>  |Never-Before|, NIL
    (intern "Never-Before") =>  |Never-Before|, :INTERNAL 
    (intern "NEVER-BEFORE" "KEYWORD") =>  :NEVER-BEFORE, NIL
    (intern "NEVER-BEFORE" "KEYWORD") =>  :NEVER-BEFORE, :EXTERNAL
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):  None.

* 参见(See Also):

        find-symbol, read, symbol, unintern, 章节 2.3.4 (符号标记)

* 注意(Notes):

        如果这里已经有一个带有给定名字的可访问[accessible]符号[symbol], intern 不需要去做任何名字冲突检测, 因为它不会创建一个新符号[symbol]. 


### <span id="F-PACKAGE-NAME">函数 PACKAGE-NAME</span>

* 语法(Syntax):

        package-name package => name

* 参数和值(Arguments and Values):

        package---一个包标识符[package designator].
        name---一个字符串[string]或 nil.

* 描述(Description):

        package-name 返回命名这个包 package 的字符串[string], 如果这个包 package 标识符[designator]是一个没有名字包[package]对象[object] (见函数[function] delete-package)就是 nil.

* 示例(Examples):

    ```LISP
    (in-package "COMMON-LISP-USER") =>  #<PACKAGE "COMMON-LISP-USER">
    (package-name *package*) =>  "COMMON-LISP-USER"
    (package-name (symbol-package :test)) =>  "KEYWORD"
    (package-name (find-package 'common-lisp)) =>  "COMMON-LISP"

    (defvar *foo-package* (make-package "FOO"))
    (rename-package "FOO" "FOO0")
    (package-name *foo-package*) =>  "FOO0"
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): 

        如果 package 不是一个包标识符[package designator], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also): None.

* 注意(Notes): None. 


### <span id="F-PACKAGE-NICKNAMES">函数 PACKAGE-NICKNAMES</span>

* 语法(Syntax):

        package-nicknames package => nicknames

* 参数和值(Arguments and Values):

        package---一个包标识符[package designator].
        nicknames---一个字符串[string]列表[list].

* 描述(Description):

        返回包 package 的别名字符串[string]列表[list], 不包括包 package 的名字.

* 示例(Examples):

    ```LISP
    (package-nicknames (make-package 'temporary
                                      :nicknames '("TEMP" "temp")))
    =>  ("temp" "TEMP") 
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): 

        如果 package 不是一个包标识符[package designator], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also): None.

* 注意(Notes): None. 


### <span id="F-PACKAGE-SHADOWING-SYMBOLS">函数 PACKAGE-SHADOWING-SYMBOLS</span>

* 语法(Syntax):

        package-shadowing-symbols package => symbols

* 参数和值(Arguments and Values):

        package---一个包标识符[package designator].
        symbols---一个符号[symbol]列表[list].

* 描述(Description):

        返回一个在包 package 中已经通过 shadow 或 shadowing-import (或等价的 defpackage 选项)被声明为遮蔽符号[shadowing symbol]的符号[symbol]列表[list]. 这个列表[list]中的所有符号[symbol]都出现[present]在这个包 package 中.

* 示例(Examples):

    ```LISP
    (package-shadowing-symbols (make-package 'temp)) =>  ()
    (shadow 'cdr 'temp) =>  T
    (package-shadowing-symbols 'temp) =>  (TEMP::CDR)
    (intern "PILL" 'temp) =>  TEMP::PILL, NIL
    (shadowing-import 'pill 'temp) =>  T
    (package-shadowing-symbols 'temp) =>  (PILL TEMP::CDR)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): 

        如果 package 不是一个包标识符[package designator], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        shadow, shadowing-import

* 注意(Notes):

        这些符号 symbols 的列表是否是新[fresh]的依赖于具体实现[implementation-dependent]. 


### <span id="F-PACKAGE-USE-LIST">函数 PACKAGE-USE-LIST</span>

* 语法(Syntax):

        package-use-list package => use-list

* 参数和值(Arguments and Values):

        package---一个包标识符[package designator].
        use-list---一个包[package]对象[object]的列表[list].

* 描述(Description):

        返回被包 package 使用的其他包[package]的列表[list].

* 示例(Examples):

    ```LISP
    (package-use-list (make-package 'temp)) =>  (#<PACKAGE "COMMON-LISP">)
    (use-package 'common-lisp-user 'temp) =>  T
    (package-use-list 'temp) =>  (#<PACKAGE "COMMON-LISP"> #<PACKAGE "COMMON-LISP-USER">)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): 

        如果 package 不是一个包标识符[package designator], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        use-package, unuse-package

* 注意(Notes): None. 


### <span id="F-PACKAGE-USED-BY-LIST">函数 PACKAGE-USED-BY-LIST</span>

* 语法(Syntax):

        package-used-by-list package => used-by-list

* 参数和值(Arguments and Values):

        package---一个包标识符[package designator].
        used-by-list---一个包[package]对象[object]的列表[list].

* 描述(Description):

        package-used-by-list 返回其他使用包 package 的包[package]的列表[list].

* 示例(Examples):

    ```
    (package-used-by-list (make-package 'temp)) =>  ()
    (make-package 'trash :use '(temp)) =>  #<PACKAGE "TRASH">
    (package-used-by-list 'temp) =>  (#<PACKAGE "TRASH">)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): 

        如果 package 不是一个包标识符[package designator], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        use-package, unuse-package

* 注意(Notes): None. 


### <span id="F-PACKAGEP">函数 PACKAGEP</span>

* 语法(Syntax):

        packagep object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义的 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 package 类型[type]的就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (packagep *package*) =>  true 
    (packagep 'common-lisp) =>  false 
    (packagep (find-package 'common-lisp)) =>  true 
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):  None.

* 参见(See Also): None.

* 注意(Notes):

        (packagep object) ==  (typep object 'package)


### <span id="V-PACKAGE">变量 *PACKAGE*</span>

* 值类型(Value Type):

        一个包[package]对象[object].

* 初始值(Initial Value):

        COMMON-LISP-USER 包.

* 描述(Description):

        不管哪个包[package]对象[object]当前是 *package* 的值[value], 都会被引用作为当前包[current package].

* 示例(Examples):

    ```LISP
    (in-package "COMMON-LISP-USER") =>  #<PACKAGE "COMMON-LISP-USER">
    *package* =>  #<PACKAGE "COMMON-LISP-USER">
    (make-package "SAMPLE-PACKAGE" :use '("COMMON-LISP"))
    =>  #<PACKAGE "SAMPLE-PACKAGE">
    (list 
      (symbol-package
        (let ((*package* (find-package 'sample-package)))
          (setq *some-symbol* (read-from-string "just-testing"))))
      *package*)
    =>  (#<PACKAGE "SAMPLE-PACKAGE"> #<PACKAGE "COMMON-LISP-USER">)
    (list (symbol-package (read-from-string "just-testing"))
          *package*)
    =>  (#<PACKAGE "COMMON-LISP-USER"> #<PACKAGE "COMMON-LISP-USER">)
    (eq 'foo (intern "FOO")) =>  true
    (eq 'foo (let ((*package* (find-package 'sample-package)))
                (intern "FOO")))
    =>  false
    ```

* 受此影响(Affected By):

        load, compile-file, in-package

* 参见(See Also):

        compile-file, in-package, load, package

* 注意(Notes): None. 


### <span id="CT-PACKAGE-ERROR">状况类型 PACKAGE-ERROR</span>

* 类优先级列表(Class Precedence List):

        package-error, error, serious-condition, condition, t

* 描述(Description):

        这个 package-error 类型[type]由在包[package]上的操作相关的错误[error]状况[condition]组成. 这个违规的包[package] (或者包[package]名[name]) 是通过给 make-condition 的 :package 初始化参数来初始化的, 并且可以通过函数[function] package-error-package 来访问.

* 参见(See Also):

        package-error-package, 章节 9 (状况) 


### <span id="F-PACKAGE-ERROR-PACKAGE">函数 PACKAGE-ERROR-PACKAGE</span>

* 语法(Syntax):

        package-error-package condition => package

* 参数和值(Arguments and Values):

        condition---一个 package-error 类型[type]的状况[condition].
        package---一个包标识符[package designator].

* 描述(Description):

        返回这个状况 condition 表示的情况[situation]中出问题的包[package]的标识符[designator].

* 示例(Examples):

    ```LISP
    (package-error-package 
      (make-condition 'package-error
        :package (find-package "COMMON-LISP")))
    =>  #<Package "COMMON-LISP">
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):  None.

* 参见(See Also):

        package-error

* 注意(Notes): None. 


# 12. 数字

> * 12.1 [数字的概念](#NumberConcepts)
> * 12.2 [数字的字典](#NumbersDictionary)

## 12.1 <span id="NumberConcepts">Number Concepts</span>

> * 12.1.1 [数值运算](#NumericOperations)
> * 12.1.2 [依赖于具体实现的数字常量](#IDNumericConstants)
> * 12.1.3 [有理数计算](#RationalComputations)
> * 12.1.4 [浮点计算](#FloatingPointComputations)
> * 12.1.5 [复数计算](#ComplexComputations)
> * 12.1.6 [区间标识符](#IntervalDesignators)
> * 12.1.7 [随机状态运算](#RandomStateOperations)

### 12.1.1 <span id="NumericOperations">数值运算</span>

Common Lisp 提供了大量和数字[number]相关的操作. 这个章节通过把这些操作分组成类别来强调它们之间的关系进而提供这些操作的一个综述.

下面这段展示了和算术操作相关的操作符[operator].

    *  1+         gcd   
    +  1-         incf  
    -  conjugate  lcm   
    /  decf             

    Figure 12-1. 算术相关的运算.

下面这段展示了和指数, 对数, 以及三角运算相关的已定义的名字[defined name].

    abs    cos    signum  
    acos   cosh   sin     
    acosh  exp    sinh    
    asin   expt   sqrt    
    asinh  isqrt  tan     
    atan   log    tanh    
    atanh  phase          
    cis    pi             

    Figure 12-2. 指数, 对数, 以及三角运算相关的已定义的名字.

下面这段展示了和数值比较和断言相关的操作符[operator].

    /=  >=      oddp   
    <   evenp   plusp  
    <=  max     zerop  
    =   min            
    >   minusp         

    Figure 12-3. 数值比较和断言相关的操作符.

下面这段展示了和数值类型处理和强制转换相关的已定义的名字[defined name].

    ceiling          float-radix           rational     
    complex          float-sign            rationalize  
    decode-float     floor                 realpart     
    denominator      fround                rem          
    fceiling         ftruncate             round        
    ffloor           imagpart              scale-float  
    float            integer-decode-float  truncate     
    float-digits     mod                                
    float-precision  numerator                          

    Figure 12-4. 数值类型处理和强制转换相关的已定义的名字.

> * 12.1.1.1 [数值运算中的结合律和交换律](#AssociativityCommutativityNO)
> * 12.1.1.2 [数值运算的传递性](#ContagionNumericOperations)
> * 12.1.1.3 [视整数为位和字节](#ViewingIntegersBitsBytes)


#### 12.1.1.1 <span id="AssociativityCommutativityNO">数值运算中的结合律和交换律</span>

对于数学上可结合的 (可能是可交换的) 的函数, 一个符合规范的具体实现[conforming implementation]可以以任何与结合重排 (可能是交换重排) 一致的方式处理实参[argument]. 这个不会影响实参[argument]表达式形式[form]被求值的顺序 ; 关于求值顺序的讨论, 见章节 3.1.2.1.2.3 (函数表达式形式). 唯一不确定的是形参[parameter]的值[value]被处理的顺序. 这个意味着具体实现[implementation]在自动强制转换应用的地方可能不同; 见章节 12.1.1.2 (数值运算的传递性).

一个符合规范的程序[conforming program]可以通过拆分这些操作到分开的(可能是嵌套的)函数表达式形式[function form]中, 或通过显式编写对执行强制转换函数[function]的调用来显式地控制处理的顺序.

##### 12.1.1.1.1 数值运算中的结合律和交换律的示例

思考下面表达式, 其中我们假设 1.0 和 1.0e-15 都表示 single-float:

 (+ 1/3 2/3 1.0d0 1.0 1.0e-15)

一个符合规范的具体实现[conforming implementation]可能从左到右处理这些实参[argument], 首先添加 1/3 和 2/3 来得到 1, 然后把那个转换为一个 double-float 用于和 1.0d0 结合, 接下来依次转换并添加 1.0 和 1.0e-15.

另一个符合规范的具体实现[conforming implementation]可能从右到左处理这些实参[argument], 首先执行 1.0 和 1.0e-15 的一个 single-float 加法 (可能在这个过程中丢失精度), 然后转换这个和为一个 double-float 并且加 1.0d0, 接下来转换 2/3 为一个 double-float 并且加上它, 接着转换 1/3 并且加上它.

第三种符合规范的具体实现[conforming implementation]可能首先扫描所有实参[argument], 处理所有有理数[rational]来保持这个计算准确, 然后在所有实参[argument]中找到一个最大浮点格式的参数并添加, 然后添加所有其他实参[argument], 依次转换它们 (所有这些可能是误导的尝试使计算尽可能准确).

在任何情况下, 这三种策略都是合法的.

一个符合规范的程序[conforming program]可以通过在编写时控制这个顺序, 比如,

 (+ (+ 1/3 2/3) (+ 1.0d0 1.0e-15) 1.0)

#### 12.1.1.2 <span id="ContagionNumericOperations">数值运算的传递性</span>

关于在数值运算中实参[argument]的隐式强制转换的传递性规则的信息, 见章节 12.1.4.4 (浮点精度传递规则), 章节 12.1.4.1 (浮点和有理数传递性的规则), 还有章节 12.1.5.2 (复数传递规则). 

#### 12.1.1.3 <span id="ViewingIntegersBitsBytes">视整数为位和字节</span>

> * 12.1.1.3.1 [整数上的逻辑操作](#LogicalOperationsIntegers)
> * 12.1.1.3.2 [整数上的字节操作](#ByteOperationsIntegers)

##### 12.1.1.3.1 <span id="LogicalOperationsIntegers">整数上的逻辑操作</span>

逻辑运算需要整数[integer]来作为参数; 如果提供一个不是整数[integer]的参数, 那么应该发出一个 type-error 类型[type]的错误. 给逻辑运算的整数[integer]参数被当作是用二补符号表示的.

下面这段展示了和数字上逻辑运算相关的已定义的名字[defined name].

    ash          boole-ior       logbitp   
    boole        boole-nand      logcount  
    boole-1      boole-nor       logeqv    
    boole-2      boole-orc1      logior    
    boole-and    boole-orc2      lognand   
    boole-andc1  boole-set       lognor    
    boole-andc2  boole-xor       lognot    
    boole-c1     integer-length  logorc1   
    boole-c2     logand          logorc2   
    boole-clr    logandc1        logtest   
    boole-eqv    logandc2        logxor    

    Figure 12-5. 数字上逻辑运算相关的已定义的名字. 

##### 12.1.1.3.2 <span id="ByteOperationsIntegers">整数上的字节操作</span>

字节操作函数[function]使用称之为字节指定符[byte specifier]的对象[object]来指定一个整数[integer]内特定字节[byte]的大小和位置. 一个字节指定符[byte specifier]的表示依赖于具体实现[implementation-dependent]; 它可能是也可能不是一个数字[number]. 函数[function] byte 会构造一个字节指定符[byte specifier], 它是各种其他字节操作函数[function]都会接受的.

下面这段展示和操作一个数字[number]的字节[byte]相关的已定义的名字[defined name].

    byte           deposit-field  ldb-test    
    byte-position  dpb            mask-field  
    byte-size      ldb                        

    Figure 12-6. 字节操作相关的已定义的名字. 

### 12.1.2 <span id="IDNumericConstants">依赖于具体实现的数字常量</span>

下面这段展示了和数字[number]的依赖于具体实现[implementation-dependent]的详情相关的已定义名字[defined name].

    double-float-epsilon           most-negative-fixnum           
    double-float-negative-epsilon  most-negative-long-float       
    least-negative-double-float    most-negative-short-float      
    least-negative-long-float      most-negative-single-float     
    least-negative-short-float     most-positive-double-float     
    least-negative-single-float    most-positive-fixnum           
    least-positive-double-float    most-positive-long-float       
    least-positive-long-float      most-positive-short-float      
    least-positive-short-float     most-positive-single-float     
    least-positive-single-float    short-float-epsilon            
    long-float-epsilon             short-float-negative-epsilon   
    long-float-negative-epsilon    single-float-epsilon           
    most-negative-double-float     single-float-negative-epsilon  

    Figure 12-7. 数字的依赖于具体实现的详情相关的已定义名字. 


### 12.1.3 <span id="RationalComputations">有理数计算</span>

这个章节中的规则适用于有理数[rational]计算.

> * 12.1.3.1 [无界的有理数精度规则](#RuleUnboundedRationalPrecision)
> * 12.1.3.2 [有理数的规范表示规则](#RuleCanonicalReprRationals)
> * 12.1.3.3 [浮点的置换性规则](#RuleFloatSubstitutability)

#### 12.1.3.1 <span id="RuleUnboundedRationalPrecision">无界的有理数精度规则</span>

从一般意义上来说有理数计算不可能上溢 (尽管这里可能没有足够的存储来表示一个结果), 因为整数[integer]和比数[ratio]原则上是任意大小的. 

#### 12.1.3.2 <span id="RuleCanonicalReprRationals">有理数的规范表示规则</span>

如果任何计算产生一个结果是两个整数的数学比, 并且分母可以整除分子, 那么这个结果会被转换为等价的整数[integer].

如果分母不能整除分子, 那么一个有理数[rational]的标准表示是分子和分母的比率[ratio], 其中分子和分母最大的公约数是 1 , 并且分母是大于 1 的正数.

当作为一个输入时 (在默认语法中), 符号 -0 总是表示整数[integer] 0. 一个符合规范的具体实现[conforming implementation]一定不能有着与整数 0 的表示不同的"负零"的表示. 但是, 这样的区别对于浮点数[float]也是有可能的; 见类型[type] float. 

#### 12.1.3.3 <span id="RuleFloatSubstitutability">浮点的置换性规则</span>

当一个无理数学函数[function]的参数都是有理数[rational]而真正的数学结果也是(数学上)有理数时, 除非另有说明, 否则一个实现可以自由地返回一个准确的有理数[rational]结果或者一个 single-float 近似值. 如果参数都是有理数[rational]但是结果不能被表示为一个有理数[rational]数字, 那么总是会返回一个 single-float 近似值.

当一个无理数学函数[function]的参数都是类型 (or rational (complex rational)) 并且真正的数学结果是(数学上)一个带有有理数实部和虚部的复数, 除非另有说明, 否则一个具体实现可以自由地返回一个类型 (or rational (complex rational)) 的精准结果或者一个 single-float (只有当真实的数学结果的虚部为零时才允许) 或者 (complex single-float). 如果参数都是类型 (or rational (complex rational)) 但是结果不能被表示为一个有理数[rational]或者复有理数[complex rational], 那么返回值会是 single-float 类型(只有当真实的数学结果的虚部为零时才允许) 或者 (complex single-float).

浮点数置换性不能应用于有理数学函数[function] +, -, *, 和 / 也不能应用于相关操作符[operator] 1+, 1-, incf, decf, 和 conjugate. 对于有理数学函数[function], 如果所有参数都是有理数[rational], 那么结果就是有理数[rational]; 如果所有参数都是类型 (or rational (complex rational)), 那么结果也就是类型 (or rational (complex rational)).

    函数      简单结果                                   
    abs       (abs #c(3 4)) =>  5 or 5.0                       
    acos      (acos 1) =>  0 or 0.0                            
    acosh     (acosh 1) =>  0 or 0.0                           
    asin      (asin 0) =>  0 or 0.0                            
    asinh     (asinh 0) =>  0 or 0.0                           
    atan      (atan 0) =>  0 or 0.0                            
    atanh     (atanh 0) =>  0 or 0.0                           
    cis       (cis 0) =>  1 or #c(1.0 0.0)                     
    cos       (cos 0) =>  1 or 1.0                             
    cosh      (cosh 0) =>  1 or 1.0                            
    exp       (exp 0) =>  1 or 1.0                             
    expt      (expt 8 1/3) =>  2 or 2.0                        
    log       (log 1) =>  0 or 0.0                             
              (log 8 2) =>  3 or 3.0                           
    phase     (phase 7) =>  0 or 0.0                           
    signum    (signum #c(3 4)) =>  #c(3/5 4/5) or #c(0.6 0.8)  
    sin       (sin 0) =>  0 or 0.0                             
    sinh      (sinh 0) =>  0 or 0.0                            
    sqrt      (sqrt 4) =>  2 or 2.0                            
              (sqrt 9/16) =>  3/4 or 0.75                      
    tan       (tan 0) =>  0 or 0.0                             
    tanh      (tanh 0) =>  0 or 0.0                            

    Figure 12-8. 受浮点数置换性规则影响的函数 


### 12.1.4 <span id="FloatingPointComputations">浮点计算</span>

下面规则应用于浮点数计算.

> * 12.1.4.1 [浮点和有理数传递性的规则](#RuleFloatRationalContagion)
> * 12.1.4.2 [浮点近似的规则](#RuleFloatApproximation)
> * 12.1.4.3 [浮点的上溢和下溢规则](#RuleFloatUnderflowOverflow)
> * 12.1.4.4 [浮点精度传递规则](#RuleFloatPrecisionContagion)


#### 12.1.4.1 <span id="RuleFloatRationalContagion">浮点和有理数传递性的规则</span>

当有理数[rational]和浮点数[float]通过一个数值函数进行组合时, 这个有理数[rational]首先被转换为一个相同格式的浮点数[float]. 对于像 + 这样的接受超过两个参数的函数[function], 允许部分操作使用有理数[rational]进行操作, 其余部分则使用浮点运算来完成.

当有理数[rational]和浮点数[float]被一个数值函数进行比较时, 函数[function] rational 会被调用来将这个浮点数[float]转换为一个有理数[rational]然后执行一个准确的比较. 在复数[complex]的情况下, 实部和虚部会被单独处理.

##### 12.1.4.1.1 浮点和有理数传递性的规则的示例

```LISP
;;;; Combining rationals with floats.
;;; This example assumes an implementation in which 
;;; (float-radix 0.5) is 2 (as in IEEE) or 16 (as in IBM/360),
;;; or else some other implementation in which 1/2 has an exact 
;;;  representation in floating point.
(+ 1/2 0.5) =>  1.0
(- 1/2 0.5d0) =>  0.0d0
(+ 0.5 -0.5 1/2) =>  0.5

;;;; Comparing rationals with floats.
;;; This example assumes an implementation in which the default float 
;;; format is IEEE single-float, IEEE double-float, or some other format
;;; in which 5/7 is rounded upwards by FLOAT.
(< 5/7 (float 5/7)) =>  true
(< 5/7 (rational (float 5/7))) =>  true
(< (float 5/7) (float 5/7)) =>  false
```

#### 12.1.4.2 <span id="RuleFloatApproximation">浮点近似的规则</span>

浮点数[float]的计算只是近似的, 尽管它们被描述为结果在数学上是准确的. 两个数学上相同的表达式可能在计算上是不同的因为浮点近似过程中存在固有的错误. 一个浮点数[float]的精度不一定与这个数字的精度相关. 比如, 3.142857142857142857 相比 3.14159 是 <PI> 的一个更精确的近似值, 但是后者更准确. 精度指的是在表示中保留的位元数. 当一个操作符组合一个短浮点数[short float]和一个长浮点数[long float]时, 结果会是一个长浮点数[long float]. Common Lisp 函数假定给它们的参数的准确度不会超过它们的精度. 因此当两个 small float 被组合时, 结果是一个 small float. Common Lisp 函数不会从一个较大的值转换到较小的一个. 


#### 12.1.4.3 <span id="RuleFloatUnderflowOverflow">浮点的上溢和下溢规则</span>

如果一个浮点数运算导致指数上溢或下溢, 就分别会发出一个 floating-point-overflow 或 floating-point-underflow 类型[type]的错误. 


#### 12.1.4.4 <span id="RuleFloatPrecisionContagion">浮点精度传递规则</span>

一个数值函数的结果是给这个函数[function]的所有浮点数参数中最大格式的一个浮点数[float]. 

### 12.1.5 <span id="ComplexComputations">复数计算</span>

以下规则应用于复数[complex]计算:

> * 12.1.5.1 [复数的置换性规则](#RuleComplexSubstitutability)
> * 12.1.5.2 [复数传递规则](#RuleComplexContagion)
> * 12.1.5.3 [复数的正规表示规则](#RuleCanonicalReprComplexRationals)
> * 12.1.5.4 [主值和分支切割](#PrincipalValuesBranchCuts)

#### 12.1.5.1 <span id="RuleComplexSubstitutability">复数的置换性规则</span>

除了在无理和超越函数[function]的执行期间, 除非它的实参[argument]中的一个或多个是复数[complex], 否则数值函数[function]不会产生[yield]一个复数[complex]. 

#### 12.1.5.2 <span id="RuleComplexContagion">复数传递规则</span>

当一个实数[real]和一个复数[complex]都是计算的一部分时, 这个实数[real]首先通过提供一个 0 的虚部来转换为复数[complex]. 

#### 12.1.5.3 <span id="RuleCanonicalReprComplexRationals">复数的正规表示规则</span>

如果任何计算的结果都是一个实部是 rational 类型[type], 虚部是零的复数[complex], 那么结果被转换成这个实部的有理数[rational]. 这个规则不能应用于两个部分都是浮点数[float]的复数[complex]. 比如, #C(5 0) 和 5 在 Common Lisp (它们在 eql 下总是相同的[same]) 中不是不同[different]的对象[object]; #C(5.0 0.0) 和 5.0 在 Common Lisp 中总是为不同[different]的对象[object] (它们在 eql 下总是不相同的, 尽管它们在 equalp 和 = 下是相同的[same]).


##### 12.1.5.3.1 复数的正规表示规则的示例

```LISP
#c(1.0 1.0) =>  #C(1.0 1.0)
#c(0.0 0.0) =>  #C(0.0 0.0)
#c(1.0 1) =>  #C(1.0 1.0)
#c(0.0 0) =>  #C(0.0 0.0)
#c(1 1) =>  #C(1 1)
#c(0 0) =>  0
(typep #c(1 1) '(complex (eql 1))) =>  true
(typep #c(0 0) '(complex (eql 0))) =>  false
```

##### 12.1.5.4 <span id="PrincipalValuesBranchCuts">主值和分支切割</span>

很多无理函数和超越函数在复数领域会被多次定义; 比如, 对于对数函数, 一般来说有无穷多的复数值. 在每个这样的例子中, 必须为这个函数选择一个首要[principal]的值[value]来返回. 通常情况下, 这样的值不能被选择, 从而使范围连续; 在被称为分支切割的区域中, 必须定义分支, 这又定义了范围内的不连续点. Common Lisp 为这些复数函数定义了分支切割, 首要[principal]的值[value], 还有边界状况, 这些函数遵循 "复数 APL 中的主值和分支切割". 适用于每个函数的分支切割规则和那个函数的描述相对应.

下面这段列出了在复数域的适用部分中所遵守的恒等式, 即使是在分支切割上:

    sin i z = i sinh z  sinh i z = i sin z        arctan i z = i arctanh z  
    cos i z = cosh z    cosh i z = cos z          arcsinh i z = i arcsin z  
    tan i z = i tanh z  arcsin i z = i arcsinh z  arctanh i z = i arctan z  

    Figure 12-9. 复数域的三角恒等式

在分支切割的讨论中提到的象限编号如下图所示.

    见 http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_12-1-5-4.html

    Figure 12-10. 分支切割的象限编号

### 12.1.6 <span id="IntervalDesignators">区间标识符</span>

一个数值类型指定符[type specifier]的复合类型指定符[compound type specifier]形式允许用户在实数线上去指定一个描述这个类型[type]的子类型[subtype]的区间, 该类型将由相应的原子类型指定符[atomic type specifier]描述. 某个类型[type] T 的子类型[subtype]是使用称为类型[type] T 的区间标识符[interval designator]的有序对象[object]对指定的.

T 类型[type]的两个区间标识符[interval designator]的第一个可以是以下任意一种:

一个类型[type] T 的数字 N

    这个表示包含 N 的下边界. 这也就是说, T 的子类型[subtype]的元素[element]会大于等于 N.

一个元素[element]为类型[type] T 的数字 M 的单元素[singleton]列表[list]

    这个表示不包含 M 的下边界. 这也就是说, T 的子类型[subtype]的元素[element]会大于 M.

符号 *

    这表示在区间上没有下限.

T 类型[type]的两个区间标识符[interval designator]的第二个可以是以下任意一种:

一个类型[type] T 的数字 N

    这个表示不包含 N 的上边界. 这也就是说, T 的子类型[subtype]的元素[element]会小于等于 N.

一个元素[element]为类型[type] T 的数字 M 的单元素[singleton]列表[list]

    这个表示不包含 M 的上边界. 这也就是说, T 的子类型[subtype]的元素[element]会小于 M.

符号 *

    这表示在区间上没有上限. 


### 12.1.7 <span id="RandomStateOperations">随机状态运算</span>

下面这段列出了可应用于随机状态[random state]的已定义的名字[defined name].

    *random-state*     random            
    make-random-state  random-state-p    

    Figure 12-11. 随机状态已定义的名字 


## 12.2 <span id="NumbersDictionary">数字的字典</span>

> * [系统类 NUMBER](#SC-NUMBER)
> * [系统类 COMPLEX](#SC-COMPLEX)
> * [系统类 REAL](#SC-REAL)
> * [系统类 FLOAT](#SC-FLOAT)
> * [类型 SHORT-FLOAT, SINGLE-FLOAT, DOUBLE-FLOAT, LONG-FLOAT](#T-SF-SF-DF-LF)
> * [系统类 RATIONAL](#SC-RATIONAL)
> * [系统类 RATIO](#SC-RATIO)
> * [系统类 INTEGER](#SC-INTEGER)
> * [类型 SIGNED-BYTE](#T-SIGNED-BYTE)
> * [类型 UNSIGNED-BYTE](#T-UNSIGNED-BYTE)
> * [类型特化符 MOD](#TS-MOD)
> * [类型 BIT](#T-BIT)
> * [类型 FIXNUM](#T-FIXNUM)
> * [类型 BIGNUM](#T-BIGNUM)
> * [函数 =, /=, <, >, <=, >=](#F-Compare)
> * [函数 MAX, MIN](#F-MAX-MIN)
> * [函数 MINUSP, PLUSP](#F-MINUSP-PLUSP)
> * [函数 ZEROP](#Function-ZEROP)
> * [函数 FLOOR, FFLOOR, CEILING, FCEILING, TRUNCATE, FTRUNCATE, ROUND, FROUND](#F-F-F-C-F-T-F-R-F)
> * [函数 SIN, COS, TAN](#F-SIN-COS-TAN)
> * [函数 ASIN, ACOS, ATAN](#F-ASIN-ACOS-ATAN)
> * [常量 PI](#CV-PI)
> * [函数 SINH, COSH, TANH, ASINH, ACOSH, ATANH](#F-S-C-T-A-A-A)
> * [函数 *](#F-Multiply)
> * [函数 +](#F-Add)
> * [函数 -](#F-Sub)
> * [函数 /](#F-Div)
> * [函数 1+, 1-](#F-OP-OI)
> * [函数 ABS](#F-ABS)
> * [函数 EVENP, ODDP](#F-EVENP-ODDP)
> * [函数 EXP, EXPT](#F-EXP-EXPT)
> * [函数 GCD](#F-GCD)
> * [宏 INCF, DECF](#M-INCF-DECF)
> * [函数 LCM](#F-LCM)
> * [函数 LOG](#F-LOG)
> * [函数 MOD, REM](#F-MOD-REM)
> * [函数 SIGNUM](#F-SIGNUM)
> * [函数 SQRT, ISQRT](#F-SQRT-ISQRT)
> * [系统类 RANDOM-STATE](#SC-RANDOM-STATE)
> * [函数 MAKE-RANDOM-STATE](#F-MAKE-RANDOM-STATE)
> * [函数 RANDOM](#F-RANDOM)
> * [函数 RANDOM-STATE-P](#F-RANDOM-STATE-P)
> * [变量 *RANDOM-STATE*](#V-RANDOM-STATE)
> * [函数 NUMBERP](#F-NUMBERP)
> * [函数 CIS](#F-CIS)
> * [函数 COMPLEX](#F-COMPLEX)
> * [函数 COMPLEXP](#F-COMPLEXP)
> * [函数 CONJUGATE](#F-CONJUGATE)
> * [函数 PHASE](#F-PHASE)
> * [函数 REALPART, IMAGPART](#F-REALPART-IMAGPART)
> * [函数 UPGRADED-COMPLEX-PART-TYPE](#F-UPGRADED-COMPLEX-PART-TYPE)
> * [函数 REALP](#F-REALP)
> * [函数 NUMERATOR, DENOMINATOR](#F-NUMERATOR-DENOMINATOR)
> * [函数 RATIONAL, RATIONALIZE](#F-RATIONAL-RATIONALIZE)
> * [函数 RATIONALP](#F-RATIONALP)
> * [函数 ASH](#F-ASH)
> * [函数 INTEGER-LENGTH](#F-INTEGER-LENGTH)
> * [函数 INTEGERP](#F-INTEGERP)
> * [函数 PARSE-INTEGER](#F-PARSE-INTEGER)
> * [函数 BOOLE](#F-BOOLE)
> * [常量 BOOLE-1, BOOLE-2, BOOLE-AND, BOOLE-ANDC1, BOOLE-ANDC2, BOOLE-C1, BOOLE-C2, BOOLE-CLR, BOOLE-EQV, BOOLE-IOR, BOOLE-NAND, BOOLE-NOR, BOOLE-ORC1, BOOLE-ORC2, BOOLE-SET, BOOLE-XOR](#CV-B)
> * [函数 LOGAND, LOGANDC1, LOGANDC2, LOGEQV, LOGIOR, LOGNAND, LOGNOR, LOGNOT, LOGORC1, LOGORC2, LOGXOR](#F-L)
> * [函数 LOGBITP](#F-LOGBITP)
> * [函数 LOGCOUNT](#F-LOGCOUNT)
> * [函数 LOGTEST](#F-LOGTEST)
> * [函数 BYTE, BYTE-SIZE, BYTE-POSITION](#F-BYTE-BYTE-SIZE-BYTE-POSITION)
> * [函数 DEPOSIT-FIELD](#F-DEPOSIT-FIELD)
> * [函数 DPB](#F-DPB)
> * [访问器 LDB](#A-LDB)
> * [函数 LDB-TEST](#F-LDB-TEST)
> * [访问器 MASK-FIELD](#A-MASK-FIELD)
> * [常量 MOST-POSITIVE-FIXNUM, MOST-NEGATIVE-FIXNUM](#CV-MM)
> * [函数 DECODE-FLOAT, SCALE-FLOAT, FLOAT-RADIX, FLOAT-SIGN, FLOAT-DIGITS, FLOAT-PRECISION, INTEGER-DECODE-FLOAT](#F-DSFFFFI)
> * [函数 FLOAT](#F-FLOAT)
> * [函数 FLOATP](#F-FLOATP)
> * [常量 MOST-POSITIVE-SHORT-FLOAT, LEAST-POSITIVE-SHORT-FLOAT, LEAST-POSITIVE-NORMALIZED-SHORT-FLOAT, MOST-POSITIVE-DOUBLE-FLOAT, LEAST-POSITIVE-DOUBLE-FLOAT, LEAST-POSITIVE-NORMALIZED-DOUBLE-FLOAT, MOST-POSITIVE-LONG-FLOAT, LEAST-POSITIVE-LONG-FLOAT, LEAST-POSITIVE-NORMALIZED-LONG-FLOAT, MOST-POSITIVE-SINGLE-FLOAT, LEAST-POSITIVE-SINGLE-FLOAT, LEAST-POSITIVE-NORMALIZED-SINGLE-FLOAT, MOST-NEGATIVE-SHORT-FLOAT, LEAST-NEGATIVE-SHORT-FLOAT, LEAST-NEGATIVE-NORMALIZED-SHORT-FLOAT, MOST-NEGATIVE-SINGLE-FLOAT, LEAST-NEGATIVE-SINGLE-FLOAT, LEAST-NEGATIVE-NORMALIZED-SINGLE-FLOAT, MOST-NEGATIVE-DOUBLE-FLOAT, LEAST-NEGATIVE-DOUBLE-FLOAT, LEAST-NEGATIVE-NORMALIZED-DOUBLE-FLOAT, MOST-NEGATIVE-LONG-FLOAT, LEAST-NEGATIVE-LONG-FLOAT, LEAST-NEGATIVE-NORMALIZED-LONG-FLOAT](#CV-MOST-LEAST)
> * [常量 SHORT-FLOAT-EPSILON, SHORT-FLOAT-NEGATIVE-EPSILON, SINGLE-FLOAT-EPSILON, SINGLE-FLOAT-NEGATIVE-EPSILON, DOUBLE-FLOAT-EPSILON, DOUBLE-FLOAT-NEGATIVE-EPSILON, LONG-FLOAT-EPSILON, LONG-FLOAT-NEGATIVE-EPSILON](#CV-EPSILON)
> * [状况类型 ARITHMETIC-ERROR](#CT-ARITHMETIC-ERROR)
> * [函数 ARITHMETIC-ERROR-OPERANDS, ARITHMETIC-ERROR-OPERATION](#F-AEO-AEO)
> * [状况类型 DIVISION-BY-ZERO](#CT-DIVISION-BY-ZERO)
> * [状况类型 FLOATING-POINT-INVALID-OPERATION](#CT-FLOATING-POINT-INVALID-OPERATION)
> * [状况类型 FLOATING-POINT-INEXACT](#CT-FLOATING-POINT-INEXACT)
> * [状况类型 FLOATING-POINT-OVERFLOW](#CT-FLOATING-POINT-OVERFLOW)
> * [状况类型 FLOATING-POINT-UNDERFLOW](#CT-FLOATING-POINT-UNDERFLOW)

### <span id="SC-NUMBER">系统类 NUMBER</span>

* 类优先级列表(Class Precedence List):

        number, t

* 描述(Description):

        类型[type] number 包含了表示数学数字的对象[object]. 类型[type] real 和 complex 是 number 互斥[disjoint]的子类型[subtype].

        函数[function] = 测试数值等价. 函数[function] eql, 当它的参数都是数字[number]时, 测试它们是否有着相同的类型[type]和数值. 两个数字[number]在 eql 或 = 下是相同的[same]但在 eq 下不一定相同[same].

* 注意(Notes):

        Common Lisp 在一些命名问题上和数学不同. 在数学中, 实数的集合习惯上被描述为是复数的一个子集, 但是在 Common Lisp 中, 类型[type] real 和类型[type] complex 是互斥的. 包含了所有数学复数的 Common Lisp 类型称为 number. 造成这些差异的原因包括历史先例, 和其他流行计算机语言兼容, 以及多种时间和空间效率问题.


### <span id="SC-COMPLEX">系统类 COMPLEX</span>

* 类优先级列表(Class Precedence List):

        complex, number, t

* 描述(Description):

        类型[type] complex 包括所有数学上的复数除了被包含在类型[type] rational 中的那些. 复数[complex]被表示为一个实部和一个虚部的笛卡尔形式, 其中的每个部分都是一个实数[real]. 实部和虚部都是有理数[rational]或都是相同的浮点数[float]类型[type]. 虚部可以是一个浮点数[float] 0, 但不能是一个有理数[rational] zero, 因为这样的一个数字被 Common Lisp 表示为一个有理数[rational]而不是一个复数[complex].

* 复合类型指定符类别(Compound Type Specifier Kind):

        详细的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        complex [typespec | *]

* 复合类型指定符参数(Compound Type Specifier Arguments):

        typespec---一个表示类型[type] real 的一个子类型[subtype]的类型指定符[type specifier].

* 复合类型指定符描述(Compound Type Specifier Description):

        这个类型[type]的每个元素都是实部和虚部为类型 (upgraded-complex-part-type typespec) 的一个复数[complex]. 这个类型[type]包括那些可以通过给 complex 传递类型[type] typespec 的数字来产生的复数[complex].

        (complex type-specifier) 指的是所有可以通过给函数[function] complex 传递类型 type-specifier 的数字[number]来产生的复数[complex], 加上所有其他的相同的专门的表示.

* 参见(See Also):

        章节 12.1.5.3 (复数的正规表示规则), 章节 2.3.2 (从标记构建数字), 章节 22.1.3.1.4 (打印复数)

* 注意(Notes):

        一个实部为 r 和虚部为 i 的复数[complex]的输入语法是 #C(r i). 关于更多详情, 见章节 2.4 (标准宏字符).

        对于每个浮点数[float] n, 这里会有一个表示相同数学数值的复数[complex], 可以通过 (COERCE n 'COMPLEX) 来获取. 


### <span id="SC-REAL">系统类 REAL</span>

* 类优先级列表(Class Precedence List):

        real, number, t

* 描述(Description):

        类型[type] real 包括表示数学上实数的所有数字[number], 尽管这里有着在 Common Lisp 中没有准确表示的数学上的实数. 只有实数可以使用 <, >, <=, 和 >= 函数来排序.

        类型[type] rational 和 float 是类型[type] real 互斥[disjoint]的子类型[subtype].

* 复合类型指定符类别(Compound Type Specifier Kind):

        缩写的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        real [lower-limit [upper-limit]]

* 复合类型指定符参数(Compound Type Specifier Arguments):

        lower-limit, upper-limit---类型 real 的区间指示符[interval designator]. 对于 lower-limit 和 upper-limit 中的每个默认值都是符号[symbol] *.

* 复合类型指定符描述(Compound Type Specifier Description):

        这个表示下限 lower-limit 和上限 upper-limit 所描述区间上的实数. 


### <span id="SC-FLOAT">系统类 FLOAT</span>

* 类优先级列表(Class Precedence List):

        float, real, number, t

* 描述(Description):

        一个浮点数[float]是一个 s*f*b^e-p 形式的数学上有理数 (但不是一个 Common Lisp 有理数[rational]), 其中 s 是 +1 或 -1, 就是那个正负号; b 是一个大于 1 的整数[integer], 这个表示的基数或底数; p 是一个正整数[integer], 这个浮点数[float]的精度 (以 b 为基数的数字); f 是一个在 b^p-1 和 b^p-1 (包含的) 之间的正整数[integer], 表示有效位数; 还有 e 是一个整数[integer], 表示指数. p 的值和 e 的范围取决于这个具体实现以及在这个具体实现中浮点数[float]的类型. 另外, 这里有一个浮点数 0; 依赖于具体实现, 这里也可以有一个 "负零". 如果这里没有负零, 那么 0.0 和 -0.0 都被简单解释为浮点数零. (= 0.0 -0.0) 总是为 true. 如果这里存在负零, (eql -0.0 0.0) 是 false, 否则就是 true.

        类型[type] short-float, single-float, double-float, 和 long-float 是类型[type] float 的子类型[subtype]. 它们中的任意两个都必须是互斥[disjoint]的类型[type]或者相同[same]类型[type]; 如果是相同[same]类型[type], 那么在上面顺序中在它们之间的其他类型[type]也必须是相同[same]类型[type]. 比如, 如果类型[type] single-float 和类型[type] long-float 是相同[same]类型, 那么类型[type] double-float 也必须是相同[same]类型[type].

* 复合类型指定符类别(Compound Type Specifier Kind):

        缩写的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        float [lower-limit [upper-limit]]

* 复合类型指定符参数(Compound Type Specifier Arguments):

        lower-limit, upper-limit---类型[type] float 的区间指示符[interval designator]. 对于 lower-limit 和 upper-limit 中的每个默认值都是符号[symbol] *.

* 复合类型指定符描述(Compound Type Specifier Description):

        这个表示下限 lower-limit 和上限 upper-limit 所描述区间上的浮点数[float].

* 参见(See Also):

        Figure 2-9, 章节 2.3.2 (从标记构建数字), 章节 22.1.3.1.3 (打印浮点数)

* 注意(Notes):

        注意所有数学上的整数不仅能被表示为 Common Lisp 实数, 也可以是浮点复数[complex float]. 比如, 数学上的数字 1 可能的表示包括整数[integer] 1, 浮点数[float] 1.0, 或者复数[complex] #C(1.0 0.0). 


### <span id="T-SF-SF-DF-LF">类型 SHORT-FLOAT, SINGLE-FLOAT, DOUBLE-FLOAT, LONG-FLOAT</span>

* 超类型(Supertypes):

        short-float: short-float, float, real, number, t

        single-float: single-float, float, real, number, t

        double-float: double-float, float, real, number, t

        long-float: long-float, float, real, number, t

* 描述(Description):

        对于这四个已定义的 float 类型[type]的子类型[subtype], 类型[type] short-float 和类型[type] long-float 的中间是类型[type] single-float 和类型[type] double-float. 这些类别的精度定义是具体实现定义的[implementation-defined]. 精度 (以 "位" 来测量, 用 p log 2b 来计算) 和指数大小 (也是以 "位" 来测量, 用 log 2(n+1) 计算, 其中 n 是最大指数值) 建议至少和下一段中的值一样的. 每个已定义的 float 类型[type]的子类型[subtype]可能有也可能没有一个负零.

        格式    最小精度           最小指数大小  
                                      
        Short   13 bits            5 bits                 
        Single  24 bits            8 bits                 
        Double  50 bits            8 bits                 
        Long    50 bits            8 bits                 

        Figure 12-12. 建议的最小浮点精度和指数大小

        浮点数[float]的内部表示可能少于 4 个. 如果存在更少的不同表示, 则适用以下规则:

            如果这里只有一个, 那就是类型[type] single-float. 在这个表示中, 一个对象[object]同时为类型[type] single-float, double-float, short-float, 和 long-float.

            两种内部表示可以被安排为以下两种方式:

                提供两种类型[type]: single-float 和 short-float. 一个对象[object]同时为 single-float, double-float, 和 long-float.
                提供两种类型[type]: single-float 和 double-float. 一个对象[object]同时为 single-float 和 short-float, 或 double-float 和 long-float.

            三种内部表示可以被安排以下两种方式:

                提供三种类型[type]: short-float, single-float, 和 double-float. 一个对象[object]同时为 double-float 和 long-float.
                提供三种类型[type]: single-float, double-float, 和 long-float. 一个对象[object]同时为 single-float 和 short-float. 

* 复合类型指定符类别(Compound Type Specifier Kind):

        缩写的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        short-float [short-lower-limit [short-upper-limit]]

        single-float [single-lower-limit [single-upper-limit]]

        double-float [double-lower-limit [double-upper-limit]]

        long-float [long-lower-limit [long-upper-limit]]

* 复合类型指定符参数(Compound Type Specifier Arguments):

        short-lower-limit, short-upper-limit---类型[type] short-float 的区间指示符[interval designator]. 对于 lower-limit 和 upper-limit 中的每个默认值都是符号[symbol] *.

        single-lower-limit, single-upper-limit---类型[type] single-float 的区间指示符[interval designator]. 对于 lower-limit 和 upper-limit 中的每个默认值都是符号[symbol] *.

        double-lower-limit, double-upper-limit---类型[type] double-float 的区间指示符[interval designator]. 对于 lower-limit 和 upper-limit 中的每个默认值都是符号[symbol] *.

        long-lower-limit, long-upper-limit---类型[type] long-float 的区间指示符[interval designator]. 对于 lower-limit 和 upper-limit 中的每个默认值都是符号[symbol] *.

* 复合类型指定符描述(Compound Type Specifier Description):

        每一个都表示在区间指示符[interval designator]指定的区间内的指定类型[type]的浮点数[float]集合. 


### <span id="SC-RATIONAL">系统类 RATIONAL</span>

* 类优先级列表(Class Precedence List):

        rational, real, number, t

* 描述(Description):

        如果一个有理数[rational]的值是整形的, 那么它的正规表示是一个整数[integer], 否则就是一个比数[ratio].

        类型[type] integer 和 ratio 是类型[type] rational 的互斥[disjoint]的子类型[subtype].

* 复合类型指定符类别(Compound Type Specifier Kind):

        缩写的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        rational [lower-limit [upper-limit]]

* 复合类型指定符参数(Compound Type Specifier Arguments):

        lower-limit, upper-limit---类型[type] rational 的区间指示符[interval designator]. 对于 lower-limit 和 upper-limit 中的每个默认值都是符号[symbol] *.

* 复合类型指定符描述(Compound Type Specifier Description):

        这个表示由下限 lower-limit 和上限 upper-limit 描述的有理数[rational]. 

### <span id="SC-RATIO">系统类 RATIO</span>

* 类优先级列表(Class Precedence List):

        ratio, rational, real, number, t

* 描述(Description):

        一个比数[ratio]是一个表示数学上两个非零整数的比数的数字[number], 这两个整数分别为分子和分母, 它的最大公约数为 1, 其中分母为正的并且大于 1.

* 参见(See Also):

        Figure 2-9, 章节 2.3.2 (从标记构建数字), 章节 22.1.3.1.2 (打印比数) 


### <span id="SC-INTEGER">系统类 INTEGER</span>

* 类优先级列表(Class Precedence List):

        integer, rational, real, number, t

* 描述(Description):

        一个整数[integer]是一个数学上的整数. 一个整数[integer]的大小是没有限制的.

        类型[type] fixnum 和 bignum 组成类型[type] integer 的一个详尽的分区[exhaustive partition].

* 复合类型指定符类别(Compound Type Specifier Kind):

        缩写的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        integer [lower-limit [upper-limit]]

* 复合类型指定符参数(Compound Type Specifier Arguments):

        lower-limit, upper-limit---类型[type] integer 的区间指示符[interval designator]. 对于 lower-limit 和 upper-limit 中的每个默认值都是符号[symbol] *.

* 复合类型指定符描述(Compound Type Specifier Description):

        这个表示由下限 lower-limit 和上限 upper-limit 描述的整数[integer].

* 参见(See Also):

        Figure 2-9, 章节 2.3.2 (从标记构建数字), 章节 22.1.3.1.1 (打印整数)

* 注意(Notes):

        类型[type] (integer lower upper), 其中 lower 和 upper 分别是 most-negative-fixnum 和 most-positive-fixnum, 也被称为 fixnum.

        类型[type] (integer 0 1) 也被称为 bit. 类型[type] (integer 0 *) 也被称为 unsigned-byte. 


### <span id="T-SIGNED-BYTE">类型 SIGNED-BYTE</span>

* 超类型(Supertypes):

        signed-byte, integer, rational, real, number, t

* 描述(Description):

        这个原子类型指定符[type specifier] signed-byte 表示和类型指定符[type specifier] integer 表示的相同的类型; 但是, 这两个类型指定符[type specifier]的列表形式有着不同的语义.

* 复合类型指定符类别(Compound Type Specifier Kind):

        缩写的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        signed-byte [s | *]

* 复合类型指定符参数(Compound Type Specifier Arguments):

        s---一个正整数[integer].

* 复合类型指定符描述(Compound Type Specifier Description):

        这个表示可以以二进制补码的形式用 s 比特的字节[byte]所表示的整数[integer]的集合. 这个等价于 (integer -2^s-1 2^s-1-1). 类型 signed-byte 或类型 (signed-byte *) 和类型[type] integer 是相同的. 


### <span id="T-UNSIGNED-BYTE">类型 UNSIGNED-BYTE</span>

* 超类型(Supertypes):

        unsigned-byte, signed-byte, integer, rational, real, number, t

* 描述(Description):

        这个原子类型指定符[type specifier] unsigned-byte 表示类型指定符[type specifier] (integer 0 *) 所表示的相同类型.

* 复合类型指定符类别(Compound Type Specifier Kind):

        缩写的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        unsigned-byte [s | *]

* 复合类型指定符参数(Compound Type Specifier Arguments):

        s---一个正整数[integer].

* 复合类型指定符描述(Compound Type Specifier Description):

        这个表示可以以一个大小为 s 比特的字节[byte]表示的非负整数[integer]的集合. 这个等价于 m=2^s 时的 (mod m), 或者等价于 n=2^s-1 时的 (integer 0 n). 类型[type] unsigned-byte 或类型[type] (unsigned-byte *) 和类型 (integer 0 *) 相同, 都表示非负的整数[integer]集合.

* 注意(Notes):

        类型[type] (unsigned-byte 1) 也被称为 bit. 


### <span id="TS-MOD">类型指定符 MOD</span>

* 复合类型指定符类别(Compound Type Specifier Kind):

        缩写的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        mod n

* 复合类型指定符参数(Compound Type Specifier Arguments):

        n---一个正整数[integer].

* 复合类型指定符描述(Compound Type Specifier Description):

        这个表示小于 n 的非负整数[integer]集合. 这等价于 (integer 0 (n)) 或 (integer 0 m), 其中 m=n-1.

        这个参数是必须的, 并且不能为 *.

        符号 mod 作为一个类型指定符[type specifier]是无效的. 


### <span id="T-BIT">类型 BIT</span>

* 超类型(Supertypes):

        bit, unsigned-byte, signed-byte, integer, rational, real, number, t

* 描述(Description):

        类型[type] bit 等价于类型[type] (integer 0 1) 和 (unsigned-byte 1). 


### <span id="T-FIXNUM">类型 FIXNUM</span>

* 超类型(Supertypes):

        fixnum, integer, rational, real, number, t

* 描述(Description):

        一个 fixnum 是一个值在 most-negative-fixnum 和 most-positive-fixnum (包含的) 之间的整数[integer]. 具体哪些整数[integer]是 fixnum 是由具体实现定义的[implementation-defined]. 类型[type] fixnum 需要是 (signed-byte 16) 的一个超类型. 


### <span id="T-BIGNUM">类型 BIGNUM</span>

* 超类型(Supertypes):

        bignum, integer, rational, real, number, t

* 描述(Description):

        类型[type] bignum 准确地被定义为 (and integer (not fixnum)). 


### <span id="F-Compare">函数 =, /=, <, >, <=, >=</span>

* 语法(Syntax):

        = &rest numbers+ => generalized-boolean

        /= &rest numbers+ => generalized-boolean

        < &rest numbers+ => generalized-boolean

        > &rest numbers+ => generalized-boolean

        <= &rest numbers+ => generalized-boolean

        >= &rest numbers+ => generalized-boolean

* 参数和值(Arguments and Values):

        number---对于 <, >, <=, >=: 一个实数[real]; 对于 =, /=: 一个数字[number].

        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        =, /=, <, >, <=, 和 >= 在它们的参数上按照如下执行数学比较:

        =

            如果所有数字 numbers 的值都是相同的那么 = 的结果为 true; 否则就是 false. 如果两个复数[complex]的实部和虚部根据 = 都是相等的, 那么它们就被 = 认为是相等的.

        /=

            如果没有两个数字 numbers 在值上是相等的那么 /= 的值就是 true; 否则就是 false.

        <

            如果这些数字 numbers 是单调递增的那么 < 的值就是 true; 否则就是 false.

        >

            如果这些数字 numbers 是单调递减的那么 > 的值就是 true; 否则就是 false.

        <=

            如果这些数字 numbers 是单调非递减的那么 <= 的值就是 true; 否则就是 false.

        >=

            如果这些数字 numbers 是单调非递增的那么 >= 的值就是 true; 否则就是 false.

        =, /=, <, >, <=, 和 >= 执行必要的类型转换.

* 示例(Examples):

        这些函数的用法如下面这段所示.

        (= 3 3) 是 true.              (/= 3 3) 是 false.             
        (= 3 5) 是 false.             (/= 3 5) 是 true.              
        (= 3 3 3 3) 是 true.          (/= 3 3 3 3) 是 false.         
        (= 3 3 5 3) 是 false.         (/= 3 3 5 3) 是 false.         
        (= 3 6 5 2) 是 false.         (/= 3 6 5 2) 是 true.          
        (= 3 2 3) 是 false.           (/= 3 2 3) 是 false.           
        (< 3 5) 是 true.              (<= 3 5) 是 true.              
        (< 3 -5) 是 false.            (<= 3 -5) 是 false.            
        (< 3 3) 是 false.             (<= 3 3) 是 true.              
        (< 0 3 4 6 7) 是 true.        (<= 0 3 4 6 7) 是 true.        
        (< 0 3 4 4 6) 是 false.       (<= 0 3 4 4 6) 是 true.        
        (> 4 3) 是 true.              (>= 4 3) 是 true.              
        (> 4 3 2 1 0) 是 true.        (>= 4 3 2 1 0) 是 true.        
        (> 4 3 3 2 0) 是 false.       (>= 4 3 3 2 0) 是 true.        
        (> 4 3 1 2 0) 是 false.       (>= 4 3 1 2 0) 是 false.       
        (= 3) 是 true.                (/= 3) 是 true.                
        (< 3) 是 true.                (<= 3) 是 true.                
        (= 3.0 #c(3.0 0.0)) 是 true.  (/= 3.0 #c(3.0 1.0)) 是 true.  
        (= 3 3.0) 是 true.            (= 3.0s0 3.0d0) 是 true.       
        (= 0.0 -0.0) 是 true.         (= 5/2 2.5) 是 true.           
        (> 0.0 -0.0) 是 false.        (= 0 -0.0) 是 true.            
        (<= 0 x 9) 如果 x 在 0 和 9 之间包括 9 就是 true                               
        (< 0.0 x 1.0) 如果 x 在 0.0 和 1.0 之间不包括 1.0 就是 true                              
        (< -1 j (length v)) 如果 j 是一个序列 v 的有效索引就是 true

        Figure 12-13. /=, =, <, >, <=, 和 >= 的使用

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果某个实参[argument]不是一个实数[real], 那么就会发出一个 type-error 类型[type]的错误. 如果不能满足它的合约(contract)可能发出 arithmetic-error 类型[type]的错误.

* 参见(See Also): None.

* 注意(Notes):

        = 有别于 eql, = 在 (= 0.0 -0.0) 总是为 true, 因为 = 比较它的操作数的数学值, 然而可以这么说, eql 比较表征值. 


### <span id="F-MAX-MIN">函数 MAX, MIN</span>

* 语法(Syntax):

        max &rest reals+ => max-real

        min &rest reals+ => min-real

* 参数和值(Arguments and Values):

        real---一个实数[real].
        max-real, min-real---一个实数[real].

* 描述(Description):

        max 返回最大的实数 real (接近于正无穷). min 返回最小的实数 real (接近于负无穷).

        对于 max, 具体实现可以选择去原样返回最大的参数, 也可以应用浮点数传递性[contagion]规则, 将所有参数都列入传递性[contagion]目的的考虑中. 另外, 如果不止一个参数是 = 的, 那么它们中的任何一个都可能被选择作为返回值. 比如, 如果这些实数 reals 是有理数[rational]和浮点数[float]的混合, 并且最大值是个有理数[rational], 那么具体实现可以自由地产生有理数[rational]或它的近似浮点数[float]; 如果这个最大的参数是一个比任何其他浮点数[float]参数的最大格式都小的格式的浮点数[float], 那么具体实现可以自由地以给定的格式返回那个参数或者将其扩展到更大的格式. 相似的备注适用于 min (用 "最小参数" 替换 "最大参数").

* 示例(Examples):

    ```LISP
    (max 3) =>  3 
    (min 3) =>  3
    (max 6 12) =>  12 
    (min 6 12) =>  6
    (max -6 -12) =>  -6 
    (min -6 -12) =>  -12
    (max 1 3 2 -7) =>  3 
    (min 1 3 2 -7) =>  -7
    (max -2 3 0 7) =>  7 
    (min -2 3 0 7) =>  -2
    (max 5.0 2) =>  5.0 
    (min 5.0 2)
    =>  2
    OR=>  2.0
    (max 3.0 7 1)
    =>  7
    OR=>  7.0 
    (min 3.0 7 1)
    =>  1
    OR=>  1.0
    (max 1.0s0 7.0d0) =>  7.0d0
    (min 1.0s0 7.0d0)
    =>  1.0s0
    OR=>  1.0d0
    (max 3 1 1.0s0 1.0d0)
    =>  3
    OR=>  3.0d0
    (min 3 1 1.0s0 1.0d0)
    =>  1
    OR=>  1.0s0 
    OR=>  1.0d0
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果任何数字不是一个实数[real], 那么应该会发出一个 type-error 类型[type]的错误.

* 参见(See Also): None.

* 注意(Notes): None. 


### <span id="F-MINUSP-PLUSP">函数 MINUSP, PLUSP</span>

* 语法(Syntax):

        minusp real => generalized-boolean

        plusp real => generalized-boolean

* 参数和值(Arguments and Values):

        real---一个实数[real].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果实数 real 小于 0 那么 minusp 返回 true; 否则, 返回 false.

        如果实数 real 大于 0 那么 plusp 返回 true; 否则, 返回 false.

        不管一个具体实现[implementation]是否提供了正负浮点数[float]零的不同表示, (minusp -0.0) 总是返回 false.

* 示例(Examples):

    ```LISP
    (minusp -1) =>  true
    (plusp 0) =>  false
    (plusp least-positive-single-float) =>  true
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 real 不是一个实数[real], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also): None.

* 注意(Notes): None. 


### <span id="Function-ZEROP">函数 ZEROP</span>

* 语法(Syntax):

        zerop number => generalized-boolean

* 发音(Pronunciation):

        ['zee(,)roh(,)pee]

* 参数和值(Arguments and Values):

        number---一个数字[number].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果数字 number 是零 (整数[integer], 浮点数,[float] 或复数[complex]) 就返回 true; 否则, 返回 false.

        不管一个具体实现[implementation]是否提供了正负浮点数[float]零的不同表示, (zerop -0.0) 总是返回 true.

* 示例(Examples):

    ```LISP
    (zerop 0) =>  true
    (zerop 1) =>  false
    (zerop -0.0) =>  true
    (zerop 0/100) =>  true
    (zerop #c(0 0.0)) =>  true
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 number 不是一个数字[number], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also): None.

* 注意(Notes):

        (zerop number) ==  (= number 0)


### <span id="F-F-F-C-F-T-F-R-F">函数 FLOOR, FFLOOR, CEILING, FCEILING, TRUNCATE, FTRUNCATE, ROUND, FROUND</span>

* 语法(Syntax):

        floor number &optional divisor => quotient, remainder

        ffloor number &optional divisor => quotient, remainder

        ceiling number &optional divisor => quotient, remainder

        fceiling number &optional divisor => quotient, remainder

        truncate number &optional divisor => quotient, remainder

        ftruncate number &optional divisor => quotient, remainder

        round number &optional divisor => quotient, remainder

        fround number &optional divisor => quotient, remainder

* 参数和值(Arguments and Values):

        number---一个实数[real].
        divisor---一个非零实数[real]. 默认为整数[integer] 1.
        quotient---对于 floor, ceiling, truncate, 和 round: 一个整数[integer]; 对于 ffloor, fceiling, ftruncate, 和 fround: 一个浮点数[float].
        remainder---一个实数[real].

* 描述(Description):

        这些函数用 divisor 来除数字 number, 返回商 quotient 和余数 remainder, 比如

        quotient*divisor+remainder=number

        商 quotient 总是表示一个数学上的整数. 当一个以上的数学整数是可能的时候 (换句话说, 当余数不是零), 舍入或截断的类型取决于操作符[operator]:

        floor, ffloor

            floor 和 ffloor 产生一个朝向负无穷截断的商 quotient; 这也就是说, 这个商 quotient 表示不大于那个数学上商的最大数学整数.

        ceiling, fceiling

            ceiling 和 fceiling 产生一个朝向正无穷截断的商 quotient; 这也就是说, 商 quotient 表示不小于那个数学上结果的最小数学整数.

        truncate, ftruncate

            truncate 和 ftruncate 产生一个朝向 0 截断的商 quotient; 这也就是说, 这个商 quotient 表示和那个数学上的商相同符号的数学上的整数, 并且有着不大于那个数学上的商的最大整形大小.

        round, fround

            round 和 fround 产生一个四舍五入到最近的数学整数的商 quotient; 如果这个数学上的商刚好在两个整数中间, (也积极是说, 它有着 integer+1/2 的形式), 那么这个商 quotient 会被四舍五入到偶数 (可以被2整除).

        所有这些函数在这些数字 numbers 上执行类型转换操作.

        如果 x 和 y 都是整数[integer]那么余数 remainder 也是一个整数[integer], 如果 x 和 y 都是有理数[rational]那么余数 remainder 也是一个有理数[rational], 如果 x 或 y 是一个浮点数[float]那么余数 remainder 也是一个浮点数[float].

        ffloor, fceiling, ftruncate, 和 fround 以以下方式处理不同类型[type]的参数: 如果 number 是一个浮点数[float], 并且 divisor 不是一个长格式的浮点数[float], 那么第一个结果是一个和 number 相同类型[type]的浮点数[float]. 否则, 第一个结果是由传递性[contagion]规则决定的类型[type]; 见章节 12.1.1.2 (数值运算的传递性).

* 示例(Examples):

    ```LISP
    (floor 3/2) =>  1, 1/2
    (ceiling 3 2) =>  2, -1
    (ffloor 3 2) =>  1.0, 1
    (ffloor -4.7) =>  -5.0, 0.3
    (ffloor 3.5d0) =>  3.0d0, 0.5d0
    (fceiling 3/2) =>  2.0, -1/2
    (truncate 1) =>  1, 0
    (truncate .5) =>  0, 0.5
    (round .5) =>  0, 0.5
    (ftruncate -7 2) =>  -3.0, -1
    (fround -7 2) =>  -4.0, 1
    (dolist (n '(2.6 2.5 2.4 0.7 0.3 -0.3 -0.7 -2.4 -2.5 -2.6))
      (format t "~&~4,1@F ~2,' D ~2,' D ~2,' D ~2,' D"
              n (floor n) (ceiling n) (truncate n) (round n)))
    >>  +2.6  2  3  2  3
    >>  +2.5  2  3  2  2
    >>  +2.4  2  3  2  2
    >>  +0.7  0  1  0  1
    >>  +0.3  0  1  0  0
    >>  -0.3 -1  0  0  0
    >>  -0.7 -1  0  0 -1
    >>  -2.4 -3 -2 -2 -2
    >>  -2.5 -3 -2 -2 -2
    >>  -2.6 -3 -2 -2 -3
    =>  NIL
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes):

        当只给定 number 时, 这两个结果是精确的; 这两个结果的数学和总是等于 number 的数学值.

        (function number divisor) 和 (function (/ number divisor)) (其中 function 是 floor, ceiling, ffloor, fceiling, truncate, round, ftruncate, 和 fround 中的任何一个) 返回相同的第一个值, 但是它们返回不同的余数作为第二个值. 比如:

        (floor 5 2) =>  2, 1
        (floor (/ 5 2)) =>  2, 1/2

        如果需要一个类似于 round 的效果, 但是在商刚好在两个整数中间时总是向上或向下舍入 (而不是朝向最接近的偶数), 程序员应该考虑像 (floor (+ x 1/2)) 或 (ceiling (- x 1/2)) 这样的构造. 


### <span id="F-SIN-COS-TAN">函数 SIN, COS, TAN</span>

* 语法(Syntax):

        sin radians => number

        cos radians => number

        tan radians => number

* 参数和值(Arguments and Values):

        radians---一个用弧度表示的数字[number].
        number---一个数字[number].

* 描述(Description):

        sin, cos, 和 tan 分别返回弧度 radians 正弦, 余弦和正切.

* 示例(Examples):

    ```LISP
    (sin 0) =>  0.0
    (cos 0.7853982) =>  0.707107
    (tan #c(0 1)) =>  #C(0.0 0.761594)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 radians 不是一个数字[number], 那么应该发出一个 type-error 类型[type]的错误. 可能发出 arithmetic-error 类型[type]的错误.

* 参见(See Also):

        asin, acos, atan, 章节 12.1.3.3 (浮点的置换性规则)

* 注意(Notes): None. 

### <span id="F-ASIN-ACOS-ATAN">函数 ASIN, ACOS, ATAN</span>

* 语法(Syntax):

        asin number => radians

        acos number => radians

        atan number1 &optional number2 => radians

* 参数和值(Arguments and Values):

        number---一个数字[number].
        number1---如果没有提供 number2 就是一个数字[number], 如果提供了 number2 就是一个实数[real].
        number2---一个实数[real].
        radians---一个数字[number] (弧度).

* 描述(Description):

        asin, acos, 和 atan 分别计算反正弦, 反余弦和反正切.

        反正弦, 反余弦和反正切 (只提供了 number1 的情况下) 函数可以被数学上定义为 number 或 number1 被指定为下一段中的 x 那样.

            函数          定义                         
            Arc sine     -i log  (ix+ sqrt(1-x^2) )         
            Arc cosine   (<PI>/2) - arcsin  x               
            Arc tangent  -i log  ((1+ix) sqrt(1/(1+x^2)) )  

            Figure 12-14. 反正弦, 反余弦和反正切的数学上的定义

        这些公式在数学上是正确的, 假设计算完全准确. 它们不一定是实值计算中最简单的.

        如果 number1 和 number2 都提供给了 atan, 那么结果是 number1/number2 的反正切. 当没有提供负零时, atan 的值总是在 -<PI> (不包含) 到 <PI> (包含) 之间. 当支持负零时, 两个参数的反正切的范围包括 -<PI>.

        对于一个实数[real] number1, 结果也是一个实数[real]并且位于 -<PI>/2 和 <PI>/2 之间(都不包含). 如果没有提供 number2, 那么 number1 可以是一个复数[complex]. 如果都提供了, 假设 number1 不是零那么 number2 可以是零.

        下面反正弦的定义决定了范围和分支切割:

        arcsin z = -i log (iz+sqrt(1-z^2))

        反正弦函数的分支切割为两块: 一个沿着负实轴向 -1 的左边 (包含), 与第二象限连续, 而另一个沿着正实轴向 1 的右边 (包含), 与第四象限连续. 范围是包含实部在 -<PI>/2 和 <PI>/2 之间的数字的复平面的条带. 当切仅当一个数字的虚部时非负的的时候, 实部等价于 -<PI>/2 的这个数在这个范围内; 当切仅当一个数的虚部时非正的时候, 实部等价于 <PI>/2 的这个数在这个范围内.

        下面反余弦的定义决定了范围和分支切割:

        arccos z = <PI>/2- arcsin z

        或者, 这个也是等价的,

        arccos z = -i log (z+i sqrt(1-z^2))

        arccos z = 2 log (sqrt((1+z)/2) + i sqrt((1-z)/2))/i

        反余弦函数的分支切割为两块: 一个沿着负实轴向 -1 的左边 (包含), 与第二象限连续, 而另一个沿着正实轴向 1 的右边 (包含), 与第四象限连续. 这个和反正弦是相同的分支切割. 范围是包含了实部在 0 和 <PI> 之间的数字的复数带. 当切仅当一个数字的虚部时非负的的时候, 实部等价于 0 的这个数在这个范围内; 当切仅当一个数的虚部时非正的时候, 实部等价于 <PI> 的这个数在这个范围内.

        下面(单参数)反正切的定义决定了范围和分支切割:

        arctan z = log (1+iz) - log (1-iz)/(2i)

        注意不要简化这个公式; "明显" 的简化可能会改变分支切割或分支切割上的值不正确地修改. 反正切函数的分支切割为两块: 一个沿着正虚轴到 i 上 (不包含), 与第二象限连续, 一个沿着负虚轴到 -i 下 (exclusive), 与第四象限连续. 点 i 和 -i 被排除在这个域外. 范围是包含了实部在 -<PI>/2 和 <PI>/2 之间的数字的复数带. 当切仅当一个数字的虚部严格为正时, 实部等价于 -<PI>/2 的这个数在这个范围内; 当切仅当一个数字的虚部严格为负时, 实部等价于 <PI>/2 的这个数在这个范围内. 因此这个反正切的范围和反正弦的范围除了点 -<PI>/2 and <PI>/2 被排除之外是相同的.

        对于 atan, 这个 number1 (表示为 x) 和 number2 (表示为 y) 的符号被用于获得象限信息. 下一段详细描述了各种特殊情况. 星号 (*) 表示在这段的这个条目适用于支持负零的具体实现.

            y Condition  x Condition  Cartesian locus  Range of result         
            y = 0        x > 0        Positive x-axis  0                       
            * y = +0     x > 0        Positive x-axis  +0                      
            * y = -0     x > 0        Positive x-axis  -0                      
            y > 0        x > 0        Quadrant I       0 < result< <PI>/2      
            y > 0        x = 0        Positive y-axis  <PI>/2                  
            y > 0        x < 0        Quadrant II      <PI>/2 < result< <PI>   
            y = 0        x < 0        Negative x-axis  <PI>                    
            * y = +0     x < 0        Negative x-axis  +<PI>                   
            * y = -0     x < 0        Negative x-axis  -<PI>                   
            y < 0        x < 0        Quadrant III     -<PI>< result< -<PI>/2  
            y < 0        x = 0        Negative y-axis  -<PI>/2                 
            y < 0        x > 0        Quadrant IV      -<PI>/2 < result< 0     
            y = 0        x = 0        Origin           undefined consequences  
            * y = +0     x = +0       Origin           +0                      
            * y = -0     x = +0       Origin           -0                      
            * y = +0     x = -0       Origin           +<PI>                   
            * y = -0     x = -0       Origin           -<PI>                   

            Figure 12-15. 反正切的象限信息

* 示例(Examples):

    ```LISP
    (asin 0) =>  0.0 
    (acos #c(0 1))  =>  #C(1.5707963267948966 -0.8813735870195432)
    (/ (atan 1 (sqrt 3)) 6)  =>  0.087266 
    (atan #c(0 2)) =>  #C(-1.5707964 0.54930615)
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果数字 number 不是一个数字[number], 那么 acos 和 asin 应该发出一个 type-error 类型[type]的错误. 如果提供了一个参数并且这个参数不是一个数字[number], 或者如果提供了两个参数而这两个参数都不是实数[real], 那么 atan 应该发出一个 type-error 类型[type]的错误.

        acos, asin, 和 atan 可能发出 arithmetic-error.

* 参见(See Also):

        log, sqrt, 章节 12.1.3.3 (浮点的置换性规则)

* 注意(Notes):

        即便数字 number 不是一个复数[complex], asin 或 acos 的结果也可以是一个复数[complex]; 这个发生在数字 number 的绝对值大于 1 时. 


### <span id="CV-PI">常量 PI</span>

* 值(Value):

        一个依赖于具体实现[implementation-dependent]的长浮点数[long float].

* 描述(Description):

        对数学常数 <PI> 的最好的长浮点数[long float]近似.

* 示例(Examples):

    ```LISP
    ;; In each of the following computations, the precision depends 
    ;; on the implementation.  Also, if `long float' is treated by 
    ;; the implementation as equivalent to some other float format 
    ;; (e.g., `double float') the exponent marker might be the marker
    ;; for that equivalent (e.g., `D' instead of `L').
    pi =>  3.141592653589793L0
    (cos pi) =>  -1.0L0

    (defun sin-of-degrees (degrees)
      (let ((x (if (floatp degrees) degrees (float degrees pi))))
        (sin (* x (/ (float pi x) 180)))))
    ```

* 参见(See Also): None.

* 注意(Notes):

        一个对 <PI> 的某个其他精度的近似值可以通过编写 (float pi x) 来获取, 其中 x 是一个期望精度的浮点数[float], 或者编写 (coerce pi type), 其中 type 是期望的类型, 比如 short-float. 


### <span id="F-S-C-T-A-A-A">函数 SINH, COSH, TANH, ASINH, ACOSH, ATANH</span>

* 语法(Syntax):

        sinh number => result

        cosh number => result

        tanh number => result

        asinh number => result

        acosh number => result

        atanh number => result

* 参数和值(Arguments and Values):

        number---一个数字[number].
        result---一个数字[number].

* 描述(Description):

        这些函数计算双曲正弦, 余弦, 正切, 反正弦, 反余弦, 和反正切函数, 这些函数在数学上定义为在下一个图中给出一个参数 x 的形式.

            函数                    定义                              
            Hyperbolic sine         (e^x-e^-x)/2                            
            Hyperbolic cosine       (e^x+e^-x)/2                            
            Hyperbolic tangent      (e^x-e^-x)/(e^x+e^-x)                   
            Hyperbolic arc sine     log  (x+sqrt(1+x^2))                    
            Hyperbolic arc cosine   2 log  (sqrt((x+1)/2) + sqrt((x-1)/2))  
            Hyperbolic arc tangent  (log  (1+x) - log (1-x))/2              

            Figure 12-16. 双曲函数的数学定义

        下面这个反双曲余弦的定义决定了范围和分支切割:

        arccosh z = 2 log (sqrt((z+1)/2) + sqrt((z-1)/2)).

        反双曲余弦函数的分支切割沿着实轴到 1 的左边 (包含), 沿着负实轴无限延伸, 与第二象限 (在 0 和 1 之间) 和第一象限相连. 这个范围是包含了实部为非负并且虚部在 -<PI> (不包含) 和 <PI> (包含) 之间的数字的复平面的半条. 如果一个数字的虚部在 0 (包含) 和 <PI> (包含) 之间, 那么实部为 0 的这个数在这个范围内.

        下面这个反双曲正弦的定义决定了范围和分支切割:

        arcsinh z = log (z+sqrt(1+z^2)).

        这个反双曲正弦函数的分支切割分为两块: 一个沿着正虚轴到 i (包含) 上, 与第一象限相连, 而另一个沿着负虚轴到 -i (包含) 下, 与第三象限相连. 这个范围是包含虚部在 -<PI>/2 和 <PI>/2 之间的数字的复数带. 当且仅当一个实部为非负时, 这个虚部与 -<PI>/2 相等的复数在这个范围内; 当且仅当一个数字的虚部为非负时, 这个虚部等价于 <PI>/2 的数字在这个范围内.

        下面这个反双曲正切的定义决定了范围和分支切割:

        arctanh z = log (1+z) - log (1-z)/2.

        注意:

        i arctan z = arctanh iz.

        这个反双曲正切函数的分支切割分为两块: 一个沿着负实轴到one along the negative real -1 (包含) 的左边, 与第三象限相连, 而另一个沿着正实轴到 1 (包含) 的右边, 与第一象限相连. 点 -1 和 1 被排除在这个域外. 这个范围是包含虚部在 -<PI>/2 和 <PI>/2 之间的数字的复数带. 当且仅当一个数字的实部是严格负的时, 这个虚部等于 -<PI>/2 的数字在这个范围内; 当且仅当一个数字的虚部是严格正的时, 这个虚部等于 <PI>/2 的数字在这个范围内. 因此反双曲正切函数的范围除了点 points -<PI>i/2 和 <PI>i/2 被排除之外和反向双曲正切函数是相同的.

* 示例(Examples):

    ```LISP
    (sinh 0) =>  0.0 
    (cosh (complex 0 -1)) =>  #C(0.540302 -0.0)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 number 不是一个数字[number], 那么应该发出一个 type-error 类型[type]的错误. 也可能发出 arithmetic-error 类型[type]的错误.

* 参见(See Also):

        log, sqrt, 章节 12.1.3.3 (浮点的置换性规则)

* 注意(Notes):

        即便 number 不是一个复数[complex], acosh 的结果也可以是一个复数[complex]; 这个发生在 number 小于 1 时. 同样, 即便 number 不是一个复数[complex], atanh 的结果也可以是一个复数[complex]; 这个发生在 number 的绝对值大于 1 时.

        假设计算完全准确, 分支切割公式在数学上是正确的. 实现者应该在数值分析中参考一个好的文本. 上面给出的公式并不一定是实数值计算最简单的公式; 它们被选择以合适的方式为复杂的案例定义分支切割. 


### <span id="F-Multiply">函数 *</span>

* 语法(Syntax):

        * &rest numbers => product

* 参数和值(Arguments and Values):

        number---一个数字[number].
        product---一个数字[number].

* 描述(Description):

        返回那些数字 numbers 的乘积, 在这个过程中执行任何必要的类型转换. 如果没有提供数字 numbers, 返回 1.

* 示例(Examples):

    ```LISP
    (*) =>  1
    (* 3 5) =>  15
    (* 1.0 #c(22 33) 55/98) =>  #C(12.346938775510203 18.520408163265305)
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果某个实参[argument]不是一个数字[number], 可能发出一个 type-error 类型[type]的错误. 可能发出 arithmetic-error 类型[type]的错误.

* 参见(See Also):

        章节 12.1.1 (数值运算), 章节 12.1.3 (有理数计算), 章节 12.1.4 (浮点计算), 章节 12.1.5 (复数计算)

* 注意(Notes): None. 


### <span id="F-Add">函数 +</span>

* 语法(Syntax):

        + &rest numbers => sum

* 参数和值(Arguments and Values):

        number---一个数字[number].
        sum---一个数字[number].

* 描述(Description):

        返回数字 numbers 的和, 在这个过程中执行任何必要的类型转换. 如果没有提供 numbers, 返回 0.

* 示例(Examples):

    ```LISP
    (+) =>  0
    (+ 1) =>  1
    (+ 31/100 69/100) =>  1
    (+ 1/5 0.8) =>  1.0
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果某个实参[argument]不是一个数字[number], 可能发出一个 type-error 类型[type]的错误. 可能发出 arithmetic-error 类型[type]的错误.

* 参见(See Also):

        章节 12.1.1 (数值运算), 章节 12.1.3 (有理数计算), 章节 12.1.4 (浮点计算), 章节 12.1.5 (复数计算)

* 注意(Notes): None. 


### <span id="F-Sub">函数 -</span>

* 语法(Syntax):

        - number => negation

        - minuend &rest subtrahends+ => difference

* 参数和值(Arguments and Values):

        number, minuend, subtrahend---一个数字[number].
        negation, difference---一个数字[number].

* 描述(Description):

        函数[function] - 执行数学减法和取反.

        如果只提供了一个 number, 对这个数字 number 的相反数被返回.

        如果给定了不止一个实参[argument], 它从被减数 minuend 减去所有的减数 subtrahends 并返回这个结果.

        函数[function] - 执行必要的类型转换.

* 示例(Examples):

    ```LISP
    (- 55.55) =>  -55.55
    (- #c(3 -5)) =>  #C(-3 5)
    (- 0) =>  0
    (eql (- 0.0) -0.0) =>  true
    (- #c(100 45) #c(0 45)) =>  100
    (- 10 1 2 3 4) =>  0
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果某个实参[argument]不是一个数字[number], 可能发出一个 type-error 类型[type]的错误. 可能发出 arithmetic-error 类型[type]的错误.

* 参见(See Also):

        章节 12.1.1 (数值运算), 章节 12.1.3 (有理数计算), 章节 12.1.4 (浮点计算), 章节 12.1.5 (复数计算)

* 注意(Notes): None. 


### <span id="F-Div">函数 /</span>

* 语法(Syntax):

        / number => reciprocal

        / numerator &rest denominators+ => quotient

* 参数和值(Arguments and Values):

        number, denominator---一个非零数字[number].
        numerator, quotient, reciprocal---一个数字[number].

* 描述(Description):

        函数[function] / 执行除法或取倒数.

        如果没有提供分母 denominator, 那么函数[function] / 返回数字 number 的倒数.

        如果至少提供了一个分母 denominator, 函数[function] / 用所有分母 denominators 去除这个分子 numerator 并返回产生的商 quotient.

        如果每个实参[argument]都是一个整数[integer]或一个比数[ratio], 如果结果不是一个整数[integer], 那么就是一个比数[ratio].

        函数[function] / 执行必要的类型转换.

        如果任何实参 argument 是一个浮点数[float]那么就应用浮点数传递性规则; 见章节 12.1.4 (浮点计算).

* 示例(Examples):

    ```LISP
    (/ 12 4) =>  3
    (/ 13 4) =>  13/4
    (/ -8) =>  -1/8
    (/ 3 4 5) =>  3/20
    (/ 0.5) =>  2.0
    (/ 20 5) =>  4
    (/ 5 20) =>  1/4
    (/ 60 -2 3 5.0) =>  -2.0
    (/ 2 #c(2 2)) =>  #C(1/2 -1/2)
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果除了第一个以外的任何实参[argument]是 0 那么后果是不确定的. 如果这里只有一个实参[argument], 如果它是 0 那么后果是不确定的.

        如果某个实参[argument]不是一个数字[number], 可能发出一个 type-error 类型[type]的错误. 如果尝试去用 0 除可能发出一个 division-by-zero. 可能发出 arithmetic-error.

* 参见(See Also):

        floor, ceiling, truncate, round

* 注意(Notes): None. 

### <span id="F-OP-OI">函数 1+, 1-</span>

* 语法(Syntax):

        1+ number => successor

        1- number => predecessor

* 参数和值(Arguments and Values):

        number---一个数字[number].
        successor, predecessor---一个数字[number].

* 描述(Description):

        1+ 返回比它的参数 number 多一的数字[number]. 1- 返回比它的参数 number 少一的数字[number].

* 示例(Examples):

    ```LISP
    (1+ 99) =>  100 
    (1- 100) =>  99 
    (1+ (complex 0.0)) =>  #C(1.0 0.0) 
    (1- 5/3) =>  2/3 
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果它的实参[argument]不是一个数字[number], 那么可能发出 type-error 类型[type]的错误. 可能发出 arithmetic-error.

* 参见(See Also):

        incf, decf

* 注意(Notes):

        (1+ number) ==  (+ number 1)
        (1- number) ==  (- number 1)

        我们鼓励实现者使前面两个表达式的性能相同. 


### <span id="F-ABS">函数 ABS</span>

* 语法(Syntax):

        abs number => absolute-value

* 参数和值(Arguments and Values):

        number---一个数字[number].
        absolute-value---一个非负实数[real].

* 描述(Description):

        abs 返回数字 number 的绝对值.
 
        如果 number 是一个实数[real], 结果是和 number 相同类型[type]的.

        如果 number 是一个复数[complex], 结果是和 number 相同大小的一个正实数[real]. 即便这个数字 number 的部件是有理数[rational], 结果可以是一个浮点数[float], 而一个准确的有理数结果也是可能的. 因此 (abs #c(3 4)) 的结果可能是 5 或 5.0, 取决于具体实现.

* 示例(Examples):

    ```LISP
    (abs 0) =>  0
    (abs 12/13) =>  12/13
    (abs -1.09) =>  1.09
    (abs #c(5.0 -5.0)) =>  7.071068
    (abs #c(5 5)) =>  7.071068
    (abs #c(3/5 4/5)) =>  1 or approximately 1.0
    (eql (abs -0.0) -0.0) =>  true
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        章节 12.1.3.3 (浮点的置换性规则)

* 注意(Notes):

        如果数字 number 是一个复数[complex], 结果等价于以下:

        (sqrt (+ (expt (realpart number) 2) (expt (imagpart number) 2)))

        一个具体实现不应该直接将这个公式用于所有的复数[complex], 但是应该处理非常大或非常小的组件以避免中间的上溢或下溢. 

### <span id="F-EVENP-ODDP">函数 EVENP, ODDP</span>

* 语法(Syntax):

        evenp integer => generalized-boolean

        oddp integer => generalized-boolean

* 参数和值(Arguments and Values):

        integer---一个整数[integer].

        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果整数 integer 是偶数 (可以被 2 整除) evenp 返回 true; 否则, 返回 false.

        如果整数 integer 是奇数 (不能被 2 整除) oddp 返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (evenp 0) =>  true
    (oddp 10000000000000000000000) =>  false
    (oddp -1) =>  true
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 integer 不是一个整数[integer], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also): None.

* 注意(Notes):

        (evenp integer) ==  (not (oddp integer))
        (oddp integer)  ==  (not (evenp integer))


### <span id="F-EXP-EXPT">函数 EXP, EXPT</span>

* 语法(Syntax):

        exp number => result

        expt base-number power-number => result

* 参数和值(Arguments and Values):

        number---一个数字[number].
        base-number---一个数字[number].
        power-number---一个数字[number].
        result---一个数字[number].

* 描述(Description):

        exp 和 expt 执行求幂.

        exp 将 e 提升到幂 number 并返回, e 是自然对数的底数. exp 没有分支切割.

        expt 将 base-number 提升到幂 power-number 并返回. 如果这个 base-number 是一个有理数[rational]而 power-number 是一个整数[integer], 计算是准确的, 结果将是 rational 类型[type]的; 否则可能产生一个浮点近似值. 对于一个复有理数[complex rational]到整数[integer]幂的 expt, 计算一定是准确的并且结果是 (or rational (complex rational)) 类型的.

        即便每个参数都不是复数[complex], 如果 base-number 是负的并且 power-number 不是一个整数[integer], expt 的结果仍可以是一个复数[complex]. 结果总是为首要[principal]复数[complex]值[value]. 比如, (expt -8 1/3) 不允许返回 -2, 尽管 -2 是 -8 的立方根之一. 首要[principal]立方根是一个近似等于 #C(1.0 1.73205), 而不是 -2 的复数[complex].

        expt 被定义为 b^x = e^x log b. 这就精确地定义了首要[principal]值[value]. expt 的范围是整个复数域. 视为 x 的函数, 其中 b 固定, 这里没有分支切割. 视为 b 的函数, 其中 x 固定, 这里通常没有沿着负实轴和第二象限相连的分支切割. 这个区域排除了原点. 按照定义, 0^0=1. 如果 b=0 和 x 的实部是严格正的, 那么 b^x=0. 对于所有其他 x 的值, 0^x 是一个错误.

        当 power-number 是一个整数[integer] 0, 那么结果总是为 base-number 的类型[type]的值 1, 即便 base-number 是 0 (任何类型[type]的). 就是说:

        (expt x 0) ==  (coerce 1 (type-of x))

        如果 power-number 是一个其他任何类型[type]的 0, 那么结果也是值 1, 以章节 12.1.1.2 (数值运算的传递性) 的传递性规则应用后的参数类型[type], 有一个例外: 如果 base-number 是 0 当 power-number 是 zero 并且不是 integer 类型[type]时, 后果是未定义的.

* 示例(Examples):

    ```LISP
    (exp 0) =>  1.0
    (exp 1) =>  2.718282
    (exp (log 5)) =>  5.0 
    (expt 2 8) =>  256
    (expt 4 .5) =>  2.0
    (expt #c(0 1) 2) =>  -1
    (expt #c(2 2) 3) =>  #C(-16 16)
    (expt #c(2 2) 4) =>  -64 
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        log, 章节 12.1.3.3 (浮点的置换性规则)

* 注意(Notes):

        expt 的具体实现允许去为一个 rational 类型[type]的 power-number 和一个 float 类型[type]的 power-number 的情况使用不同的算法.

        请注意以下逻辑, (sqrt (expt x 3)) 不等价于 (expt x 3/2).

        (setq x (exp (/ (* 2 pi #c(0 1)) 3)))         ;exp(2.pi.i/3)
        (expt x 3) =>  1 ;except for round-off error
        (sqrt (expt x 3)) =>  1 ;except for round-off error
        (expt x 3/2) =>  -1 ;except for round-off error



### <span id="F-GCD">函数 GCD</span>

* 语法(Syntax):

        gcd &rest integers => greatest-common-denominator

* 参数和值(Arguments and Values):

        integer---一个整数[integer].
        greatest-common-denominator---一个非负整数[integer].

* 描述(Description):

        返回这些整数 integers 的最大公约数. 如果只提供了一个整数 integer, 返回它的绝对值. 如果没有提供整数 integers, gcd 返回 0, 这是这个操作符的一个特性.

* 示例(Examples):

    ```LISP
    (gcd) =>  0
    (gcd 60 42) =>  6
    (gcd 3333 -33 101) =>  1
    (gcd 3333 -33 1002001) =>  11
    (gcd 91 -49) =>  7
    (gcd 63 -42 35) =>  7
    (gcd 5) =>  5
    (gcd -4) =>  4
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果任何一个 integer 不是一个整数[integer], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        lcm

* 注意(Notes):

        对于三个或更多参数,

        (gcd b c ... z) ==  (gcd (gcd a b) c ... z)


### <span id="M-INCF-DECF">宏 INCF, DECF</span>

* 语法(Syntax):

        incf place [delta-form] => new-value

        decf place [delta-form] => new-value

* 参数和值(Arguments and Values):

        place---一个位置[place].
        delta-form---一个表达式形式[form]; 用来求值产生一个差值 delta. 默认是 1.
        delta---一个数字[number].
        new-value---一个数字[number].

* 描述(Description):

        incf 和 decf 分别被用于递增或递减位置 place 的值[value].

        这个差值 delta 会被添加到 place 中的数 (在 incf 的情况中) 或者从 place 中的数中减去 (在 decf 的情况中) 然后结果存储到 place 中.

        自动执行任何必要的类型转换.

        关于 places 的子表达式形式[subform]的求值[evaluation]信息, 见章节 5.1.1.1 (位置的子表达式形式求值).

* 示例(Examples):

    ```LISP
    (setq n 0)
    (incf n) =>  1      
    n =>  1
    (decf n 3) =>  -2   
    n =>  -2
    (decf n -5) =>  3      
    (decf n) =>  2      
    (incf n 0.5) =>  2.5
    (decf n) =>  1.5
    n =>  1.5
    ```

* 副作用(Side Effects):

        place 会被修改.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        +, -, 1+, 1-, setf

* 注意(Notes): None. 

### <span id="F-LCM">函数 LCM</span>

* 语法(Syntax):

        lcm &rest integers => least-common-multiple

* 参数和值(Arguments and Values):

        integer---一个整数[integer].
        least-common-multiple---一个非负整数[integer].

* 描述(Description):

        lcm 返回这些整数 integers 的最小公倍数.

        如果没有提供整数 integer, 返回整数[integer] 1.

        如果只提供一个整数 integer, 返回那个整数 integer 的绝对值.

        对于两个不是 0 的参数,

        (lcm a b) ==  (/ (abs (* a b)) (gcd a b))

        如果一个参数为 0 或两个参数都为 0,

        (lcm a 0) ==  (lcm 0 a) ==  0

        对于三个或更多参数,

        (lcm a b c ... z) ==  (lcm (lcm a b) c ... z)

* 示例(Examples):

    ```LISP
    (lcm 10) =>  10
    (lcm 25 30) =>  150
    (lcm -24 18 10) =>  360
    (lcm 14 35) =>  70
    (lcm 0 5) =>  0
    (lcm 1 2 3 4 5 6) =>  60
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果任何一个参数不是整数[integer], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        gcd

* 注意(Notes): None. 


### <span id="F-LOG">函数 LOG</span>

* 语法(Syntax):

        log number &optional base => logarithm

* 参数和值(Arguments and Values):

        number---一个非零数字[number].
        base---一个数字[number].
        logarithm---一个数字[number].

* 描述(Description):

        log 返回数字 number 在基数 base 下的对数. 如果没有提供基数 base, 那么它的值就是 e, 也就是那个自然对数的基数.

        当给定一个负实数[real] number 时, log 可能返回一个复数[complex].

        (log -1.0) ==  (complex 0.0 (float pi 0.0))

        如果基数 base 是 zero, log 返回 zero.

        (log 8 2) 的结果可能是 3 或 3.0, 取决于具体实现. 即便一个整数结果是可能的, 一个具体实现仍可以使用浮点计算.

        这个单参数的对数函数 (自然对数) 的分支切割位于沿着负实轴, 与第二象限相连的区域. 这个区域不包括原点.

        复对数的数学定义如下, 不管具体实现是否支持负零:

        (log x) ==  (complex (log (abs x)) (phase x))

        因此这个单参数对数函数的范围是那个在不支持负零时包含虚部在 -<PI> (不包含) 和 <PI> (包含) 之间的复数带以及支持负零时包含虚部在 -<PI> (包含) 和 <PI> (包含) 之间的复数带.

        两个参数的对数函数被定义为

        (log base number)
        ==  (/ (log number) (log base))

        这就精确地定义了首要[principal]值[value]. 这个两个参数的对数函数的范围是整个复数域.

* 示例(Examples):

    ```LISP
    (log 100 10)
    =>  2.0
    =>  2
    (log 100.0 10) =>  2.0
    (log #c(0 1) #c(0 -1))
    =>  #C(-1.0 0.0)
    OR=>  #C(-1 0)
    (log 8.0 2) =>  3.0

    (log #c(-16 16) #c(2 2)) =>  3 or approximately #c(3.0 0.0)
                                  or approximately 3.0 (unlikely)
    ```

* 受此影响(Affected By):

        具体实现.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        exp, expt, 章节 12.1.3.3 (浮点的置换性规则)

* 注意(Notes): None. 

### <span id="F-MOD-REM">函数 MOD, REM</span>

* 语法(Syntax):

        mod number divisor => modulus

        rem number divisor => remainder

* 参数和值(Arguments and Values):

        number---一个实数[real].
        divisor---一个实数[real].
        modulus, remainder---一个实数[real].

* 描述(Description):

        mod 和 rem 分别是模量和剩余函数的泛化.

        mod 在数字 number 和除数 divisor 上执行操作 floor 并且返回这个 floor 操作的余数.

        rem 在数字 number 和除数 divisor 上执行操作 truncate 并且返回这个 truncate 操作的余数.

        当数字 number 和除数 divisor 都是整数[integer]时, mod 和 rem 是模量和剩余函数.

* 示例(Examples):

    ```LISP
    (rem -1 5) =>  -1
    (mod -1 5) =>  4
    (mod 13 4) =>  1
    (rem 13 4) =>  1
    (mod -13 4) =>  3
    (rem -13 4) =>  -1
    (mod 13 -4) =>  -3
    (rem 13 -4) =>  1
    (mod -13 -4) =>  -1
    (rem -13 -4) =>  -1
    (mod 13.4 1) =>  0.4
    (rem 13.4 1) =>  0.4
    (mod -13.4 1) =>  0.6
    (rem -13.4 1) =>  -0.4
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        floor, truncate

* 注意(Notes):

        mod 的结果是 0 或一个带有和 divisor 相同符号的实数. 

### <span id="F-SIGNUM">函数 SIGNUM</span>

* 语法(Syntax):

        signum number => signed-prototype

* 参数和值(Arguments and Values):

        number---一个数字[number].
        signed-prototype---一个数字[number].

* 描述(Description):

        signum 确定一个表示数字 number 是否为负数, 0, 或正数的一个数字值.

        对于一个有理数[rational], signum 根据数字 number 是否为负数, 0, 或正数来返回 -1, 0, 或 1 的其中一个. 对于一个浮点数[float], 结果是一个相同格式的浮点数[float], 它的值为负一, 零, 或一. 对于一个复数[complex] z, (signum z) 是同阶的单位大小的复数, 但单位大小, 除非 z 是复数 0, 在这种情况下, 结果是 z.

        对于有理数[rational]实参[argument], signum 是一个有理数学函数, 但是它对于一个复数参数可能是无理数的.

        如果数字 number 是一个浮点数[float], 结果是一个浮点数[float]. 如果数字 number 是一个有理数[rational], 结果就是一个有理数[rational]. 如果数字 number 是一个复浮点数[complex float], 结果就是一个复浮点数[complex float]. 如果数字 number 是一个复有理数[complex rational], 结果就是一个复数[complex], 但是它的结果是一个复有理数[complex rational]还是一个负浮点数[complex float]是依赖于具体实现的[implementation-dependent].

* 示例(Examples):

    ```LISP
    (signum 0) =>  0
    (signum 99) =>  1
    (signum 4/5) =>  1
    (signum -99/100) =>  -1
    (signum 0.0) =>  0.0
    (signum #c(0 33)) =>  #C(0.0 1.0)
    (signum #c(7.5 10.0)) =>  #C(0.6 0.8)
    (signum #c(0.0 -14.7)) =>  #C(0.0 -1.0)
    (eql (signum -0.0) -0.0) =>  true
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        章节 12.1.3.3 (浮点的置换性规则)

* 注意(Notes):

        (signum x) ==  (if (zerop x) x (/ x (abs x)))



### <span id="F-SQRT-ISQRT">函数 SQRT, ISQRT</span>

* 语法(Syntax):

        sqrt number => root

        isqrt natural => natural-root

* 参数和值(Arguments and Values):

        number, root---一个数字[number].
        natural, natural-root---一个非负整数[integer].

* 描述(Description):

        sqrt 和 isqrt 计算平方根.

        sqrt 返回数字 number 的首要[principal]平方根. 如果数字 number 不是一个复数[complex]但是是负的, 那么结果就是一个复数[complex].

        isqrt 返回小于等于自然数 natural 准确平方根的最大整数[integer].

        如果数字 number 是一个正有理数[rational], 那么平方根 root 是一个有理数[rational]还是一个浮点数[rational]是依赖于具体实现的[implementation-dependent]. 如果数字 number 是一个负有理数[rational], 那么平方根 root 是一个复有理数[complex rational]还是一个复浮点数[complex float].

        复数平方根的数学定义 (不管是否支持 -0)) 如下:

        (sqrt x) = (exp (/ (log x) 2))

        平方根的分支切割位于沿着负实轴, 与第二象限相连. 这个返回由右半平面组成, 包括非负的虚轴, 不包括负的虚轴.

* 示例(Examples):

    ```LISP
    (sqrt 9.0) =>  3.0
    (sqrt -9.0) =>  #C(0.0 3.0)
    (isqrt 9) =>  3
    (sqrt 12) =>  3.4641016
    (isqrt 12) =>  3
    (isqrt 300) =>  17
    (isqrt 325) =>  18
    (sqrt 25)
    =>  5
    OR=>  5.0
    (isqrt 25) =>  5
    (sqrt -1) =>  #C(0.0 1.0)
    (sqrt #c(0 2)) =>  #C(1.0 1.0)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果参数不是一个数字[number], 函数[function] sqrt 应该发出一个 type-error 类型[type]的错误.

        如果参数不是一个非负整数[integer], 函数[function] isqrt 应该发出一个 type-error 类型[type]的错误.

        函数 sqrt 和 isqrt 可能发出 arithmetic-error.

* 参见(See Also):

        exp, log, 章节 12.1.3.3 (浮点的置换性规则)

* 注意(Notes):

        (isqrt x) ==  (values (floor (sqrt x))) 

        但它可能更有效率. 


### <span id="SC-RANDOM-STATE">系统类 RANDOM-STATE</span>

* 类优先级列表(Class Precedence List):

        random-state, t

* 描述(Description):

        一个随机状态[random state]对象[object]包含了被伪随机数字生成器使用的状态信息. 一个随机状态[random state]对象[object]的性质是依赖于具体实现的[mplementation-dependent]. 它可以被打印出来并且被相同的具体实现[implementation]读回去, 但是在另一个实现[implementation]中可能不能正确地作为一个随机状态随机状态[random state]运行.

        具体实现[implementation]需要去为 random-state 类型[type]的对象[object]提供一个读取语法, 但是那个语法的具体的特性是依赖于具体实现的[implementation-dependent].

* 参见(See Also):

        *random-state*, random, 章节 22.1.3.10 (打印随机状态) 


### <span id="F-MAKE-RANDOM-STATE">函数 MAKE-RANDOM-STATE</span>

* 语法(Syntax):

        make-random-state &optional state => new-state

* 参数和值(Arguments and Values):

        state---一个随机状态[random state], 或 nil, 或 t. 默认是 nil.
        new-state---一个随机状态[random state]对象[object].

* 描述(Description):

        创建一个适合用作 *random-state* 的值[value]的 random-state 类型[type]的新[fresh]对象[object].

        如果状态 state 是一个随机状态[random state]对象[object], 那么这个 new-state 是那个对象[object]的一个拷贝[copy[5]]. 如果状态 state 是 nil, 新的状态 new-state 是当前随机状态[current random state]的一个拷贝[copy[5]]. 如果状态 state 是 t, 那么新状态 new-state 是一个通过某种方式被随机初始化的新的[fresh]随机状态[random state]对象[object].

* 示例(Examples):

    ```LISP
    (let* ((rs1 (make-random-state nil))
            (rs2 (make-random-state t))
            (rs3 (make-random-state rs2))
            (rs4 nil))
      (list (loop for i from 1 to 10 
                  collect (random 100)
                  when (= i 5)
                    do (setq rs4 (make-random-state)))
            (loop for i from 1 to 10 collect (random 100 rs1))
            (loop for i from 1 to 10 collect (random 100 rs2))
            (loop for i from 1 to 10 collect (random 100 rs3))
            (loop for i from 1 to 10 collect (random 100 rs4))))
    =>  ((29 25 72 57 55 68 24 35 54 65)
        (29 25 72 57 55 68 24 35 54 65)
        (93 85 53 99 58 62 2 23 23 59)
        (93 85 53 99 58 62 2 23 23 59)
        (68 24 35 54 65 54 55 50 59 49))
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 state 不是一个随机状态[random state], 或 nil, 或 t, 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        random, *random-state*

* 注意(Notes):

        make-random-state 一个重要的使用是允许在单个程序中同样的一系列伪随机数字[number]被生成多次. 

### <span id="F-RANDOM">函数 RANDOM</span>

* 语法(Syntax):

        random limit &optional random-state => random-number

* 参数和值(Arguments and Values):

        limit---一个正整数[integer], 或者一个正浮点数[float].
        random-state---一个随机状态[random state]. 默认是当前随机状态[current random state].
        random-number---一个小于 limit 并且和 limit 相同类型[type]的非负数字[number].

* 描述(Description):

        返回一个小于 limit 并且和 limit 相同类型[type]的非负伪随机数字[number].

        被这个函数修改的随机状态 random-state 编码由这个随机数生成器维护的内部状态.

        使用了一个近似均匀的选择分布. 如果 limit 是一个整数[integer], 每一个可能的结果发生的可能性 (近似) 是 1/limit.

* 示例(Examples):

    ```LISP
    (<= 0 (random 1000) 1000) =>  true
    (let ((state1 (make-random-state))
          (state2 (make-random-state)))
      (= (random 1000 state1) (random 1000 state2))) =>  true
    ```

* 副作用(Side Effects):

        这个随机状态 random-state 被修改.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 limit 不是一个正整数[integer]或一个正实数[real], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        make-random-state, *random-state*

* 注意(Notes):

        关于生成随机数的信息见 Common Lisp: The Language. 


### <span id="F-RANDOM-STATE-P">函数 RANDOM-STATE-P</span>

* 语法(Syntax):

        random-state-p object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 random-state 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (random-state-p *random-state*) =>  true
    (random-state-p (make-random-state)) =>  true
    (random-state-p 'test-function) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        make-random-state, *random-state*

* 注意(Notes):

        (random-state-p object) ==  (typep object 'random-state)


### <span id="V-RANDOM-STATE">变量 *RANDOM-STATE*</span>

* 值类型(Value Type):

        一个随机状态[random state].

* 初始值(Initial Value):

        依赖于具体实现[implementation-dependent].

* 描述(Description):

        当前随机状态[current random state], 比如, 当一个随机状态[random state]没有提供给 random 函数[function]时, 它会被使用.

* 示例(Examples):

    ```LISP
    (random-state-p *random-state*) =>  true
    (setq snap-shot (make-random-state))
    ;; The series from any given point is random,
    ;; but if you backtrack to that point, you get the same series.
    (list (loop for i from 1 to 10 collect (random))
          (let ((*random-state* snap-shot))
            (loop for i from 1 to 10 collect (random)))
          (loop for i from 1 to 10 collect (random))
          (let ((*random-state* snap-shot))
            (loop for i from 1 to 10 collect (random))))
    =>  ((19 16 44 19 96 15 76 96 13 61)
        (19 16 44 19 96 15 76 96 13 61)
        (16 67 0 43 70 79 58 5 63 50)
        (16 67 0 43 70 79 58 5 63 50))
    ```

* 受此影响(Affected By):

        具体实现[implemnetation].

        random.

* 参见(See Also):

        make-random-state, random, random-state

* 注意(Notes):

        将 *random-state* 绑定[binding]到一个不同的随机状态[random state]对象[object]时, 正确地保存和还原旧的随机状态[random state]对象[object]. 


### <span id="F-NUMBERP">函数 NUMBERP</span>

* 语法(Syntax):

        numberp object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 number 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (numberp 12) =>  true
    (numberp (expt 2 130)) =>  true
    (numberp #c(5/3 7.2)) =>  true
    (numberp nil) =>  false
    (numberp (cons 1 2)) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes):

        (numberp object) ==  (typep object 'number)


### <span id="F-CIS">函数 CIS</span>

* 语法(Syntax):

        cis radians => number

* 参数和值(Arguments and Values):

        radians---一个实数[real].
        number---一个复数[complex].

* 描述(Description):

        cis 返回 e^i* radians 的值, 它是一个实部等价于弧度 radians 的余弦并且虚部等价于弧度 radians 的正弦的复数[complex].

* 示例(Examples):

    ```LISP
    (cis 0) =>  #C(1.0 0.0)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        章节 12.1.3.3 (浮点的置换性规则)

* 注意(Notes): None. 

### <span id="F-COMPLEX">函数 COMPLEX</span>

* 语法(Syntax):

        complex realpart &optional imagpart => complex

* 参数和值(Arguments and Values):

        realpart---一个实数[real].
        imagpart---一个实数[real].
        complex---一个有理数[rational]或一个复数[complex].

* 描述(Description):

        complex 返回一个实部为 realpart 并且虚部为 imagpart 的数字[number].

        如果 realpart 是一个有理数[rational]并且虚部是一个有理数[rational] 0, 那么 complex 结果是一个有理数[rational] realpart. 否则, 结果就是一个复数[complex].

        如果 realpart 或 imagpart 任意一个是浮点数[float], 那么非浮点数在这个复数[complex]被创建之前被转化为一个浮点数[float]. 如果 imagpart 没有被提供, 这个虚部就是和实部相同类型[type]的零; 换句话说, 实际使用 (coerce 0 (type-of realpart)).

        类型提升意味着在类型层次结构中向上移动. 在复数[complex]的情况下, 这个类型指定符 type-specifier 必须是 (upgraded-complex-part-type type-specifier) 的子类型. 如果类型指定符 type-specifier1 是类型指定符 type-specifier2 的子类型, 那么 (upgraded-complex-element-type 'type-specifier1) 必须也是 (upgraded-complex-element-type 'type-specifier2) 的一个子类型. 两个互斥的类型可以被提升到同一个类型.

* 示例(Examples):

    ```LISP
    (complex 0) =>  0
    (complex 0.0) =>  #C(0.0 0.0)
    (complex 1 1/2) =>  #C(1 1/2)
    (complex 1 .99) =>  #C(1.0 0.99)
    (complex 3/2 0.0) =>  #C(1.5 0.0)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        realpart, imagpart, 章节 2.4.8.11 (井号C(#C))

* 注意(Notes): None. 


### <span id="F-COMPLEXP">函数 COMPLEXP</span>

* 语法(Syntax):

        complexp object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是类型[type] complex 就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (complexp 1.2d2) =>  false
    (complexp #c(5/3 7.2)) =>  true
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        complex (函数[function]和类型[type]), typep

* 注意(Notes):

        (complexp object) ==  (typep object 'complex)


### <span id="F-CONJUGATE">函数 CONJUGATE</span>

* 语法(Syntax):

        conjugate number => conjugate

* 参数和值(Arguments and Values):

        number---一个数字[number].
        conjugate---一个数字[number].

* 描述(Description):

        返回数字 number 的复变位数(conjugate). 一个实数[real]的复变位数(conjugate) 是它自身.

* 示例(Examples):

    ```LISP
    (conjugate #c(0 -1)) =>  #C(0 1)
    (conjugate #c(1 1)) =>  #C(1 -1)
    (conjugate 1.5) =>  1.5
    (conjugate #C(3/5 4/5)) =>  #C(3/5 -4/5)
    (conjugate #C(0.0D0 -1.0D0)) =>  #C(0.0D0 1.0D0)
    (conjugate 3.7) =>  3.7
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes):

        对于一个复数[complex] z,

        (conjugate z) ==  (complex (realpart z) (- (imagpart z)))


### <span id="F-PHASE">函数 PHASE</span>

* 语法(Syntax):

        phase number => phase

* 参数和值(Arguments and Values):

        number---一个数字[number].
        phase---一个数字[number].

* 描述(Description):

        phase 返回表示弧度的数字 number 的相位 (它的极坐标表示的角度部分), 如果不支持负零, 那么范围就在 -<PI> (不包含) 到 <PI> (包含) 之间, 如果支持负零, 那么返回就在 -<PI> (包含) 到 <PI> (包含) 之间. 正实数的相位是零; 对于复实数就是 <PI>. 零的相位被定义为零.

        如果数字 number 是一个复浮点数[complex float], 结果就是和 number 各部分相同类型[type]的浮点数[float]. 如果数字 number 是一个浮点数[float], 结果就是一个相同类型[type]的浮点数[float]. 如果数字 number 是一个有理数[rational]或一个复有理数[complex rational], 结果就是一个单浮点数[single float].

        phase 的分支切割位于沿着复实轴, 与第二象限相连的部分. 范围由 -<PI> (不包含) 和 <PI> (不包含) 之间的实轴组成.

        这个 phase 的数学定义如下:

        (phase x) = (atan (imagpart x) (realpart x))

* 示例(Examples):

    ```LISP
    (phase 1) =>  0.0s0
    (phase 0) =>  0.0s0
    (phase (cis 30)) =>  -1.4159266
    (phase #c(0 1)) =>  1.5707964
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果它的参数不是一个数字[number]就应该发出一个 type-error 类型的错误. 可能发出 arithmetic-error.

* 参见(See Also):

        章节 12.1.3.3 (浮点的置换性规则)

* 注意(Notes): None. 


### <span id="F-REALPART-IMAGPART">函数 REALPART, IMAGPART</span>

* 语法(Syntax):

        realpart number => real

        imagpart number => real

* 参数和值(Arguments and Values):

        number---一个数字[number].
        real---一个实数[real].

* 描述(Description):

        realpart 和 imagpart 分别返回数字 number 的实部和虚部. 如果数字 number 是一个实数[real], 那么 realpart 返回数字 number 而 imagpart 返回 (* 0 number), 它的作用是, 一个有理数[rational]的虚部是 0 而浮点数[float]是相同格式的浮点数零.

* 示例(Examples):

    ```LISP
    (realpart #c(23 41)) =>  23
    (imagpart #c(23 41.0)) =>  41.0
    (realpart #c(23 41.0)) =>  23.0
    (imagpart 23.0) =>  0.0
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 number 不是一个数字[number], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        complex

* 注意(Notes): None. 


### <span id="F-UPGRADED-COMPLEX-PART-TYPE">函数 UPGRADED-COMPLEX-PART-TYPE</span>

* 语法(Syntax):

        upgraded-complex-part-type typespec &optional environment => upgraded-typespec

* 参数和值(Arguments and Values):

        typespec---一个类型指定符[type specifier].
        environment---一个环境[environment]对象[object]. 默认是 nil, 表示空词法环境[null lexical environment]和当前全局环境[global environment].
        upgraded-typespec---一个类型指定符[type specifier].

* 描述(Description):

        upgraded-complex-part-type 返回可以持有类型[type] typespec 的部分的最具体的复数[complex]表示的部分类型.

        这个 typespec 是 upgraded-typespec 的一个子类型[subtype] (也可能是类型等价的[type equivalent]).

        upgraded-complex-part-type 的目的是去揭露一个具体实现如何执行它的提升[upgrade].

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        complex (函数[function]和类型[type])

* 注意(Notes):

### <span id="F-REALP">函数 REALP</span>

* 语法(Syntax):

        realp object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[real].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 不是 real 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (realp 12) =>  true
    (realp #c(5/3 7.2)) =>  false
    (realp nil) =>  false
    (realp (cons 1 2)) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes):

        (realp object) ==  (typep object 'real)


### <span id="F-NUMERATOR-DENOMINATOR">函数 NUMERATOR, DENOMINATOR</span>

* 语法(Syntax):

        numerator rational => numerator

        denominator rational => denominator

* 参数和值(Arguments and Values):

        rational---一个有理数[rational].
        numerator---一个整数[integer].
        denominator---一个正整数[integer].

* 描述(Description):

        numerator 和 denominator 分解有理数 rational 为规范形式并计算那个数字的分子和分母.

        numerator 和 denominator 返回有理数 rational 的规范形式的分子和分母.

        如果有理数 rational 是一个整数[integer], numerator 返回有理数并且 denominator 返回 1.

* 示例(Examples):

    ```LISP
    (numerator 1/2) =>  1
    (denominator 12/36) =>  3
    (numerator -1) =>  -1
    (denominator (/ -33)) =>  33
    (numerator (/ 8 -6)) =>  -4
    (denominator (/ 8 -6)) =>  3
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        /

* 注意(Notes):

        (gcd (numerator x) (denominator x)) =>  1


### <span id="F-RATIONAL-RATIONALIZE">函数 RATIONAL, RATIONALIZE</span>

* 语法(Syntax):

        rational number => rational

        rationalize number => rational

* 参数和值(Arguments and Values):

        number---一个实数[real].
        rational---一个有理数[rational].

* 描述(Description):

        rational 和 rationalize 转换这些实数 reals 为有理数[rational].

        如果数字 number 已经是一个有理数[rational], 它就会被返回.

        如果数字 number 是一个浮点数[float], rational 返回一个在数学上等价于这个浮点数[float]的有理数[rational]. rationalize 返回一个有理数[rational], 它将该浮点数[float]近似为底层浮点表示的精度.

        rational 假定这个浮点数[float]是完全准确的.

        rationalize 假定那个浮点数[float]仅对于那个浮点表示的精度是精确的.

* 示例(Examples):

    ```LISP
    (rational 0) =>  0
    (rationalize -11/100) =>  -11/100
    (rational .1) =>  13421773/134217728 ;implementation-dependent
    (rationalize .1) =>  1/10
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        具体实现[implementation].

* 异常情况(Exceptional Situations):

        如果数字 number 不是一个实数[real], 那么应该发出一个 type-error 类型[type]的错误. 可能发出 arithmetic-error.

* 参见(See Also): None.

* 注意(Notes):

        情况总是如下

        (float (rational x) x) ==  x

        并且

        (float (rationalize x) x) ==  x

        这也就是说, 通过任意一个方法来有理化一个浮点数[float], 然后把它转换会一个相同格式的浮点数[float]会产生原始的数字 number. 

### <span id="F-RATIONALP">函数 RATIONALP</span>

* 语法(Syntax):

        rationalp object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 rational 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (rationalp 12) =>  true
    (rationalp 6/5) =>  true
    (rationalp 1.212) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        rational

* 注意(Notes):

        (rationalp object) ==  (typep object 'rational)


### <span id="F-ASH">函数 ASH</span>

* 语法(Syntax):

        ash integer count => shifted-integer

* 参数和值(Arguments and Values):

        integer---一个整数[integer].
        count---一个整数[integer].
        shifted-integer---一个整数[integer].

* 描述(Description):

        ash 在整数 integer 的二进制表示上执行算术位移操作, 这个整数被当作二进制数对待.

        如果 count 是正的 ash 就将整数 integer 左位移 count 位, 如果 count 是负的就右位移 count 位. 返回和整数 integer 相同符号的位移后的值.

        数学上说, ash 执行计算 floor(integer*2^count). 逻辑上, ash 移动整数 integer 中的所有位到左边, 在右边用零位填充, 或者移动它们到右边, 丢弃那些位.

        ash 被定义为行为上表现得就好像整数 integer 是以两个补码的形式表示的, 不管这些整数[integer]内部怎么表示.

* 示例(Examples):

    ```LISP
    (ash 16 1) =>  32
    (ash 16 0) =>  16
    (ash 16 -1) =>  8
    (ash -100000000000000000000000000000000 -100) =>  -79
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 integer 不是一个整数[integer]那么应该发出一个 type-error 类型[type]的错误. 如果 count 不是一个整数[integer]那么应该发出一个 type-error 类型[type]的错误. 可能发出 arithmetic-error.

* 参见(See Also): None.

* 注意(Notes):

        (logbitp j (ash n k))
        ==  (and (>= j k) (logbitp (- j k) n))


### <span id="F-INTEGER-LENGTH">函数 INTEGER-LENGTH</span>

* 语法(Syntax):

        integer-length integer => number-of-bits

* 参数和值(Arguments and Values):

        integer---一个整数[integer].
        number-of-bits---一个非负整数[integer].

* 描述(Description):

        返回以二进制补码形式去表示整数 integer 所需的位数.

* 示例(Examples):

    ```LISP
    (integer-length 0) =>  0
    (integer-length 1) =>  1
    (integer-length 3) =>  2
    (integer-length 4) =>  3
    (integer-length 7) =>  3
    (integer-length -1) =>  0
    (integer-length -4) =>  2
    (integer-length -7) =>  3
    (integer-length -8) =>  3
    (integer-length (expt 2 9)) =>  10
    (integer-length (1- (expt 2 9))) =>  9
    (integer-length (- (expt 2 9))) =>  9
    (integer-length (- (1+ (expt 2 9)))) =>  10
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 integer 不是一个整数[integer]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also): None.

* 注意(Notes):

        这个函数可以这样被定义:

    ```LISP
    (defun integer-length (integer)
      (ceiling (log (if (minusp integer)
                        (- integer)
                        (1+ integer))
                    2)))
    ```

        如果整数 integer 非负, 那么它的值就可以用无符号的二进制形式表示在一个宽度不小于 (integer-length integer) 的字段中. 不管整数 integer 的符号, 它的值可以用带符号的二进制补码形式表示在一个位宽度不小于 (+ (integer-length integer) 1) 的字段中. 


### <span id="F-INTEGERP">函数 INTEGERP</span>

* 语法(Syntax):

        integerp object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象是 integer 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (integerp 1) =>  true
    (integerp (expt 2 130)) =>  true
    (integerp 6/5) =>  false
    (integerp nil) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes):

        (integerp object) ==  (typep object 'integer)


### <span id="F-PARSE-INTEGER">函数 PARSE-INTEGER</span>

* 语法(Syntax):

        parse-integer string &key start end radix junk-allowed => integer, pos

* 参数和值(Arguments and Values):

        string---一个字符串[string].
        start, end---字符串 string 的边界下标标识符[bounding index designator]. 默认的 start 和 end 分别为 0 和 nil.
        radix---一个基数[radix]. 默认是 10.
        junk-allowed---一个广义 boolean [generalized boolean]. 默认是 false.
        integer---一个整数[integer]或者 false.
        pos---字符串 string 的边界下标[bounding index].

* 描述(Description):

        parse-integer 从由 start 和 end 限定的字符串 string 的子字符串中以指定基数 radix 来解析一个整数[integer].

        parse-integer 预期一个可选的符号 (+ 或 -) 后面跟着一个被解释为指定基数 radix 的非空数字序列. 可选的前后空格[whitespace[1]]会被忽略.

        parse-integer 不识别语法的进制指定符前缀 #O, #B, #X, 和 #nR, 也不识别一个尾随的小数点.

        如果 junk-allowed 是 false, 如果子字符串不是完全由一个带符号整数[integer]表示, 可能周围存在空白[whitespace[1]]字符[character], 那么会发出一个 parse-error 类型[type]的错误.

        返回的第一个值[value]是被解析得到的整数[integer], 如果没有发现语法上正确的整数[integer]但是 junk-allowed 是 true 那么就是 nil.

        第二个值[value]是这个字符串[string]中终止这个解析的定界符的下标, 或者如果这个解析在子字符串的最后终止, 那么就是字符串的上边界[bounding index] (如果 junk-allowed 为 false 则情况总是如此).

* 示例(Examples):

    ```LISP
    (parse-integer "123") =>  123, 3
    (parse-integer "123" :start 1 :radix 5) =>  13, 3
    (parse-integer "no-integer" :junk-allowed t) =>  NIL, 0
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 junk-allowed 是 false, 如果子字符串不是完全由一个整数[integer]表示, 可能周围存在空白[whitespace[1]]字符, 那么就会发出一个错误.

* 参见(See Also): None.

* 注意(Notes): None. 


### <span id="F-BOOLE">函数 BOOLE</span>

* 语法(Syntax):

        boole op integer-1 integer-2 => result-integer

* 参数和值(Arguments and Values):

        op---一个位逻辑操作指定符[bit-wise logical operation specifier].
        integer-1---一个整数[integer].
        integer-2---一个整数[integer].
        result-integer---一个整数[integer].

* 描述(Description):

        boole 在整数 integer-1 和 integer-2 上执行一个位逻辑操作符, 它们被当作是以两个补码表示的二进制数.

        要执行的操作符和返回值由操作符 op 决定.

        boole 返回下面这段中的操作符 op 指定的值.

            Op           Result                                      
            boole-1      integer-1                                   
            boole-2      integer-2                                   
            boole-andc1  and complement of integer-1 with integer-2  
            boole-andc2  and integer-1 with complement of integer-2  
            boole-and    and                                         
            boole-c1     complement of integer-1                     
            boole-c2     complement of integer-2                     
            boole-clr    always 0 (all zero bits)                    
            boole-eqv    equivalence (exclusive nor)                 
            boole-ior    inclusive or                                
            boole-nand   not-and                                     
            boole-nor    not-or                                      
            boole-orc1   or complement of integer-1 with integer-2   
            boole-orc2   or integer-1 with complement of integer-2   
            boole-set    always -1 (all one bits)                    
            boole-xor    exclusive or                                

            Figure 12-17. 位逻辑操作符

* 示例(Examples):

    ```LISP
    (boole boole-ior 1 16) =>  17
    (boole boole-and -2 5) =>  4
    (boole boole-eqv 17 15) =>  -31

    ;;; These examples illustrate the result of applying BOOLE and each
    ;;; of the possible values of OP to each possible combination of bits.
    (progn
      (format t "~&Results of (BOOLE <op> #b0011 #b0101) ...~
              ~%---Op-------Decimal-----Binary----Bits---~%")
      (dolist (symbol '(boole-1     boole-2    boole-and  boole-andc1
                        boole-andc2 boole-c1   boole-c2   boole-clr
                        boole-eqv   boole-ior  boole-nand boole-nor
                        boole-orc1  boole-orc2 boole-set  boole-xor))
        (let ((result (boole (symbol-value symbol) #b0011 #b0101)))
          (format t "~& ~A~13T~3,' D~23T~:*~5,' B~31T ...~4,'0B~%" 
                  symbol result (logand result #b1111)))))
    >>  Results of (BOOLE <op> #b0011 #b0101) ...
    >>  ---Op-------Decimal-----Binary----Bits---
    >>   BOOLE-1       3          11    ...0011
    >>   BOOLE-2       5         101    ...0101
    >>   BOOLE-AND     1           1    ...0001
    >>   BOOLE-ANDC1   4         100    ...0100
    >>   BOOLE-ANDC2   2          10    ...0010
    >>   BOOLE-C1     -4        -100    ...1100
    >>   BOOLE-C2     -6        -110    ...1010
    >>   BOOLE-CLR     0           0    ...0000
    >>   BOOLE-EQV    -7        -111    ...1001
    >>   BOOLE-IOR     7         111    ...0111
    >>   BOOLE-NAND   -2         -10    ...1110
    >>   BOOLE-NOR    -8       -1000    ...1000
    >>   BOOLE-ORC1   -3         -11    ...1101
    >>   BOOLE-ORC2   -5        -101    ...1011
    >>   BOOLE-SET    -1          -1    ...1111
    >>   BOOLE-XOR     6         110    ...0110
    =>  NIL
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果它的第一个参数不是一个位逻辑操作指定符[bit-wise logical operation specifier]或者任何后面的参数不是一个整数[integer], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        logand

* 注意(Notes):

        通常情况下,

        (boole boole-and x y) ==  (logand x y)

        更偏向于使用数字指标而不是位逻辑操作指定符[bit-wise logical operation specifier]的程序员[programmer]可以通过下面这样的手法来得到同样效果:

    ```LISP
    ;; The order of the values in this `table' are such that
    ;; (logand (boole (elt boole-n-vector n) #b0101 #b0011) #b1111) => n
    (defconstant boole-n-vector
        (vector boole-clr   boole-and  boole-andc1 boole-2
                boole-andc2 boole-1    boole-xor   boole-ior
                boole-nor   boole-eqv  boole-c1    boole-orc1
                boole-c2    boole-orc2 boole-nand  boole-set))
    =>  BOOLE-N-VECTOR
    (proclaim '(inline boole-n))
    =>  implementation-dependent
    (defun boole-n (n integer &rest more-integers)
      (apply #'boole (elt boole-n-vector n) integer more-integers))
    =>  BOOLE-N
    (boole-n #b0111 5 3) =>  7
    (boole-n #b0001 5 3) =>  1
    (boole-n #b1101 5 3) =>  -3
    (loop for n from #b0000 to #b1111 collect (boole-n n 5 3))
    =>  (0 1 2 3 4 5 6 7 -8 -7 -6 -5 -4 -3 -2 -1)
    ```LISP


### <span id="CV-B">常量 BOOLE-1, BOOLE-2, BOOLE-AND, BOOLE-ANDC1, BOOLE-ANDC2, BOOLE-C1, BOOLE-C2, BOOLE-CLR, BOOLE-EQV, BOOLE-IOR, BOOLE-NAND, BOOLE-NOR, BOOLE-ORC1, BOOLE-ORC2, BOOLE-SET, BOOLE-XOR</span>

* 常量值(Constant Value):

        这些变量[variable]中的每一个的值[value]的标识和性质都是依赖于具体实现的[implementation-dependent], 除了它必须和其他任何一个的值[value]都不同[distinct], 并且它必须是一个给函数[function] boole 的有效的第一个实参[argument].

* 描述(Description):

        这些常量[constant]中的每一个的值[value]都是十六个可能的位逻辑操作指定符[bit-wise logical operation specifier]中的一个.

* 示例(Examples):

    ```LISP
    (boole boole-ior 1 16) =>  17
    (boole boole-and -2 5) =>  4
    (boole boole-eqv 17 15) =>  -31
    ```

* 参见(See Also):

        boole

* 注意(Notes): None. 


### <span id="F-L">函数 LOGAND, LOGANDC1, LOGANDC2, LOGEQV, LOGIOR, LOGNAND, LOGNOR, LOGNOT, LOGORC1, LOGORC2, LOGXOR</span>

* 语法(Syntax):

        logand &rest integers => result-integer

        logandc1 integer-1 integer-2 => result-integer

        logandc2 integer-1 integer-2 => result-integer

        logeqv &rest integers => result-integer

        logior &rest integers => result-integer

        lognand integer-1 integer-2 => result-integer

        lognor integer-1 integer-2 => result-integer

        lognot integer => result-integer

        logorc1 integer-1 integer-2 => result-integer

        logorc2 integer-1 integer-2 => result-integer

        logxor &rest integers => result-integer

* 参数和值(Arguments and Values):

        integers---多个整数[integer].
        integer---一个整数[integer].
        integer-1---一个整数[integer].
        integer-2---一个整数[integer].
        result-integer---一个整数[integer].

* 描述(Description):

        函数[function] logandc1, logandc2, logand, logeqv, logior, lognand, lognor, lognot, logorc1, logorc2, 和 logxor 在它们的实参[argument]上执行位逻辑操作, 这些参数会被看作二进制数.

        下面这段列出了这些函数[function]中的每一个的意义. 在 'identity' 出现的位置, 表示当没有提供实参[argument]时这个函数[function]产生的值[value].

        Function  Identity  Operation performed                         
        logandc1  ---       and complement of integer-1 with integer-2  
        logandc2  ---       and integer-1 with complement of integer-2  
        logand    -1        and                                         
        logeqv    -1        equivalence (exclusive nor)                 
        logior    0         inclusive or                                
        lognand   ---       complement of integer-1 and integer-2       
        lognor    ---       complement of integer-1 or integer-2        
        lognot    ---       complement                                  
        logorc1   ---       or complement of integer-1 with integer-2   
        logorc2   ---       or integer-1 with complement of integer-2   
        logxor    0         exclusive or                                

        Figure 12-18. 整数上的位逻辑操作

        负的整数会被看作它们是以两个补数的二进制表示的.

* 示例(Examples):

    ```LISP
    (logior 1 2 4 8) =>  15
    (logxor 1 3 7 15) =>  10
    (logeqv) =>  -1
    (logand 16 31) =>  16
    (lognot 0) =>  -1
    (lognot 1) =>  -2
    (lognot -1) =>  0
    (lognot (1+ (lognot 1000))) =>  999

    ;;; In the following example, m is a mask.  For each bit in
    ;;; the mask that is a 1, the corresponding bits in x and y are
    ;;; exchanged.  For each bit in the mask that is a 0, the 
    ;;; corresponding bits of x and y are left unchanged.
    (flet ((show (m x y)
              (format t "~%m = #o~6,'0O~%x = #o~6,'0O~%y = #o~6,'0O~%"
                      m x y)))
      (let ((m #o007750)
            (x #o452576)
            (y #o317407))
        (show m x y)
        (let ((z (logand (logxor x y) m)))
          (setq x (logxor z x))
          (setq y (logxor z y))
          (show m x y))))
    >>  m = #o007750
    >>  x = #o452576
    >>  y = #o317407
    >>  
    >>  m = #o007750
    >>  x = #o457426
    >>  y = #o312557
    =>  NIL
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果任何参数不是一个整数[argument], 那么应该发出一个 type-error 错误.

* 参见(See Also):

        boole

* 注意(Notes):

        (logbitp k -1) 对于 k 的所有值都返回 true.

        因为下面的函数不是结合的, 它们只取两个参数而不是任意数量的参数.

        (lognand n1 n2) ==  (lognot (logand n1 n2))
        (lognor n1 n2) ==  (lognot (logior n1 n2))
        (logandc1 n1 n2) ==  (logand (lognot n1) n2)
        (logandc2 n1 n2) ==  (logand n1 (lognot n2))
        (logiorc1 n1 n2) ==  (logior (lognot n1) n2)
        (logiorc2 n1 n2) ==  (logior n1 (lognot n2))
        (logbitp j (lognot x)) ==  (not (logbitp j x))


### <span id="F-LOGBITP">函数 LOGBITP</span>

* 语法(Syntax):

        logbitp index integer => generalized-boolean

* 参数和值(Arguments and Values):

        index---一个非负整数[integer].
        integer---一个整数[integer].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        logbitp 被用于测试整数 integer 中的特定位的值, 它会被当作一个二进制数处理. 如果整数 integer 的索引为 index (这也就是说, 它的权重是 2^index)的位是 1 比特, logbitp 的值就是 true; 否则就是 false.

        那些负的整数 integers 会被看作是以两个补数的二进制表示的.

* 示例(Examples):

    ```LISP
    (logbitp 1 1) =>  false
    (logbitp 0 1) =>  true
    (logbitp 3 10) =>  true
    (logbitp 1000000 -1) =>  true
    (logbitp 2 6) =>  true
    (logbitp 0 6) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 index 不是一个非负整数[integer], 那么应该发出一个 type-error 类型[type]的错误. 如果整数 integer 不是一个整数[integer], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also): None.

* 注意(Notes):

        (logbitp k n) ==  (ldb-test (byte 1 k) n)


### <span id="F-LOGCOUNT">函数 LOGCOUNT</span>

* 语法(Syntax):

        logcount integer => number-of-on-bits

* 参数和值(Arguments and Values):

        integer---一个整数[integer].
        number-of-on-bits---一个非负整数[integer].

* 描述(Description):

        计算并返回整数 integer 的二进制补码表示中处于 'on' 或 'set' 的位的数量. 如果整数 integer 是负的, 0 位会被计数; 否则, 1 位会被计数.

* 示例(Examples):

    ```LISP
    (logcount 0) =>  0
    (logcount -1) =>  0
    (logcount 7) =>  3
    (logcount  13) =>  3 ;Two's-complement binary: ...0001101
    (logcount -13) =>  2 ;Two's-complement binary: ...1110011
    (logcount  30) =>  4 ;Two's-complement binary: ...0011110
    (logcount -30) =>  4 ;Two's-complement binary: ...1100010
    (logcount (expt 2 100)) =>  1
    (logcount (- (expt 2 100))) =>  100
    (logcount (- (1+ (expt 2 100)))) =>  1
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果它的参数不是一个整数[integer], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also): None.

* 注意(Notes):

        即使这个具体实现[implementation]内部不是把整数[integer]表示为二进制补码形式, logcount 还是表现地就像它所做的那样.

        以下恒等式总是符合的:

            (logcount x)
        ==  (logcount (- (+ x 1)))
        ==  (logcount (lognot x))


### <span id="F-LOGTEST">函数 LOGTEST</span>

* 语法(Syntax):

        logtest integer-1 integer-2 => generalized-boolean

* 参数和值(Arguments and Values):

        integer-1---一个整数[integer].
        integer-2---一个整数[integer].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果 interger-1 中的 1 表示的位在 integer-2 中是 1 就返回 true; 否则就是 false. integer-1 和 integer-2 被当作二进制的.

        负的 integer-1 和 integer-2 被当作就好像它们是以二进制补码表示的.

* 示例(Examples):

    ```LISP
    (logtest 1 7) =>  true
    (logtest 1 2) =>  false
    (logtest -2 -1) =>  true
    (logtest 0 -1) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 integer-1 不是一个整数[integer]就会发出一个 type-error 类型[type]的错误. 如果 integer-2 不是一个整数[integer]就会发出一个 type-error 类型[type]的错误.

* 参见(See Also): None.

* 注意(Notes):

        (logtest x y) ==  (not (zerop (logand x y)))


### <span id="F-BYTE-BYTE-SIZE-BYTE-POSITION">函数 BYTE, BYTE-SIZE, BYTE-POSITION</span>

* 语法(Syntax):

        byte size position => bytespec

        byte-size bytespec => size

        byte-position bytespec => position

* 参数和值(Arguments and Values):

        size, position---一个非负整数[integer].
        bytespec---一个字节指定符[byte specifier].

* 描述(Description):

        byte 返回一个字节指定符[byte specifier], 它表示宽度为 size 的字节[byte], 而它的位有着权重 2^position + size - 1 到 2^position, 并且它的表示是依赖于具体实现的[implementation-dependent].

        byte-size 返回 bytespec 指定的位数.

        byte-position 返回 bytespec 指定的位置.

* 示例(Examples):

    ```LISP
    (setq b (byte 100 200)) =>  #<BYTE-SPECIFIER size 100 position 200>
    (byte-size b) =>  100
    (byte-position b) =>  200
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        ldb, dpb

* 注意(Notes):

        (byte-size (byte j k)) ==  j
        (byte-position (byte j k)) ==  k

        一个 0 大小的字节[byte]是允许的; 它指的是一个宽度为 0 的字节[byte]. 比如,

        (ldb (byte 0 3) #o7777) =>  0
        (dpb #o7777 (byte 0 3) 0) =>  0


### <span id="F-DEPOSIT-FIELD">函数 DEPOSIT-FIELD</span>

* 语法(Syntax):

        deposit-field newbyte bytespec integer => result-integer

* 参数和值(Arguments and Values):

        newbyte---一个整数[integer].
        bytespec---一个字节指定符[byte specifier].
        integer---一个整数[integer].
        result-integer---一个整数[integer].

* 描述(Description):

        替换整数 integer 中的一个位的域; 具体的说, 返回一个整数[integer], 其中 bytespec 所指定的字节[byte]中包含了 newbyte 的位, 而其他地方则包含整数 integer 的位.

* 示例(Examples):

    ```LISP
    (deposit-field 7 (byte 2 1) 0) =>  6
    (deposit-field -1 (byte 4 0) 0) =>  15
    (deposit-field 0 (byte 2 1) -3) =>  -7
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        byte, dpb

* 注意(Notes):

        (logbitp j (deposit-field m (byte s p) n))
        ==  (if (and (>= j p) (< j (+ p s)))
                (logbitp j m)
                (logbitp j n))

        deposit-field 对于 mask-field 就像是 dpb 对于 ldb. 

### <span id="F-DPB">函数 DPB</span>

* 语法(Syntax):

        dpb newbyte bytespec integer => result-integer

* 发音(Pronunciation):

        [,duh'pib] 或 [,duh'puhb] 或 ['dee'pee'bee]

* 参数和值(Arguments and Values):

        newbyte---一个整数[integer].
        bytespec---一个字节指定符[byte specifier].
        integer---一个整数[integer].
        result-integer---一个整数[integer].

* 描述(Description):

        dpb (deposit byte) 被用于替换整数 integer 中一个位的域. dpb 返回一个和整数 integer 除了 bytespec 指定的位以外都相同的整数[integer].

        让 s 为 bytespec 指定的大小; 然后这个 newbyte 的低 s 位出现在 bytespec 指定的字节的结果中. 这个 newbyte 被解释为是右对齐的, 就好像是 ldb 的结果.

* 示例(Examples):

    ```LISP
    (dpb 1 (byte 1 10) 0) =>  1024
    (dpb -2 (byte 2 10) 0) =>  2048
    (dpb 1 (byte 2 10) 2048) =>  1024
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        byte, deposit-field, ldb

* 注意(Notes):

        (logbitp j (dpb m (byte s p) n))
        ==  (if (and (>= j p) (< j (+ p s)))
                (logbitp (- j p) m)
                (logbitp j n))

        通常情况下, 对于所有有效的 x, y, 和 z 的值

        (dpb x (byte 0 y) z) =>  z

        历史上, "dpb" 的名称来自于 DEC 的 PDP-10 汇编语言指令, 意思是 "存储字节(deposit byte)". 


### <span id="A-LDB">访问器 LDB</span>

* 语法(Syntax):

        ldb bytespec integer => byte

        (setf (ldb bytespec place) new-byte)

* 发音(Pronunciation):

        ['lidib] 或 ['liduhb] 或 ['el'dee'bee]

* 参数和值(Arguments and Values):

        bytespec---一个字节指定符[byte specifier].
        integer---一个整数[integer].
        byte, new-byte---一个非负整数[integer].

* 描述(Description):

        ldb 提取并返回整数 integer 中 bytespec 所指定的字节[byte].

        ldb 返回一个整数[integer], 在这个整数中 2^(s-1) 到 2^0 的位和整数中 2^(p+s-1) 到 2^p 的一样, 其他位都是 0; s 是 (byte-size bytespec) 并且 p 是 (byte-position bytespec).

        setf 可以和 ldb 一起使用来修改存储在给定 place 中的这个整数 integer 中的一个字节. 当一个 ldb 表达式形式被提供给 setf 时, 求值顺序是从左到右的. 效果就是去执行一个 dpb 操作然后把结果存储回那个 place 中.

* 示例(Examples):

    ```LISP
    (ldb (byte 2 1) 10) =>  1
    (setq a (list 8)) =>  (8)
    (setf (ldb (byte 2 1) (car a)) 1) =>  1
    a =>  (10)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        byte, byte-position, byte-size, dpb

* 注意(Notes):

        (logbitp j (ldb (byte s p) n))
            ==  (and (< j s) (logbitp (+ j p) n))

        通常, 对于所有 x 和 y 的有效值

        (ldb (byte 0 x) y) =>  0

        在历史上, "ldb" 的名称来自于 DEC 的 PDP-10 汇编语言指令, 意思是"载入字节(load byte)". 


### <span id="F-LDB-TEST">函数 LDB-TEST</span>

* 语法(Syntax):

        ldb-test bytespec integer => generalized-boolean

* 参数和值(Arguments and Values):

        bytespec---一个字节指定符[byte specifier].
        integer---一个整数[integer].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果整数 integer 中 bytespec 所指定的字节的任意位不是 0 就返回 true; 否则返回 false.

* 示例(Examples):

    ```LISP
    (ldb-test (byte 4 1) 16) =>  true
    (ldb-test (byte 3 1) 16) =>  false
    (ldb-test (byte 3 2) 16) =>  true
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        byte, ldb, zerop

* 注意(Notes):

        (ldb-test bytespec n) == 
        (not (zerop (ldb bytespec n))) == 
        (logtest (ldb bytespec -1) n)


### <span id="A-MASK-FIELD">访问器 MASK-FIELD</span>

* 语法(Syntax):

        mask-field bytespec integer => masked-integer

        (setf (mask-field bytespec place) new-masked-integer)

* 参数和值(Arguments and Values):

        bytespec---一个字节指定符[byte specifier].
        integer---一个整数[integer].
        masked-integer, new-masked-integer---一个非负整数[integer].

* 描述(Description):

        mask-field 在整数 integer 上执行 "掩码(mask)" 操作. 它返回一个和整数 integer 在 bytespec 所指定的字节[byte]上有着相同比特而其他都是 0 比特的整数[integer].

        setf 可以和 mask-field 一起使用来修改存储在一个给定位置 place 的整数[integer]中的一个字节. 这个的效果是去执行一个 deposit-field 操作然后存储结果到那个 place 中.

* 示例(Examples):

    ```LISP
    (mask-field (byte 1 5) -1) =>  32
    (setq a 15) =>  15
    (mask-field (byte 2 0) a) =>  3
    a =>  15
    (setf (mask-field (byte 2 0) a) 1) =>  1
    a =>  13
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        byte, ldb

* 注意(Notes):

        (ldb bs (mask-field bs n)) ==  (ldb bs n)
        (logbitp j (mask-field (byte s p) n))
          ==  (and (>= j p) (< j s) (logbitp j n))
        (mask-field bs n) ==  (logand n (dpb -1 bs 0))



### <span id="CV-MM">常量 MOST-POSITIVE-FIXNUM, MOST-NEGATIVE-FIXNUM</span>

* 常量值(Constant Value):

        依赖于具体实现[implementation-dependent].

* 描述(Description):

        most-positive-fixnum 是最接近于这个具体实现提供的正无穷的 fixnum, 并且大于等于 2^15 - 1 和 array-dimension-limit.

        most-negative-fixnum 是最接近于这个具体实现提供的负无穷的 fixnum, 小于等于 -2^15.

* 示例(Examples): None.

* 参见(See Also): None.

* 注意(Notes): None. 


### <span id="F-DSFFFFI">函数 DECODE-FLOAT, SCALE-FLOAT, FLOAT-RADIX, FLOAT-SIGN, FLOAT-DIGITS, FLOAT-PRECISION, INTEGER-DECODE-FLOAT</span>

* 语法(Syntax):

        decode-float float => significand, exponent, sign

        scale-float float integer => scaled-float

        float-radix float => float-radix

        float-sign float-1 &optional float-2 => signed-float

        float-digits float => digits1

        float-precision float => digits2

        integer-decode-float float => significand, exponent, integer-sign

* 参数和值(Arguments and Values):

        digits1---一个非负整数[integer].
        digits2---一个非负整数[integer].
        exponent---一个整数[integer].
        float---一个浮点数[float].
        float-1---一个浮点数[float].
        float-2---一个浮点数[float].
        float-radix---一个整数[integer].
        integer---一个非负整数[integer].
        integer-sign---整数[integer] -1, 或者整数[integer] 1.
        scaled-float---一个浮点数[float].
        sign---一个和浮点数 float 相同类型[type]但是数学上等价于 1.0 或 -1.0 一个浮点数[float].
        signed-float---一个浮点数[float].
        significand---一个浮点数[float].

* 描述(Description):

        decode-float 计算出描绘浮点数 float 的三个值. 第一个值和浮点数 float 相同类型[type]并且表示有效位数. 第二个值表示一个指数, 那个基数 (在 b 的描述中被提到) 必须被提升到那个指数来获取那个值, 当这个值和第一个值相乘时, 产生浮点数 float 的绝对值. 如果浮点数 float 是 0, 任何整数[integer]值可能被返回, 假设保持 scale-float 展示不变. 第三个值是和浮点数 float 相同类型[type]并且如果浮点数 float 大于等于 0 就是 1.0, 否则就是 -1.0.

        decode-float 用 b 的一个整数幂来除浮点数 float 进而使它的值在 1/b (包含) 和 1 (不包含) 之间, 并且返回这个商作为一个值. 然而, 如果浮点数 float 是 zero, 结果和这个浮点数 float 的绝对值相等 (这也就是说, 如果这里有个负零, 它的有效位数被认为是正零).

        scale-float 返回 (* float (expt (float b float) integer)), 其中 b 是这个浮点表示的基数. 浮点数 float 没有必要在 1/b 和 1 之间.

        float-radix 返回 float 的基数.

        float-sign 返回一个数字 z, 这个 z 和 float-1 有着相同的符号并且 z 和 float-2 有着相同的绝对值. 如果没有提供 float-2, 它的值就是 (float 1 float-1). 如果一个具体实现对于负零和正零有着不同的表示, 那么 (float-sign -0.0) => -1.0.

        float-digits 返回在浮点数 float 中使用的基数 b 的数量 (包括任何隐式的数量, 例如一个 "隐藏位(hidden bit)").

        float-precision 返回在浮点数 float 中出现的有效基数 b 的数量; 如果浮点数 float 是一个浮点数[float]零, 那么结果就是一个整数[integer]零.

        对于标准化[normalized]浮点数[float], 这个 float-digits 和 float-precision 的结果是一样的, 但是精度小于非标准化[denormalized]或零值的表示位数.

        integer-decode-float 计算出描绘浮点数 float 的三个值 - 这个有效位数被缩放为一个整数[integer], 最后两个值和 decode-float 返回的一样. 如果浮点数 float 是零, integer-decode-float 返回 0 作为第一个值. 第二个值与第一个值的关系和 decode-float 相同:

        (multiple-value-bind (signif expon sign)
                              (integer-decode-float f)
          (scale-float (float signif f) expon)) ==  (abs f)

* 示例(Examples):

    ```LISP
    ;; Note that since the purpose of this functionality is to expose
    ;; details of the implementation, all of these examples are necessarily
    ;; very implementation-dependent.  Results may vary widely.
    ;; Values shown here are chosen consistently from one particular implementation.
    (decode-float .5) =>  0.5, 0, 1.0
    (decode-float 1.0) =>  0.5, 1, 1.0
    (scale-float 1.0 1) =>  2.0
    (scale-float 10.01 -2) =>  2.5025
    (scale-float 23.0 0) =>  23.0
    (float-radix 1.0) =>  2
    (float-sign 5.0) =>  1.0
    (float-sign -5.0) =>  -1.0
    (float-sign 0.0) =>  1.0
    (float-sign 1.0 0.0) =>  0.0
    (float-sign 1.0 -10.0) =>  10.0
    (float-sign -1.0 10.0) =>  -10.0
    (float-digits 1.0) =>  24
    (float-precision 1.0) =>  24
    (float-precision least-positive-single-float) =>  1
    (integer-decode-float 1.0) =>  8388608, -23, 1
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        具体实现关于浮点数[float]的表示法.

* 异常情况(Exceptional Situations):

        如果函数[function] decode-float, float-radix, float-digits, float-precision, and integer-decode-float 仅有的参数不是一个浮点数[float], 那么它们应该发出一个错误.

        如果函数[function] scale-float 的第一个参数不是一个浮点数[float]或者它的第二个参数不是一个整数[integer], 那么它应该发出一个错误.

        如果函数[function] float-sign 的第一个参数不是一个浮点数[float]或者提供的第二个参数不是一个浮点数[float], 那么它应该发出一个错误.

* 参见(See Also): None.

* 注意(Notes):

        decode-float 或 integer-decode-float的第一个结果与第二个结果的幂的基数的乘积, 与第三个结果的乘积恰好等于浮点数 float 的值.

        (multiple-value-bind (signif expon sign)
                              (decode-float f)
          (scale-float signif expon))
        ==  (abs f)

        并且

        (multiple-value-bind (signif expon sign)
                              (decode-float f)
          (* (scale-float signif expon) sign))
        ==  f


### <span id="F-FLOAT">函数 FLOAT</span>

* 语法(Syntax):

        float number &optional prototype => float

* 参数和值(Arguments and Values):

        number---一个实数[real].
        prototype---一个浮点数[float].
        float---一个浮点数[float].

* 描述(Description):

        float 把一个实数[real]转换为浮点数[float].

        如果提供了一个原型 prototype, 会返回一个和数字 number 数学上相等的但是有着和原型 prototype 相同格式的浮点数[float].

        如果没有提供原型 prototype, 那么如果这个数字 number 已经是一个浮点数[float], 就把它返回; 否则, 就返回一个和数字 number 数学上相等的但是是一个单精度浮点[single float]的浮点数[float].

* 示例(Examples):

    ```LISP
    (float 0) =>  0.0
    (float 1 .5) =>  1.0
    (float 1.0) =>  1.0
    (float 1/2) =>  0.5
    =>  1.0d0
    OR=>  1.0
    (eql (float 1.0 1.0d0) 1.0d0) =>  true
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        coerce

* 注意(Notes): None. 


### <span id="F-FLOATP">函数 FLOATP</span>

* 语法(Syntax):

        floatp object

        generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 float 类型[type]的就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (floatp 1.2d2) =>  true
    (floatp 1.212) =>  true
    (floatp 1.2s2) =>  true
    (floatp (expt 2 130)) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes):

        (floatp object) ==  (typep object 'float)


### <span id="CV-MOST-LEAST">常量 MOST-POSITIVE-SHORT-FLOAT, LEAST-POSITIVE-SHORT-FLOAT, LEAST-POSITIVE-NORMALIZED-SHORT-FLOAT, MOST-POSITIVE-DOUBLE-FLOAT, LEAST-POSITIVE-DOUBLE-FLOAT, LEAST-POSITIVE-NORMALIZED-DOUBLE-FLOAT, MOST-POSITIVE-LONG-FLOAT, LEAST-POSITIVE-LONG-FLOAT, LEAST-POSITIVE-NORMALIZED-LONG-FLOAT, MOST-POSITIVE-SINGLE-FLOAT, LEAST-POSITIVE-SINGLE-FLOAT, LEAST-POSITIVE-NORMALIZED-SINGLE-FLOAT, MOST-NEGATIVE-SHORT-FLOAT, LEAST-NEGATIVE-SHORT-FLOAT, LEAST-NEGATIVE-NORMALIZED-SHORT-FLOAT, MOST-NEGATIVE-SINGLE-FLOAT, LEAST-NEGATIVE-SINGLE-FLOAT, LEAST-NEGATIVE-NORMALIZED-SINGLE-FLOAT, MOST-NEGATIVE-DOUBLE-FLOAT, LEAST-NEGATIVE-DOUBLE-FLOAT, LEAST-NEGATIVE-NORMALIZED-DOUBLE-FLOAT, MOST-NEGATIVE-LONG-FLOAT, LEAST-NEGATIVE-LONG-FLOAT, LEAST-NEGATIVE-NORMALIZED-LONG-FLOAT</span>

* 常量值(Constant Value):

        依赖于具体实现[implementation-dependent].

* 描述(Description):

        这些常变量[constant variable]为程序去检测多种浮点格式的具体实现定义的[implementation-defined]限制提供了一种方式.

        这些变量[variable]中, 每个名字[name]中有着 "-normalized" 的必须有着一个标准化[normalized]浮点数[float]的值[value], 而每个名字中没有 "-normalized" 的可能有着一个标准化[normalized]浮点数[float]或者非标准化[denormalized]浮点数[float]的值[value], 视情况而定.

        这些变量[variable]中, 每个名字[name]中有着 "short-float" 的必须有着一个短浮点数[short float]的值[value], 每个名字[name]中有着 "single-float" 必须有着一个单精度浮点数[single float]的值[value], 每个名字[name]中有着 "double-float" 的必须有着一个双精度浮点数[double float]的值[value], 而每个名字[name]中有着 "long-float" 的必须有着一个长浮点数[long float]的值[value].

            * most-positive-short-float, most-positive-single-float, most-positive-double-float, most-positive-long-float

            这些常变量[constant variable]中的每一个都是名字所暗示的浮点格式中最大数值的正浮点数[float] (最接近, 但不等于正无穷).

            * least-positive-short-float, least-positive-normalized-short-float, least-positive-single-float, least-positive-normalized-single-float, least-positive-double-float, least-positive-normalized-double-float, least-positive-long-float, least-positive-normalized-long-float

            这些常变量[constant variable]中的每一个都是名字所暗示的浮点格式中最小数值的正浮点数[float] (非零).

            * least-negative-short-float, least-negative-normalized-short-float, least-negative-single-float, least-negative-normalized-single-float, least-negative-double-float, least-negative-normalized-double-float, least-negative-long-float, least-negative-normalized-long-float

            这些常变量[constant variable]中的每一个都是名字所暗示的浮点格式中最小数值的负(非零)浮点数[float]. (如果一个实现支持 -0 作为一个和 +0 不同[different]的对象[object], 这个值一定不能是 -0.)

            * most-negative-short-float, most-negative-single-float, most-negative-double-float, most-negative-long-float

            这些常变量[constant variable]中的每一个都是名字所暗示的浮点格式中最大数值的负(非零)浮点数[float] (值接近于, 但不等于负无穷).

* 示例(Examples): None.

* 参见(See Also): None.

* 注意(Notes):


### <span id="CV-EPSILON">常量 SHORT-FLOAT-EPSILON, SHORT-FLOAT-NEGATIVE-EPSILON, SINGLE-FLOAT-EPSILON, SINGLE-FLOAT-NEGATIVE-EPSILON, DOUBLE-FLOAT-EPSILON, DOUBLE-FLOAT-NEGATIVE-EPSILON, LONG-FLOAT-EPSILON, LONG-FLOAT-NEGATIVE-EPSILON</span>

* 常量值(Constant Value):

        依赖于具体实现[implementation-dependent].

* 描述(Description):

        这些常量 short-float-epsilon, single-float-epsilon, double-float-epsilon, 和 long-float-epsilon 中的每一个的值都是给定格式下的最小正浮点数[float] <EPSILON>, 这样一来下面表达式在求值时是 true 的:

        (not (= (float 1 <EPSILON>) (+ (float 1 <EPSILON>) <EPSILON>)))

        这些常量 short-float-negative-epsilon, single-float-negative-epsilon, double-float-negative-epsilon, 和 long-float-negative-epsilon 中的每一个的值都是给定格式下的最小正浮点数[float] <EPSILON>, 这样一来下面表达式在求值时是 true 的:

        (not (= (float 1 <EPSILON>) (- (float 1 <EPSILON>) <EPSILON>)))

* 示例(Examples): None.

* 参见(See Also): None.

* 注意(Notes): None. 


### <span id="CT-ARITHMETIC-ERROR">状况类型 ARITHMETIC-ERROR</span>

* 类优先级列表(Class Precedence List):

        arithmetic-error, error, serious-condition, condition, t

* 描述(Description):

        类型[type] arithmetic-error 由运算操作期间发生的错误状况组成. 这个操作符和操作数通过使用给 make-condition 的名为 :operation 和 :operands 的初始化参数来初始化, 并且可以通过函数 arithmetic-error-operation 和 arithmetic-error-operands 访问.

* 参见(See Also):

        arithmetic-error-operation, arithmetic-error-operands 


### <span id="F-AEO-AEO">函数 ARITHMETIC-ERROR-OPERANDS, ARITHMETIC-ERROR-OPERATION</span>

* 语法(Syntax):

        arithmetic-error-operands condition => operands

        arithmetic-error-operation condition => operation

* 参数和值(Arguments and Values):

        condition---一个 arithmetic-error 类型[type]的状况[condition].
        operands---一个列表[list].
        operation---一个函数标识符[function designator].

* 描述(Description):

        arithmetic-error-operands 返回一个操作数的列表[list], 这些操作数被用于发出这个状况 condition 的操作符的违规调用中.

        arithmetic-error-operation 返回一个在发出这个状况 condition 的违规调用中违规的操作符列表[list].

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        arithmetic-error, 章节 9 (状况)

* 注意(Notes):


### <span id="CT-DIVISION-BY-ZERO">状况类型 DIVISION-BY-ZERO</span>

* 类优先级列表(Class Precedence List):

        division-by-zero, arithmetic-error, error, serious-condition, condition, t

* 描述(Description):

        类型[type] division-by-zero 由因为被 0 除所导致的错误状况所组成. 


### <span id="CT-FLOATING-POINT-INVALID-OPERATION">状况类型 FLOATING-POINT-INVALID-OPERATION</span>

* 类优先级列表(Class Precedence List):

        floating-point-invalid-operation, arithmetic-error, error, serious-condition, condition, t

* 描述(Description):

        类型[type] floating-point-invalid-operation 由因为某些浮点数陷阱造成的错误状况组成.

        浮点数陷阱是否发生, 并且它们是否或如何被启用或禁用是依赖于具体实现的[implementation-dependent]. 因此, 符合规范的代码可能为这个状况建立处理者, 但是一定不能依赖于它的发送.  

### <span id="CT-FLOATING-POINT-INEXACT">状况类型 FLOATING-POINT-INEXACT</span>

* 类优先级列表(Class Precedence List):

        floating-point-inexact, arithmetic-error, error, serious-condition, condition, t

* 描述(Description):

        类型[type] floating-point-inexact 由因为某些浮点数陷阱造成的错误状况组成.

        浮点数陷阱是否发生, 并且它们是否或如何被启用或禁用是依赖于具体实现的[implementation-dependent]. 因此, 符合规范的代码可能为这个状况建立处理者, 但是一定不能依赖于它的发送. 

### <span id="CT-FLOATING-POINT-OVERFLOW">状况类型 FLOATING-POINT-OVERFLOW</span>

* 类优先级列表(Class Precedence List):

        floating-point-overflow, arithmetic-error, error, serious-condition, condition, t

* 描述(Description):

        类型[type] floating-point-overflow 由因为浮点上溢造成的错误状况组成. 


### <span id="CT-FLOATING-POINT-UNDERFLOW">状况类型 FLOATING-POINT-UNDERFLOW</span>

* 类优先级列表(Class Precedence List):

        floating-point-underflow, arithmetic-error, error, serious-condition, condition, t

* 描述(Description):

        类型[type] floating-point-underflow 由因为浮点下溢造成的错误状况组成. 


# 13. 字符

> * 13.1 [字符概念](#CharacterConcepts)
> * 13.2 [字符字典](#TheCharactersDictionary)

## 13.1 <span id="CharacterConcepts">字符概念</span>

> * 13.1.1 [字符介绍](#IntroductionToCharacters)
> * 13.1.2 [文字和字符集的介绍](#IntroductionScriptsRepertoires)
> * 13.1.3 [字符属性](#CharacterAttributes)
> * 13.1.4 [字符类别](#CharacterCategories)
> * 13.1.5 [字符的等价性](#IdentityCharacters)
> * 13.1.6 [字符的顺序](#OrderingCharacters)
> * 13.1.7 [字符的名字](#CharacterNames)
> * 13.1.8 [在输入和输出中的 Newline 的处理](#TreatmentNewlineInputOutput)
> * 13.1.9 [字符编码](#CharacterEncodings)
> * 13.1.10 [具体实现定义的文字的文档](#DocImplDefinedScripts)

### 13.1.1 <span id="IntroductionToCharacters">字符介绍</span>

一个字符[character]是在一个文本的总量中 (比如, 一个字符串[string]或一个文本流[stream]) 表示单位标记 (比如, 一个字符, 一个特殊符号, 或者一个 "控制字符(control character)") 的对象[object].

Common Lisp 允许一个具体实现去为国际语言字符[character]和专门领域中(比如, 数学上)使用的字符[character]提供支持.

下面这段包含了可应用于字符[character]的已定义名字[defined name].

下面这段列出了一些和字符[character]属性[attribute]和字符[character]断言[predicate]相关的已定义名字[defined name].

    alpha-char-p     char-not-equal     char>            
    alphanumericp    char-not-greaterp  char>=           
    both-case-p      char-not-lessp     digit-char-p     
    char-code-limit  char/=             graphic-char-p   
    char-equal       char<              lower-case-p     
    char-greaterp    char<=             standard-char-p  
    char-lessp       char=              upper-case-p     

    Figure 13-1. 字符相关的已定义的名字 -- 1

下面这段列出了一些字符[character]构造和转换的已定义名字[defined name].

    char-code      char-name    code-char   
    char-downcase  char-upcase  digit-char  
    char-int       character    name-char   

    Figure 13-2. 字符相关的已定义的名字 -- 2 


### 13.1.2 <span id="IntroductionScriptsRepertoires">文字和字符集的介绍</span>

#### 13.1.2.1 字符文字

一类文字[script]是组成这个 character 类型详尽分区[exhaustive partition]的可能的几个集合中的一个.

这样的集合的数量以及它们之间的边界是具体实现定义的[implementation-defined]. Common Lisp 不需要这些集合成为类型[type], 但是一个具体实现[implementation]允许开去定义这样的类型[type]作为一个扩展. 因为一类文字[script]的字符[character]不能是另一类文字[script]的成员, 所以它在谈及字符字符集[repertoire]时是很有用的.

虽然术语 "文字(script)" 为了和 ISO 术语定义上兼容而被选择, 但是符合规范的具体实现[conforming implementation]不需要去使用 ISO 或者任何其他标准化组织标准化的特定文字[script].

任何给定的实现[implementation]使用的文字[script]是否被命名, 如何命名, 是依赖于具体实现的[implementation-dependent]. 


#### 13.1.2.2 字符集

一个字符集[repertoire]是一个 character 类型[type]的子类型[subtype]的类型指定符[type specifier]. 这个术语通常在描述一个独立于编码的字符[character]集合时被使用. 字符集[repertoire]中的字符只能通过名字, 字符的可见表示[glyph], 或者通过字符描述来识别.

一个字符集[repertoire]可以包含来自多个 scripts 的字符[character], 并且一个字符[character]可以出现在不止一个字符集[repertoire]中.

关于字符集[repertoire]的一些例子, 见字符编码标准 ISO 8859/1, ISO 8859/2, 和 ISO 6937/2. 注意, 虽然术语 "字符集(repertoire)" 为了和 ISO 术语定义上兼容而被选择, 但是符合规范的具体实现[conforming implementation]不需要去使用 ISO 或者任何其他标准化组织标准化的字符集[repertoire]. 


### 13.1.3 <span id="CharacterAttributes">字符属性</span>

字符[character]只有一个标准化[standardized]的属性[attribute]: 一个码值[code]. 一个字符[character]的码值[code]是一个非负整数[integer]. 这个码值[code]是由一个字符 script 和一个字符标签以一种依赖于具体实现[implementation-dependent]的方式组成. 见函数[function] char-code 和 code-char.

另外, 具体实现定义[implementation-defined]的字符[character]的属性[attribute]是允许的, 这样一来, 比如, 两个带有相同码值[code]的字符[character]可以以一个具体实现定义[implementation-defined]的方式来区分.

对于任何具体实现定义[implementation-defined]的属性[attribute]这里有一个特异的值称之为这个属性[attribute]的空[null]值. 一个每个具体实现定义[implementation-defined]的属性[attribute]都是这个属性[attribute]的空[null]值的字符[character]被称为一个简单字符[simple character]. 如果这个具体实现[implementation]没有具体实现定义[implementation-defined]的属性[attribute], 那么所有字符[character]都是简单字符[simple character]. 


### 13.1.4 <span id="CharacterCategories">字符类别</span>

有几个(重叠的)类别的字符[character]没有正式关联的类型[type]但是它们的名称仍然很有用. 它们包括图形[graphic]字符[character], 字母[alphabetic[1]]字符[character], 大小写[case]字符[character] (大写[uppercase]和小写[lowercase]字符[character]), 数字[numeric]字符[character], 字母数字[alphanumeric]字符[character], 还有数字[digit] (以一个给定的基数[radix]).

对于一个字符[character]的每个具体实现定义[implementation-defined]的属性[attribute], 那个具体实现[implementation]的文档必须指明只能在那个属性[attribute]上区分的字符[character]是否被允许去区分是否属于上述类别之一.

注意, 这些定义的术语独立于任何当前读取表[current readtable]中启用的特殊语法.

> * 13.1.4.1 [图形字符](#GraphicCharacters)
> * 13.1.4.2 [字母字符](#AlphabeticCharacters)
> * 13.1.4.3 [大小写字符](#CharactersWithCase)
> * 13.1.4.4 [数字字符](#NumericCharacters)
> * 13.1.4.5 [字母数字字符](#AlphanumericCharacters)
> * 13.1.4.6 [一个给定基数的数字](#DigitsRadix)

#### 13.1.4.1 <span id="GraphicCharacters">图形字符</span>

每个被分类为图形[graphic]或可显示的字符[character]都和一个显现字形(该字符的可见表示)相关联.

一个图形[graphic]字符[character]是一种具有单独显现字形[glyph]的标准文本表示形式的字符, 就像 A 或 * 或 =. 实际上有着空白显现字形[glyph]的空格[space]被定义为是一个图形[graphic]字符.

在标准字符[standard character]中, 换行[newline]是非图形的[non-graphic]而所有其他的是图形的[graphic]; 见章节 2.1.3 (标准字符).

不是图形[graphic]的字符[character]被称为非图形[non-graphic]字符. 非图形[non-graphic]字符[character]有时也被通俗地称为 "格式化字符(formatting characters)" 或 "控制字符(control characters)".

如果 #\Backspace, #\Tab, #\Rubout, #\Linefeed, #\Return, 和 #\Page 被具体实现[implementation]支持, 那么它们都是非图形的[non-graphic]. 


#### 13.1.4.2 <span id="AlphabeticCharacters">字母字符</span>

字母[alphabetic[1]]字符[character]是图形[graphic]字符[character]的一个子集. 标准字符[standard character]中, 只有这些是字母[alphabetic[1]]字符[character]:

    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

    a b c d e f g h i j k l m n o p q r s t u v w x y z

任何具体实现定义的[implementation-defined]有着大小写[case]的字符[character]都是字母的[alphabetic[1]]. 对于每个具体实现定义的[implementation-defined]没有大小写[case]的图形[graphic]字符[character], 它是否为字母的[alphabetic[1]]是具体实现定义的[implementation-defined]. 


#### 13.1.4.3 <span id="AlphabeticCharacters">大小写字符</span>

带有大小写[case]的字符[character]是字母[alphabetic[1]]字符[character]的一个子集. 一个带有大小写[case]的字符[character]有着可以是大写[uppercase]或小写[lowercase]的属性. 每个带有大小写[case]的字符[character]都和另一个带有相反大小写[case]的字符[character]一对一对应.

> * 13.1.4.3.1 [大写字符](#UppercaseCharacters)
> * 13.1.4.3.2 [小写字符](#LowercaseCharacters)
> * 13.1.4.3.3 [另一个大小写的对应字符](#CorrespondingCharactersOtherCase)
> * 13.1.4.3.4 [具体实现定义的字符的大小写](#CaseImplDefCharacters)


##### 13.1.4.3.1 <span id="UppercaseCharacters">大写字符</span>

一个大写字符[character]是一个有着对应不同[different]的小写[lowercase]字符[character] (可以使用 char-downcase 来获取) 的字符.

标准字符[standard character]中, 只有这些是大写[uppercase]字符[character]:

    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 


##### 13.1.4.3.2 <span id="LowercaseCharacters">小写字符</span>

一个小写字符[character]是一个有着对应不同的大写[uppercase]字符[character] (可以使用 char-upcase 来获取)的字符.

标准字符[standard character]中, 只有这些是小写[lowercase]字符[character]:

    a b c d e f g h i j k l m n o p q r s t u v w x y z 

##### 13.1.4.3.3 <span id="CorrespondingCharactersOtherCase">另一个大小写的对应字符</span>

上面提及的大写[uppercase]标准字符[standard character] A 到 Z 分别对应上面提及的小写[lowercase]标准字符[standard character] a 到 z. 比如, 大写[uppercase]字符[character] E 对应小写[lowercase]字符[character] e, 反之亦然. 

##### 13.1.4.3.4 <span id="CaseImplDefCharacters">具体实现定义的字符的大小写</span>

一个具体实现[implementation]可能定义其他具体实现定义[implementation-defined]的图形[graphic]字符[character]有着大小写[case]. 这样的定义必须总是成对的---一个大写[uppercase]字符[character]和一个小写[lowercase]字符[character]一对一对应. 

#### 13.1.4.4 <span id="NumericCharacters">数字字符</span>

数字[numeric]字符[character]是图形[graphic]字符[character]的一个子集. 在标准字符[standard character]中, 只有这些是数字[number]字符[character]:

    0 1 2 3 4 5 6 7 8 9

对于每个具体实现定义[implementation-defined]的没有大小写[case]的图形[graphic]字符[character], 具体实现[implementation]必须定义它是否为一个数字[numeric]字符[character]. 


#### 13.1.4.5 <span id="AlphanumericCharacters">字母数字字符</span>

数字字母[alphanumeric]字符[character]集合是字母[alphabetic[1]]字符[character]集合和数字[numeric]字符[character]集合的并集. 

#### 13.1.4.6 <span id="DigitsRadix">一个给定基数的数字</span>

什么是数字[digit]取决于基数[radix] (一个在 2 到 36 之间的整数[integer], 包含 36). 这些可能的数字[digit]是:

0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

它们的权重分别是 0, 1, 2, ... 35. 在任何给定的基数 n, 只有前面 n 个可能的数字[digit]会被当作数字[digit]. 比如, 在基数 2 的数字是 0 和 1, 在基数 10 的数字是 0 到 9, 而在基数 16 的数字是 0 到 F.

在数字[digit]中大小写[case]是无效的; 比如, 在基数 16 中, 不管是 F 还是 f 都是权重为 15 的数字[digit]. 

### 13.1.5 <span id="IdentityCharacters">字符的等价性</span>

字符的等价性表示两个字符[character]是 eql, char=, 或 char-equal 但没有必要是 eq. 

### 13.1.6 <span id="OrderingCharacters">字符的顺序</span>

字符[character]的总顺序保证有着以下特性:

* 如果两个字符[character]有着相同的具体实现定义[implementation-defined]的属性[attribute], 那么它们根据 char< 的顺序和根据它们的码值属性[attribute]上的 < 断言的数值顺序是一致的.

* 如果两个字符[character]在任何一个属性[attribute]上有区别, 那么它们就不是 char=.

* 这个总的顺序没有必要和给这些字符[character]应用 char-int 所产生的整数[integer]的总顺序一致.

* 虽然一个给定大小写[case]的那些字母[alphabetic[1]]标准字符[standard character]必须遵循一个局部顺序, 它们不需要是连续的; 允许大写[uppercase]和小写[lowercase]字母[character]是交错的. 因此 (char<= #\a x #\z) 不是一个确定 x 是否为一个小写[lowercase]字符[character]的有效方法.

在标准字符[standard character]中, 那些数字字母[alphanumeric]字符遵循下面的局部顺序:

    A<B<C<D<E<F<G<H<I<J<K<L<M<N<O<P<Q<R<S<T<U<V<W<X<Y<Z
    a<b<c<d<e<f<g<h<i<j<k<l<m<n<o<p<q<r<s<t<u<v<w<x<y<z
    0<1<2<3<4<5<6<7<8<9
    9<A 或 Z<0
    9<a 或 z<0                                                      

这个意味着, 对于标准字符[standard character], 在每个大小写[case]中(大写[uppercase]和小写[lowercase])字母[alphabetic[1]]顺序保持不变, 并且数字[numeric]字符[character]作为一个组不会和字母[alphabetic]字符[character]交错. 但是, 大写[uppercase]字符[character]和小写[lowercase]字符[character]的顺序或交错可能性是具体实现定义的[implementation-defined]. 

### 13.1.7 <span id="CharacterNames">字符的名字</span>

下面这些字符[character]名字[name]必须出现在所有符合规范的具体实现[conforming implementation]中:

Newline

    这个字符表示行之间的分割. 一个具体实现必须在 #\Newline, 一个单字符表示, 和可能被使用的其他外部表示之间转换.

Space

    空格或空白字符.

下面的名字是不完全标准的[semi-standard]; 如果一个具体实现[implementation]支持它们, 它们应该用于这些描述的字符[character], 而不是其他字符.

Rubout

    擦去或删除字符.

Page

    格式符或页分割字符.

Tab

    制表符.

Backspace

    退格符.

Return

    回车字符.

Linefeed

    换行符字符.

在一些具体实现[implementation]中, 这些字符[character]名字[name]中的一个或多个可能表示一个标准字符[standard character]; 比如, #\Linefeed 和 #\Newline 在某些具体实现[implementation]中可能是相同[same]字符[character]. 


### 13.1.8 <span id="TreatmentNewlineInputOutput">在输入和输出中的 Newline 的处理</span>

当这个 #\Newline 字符被写入到一个输出文件中, 具体实现必须采取适当的动作来产生一个行分割符. 这个可能涉及输出一个标记或转换 #\Newline 为一个 CR/LF 序列. 在读取时, 会发生一个对应的反向转换. 


### 13.1.9 <span id="CharacterEncodings">字符编码</span>

一个字符[character]有时仅仅由它的码值[code]表示, 而有时候通过另一个由码值[code]和所有具体实现定义[implementation-defined]的属性[attribute]组成的整数[integer]来表示 (以一种具体实现定义[implementation-defined]的即便在相同具体实现[implementation]中的 Lisp 镜像[Lisp image]之间也可能不同的方式). 这个被函数 char-int 返回的整数[integer], 称为这个字符的 "编码(encoding)". 这里没有对应的函数从一个字符的编码回退到这个字符[character], 因为它的主要用途包括像哈希这样的东西, 在这里不需要进行逆运算. 


### 13.1.10 <span id="DocImplDefinedScripts">具体实现定义的文字的文档</span>

一个具体实现[implementation]必须记录它支持的字符[character]文字[script]. 对于每个支持的字符[character]文字[script], 这个文档必须描述以下这些:

* 字符标签, 显现字形, 和描述. 字符标签必须使用拉丁大写字母 A--Z, 连字符 (-), 和数字 0--9 来唯一命名.

* 读取器规范化. 任何 read 用来把不同[different]字符当作等价的机制必须被记录.

* 对 char-upcase, char-downcase, 还有大小写敏感的格式化指令[format directive]的影响. 特别地, 对于每个带有大小写[case]的字符[character], 它是大写[uppercase]还是小写[lowercase], 以及哪个字符[character]是它在相反大小写的等价物.

* 大小写敏感的函数[function] char-equal, char-not-equal, char-lessp, char-greaterp, char-not-greaterp, 和 char-not-lessp 的行为.

* 任意字符[character]断言[predicate]的行为; 尤其, alpha-char-p, lower-case-p, upper-case-p, both-case-p, graphic-char-p, 和 alphanumericp 的效果.

* 与文件 I/O 的交互, 特别地, 记录支持的编码字符集 (比如, ISO8859/1-1987) 和支持的外部编码方案. 


## 13.2 <span id="TheCharactersDictionary">字符字典</span>

> * [系统类 CHARACTER](#SC-CHARACTER)
> * [类型 BASE-CHAR](#T-BASE-CHAR)
> * [类型 STANDARD-CHAR](#T-STANDARD-CHAR)
> * [类型 EXTENDED-CHAR](#T-EXTENDED-CHAR)
> * [函数 CHAR=, CHAR/=, CHAR<, CHAR>, CHAR<=, CHAR>=, CHAR-EQUAL, CHAR-NOT-EQUAL, CHAR-LESSP, CHAR-GREATERP, CHAR-NOT-GREATERP, CHAR-NOT-LESSP](#F-CCCCCCCCCCCC)
> * [函数 CHARACTER](#F-CHARACTER)
> * [函数 CHARACTERP](#F-CHARACTERP)
> * [函数 ALPHA-CHAR-P](#F-ALPHA-CHAR-P)
> * [函数 ALPHANUMERICP](#F-ALPHANUMERICP)
> * [函数 DIGIT-CHAR](#F-DIGIT-CHAR)
> * [函数 DIGIT-CHAR-P](#F-DIGIT-CHAR-P)
> * [函数 GRAPHIC-CHAR-P](#F-GRAPHIC-CHAR-P)
> * [函数 STANDARD-CHAR-P](#F-STANDARD-CHAR-P)
> * [函数 CHAR-UPCASE, CHAR-DOWNCASE](#F-CHAR-UPCASE-DOWNCASE)
> * [函数 UPPER-CASE-P, LOWER-CASE-P, BOTH-CASE-P](#F-CASE-P)
> * [函数 CHAR-CODE](#F-CHAR-CODE)
> * [函数 CHAR-INT](#F-CHAR-INT)
> * [函数 CODE-CHAR](#F-CODE-CHAR)
> * [常量 CHAR-CODE-LIMIT](#CV-CHAR-CODE-LIMIT)
> * [函数 CHAR-NAME](#F-CHAR-NAME)
> * [函数 NAME-CHAR](#F-NAME-CHAR)

### <span id="SC-CHARACTER">系统类 CHARACTER</span>

* 类优先级列表(Class Precedence List):

        character, t

* 描述(Description):

      一个字符[character]是表示在文本总量中表示一个单一标记的一个对象[object]; 见章节 13.1 (字符概念).

      类型[type] base-char 和 extended-char 组成类型[type] character 的一个详尽分区[exhaustive partition].

* 参见(See Also):

        章节 13.1 (字符概念), 章节 2.4.8.1 (井号C(#C)), 章节 22.1.3.2 (打印字符) 


### <span id="T-BASE-CHAR">类型 BASE-CHAR</span>

* 超类型(Supertypes):

        base-char, character, t

* 描述(Description):

        类型[type] base-char 被定义为 standard-char 的提升数组元素类型[upgraded array element type]. 一个具体实现[implementation]可以支持额外的 character 类型[type]的子类型[subtype] (除了在这个标准中列出的那些), 它们可能或可能不是 base-char 类型[type]的超类型[supertype]. 另外, 一个具体实现[implementation]可以定义 base-char 为 charactor 的相同[same]类型[type].

        基本字符[base character]在以下方面有区别:

        1. 类型[type] standard-char 是类型[type] base-char 的一个子字符集[subrepertoire].
        2. 不是标准字符[standard character]的基本字符[base character]的判定是具体实现定义的.
        3. 只有 base-char 类型[type]的对象[object]可以是一个 base-string 类型[type]的元素[element].
        4. 在这个 base-char 字符集[repertoire]中没有指定字符数量的上边界; 那个字符集[repertoire]的大小是具体实现定义的[implementation-defined]. 下边界是 96, 就是标准字符[standard character]的数量.

        一个字符是否为一个基本字符[base character]依赖于一个具体实现[implementation]表示字符串[string]的方式, 而不是任何其他具体实现[implementation]和主机操作系统的特性. 比如, 一个实现可能把所有字符串[string]编码为有着16位编码的字符, 而另一种可能有着两种字符串[string]: 那些有着8位编码的字符和有着16位编码的字符. 在第一个实现[implementation]中, 类型[type] base-char 等价于 character 类型[type]: 这里只有一种字符串[string]. 在第二个实现[implementation]中, 基本字符[base character]是那些可以被存储在一个有着8位编码字符[character]的字符串[string]的字符[character]. 在这样一个实现[implementation]中, 类型[type] base-char 是一个 charactor 类型[type]的适当子类型[proper subtype].

        类型[type] standard-char 是类型[type] base-char 的子类型[subtype]. 


### <span id="T-STANDARD-CHAR">类型 STANDARD-CHAR</span>

* 超类型(Supertypes):

        standard-char, base-char, character, t

* 描述(Description):

        在所有符合规范的实现[conforming implementation]中, 需要有一个 96 个字符[character]的固定集合. 标准字符被定义在章节 2.1.3 (标准字符).

        任何不是简单字符的字符不是标准字符.

* 参见(See Also):

        章节 2.1.3 (标准字符) 

### </span id="T-EXTENDED-CHAR">类型 EXTENDED-CHAR</span>

* 超类型(Supertypes):

        extended-char, character, t

* 描述(Description):

        类型[type] extended-char 等价于类型[type] (and character (not base-char)).

* 注意(Notes):

        类型[type] extended-char 在所有字符[character]都是 base-char 类型[type]的实现[implementation]中可能没有元素[element[4]]. 

### <span id="F-CCCCCCCCCCCC">函数 CHAR=, CHAR/=, CHAR<, CHAR>, CHAR<=, CHAR>=, CHAR-EQUAL, CHAR-NOT-EQUAL, CHAR-LESSP, CHAR-GREATERP, CHAR-NOT-GREATERP, CHAR-NOT-LESSP</span>

* 语法(Syntax):

        char= &rest characters+ => generalized-boolean

        char/= &rest characters+ => generalized-boolean

        char< &rest characters+ => generalized-boolean

        char> &rest characters+ => generalized-boolean

        char<= &rest characters+ => generalized-boolean

        char>= &rest characters+ => generalized-boolean

        char-equal &rest characters+ => generalized-boolean

        char-not-equal &rest characters+ => generalized-boolean

        char-lessp &rest characters+ => generalized-boolean

        char-greaterp &rest characters+ => generalized-boolean

        char-not-greaterp &rest characters+ => generalized-boolean

        char-not-lessp &rest characters+ => generalized-boolean

* 参数和值(Arguments and Values):

        character---一个字符[character].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        这些断言用来比较字符[character].

        如果所有字符 characters 都是相同的[same]那么 char= 返回 true; 否则, 它返回 false. 如果两个字符在任何一个具体实现定义[implementation-defined]的属性[attribute]上不相同, 那么它们就不是 char= 的.

        如果所有字符 characters 都是不同的那么 char/= 返回 true; 否则, 它返回 false.

        如果所有字符 characters 都是单调递增那么 char< 返回 true; 否则, 它返回 false. 如果两个字符[character]有着相同的具体实现定义[implementation-defined]的属性[attribute], 那么它们根据 char< 得到的顺序和在它们的码值[code]上根据断言 < 得到的顺序一致.

        如果所有字符 characters 都是单调递减那么 char> 返回 true; 否则, 它返回 false. 如果两个字符[character]有着相同的具体实现定义[implementation-defined]的属性[attribute], 那么它们根据 char> 得到的顺序和在它们的码值[code]上根据断言 > 得到的顺序一致.

        如果所有字符 characters 都是非单调递减的那么 char<= 返回 true; 否则, 它返回 false. 如果两个字符[character]有着相同的具体实现定义[implementation-defined]的属性[attribute], 那么它们根据 char<= 得到的顺序和在它们的码值[code]上根据断言 <= 得到的顺序一致.

        如果所有字符 characters 都是非单调递增的那么 char>= 返回 true; 否则, 它返回 false. 如果两个字符有着相同的具体实现定义[implementation-defined]的属性[attribute], 那么它们根据 char>= 得到的顺序和在它们的码值[code]上根据断言 >= 得到的顺序一致.

        char-equal, char-not-equal, char-lessp, char-greaterp, char-not-greaterp, 和 char-not-lessp 分别类似于 char=, char/=, char<, char>, char<=, char>=, 除了它们忽略大小写[case]差异并且可能对非简单[non-simple]字符[character]有着具体实现定义的[implementation-defined]行为. 比如, 一个具体实现[implementation]可能定义 char-equal, 等等, 忽略某些具体实现定义[implementation-defined]的属性[attribute]. 每个具体实现定义[implementation-defined]的属性[attribute]对这些函数的影响(如果有的话)必须被指定为该属性定义的一部分.

* 示例(Examples):

    ```LISP
    (char= #\d #\d) =>  true
    (char= #\A #\a) =>  false
    (char= #\d #\x) =>  false
    (char= #\d #\D) =>  false
    (char/= #\d #\d) =>  false
    (char/= #\d #\x) =>  true
    (char/= #\d #\D) =>  true
    (char= #\d #\d #\d #\d) =>  true
    (char/= #\d #\d #\d #\d) =>  false
    (char= #\d #\d #\x #\d) =>  false
    (char/= #\d #\d #\x #\d) =>  false
    (char= #\d #\y #\x #\c) =>  false
    (char/= #\d #\y #\x #\c) =>  true
    (char= #\d #\c #\d) =>  false
    (char/= #\d #\c #\d) =>  false
    (char< #\d #\x) =>  true
    (char<= #\d #\x) =>  true
    (char< #\d #\d) =>  false
    (char<= #\d #\d) =>  true
    (char< #\a #\e #\y #\z) =>  true
    (char<= #\a #\e #\y #\z) =>  true
    (char< #\a #\e #\e #\y) =>  false
    (char<= #\a #\e #\e #\y) =>  true
    (char> #\e #\d) =>  true
    (char>= #\e #\d) =>  true
    (char> #\d #\c #\b #\a) =>  true
    (char>= #\d #\c #\b #\a) =>  true
    (char> #\d #\d #\c #\a) =>  false
    (char>= #\d #\d #\c #\a) =>  true
    (char> #\e #\d #\b #\c #\a) =>  false
    (char>= #\e #\d #\b #\c #\a) =>  false
    (char> #\z #\A) =>  implementation-dependent
    (char> #\Z #\a) =>  implementation-dependent
    (char-equal #\A #\a) =>  true
    (stable-sort (list #\b #\A #\B #\a #\c #\C) #'char-lessp)
    =>  (#\A #\a #\b #\B #\c #\C)
    (stable-sort (list #\b #\A #\B #\a #\c #\C) #'char<)
    =>  (#\A #\B #\C #\a #\b #\c) ;Implementation A
    =>  (#\a #\b #\c #\A #\B #\C) ;Implementation B
    =>  (#\a #\A #\b #\B #\c #\C) ;Implementation C
    =>  (#\A #\a #\B #\b #\C #\c) ;Implementation D
    =>  (#\A #\B #\a #\b #\C #\c) ;Implementation E
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果一个字符 character 都没有提供那么应该发出一个 program-error 类型[type]的错误.

* 参见(See Also):

        章节 2.1 (字符语法), 章节 13.1.10 (具体实现定义的文字的文档)

* 注意(Notes):

        如果字符在它们的码值[code]属性[attribute]或其他具体实现定义[implementation-defined]的属性[attribute]上有区别, 它们被 char= 当作是不同的.

        没有必要仅仅因为 (char= c1 c2) 为 true, (eq c1 c2) 就要为 true. 尽管 eq 可以区分两个 char= 区分不了的字符[character]时, 它不是作为字符[character]来区分它们, 而是某种意义上基于较低层次的具体实现的特性. 如果 (eq c1 c2) 是 true, 那么 (char= c1 c2) 也是 true. eql 和 equal 比较字符[character]的方式和 char= 相同.

        char-equal, char-not-equal, char-lessp, char-greaterp, char-not-greaterp, 和 char-not-lessp 所使用的大小写[case]的惯例意味着标准字符[standard character]的顺序是 A=a, B=b, 诸如此类, 直到 Z=z, 而且 9<A 或 Z<0. 


### <span id="F-CHARACTER">函数 CHARACTER</span>

* 语法(Syntax):

        character character => denoted-character

* 参数和值(Arguments and Values):

        character---一个字符标识符[character designator].
        denoted-character---一个字符[character].

* 描述(Description):

        返回标识符[designator] character 表示的字符[character].

* 示例(Examples):

    ```LISP
    (character #\a) =>  #\a
    (character "a") =>  #\a
    (character 'a) =>  #\A
    (character '\a) =>  #\a
    (character 65.) is an error.
    (character 'apple) is an error.
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果对象 character 不是一个字符标识符[character designator], 那么应该发出一个 type-error 类型[type]的错误.
<!--这里的 character 原文是 object-->
* 参见(See Also):

        coerce

* 注意(Notes):

        (character object) ==  (coerce object 'character)


### <span id="F-CHARACTERP">函数 CHARACTERP</span>

* 语法(Syntax):

        characterp object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 character 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (characterp #\a) =>  true
    (characterp 'a) =>  false
    (characterp "a") =>  false
    (characterp 65.) =>  false
    (characterp #\Newline) =>  true
    ;; This next example presupposes an implementation 
    ;; in which #\Rubout is an implementation-defined character.
    (characterp #\Rubout) =>  true
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        character (类型[type]和函数[function]), typep

* 注意(Notes):

        (characterp object) ==  (typep object 'character)


### <span id="F-ALPHA-CHAR-P">函数 ALPHA-CHAR-P</span>

* 语法(Syntax):

        alpha-char-p character => generalized-boolean

* 参数和值(Arguments and Values):

        character---一个字符[character].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果字符 character 是一个字母[alphabetic[1]]字符[character]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (alpha-char-p #\a) =>  true
    (alpha-char-p #\5) =>  false
    (alpha-char-p #\Newline) =>  false
    ;; This next example presupposes an implementation
    ;; in which #\<ALPHA> is a defined character.
    (alpha-char-p #\<ALPHA>) =>  implementation-dependent
    ```

* 受此影响(Affected By):

        无. (特别地, 这个断言的结果独立于任何在当前读取表[current readtable]中被启用的特殊语法.)

* 异常情况(Exceptional Situations):

        如果 character 不是一个字符[character]就应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        alphanumericp, 章节 13.1.10 (具体实现定义的文字的文档)

* 注意(Notes): None. 

### <span id="F-ALPHANUMERICP">函数 ALPHANUMERICP</span>

* 语法(Syntax):

        alphanumericp character => generalized-boolean

* 参数和值(Arguments and Values):

        character---一个字符[character].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果 character 是一个字母[alphabetic[1]]字符[character]或一个数字[numeric]字符[character]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (alphanumericp #\Z) =>  true
    (alphanumericp #\9) =>  true
    (alphanumericp #\Newline) =>  false
    (alphanumericp #\#) =>  false
    ```

* 受此影响(Affected By):

        无. (特别地, 这个断言的结果独立于任何在当前读取表[current readtable]中被启用的特殊语法.)

* 异常情况(Exceptional Situations):

        如果 character 不是一个字符[character]就应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        alpha-char-p, graphic-char-p, digit-char-p

* 注意(Notes):

        字母数字字符是图形的就像 graphic-char-p 定义的那样. 字母数字字符是图形字符的一个子集. 标准字符 A 到 Z, a 到 z, 还有 0 到 9 是字母数字字符.

        (alphanumericp x)
          ==  (or (alpha-char-p x) (not (null (digit-char-p x))))


### <span id="F-DIGIT-CHAR">函数 DIGIT-CHAR</span>

* 语法(Syntax):

        digit-char weight &optional radix => char

* 参数和值(Arguments and Values):

        weight---一个非负整数[integer].
        radix---一个基数[radix]. 默认是 10.
        char---一个字符[character]或 false.

* 描述(Description):

        如果权重 weight 小于基数 radix, 那么 digit-char 返回一个字符[character], 当这个字符被当作指定基数下的数字时有着那个权重 weight. 如果产生的字符[character]是一个字母[alphabetic[1]]字符[character], 它会是一个大写[uppercase]字符[character].

        如果权重 weight 大于等于基数 radix, digit-char 返回 false.

* 示例(Examples):

    ```LISP
    (digit-char 0) =>  #\0
    (digit-char 10 11) =>  #\A
    (digit-char 10 10) =>  false
    (digit-char 7) =>  #\7
    (digit-char 12) =>  false
    (digit-char 12 16) =>  #\C  ;not #\c
    (digit-char 6 2) =>  false
    (digit-char 1 2) =>  #\1
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        digit-char-p, graphic-char-p, 章节 2.1 (字符语法)

* 注意(Notes):

### <span id="F-DIGIT-CHAR-P">函数 DIGIT-CHAR-P</span>

* 语法(Syntax):

        digit-char-p char &optional radix => weight

* 参数和值(Arguments and Values):

        char---一个字符[character].
        radix---一个基数[radix]. 默认为 10.
        weight---一个小于基数 radix 的非负整数[integer], 或者 false.

* 描述(Description):

        测试字符 char 是否为给定基数下的一个数字 (换句话说, 它带有小于基数 radix 的权重). 如果它是那个基数下的一个数字, 它的权重会作为整数[integer]返回; 否则返回 nil.

* 示例(Examples):

    ```LISP
    (digit-char-p #\5)    =>  5
    (digit-char-p #\5 2)  =>  false
    (digit-char-p #\A)    =>  false
    (digit-char-p #\a)    =>  false
    (digit-char-p #\A 11) =>  10
    (digit-char-p #\a 11) =>  10
    (mapcar #'(lambda (radix) 
                (map 'list #'(lambda (x) (digit-char-p x radix)) 
                      "059AaFGZ"))
            '(2 8 10 16 36))
    =>  ((0 NIL NIL NIL NIL NIL NIL NIL)
        (0 5 NIL NIL NIL NIL NIL NIL)
        (0 5 9 NIL NIL NIL NIL NIL)
        (0 5 9 10 10 15 NIL NIL)
        (0 5 9 10 10 15 16 35))
    ```

* 受此影响(Affected By):

        无. (特别地, 这个断言的结果独立于任何在当前读取表[current readtable]中被启用的特殊语法.)

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        alphanumericp

* 注意(Notes):

        数字是一个图形[graphic]字符[character].
 

### <span id="F-GRAPHIC-CHAR-P">函数 GRAPHIC-CHAR-P</span>

* 语法(Syntax):

        graphic-char-p char => generalized-boolean

* 参数和值(Arguments and Values):

        char---一个字符.
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果字符 character 是一个图形[graphic]字符[character]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (graphic-char-p #\G) =>  true
    (graphic-char-p #\#) =>  true
    (graphic-char-p #\Space) =>  true
    (graphic-char-p #\Newline) =>  false
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 character 不是一个字符[character]就应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        read, 章节 2.1 (字符语法), 章节 13.1.10 (具体实现定义的文字的文档)

* 注意(Notes): None. 

### <span id="F-STANDARD-CHAR-P">函数 STANDARD-CHAR-P</span>

* 语法(Syntax):

        standard-char-p character => generalized-boolean

* 参数和值(Arguments and Values):

        character---一个字符[character].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果字符 character 是 standard-char 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (standard-char-p #\Space) =>  true
    (standard-char-p #\~) =>  true
    ;; This next example presupposes an implementation
    ;; in which #\Bell is a defined character.
    (standard-char-p #\Bell) =>  false
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 character 不是一个字符[character]就应该发出一个 type-error 类型[type]的错误.

* 参见(See Also): None.

* 注意(Notes): None. 

### <span id="F-CHAR-UPCASE-DOWNCASE">函数 CHAR-UPCASE, CHAR-DOWNCASE</span>

* 语法(Syntax):

        char-upcase character => corresponding-character

        char-downcase character => corresponding-character

* 参数和值(Arguments and Values):

        character, corresponding-character---一个字符.

* 描述(Description):

        如果字符 character 是一个小写[lowercase]字符[character], char-upcase 返回对应大写[uppercase]字符[character]. 否则, char-upcase 只是返回给定字符 character.

        如果 character 是一个大写[uppercase]字符[character], char-downcase 返回对应小写[lowercase]字符[character]. 否则, char-downcase 只是返回给定字符 character.

        结果只在码值[code]属性[attribute]上和字符 character 有区别; 所有具体实现定义[implementation-defined]的属性[attribute]都会被保留.

* 示例(Examples):

    ```LISP
    (char-upcase #\a) =>  #\A
    (char-upcase #\A) =>  #\A
    (char-downcase #\a) =>  #\a
    (char-downcase #\A) =>  #\a
    (char-upcase #\9) =>  #\9
    (char-downcase #\9) =>  #\9
    (char-upcase #\@) =>  #\@
    (char-downcase #\@) =>  #\@
    ;; Note that this next example might run for a very long time in 
    ;; some implementations if CHAR-CODE-LIMIT happens to be very large
    ;; for that implementation.
    (dotimes (code char-code-limit)
      (let ((char (code-char code)))
        (when char
          (unless (cond ((upper-case-p char) (char= (char-upcase (char-downcase char)) char))
                        ((lower-case-p char) (char= (char-downcase (char-upcase char)) char))
                        (t (and (char= (char-upcase (char-downcase char)) char)
                                (char= (char-downcase (char-upcase char)) char))))
            (return char)))))
    =>  NIL
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 character 不是一个字符[character]就应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        upper-case-p, alpha-char-p, 章节 13.1.4.3 (大小写字符), 章节 13.1.10 (具体实现定义的文字的文档)

* 注意(Notes):

        如果这个 corresponding-char 和 character 不同[different], 那么字符 character 和 corresponding-char 都有大小写[case].

        由于 char-equal 忽略它比较的字符[character]的大小写[case], 因此这个 corresponding-character 在 char-equal 下总是和字符 character 相同[same]. 


### <span id="F-CASE-P">函数 UPPER-CASE-P, LOWER-CASE-P, BOTH-CASE-P</span>

* 语法(Syntax):

        upper-case-p character => generalized-boolean

        lower-case-p character => generalized-boolean

        both-case-p character => generalized-boolean

* 参数和值(Arguments and Values):

        character---一个符号[symbol].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        这些函数测试给定字符的大小写.

        如果字符 character 是一个大写[uppercase]字符[character]那么 upper-case-p 返回 true; 否则, 返回 false.

        如果字符 character 是一个小写[lowercase]字符[character]那么 lower-case-p 返回 true; 否则, 返回 false.

        如果字符 character 是一个带有大小写[case]的字符[character]那么 both-case-p 返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (upper-case-p #\A) =>  true
    (upper-case-p #\a) =>  false
    (both-case-p #\a) =>  true
    (both-case-p #\5) =>  false
    (lower-case-p #\5) =>  false
    (upper-case-p #\5) =>  false
    ;; This next example presupposes an implementation 
    ;; in which #\Bell is an implementation-defined character.
    (lower-case-p #\Bell) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 character 不是一个字符[character]就应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        char-upcase, char-downcase, 章节 13.1.4.3 (大小写字符), 章节 13.1.10 (具体实现定义的文字的文档)

* 注意(Notes): None. 

### <span id="F-CHAR-CODE">函数 CHAR-CODE</span>

* 语法(Syntax):

        char-code character => code

* 参数和值(Arguments and Values):

        character---一个字符[character].
        code---一个字符码值[character code].

* 描述(Description):

        char-code 返回字符 character 的码值[code]属性[attribute].

* 示例(Examples):

    ```LISP
    ;; An implementation using ASCII character encoding 
    ;; might return these values:
    (char-code #\$) =>  36
    (char-code #\a) =>  97
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 character 不是一个字符[character]就应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        char-code-limit

* 注意(Notes): None. 

### <span id="F-CHAR-INT">函数 CHAR-INT</span>

* 语法(Syntax):

        char-int character => integer

* 参数和值(Arguments and Values):

        character---一个字符[character].
        integer---一个非负整数[integer].

* 描述(Description):

        返回一个编码这个字符 character 对象的非负整数[integer]. 这个整数[integer]计算的方式是依赖于具体实现的[implementation-dependent]. 与 sxhash 相比, 结果不保证独立于特定的 Lisp 镜像[Lisp image].

        如果字符 character 没有具体实现定义[implementation-defined]的属性[attribute], char-int 和 char-code 的结果是相同的.

        对于字符 c1 和 c2

        (char= c1 c2) ==  (= (char-int c1) (char-int c2))

* 示例(Examples):

    ```LISP
    (char-int #\A) =>  65       ; implementation A
    (char-int #\A) =>  577      ; implementation B
    (char-int #\A) =>  262145   ; implementation C
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        char-code

* 注意(Notes): None. 

### <span id="F-CODE-CHAR">函数 CODE-CHAR</span>

* 语法(Syntax):

        code-char code => char-p

* 参数和值(Arguments and Values):

        code---一个字符码值[character code].
        char-p---一个字符[character]或 nil.

* 描述(Description):

        返回一个带有给定码值 code 的码值[code]属性[attribute]的字符[character]. 如果不存在这样的字符[character]并且不能创建一个, 那么就返回 nil.

* 示例(Examples):

    ```LISP
    (code-char 65.) =>  #\A  ;in an implementation using ASCII codes
    (code-char (char-code #\Space)) =>  #\Space  ;in any implementation
    ```

* 受此影响(Affected By):

        具体实现[implementation]的字符编码.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        char-code

* 注意(Notes):


### <span id="CV-CHAR-CODE-LIMIT">常量 CHAR-CODE-LIMIT</span>

* 常量值(Constant Value):

        一个非负整数[integer], 它的准确大小是依赖于具体实现的[implementation-dependent], 但是不小于 96 (标准字符[standard character]的数量).

* 描述(Description):

        函数[function] char-code 返回的值[value]的上边界.

* 参见(See Also):

        char-code

* 注意(Notes):

        char-code-limit 的值[value]可能大于这个具体实现[implementation]所支持的字符[character]数量. 


### <span id="F-CHAR-NAME">函数 CHAR-NAME</span>

* 语法(Syntax):

        char-name character => name

* 参数和值(Arguments and Values):

        character---一个字符[character].
        name---一个字符串[string]或 nil.

* 描述(Description):

        返回字符 character 名称[name]字符串[string], 如果字符 character 没有名称[name]就是 nil.

        所有非图形[non-graphic]字符需要有名字[name], 除非它们有着一些具体实现定义的[implementation-defined]不为空[null]的属性[attribute]. 其他字符[character]是否有名称[name]是依赖于具体实现的[implementation-dependent].

        标准字符[standard character] <Newline> 和 <Space> 有着各自的名称 "Newline" 和 "Space". 不完全标准[semi-standard]字符[character] <Tab>, <Page>, <Rubout>, <Linefeed>, <Return>, 和 <Backspace> (如果这个具体实现[implementation]支持它们的话) 有着各自的名称 "Tab", "Page", "Rubout", "Linefeed", "Return", 和 "Backspace" (在这个指示的情况下, 即便名字是通过 "#\" 和函数[function] name-char 查找的也不是大小写敏感的).

* 示例(Examples):

    ```LISP
    (char-name #\ ) =>  "Space"
    (char-name #\Space) =>  "Space"
    (char-name #\Page) =>  "Page"

    (char-name #\a)
    =>  NIL
    OR=>  "LOWERCASE-a"
    OR=>  "Small-A"
    OR=>  "LA01"

    (char-name #\A)
    =>  NIL
    OR=>  "UPPERCASE-A"
    OR=>  "Capital-A"
    OR=>  "LA02"

    ;; Even though its CHAR-NAME can vary, #\A prints as #\A
    (prin1-to-string (read-from-string (format nil "#\\~A" (or (char-name #\A) "A"))))
    =>  "#\\A"
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 character 不是一个字符[character]就应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        name-char, 章节 22.1.3.2 (打印字符)

* 注意(Notes):

        非图形[non-graphic]字符[character]的名字[name]被 Lisp 打印器[Lisp printer]写做 "#\" 后面跟着这个名字[name]; 见章节 22.1.3.2 (打印字符). 

### <span id="F-NAME-CHAR">函数 NAME-CHAR</span>

* 语法(Syntax):

        name-char name => char-p

* 参数和值(Arguments and Values):

        name---一个字符串标识符[string designator].
        char-p---一个字符[character]或 nil.

* 描述(Description):

        返回名称[name]为 name 的字符[character]对象[object] (由 string-equal 决定---换句话说, 查找是大小写敏感的). 如果这样一个字符[character]不存在, 返回 nil.

* 示例(Examples):

    ```LISP
    (name-char 'space) =>  #\Space
    (name-char "space") =>  #\Space
    (name-char "Space") =>  #\Space
    (let ((x (char-name #\a)))
      (or (not x) (eql (name-char x) #\a))) =>  true
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 name 不是一个字符串标识符[string designator], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        char-name

* 注意(Notes): None. 


# 14. 构造(Conses)

> * 14.1 [构造的概念](#ConsConcepts)
> * 14.2 [构造的字典](#TheConsesDictionary)


## 14.1 <span id="ConsConcepts">构造的概念</span>

一个构造[cons]是一个有着称为 car 和 cdr 两部分的复合数据对象[object].

    car  cons    rplacd  
    cdr  rplaca          

    Figure 14-1. 和构造相关的已定义的名字.

根据上下文, 一组连接的构造[cons]可以以各种不同的视角来看. 提供了各种各样的操作来支持这些不同的视角.

> * 14.1.1 [构造作为树](#ConsesTrees)
> * 14.1.2 [构造作为列表](#ConsesLists)

### 14.1.1 <span id="ConsesTrees">构造作为树</span>

一个树[tree]是一个由构造[cons]和原子[atom]组成的二元递归数据结构: 这些构造[cons]自身也是树[true] (有时称之为 "子树(subtree)" 或 "分枝(branch)"), 而这些原子[atom]是终止节点 (有时也称为叶[leave]). 典型地, 这些叶[leave]表示数据而分枝确定这些数据的关系.

    caaaar  caddar  cdar       nsubst         
    caaadr  cadddr  cddaar     nsubst-if      
    caaar   caddr   cddadr     nsubst-if-not  
    caadar  cadr    cddar      nthcdr         
    caaddr  cdaaar  cdddar     sublis         
    caadr   cdaadr  cddddr     subst          
    caar    cdaar   cdddr      subst-if       
    cadaar  cdadar  cddr       subst-if-not   
    cadadr  cdaddr  copy-tree  tree-equal     
    cadar   cdadr   nsublis                   

    Figure 14-2. 和树相关的一些已定义的名字.

#### 14.1.1.1 对必须是树的参数的常规限制

除非有明确的声明, 对于任何接受一个必须为树[tree]的形参[parameter]的标准化[standardized]函数[function], 如果该树[tree]是环状的, 其后果是未定义的. 

### 14.1.2 <span id="ConsesLists">构造作为列表</span>

一个列表[list]是一个构造[cons]的链, 其中每一个构造[cons]的 car 是这个列表[list]的元素[element], 而每个构造[cons]的 cdr 是这个链中的下一个链接或一个终止原子[atom].

一个正规列表[proper list]列表是一个以空列表[empty list]终止的列表[list]. 这个空列表[empty list]是一个正规列表[proper list], 但不是一个构造[cons].

一个非正规列表[improper list]是一个不是正规列表[proper list]的列表[list]; 这也就是说, 它是一个环状列表[circular list]或一个点列表[dotted list].

一个点列表[dotted list]是一个有着一个不是空列表[empty list]的终止原子[atom]的列表[list]. 一个非 nil [non-nil]的原子[atom]自身不会被当作任何种类的列表[list]---甚至不是一个点列表[dotted list].

一个环状列表[circular list]是一个构造[cons]的链, 由于这个链中的某个构造[cons]是后面一个构造[cons]的 cdr 所以它没有终止.

    append      last           nbutlast  rest       
    butlast     ldiff          nconc     revappend  
    copy-alist  list           ninth     second     
    copy-list   list*          nreconc   seventh    
    eighth      list-length    nth       sixth      
    endp        make-list      nthcdr    tailp      
    fifth       member         pop       tenth      
    first       member-if      push      third      
    fourth      member-if-not  pushnew              

    Figure 14-3. 和列表相关的已定义的名字.

> * 14.1.2.1 [列表作为关联列表](#ListsAssociationLists)
> * 14.1.2.2 [列表作为集合](#ListsSets)
> * 14.1.2.3 [对必须是列表的参数的普通限制](#GeneralRestrictParametersLists)


#### 14.1.2.1 <span id="ListsAssociationLists">列表作为关联列表</span>

一个关联列表[association list]是一个表示一个键[key]和值[value]关联的构造[cons]的列表[list], 其中每一个构造[cons]的 car 是那个键[key]而 cdr 是和那个键[key]关联的值[value].

    acons  assoc-if      pairlis  rassoc-if      
    assoc  assoc-if-not  rassoc   rassoc-if-not  

    Figure 14-4. 和关联列表相关的已定义的名字.


#### 14.1.2.2 <span id="ListsSets">列表作为集合</span>

列表[list]有时可以通过把它们的元素当作无序的并且假定这里没有重复元素来视作集合.

    adjoin         nset-difference    set-difference    union  
    intersection   nset-exclusive-or  set-exclusive-or         
    nintersection  nunion             subsetp                  

    Figure 14-5. 和集合相关的已定义的名字.


#### 14.1.2.3 <span id="GeneralRestrictParametersLists">对必须是列表的参数的普通限制</span>

除非有明确的声明, 对于任何接受一个需要为列表[list]的形参[parameter]的标准化[standard]函数[function], 如果接收到的值[value]是一个点列表[dotted list], 都应该准备发出一个 type-error 类型[type]的错误.

除非有明确的声明, 对于任何接受一个需要为列表[list]的参数[parameter]的标准化[standard]函数[function], 如果列表[list]是环状[circular]的那么后果是未定义的. 


## 14.2 <span id="TheConsesDictionary">构造的字典</span>

> * [系统类 LIST](#SC-LIST)
> * [系统类 NULL](#SC-NULL)
> * [系统类 CONS](#SC-CONS)
> * [类型 ATOM](#T-ATOM)
> * [函数 CONS](#F-CONS)
> * [函数 CONSP](#F-CONSP)
> * [函数 ATOM](#F-ATOM)
> * [函数 RPLACA, RPLACD](#F-RPLACA-RPLACD)
> * [访问器 CAR, CDR, CAAR, CADR, CDAR, CDDR, CAAAR, CAADR, CADAR, CADDR, CDAAR, CDADR, CDDAR, CDDDR, CAAAAR, CAAADR, CAADAR, CAADDR, CADAAR, CADADR, CADDAR, CADDDR, CDAAAR, CDAADR, CDADAR, CDADDR, CDDAAR, CDDADR, CDDDAR, CDDDDR](#A-CR-ALL)
> * [函数 COPY-TREE](#F-COPY-TREE)
> * [函数 SUBLIS, NSUBLIS](#F-SUBLIS-NSUBLIS)
> * [函数 SUBST, SUBST-IF, SUBST-IF-NOT, NSUBST, NSUBST-IF, NSUBST-IF-NOT](#F-SUBST-ALL)
> * [函数 TREE-EQUAL](#F-TREE-EQUAL)
> * [函数 COPY-LIST](#F-COPY-LIST)
> * [函数 LIST, LIST*](#F-LIST-LIST)
> * [函数 LIST-LENGTH](#F-LIST-LENGTH)
> * [函数 LISTP](#F-LISTP)
> * [函数 MAKE-LIST](#F-MAKE-LIST)
> * [宏 PUSH](#M-PUSH)
> * [宏 POP](#M-POP)
> * [访问器 FIRST, SECOND, THIRD, FOURTH, FIFTH, SIXTH, SEVENTH, EIGHTH, NINTH, TENTH](#A-FSTFFSSENT)
> * [访问器 NTH](#A-NTH)
> * [函数 ENDP](#F-ENDP)
> * [函数 NULL](#F-NULL)
> * [函数 NCONC](#F-NCONC)
> * [函数 APPEND](#F-APPEND)
> * [函数 REVAPPEND, NRECONC](#F-REVAPPEND-NRECONC)
> * [函数 BUTLAST, NBUTLAST](#F-BUTLAST-NBUTLAST)
> * [函数 LAST](#F-LAST)
> * [函数 LDIFF, TAILP](#F-LDIFF-TAILP)
> * [函数 NTHCDR](#F-NTHCDR)
> * [访问器 REST](#A-REST)
> * [函数 MEMBER, MEMBER-IF, MEMBER-IF-NOT](#F-MEMBER-ALL)
> * [函数 MAPC, MAPCAR, MAPCAN, MAPL, MAPLIST, MAPCON](#F-MAP-ALL)
> * [函数 ACONS](#F-ACONS)
> * [函数 ASSOC, ASSOC-IF, ASSOC-IF-NOT](#F-ASSOC-ALL)
> * [函数 COPY-ALIST](#F-COPY-ALIST)
> * [函数 PAIRLIS](#F-PAIRLIS)
> * [函数 RASSOC, RASSOC-IF, RASSOC-IF-NOT](#F-RASSOC-ALL)
> * [函数 GET-PROPERTIES](#F-GET-PROPERTIES)
> * [访问器 GETF](#A-GETF)
> * [宏 REMF](#M-REMF)
> * [函数 INTERSECTION, NINTERSECTION](#F-INTERSECTION-NINTERSECTION)
> * [函数 ADJOIN](#F-ADJOIN)
> * [宏 PUSHNEW](#M-PUSHNEW)
> * [函数 SET-DIFFERENCE, NSET-DIFFERENCE](#F-SET-DIFFERENCE-ALL)
> * [函数 SET-EXCLUSIVE-OR, NSET-EXCLUSIVE-OR](#F-SET-EXCLUSIVE-OR-ALL)
> * [函数 SUBSETP](#F-SUBSETP)
> * [函数 UNION, NUNION](#F-UNION-NUNION)


### <span id="SC-LIST">系统类 LIST</span>

* 类优先级列表(Class Precedence List):

        list, sequence, t

* 描述(Description):

        一个列表[list]是一个构造[cons]的链, 其中每一个构造[cons]的 car 是这个列表[list]的一个元素[element], 而每个构造[cons]的 cdr 是这个链的下一个链接或一个终止原子[atom].

        一个正规列表[proper list]是一个由空列表[empty list] () 来终止的构造[cons]链, 这个空列表[empty list]自身也是一个正规列表[proper list]. 一个点列表[dotted list]是一个终止原子[atom]不是空列表[empty list]的列表[list]. 一个环状列表[circular list]是一个由于链中的某个构造[cons]是后面的构造[cons]的 cdr 而没有终止的 cons 链.

        点列表[dotted list]和环状列表[circular list]也是列表[list], 但通常在这个规范中的那个非限制术语 "list" 意味着正规列表[proper list]. 然而, 类型[type] list 明确地包含了点列表[dotted list]和环状列表[circular list].

        对于一个列表[list]中的每个元素[element]这里都有一个构造[cons]. 空列表[empty list]没有元素[element]并且不是一个构造[cons].

        类型[type] cons 和 null 构成 list 类型[type]的详尽分区[exhaustive partition].

* 参见(See Also):

        章节 2.4.1 (左圆括号), 章节 22.1.3.5 (打印列表和构造(cons)) 


### <span id="SC-NULL">系统类 NULL</span>

* 类优先级列表(Class Precedence List):

        null, symbol, list, sequence, t

* 描述(Description):

        null 类型[type]仅有的对象[object]是 nil, 它表示空列表[empty list]并且也可以被标记为 ().

* 参见(See Also):

        章节 2.3.4 (符号标记), 章节 2.4.1 (左圆括号), 章节 22.1.3.3 (打印符号) 


### <span id="SC-CONS">系统类 CONS</span>

* 类优先级列表(Class Precedence List):

        cons, list, sequence, t

* 描述(Description):

        一个 cons 是一个有着两个部分的复合对象[object], 这两个部分称为 car 和 cdr. 这些组成了一个点对[dotted pair]. 每个部分可以是任何对象[object].

* 复合类型指定符类别(Compound Type Specifier Kind):

        详细的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        cons [car-typespec [cdr-typespec]]

* 复合类型指定符参数(Compound Type Specifier Arguments):

        car-typespec---一个类型指定符[type specifier], 或者符号[symbol] *. 默认是符号[symbol] *.

        cdr-typespec---一个类型指定符[type specifier], 或者符号[symbol] *. 默认是符号[symbol] *.

* 复合类型指定符描述(Compound Type Specifier Description):

        这个表示这个 car 受类型[type] car-typespec 约束而 cdr 受类型[type] cdr-typespec 约束的 cons 集合. (如果 car-typespec 或 cdr-typespec 是 *, 它就好像被表示为类型[type] t.)

* 参见(See Also):

        章节 2.4.1 (左圆括号), 章节 22.1.3.5 (打印列表和构造(cons)) 


### <span id="T-ATOM">类型 ATOM</span>

* 超类型(Supertypes):

        atom, t

* 描述(Description):

        它等价于 (not cons). 


### <span id="F-CONS">函数 CONS</span>

* 语法(Syntax):

        cons object-1 object-2 => cons

* 参数和值(Arguments and Values):

        object-1---一个对象[object].
        object-2---一个对象[object].
        cons---一个 cons.

* 描述(Description):

        创建一个新[fresh]的 cons, 它的 car 是对象 object-1 而它的 cdr 是对象 object-2.

* 示例(Examples):

    ```LISP
    (cons 1 2) =>  (1 . 2)
    (cons 1 nil) =>  (1)
    (cons nil 2) =>  (NIL . 2)
    (cons nil nil) =>  (NIL)
    (cons 1 (cons 2 (cons 3 (cons 4 nil)))) =>  (1 2 3 4)
    (cons 'a 'b) =>  (A . B)
    (cons 'a (cons 'b (cons 'c '()))) =>  (A B C)
    (cons 'a '(b c d)) =>  (A B C D)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        list

* 注意(Notes):

        如果 object-2 是一个列表[list], cons 可以被认为产生一个和 object-2 相似但是前面加上对象 object-1 的新的列表[list]. 


### <span id="F-CONSP">函数 CONSP</span>

* 语法(Syntax):

        consp object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 cons 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (consp nil) =>  false
    (consp (cons 1 2)) =>  true
    ```

        空列表[empty list]不是一个 cons, 因此

    ```LISP
    (consp '()) ==  (consp 'nil) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        listp

* 注意(Notes):

        (consp object) ==  (typep object 'cons) ==  (not (typep object 'atom)) ==  (typep object '(not atom))


### <span id="F-ATOM">函数 ATOM</span>

* 语法(Syntax):

        atom object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象是 atom 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (atom 'sss) =>  true
    (atom (cons 1 2)) =>  false
    (atom nil) =>  true
    (atom '()) =>  true
    (atom 3) =>  true
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes):

        (atom object) ==  (typep object 'atom) ==  (not (consp object))
        ==  (not (typep object 'cons)) ==  (typep object '(not cons))


### <span id="F-RPLACA-RPLACD">函数 RPLACA, RPLACD</span>

* 语法(Syntax):

        rplaca cons object => cons

        rplacd cons object => cons

* 发音(Pronunciation):

        rplaca: [,ree'plakuh] or [,ruh'plakuh]

        rplacd: [,ree'plakduh] or [,ruh'plakduh] or [,ree'plakdee] or [,ruh'plakdee]

* 参数和值(Arguments and Values):

        cons---一个 cons.
        object---一个对象[object].

* 描述(Description):

        rplaca 替换这个 cons 的 car 为对象 object.

        rplacd 替换这个 cons 的 cdr 为对象 object.

* 示例(Examples):

    ```LISP
    (defparameter *some-list* (list* 'one 'two 'three 'four)) =>  *some-list*
    *some-list* =>  (ONE TWO THREE . FOUR)
    (rplaca *some-list* 'uno) =>  (UNO TWO THREE . FOUR)
    *some-list* =>  (UNO TWO THREE . FOUR)
    (rplacd (last *some-list*) (list 'IV)) =>  (THREE IV)
    *some-list* =>  (UNO TWO THREE IV)
    ```

* 副作用(Side Effects):

        这个 cons 被修改.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

        如果 cons 不是一个构造(cons) 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also): None.

* 注意(Notes): None. 

### <span id="A-CR-ALL">访问器 CAR, CDR, CAAR, CADR, CDAR, CDDR, CAAAR, CAADR, CADAR, CADDR, CDAAR, CDADR, CDDAR, CDDDR, CAAAAR, CAAADR, CAADAR, CAADDR, CADAAR, CADADR, CADDAR, CADDDR, CDAAAR, CDAADR, CDADAR, CDADDR, CDDAAR, CDDADR, CDDDAR, CDDDDR</span>

* 语法(Syntax):

        car x => object

        cdr x => object

        caar x => object

        cadr x => object

        cdar x => object

        cddr x => object

        caaar x => object

        caadr x => object

        cadar x => object

        caddr x => object

        cdaar x => object

        cdadr x => object

        cddar x => object

        cdddr x => object

        caaaar x => object

        caaadr x => object

        caadar x => object

        caaddr x => object

        cadaar x => object

        cadadr x => object

        caddar x => object

        cadddr x => object

        cdaaar x => object

        cdaadr x => object

        cdadar x => object

        cdaddr x => object

        cddaar x => object

        cddadr x => object

        cdddar x => object

        cddddr x => object

        (setf (car x) new-object)

        (setf (cdr x) new-object)

        (setf (caar x) new-object)

        (setf (cadr x) new-object)

        (setf (cdar x) new-object)

        (setf (cddr x) new-object)

        (setf (caaar x) new-object)

        (setf (caadr x) new-object)

        (setf (cadar x) new-object)

        (setf (caddr x) new-object)

        (setf (cdaar x) new-object)

        (setf (cdadr x) new-object)

        (setf (cddar x) new-object)

        (setf (cdddr x) new-object)

        (setf (caaaar x) new-object)

        (setf (caaadr x) new-object)

        (setf (caadar x) new-object)

        (setf (caaddr x) new-object)

        (setf (cadaar x) new-object)

        (setf (cadadr x) new-object)

        (setf (caddar x) new-object)

        (setf (cadddr x) new-object)

        (setf (cdaaar x) new-object)

        (setf (cdaadr x) new-object)

        (setf (cdadar x) new-object)

        (setf (cdaddr x) new-object)

        (setf (cddaar x) new-object)

        (setf (cddadr x) new-object)

        (setf (cdddar x) new-object)

        (setf (cddddr x) new-object)

* 发音(Pronunciation):

        cadr: ['ka,duhr]

        caddr: ['kaduh,duhr] or ['ka,dduhr]

        cdr: ['k,duhr]

        cddr: ['kduh,duhr] or ['kuh,dduhr]

* 参数和值(Arguments and Values):

        x---一个列表[list].
        object---一个对象[object].
        new-object---一个对象[object].

* 描述(Description):

        如果 x 是一个 cons, car 返回这个 cons 的 car. 如果 x 是 nil, car 返回 nil.

        如果 x 是一个 cons, cdr 返回这个 cons 的 cdr. 如果 x 是 nil, cdr 返回 nil.

        提供了执行多达四个 car 和 cdr 操作组合的函数. 它们的名字[name]有一个 C, 后面跟着 2, 3, 或 4 个 A 或 D, 最后是一个 R. 在每个函数[function]名字[name]中的 A 和 D 的序列被选择用来确定这个函数执行的 car 和 cdr 操作的序列. 这个 A 和 D 出现的顺序是对应操作被执行的顺序的倒序. 下一段准确地定义了这些关系.

            这个位置 ...     相当于这个位置 ...  
            (caar x)        (car (car x))                    
            (cadr x)        (car (cdr x))                    
            (cdar x)        (cdr (car x))                    
            (cddr x)        (cdr (cdr x))                    
            (caaar x)       (car (car (car x)))              
            (caadr x)       (car (car (cdr x)))              
            (cadar x)       (car (cdr (car x)))              
            (caddr x)       (car (cdr (cdr x)))              
            (cdaar x)       (cdr (car (car x)))              
            (cdadr x)       (cdr (car (cdr x)))              
            (cddar x)       (cdr (cdr (car x)))              
            (cdddr x)       (cdr (cdr (cdr x)))              
            (caaaar x)      (car (car (car (car x))))        
            (caaadr x)      (car (car (car (cdr x))))        
            (caadar x)      (car (car (cdr (car x))))        
            (caaddr x)      (car (car (cdr (cdr x))))        
            (cadaar x)      (car (cdr (car (car x))))        
            (cadadr x)      (car (cdr (car (cdr x))))        
            (caddar x)      (car (cdr (cdr (car x))))        
            (cadddr x)      (car (cdr (cdr (cdr x))))        
            (cdaaar x)      (cdr (car (car (car x))))        
            (cdaadr x)      (cdr (car (car (cdr x))))        
            (cdadar x)      (cdr (car (cdr (car x))))        
            (cdaddr x)      (cdr (car (cdr (cdr x))))        
            (cddaar x)      (cdr (cdr (car (car x))))        
            (cddadr x)      (cdr (cdr (car (cdr x))))        
            (cdddar x)      (cdr (cdr (cdr (car x))))        
            (cddddr x)      (cdr (cdr (cdr (cdr x))))        

            Figure 14-6. CAR 和 CDR 变体

        setf 也可以和这些函数中的任意一个一起使用来改变一个已存在的 x 的成分, 但是 setf 不会创建新的成分. 所以, 比如, 一个 cons 的 car 可以用 car 的 setf 来赋值, 但是 nil 的 car 不能使用 car 的 setf 来赋值. 相似地, 一个 car 为一个 cons 的 cons, 它的 car 的 car 可以使用 caar 的 setf 来赋值, 但是 nil 和一个 car 为 nil 的 cons 不能使用 caar 的 setf 来赋值.

        参数 x 允许为一个点列表[dotted list]或者一个环状列表[circular list].

* 示例(Examples):

    ```LISP
    (car nil) =>  NIL  
    (cdr '(1 . 2)) =>  2
    (cdr '(1 2)) =>  (2)
    (cadr '(1 2)) =>  2 
    (car '(a b c)) =>  A
    (cdr '(a b c)) =>  (B C)
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果函数 car 和 cdr 收到参数不是一个列表[list], 那么它应该发出一个 type-error 类型的错误. 其他函数 (caar, cadr, ... cddddr) 应该处于错误检查的目的而表现地就好像是通过 car 和 cdr 的适当调用来定义的.

* 参见(See Also):

        rplaca, first, rest

* 注意(Notes):

        一个 cons 的 car 也可以通过使用 rplaca 来修改, 而一个 cons 的 cdr 可以使用 rplacd 来修改.

        (car x)    ==  (first x)
        (cadr x)   ==  (second x) ==  (car (cdr x))
        (caddr x)  ==  (third x)  ==  (car (cdr (cdr x)))
        (cadddr x) ==  (fourth x) ==  (car (cdr (cdr (cdr x))))


### <span id="F-COPY-TREE">函数 COPY-TREE</span>

* 语法(Syntax):

        copy-tree tree => new-tree

* 参数和值(Arguments and Values):

        tree---一个树[tree].
        new-tree---一个树[tree].

* 描述(Description):

        创建一个 cons 树[tree]的一个拷贝[copy].

        如果 tree 不是一个 cons, 它会被返回; 否则, 结果就是在树 tree 的 car 和 cdr 上调用 copy-tree 的结果的 cons. 换句话说, 由 tree 表示的树中的所有 cons 会被递归复制, 只有在没有 cons 时停止.

        copy-tree 不保持环状和子结构的共享.

* 示例(Examples):

    ```LISP
    (setq object (list (cons 1 "one")
                        (cons 2 (list 'a 'b 'c))))
    =>  ((1 . "one") (2 A B C))
    (setq object-too object) =>  ((1 . "one") (2 A B C))
    (setq copy-as-list (copy-list object))
    (setq copy-as-alist (copy-alist object))
    (setq copy-as-tree (copy-tree object))
    (eq object object-too) =>  true
    (eq copy-as-tree object) =>  false
    (eql copy-as-tree object) =>  false
    (equal copy-as-tree object) =>  true
    (setf (first (cdr (second object))) "a"
          (car (second object)) "two"
          (car object) '(one . 1)) =>  (ONE . 1)
    object =>  ((ONE . 1) ("two" "a" B C))
    object-too =>  ((ONE . 1) ("two" "a" B C))
    copy-as-list =>  ((1 . "one") ("two" "a" B C))
    copy-as-alist =>  ((1 . "one") (2 "a" B C))
    copy-as-tree =>  ((1 . "one") (2 A B C)) 
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        tree-equal

* 注意(Notes): None. 


### <span id="F-SUBLIS-NSUBLIS">函数 SUBLIS, NSUBLIS</span>

* 语法(Syntax):

        sublis alist tree &key key test test-not => new-tree

        nsublis alist tree &key key test test-not => new-tree

* 参数和值(Arguments and Values):

        alist---一个关联列表[association list].
        tree---一个树[tree].
        test---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        test-not---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        key---一个单实参[argument]函数[function]的标识符[designator], 或者 nil.
        new-tree---一个树[tree].

* 描述(Description):

        sublis 对树 tree (一个 cons 结构) 中的对象[object]进行替换. nsublis 和 sublis 相似但是它会破坏性修改树 tree 中相关的结构.

        sublis 查找树 tree 中的所有子树和叶; 如果一个子树或叶作为关联列表 alist 中的一个键出现 (这也就是说, 这个键和这个子树或叶满足这个测试条件[satisfy the test]), 那么它就会被和那个键关联的对象[object]所替换. 这个操作是非破坏性的. 实际上, sublis 可以同时执行多个 subst 操作.

        如果 sublis 成功了, 一个树 tree 的新的拷贝会被返回, 其中每个出现的这样的子树或叶都会被它关联的对象[object]所替代. 如果没有做出改变, 返回原始的树. 原始的树保持不修改, 但是产生的树可能和它共享存储格(cell).

        nsublis 允许去修改树 tree, 否则就返回和 sublis 一样的值.

* 示例(Examples):

    ```LISP
    (sublis '((x . 100) (z . zprime))
            '(plus x (minus g z x p) 4 . x))
    =>  (PLUS 100 (MINUS G ZPRIME 100 P) 4 . 100)
    (sublis '(((+ x y) . (- x y)) ((- x y) . (+ x y)))
            '(* (/ (+ x y) (+ x p)) (- x y))
            :test #'equal)
    =>  (* (/ (- X Y) (+ X P)) (+ X Y))
    (setq tree1 '(1 (1 2) ((1 2 3)) (((1 2 3 4)))))
    =>  (1 (1 2) ((1 2 3)) (((1 2 3 4))))
    (sublis '((3 . "three")) tree1) 
    =>  (1 (1 2) ((1 2 "three")) (((1 2 "three" 4))))
    (sublis '((t . "string"))
              (sublis '((1 . "") (4 . 44)) tree1)
              :key #'stringp)
    =>  ("string" ("string" 2) (("string" 2 3)) ((("string" 2 3 44))))
    tree1 =>  (1 (1 2) ((1 2 3)) (((1 2 3 4))))
    (setq tree2 '("one" ("one" "two") (("one" "Two" "three"))))
    =>  ("one" ("one" "two") (("one" "Two" "three"))) 
    (sublis '(("two" . 2)) tree2) 
    =>  ("one" ("one" "two") (("one" "Two" "three"))) 
    tree2 =>  ("one" ("one" "two") (("one" "Two" "three"))) 
    (sublis '(("two" . 2)) tree2 :test 'equal) 
    =>  ("one" ("one" 2) (("one" "Two" "three"))) 

    (nsublis '((t . 'temp))
              tree1
              :key #'(lambda (x) (or (atom x) (< (list-length x) 3))))
    =>  ((QUOTE TEMP) (QUOTE TEMP) QUOTE TEMP) 
    ```

* 副作用(Side Effects):

        nsublis 修改树 tree.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        subst, 章节 3.2.1 (编译器术语), 章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        这个 :test-not 参数被废弃了.

        由于那些副作用变体 (例如, nsublis) 潜在地改变了它要经过的路径, 它们对共享或环状结构的影响可能会以令人惊讶的方式不同于它们的无副作用替代方案. 为了看到这个, 细想下面这个带副作用的行为, 它可能被某些具体实现展示:

    ```LISP
    (defun test-it (fn)
      (let* ((shared-piece (list 'a 'b))
              (data (list shared-piece shared-piece)))
        (funcall fn '((a . b) (b . a)) data)))
    (test-it #'sublis) =>  ((B A) (B A))
    (test-it #'nsublis) =>  ((A B) (A B))
    ```


### <span id="F-SUBST-ALL">函数 SUBST, SUBST-IF, SUBST-IF-NOT, NSUBST, NSUBST-IF, NSUBST-IF-NOT</span>

* 语法(Syntax):

        subst new old tree &key key test test-not => new-tree

        subst-if new predicate tree &key key => new-tree

        subst-if-not new predicate tree &key key => new-tree

        nsubst new old tree &key key test test-not => new-tree

        nsubst-if new predicate tree &key key => new-tree

        nsubst-if-not new predicate tree &key key => new-tree

* 参数和值(Arguments and Values):

        new---一个对象[object].
        old---一个对象[object].
        predicate---命名一个函数[function]的符号[symbol]或者一个返回广义 boolean [generalized boolean]值的单参数函数[function].
        tree---一个树[tree].
        test---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        test-not---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        key---一个单参数函数[function]的标识符[designator], 或者 nil.
        new-tree---一个树.

* 描述(Description):

        subst, subst-if, 和 subst-if-not 在树 tree 上执行替换操作. 每个函数都搜索树 tree, 以查找满足测试条件[satisfy the test]的某个元素或子表达式的某个旧项 old 的出现.

        nsubst, nsubst-if, 和 nsubst-if-not 分别类似于 subst, subst-if, 和 subst-if-not, 除了原始的树 tree 会被修改.

        subst 做一份树 tree 的拷贝, 用新的 new 替换树 tree 中每一个旧值为 old 和满足测试条件[satisfy the test]的子树和叶 (不管那个子树和叶是它的父节点的 car 还是 cdr).

        nsubst 是 subst 的一个破坏性版本. 树 tree 的列表结构会被破坏性地替换, 用新值 new 替换树 tree 中的旧值为 old 和满足测试条件 test 的叶.

        对于 subst, subst-if, 和 subst-if-not, 如果这些函数成功了, 这个树 tree 的一个新的拷贝会被返回, 其中每一个这样的元素的出现都被替换成那个新的元素 new 或子表达式. 如果没有发生变化, 返回原始的树 tree. 原始的树 tree 保持不变, 但是产生的树可能和它共享存储.

        对于 nsubst, nsubst-if, 和 nsubst-if-not 原始的树 tree 会被修改并作为这个函数的结果返回, 但是结果可能和树 tree 不是 eq 的.

* 示例(Examples):

    ```LISP
    (setq tree1 '(1 (1 2) (1 2 3) (1 2 3 4))) =>  (1 (1 2) (1 2 3) (1 2 3 4))
    (subst "two" 2 tree1) =>  (1 (1 "two") (1 "two" 3) (1 "two" 3 4))
    (subst "five" 5 tree1) =>  (1 (1 2) (1 2 3) (1 2 3 4))
    (eq tree1 (subst "five" 5 tree1)) =>  implementation-dependent
    (subst 'tempest 'hurricane
            '(shakespeare wrote (the hurricane)))
    =>  (SHAKESPEARE WROTE (THE TEMPESTSUBST))
    (subst 'foo 'nil '(shakespeare wrote (twelfth night)))
    =>  (SHAKESPEARE WROTE (TWELFTH NIGHT . FOO) . FOO)
    (subst '(a . cons) '(old . pair)
            '((old . spice) ((old . shoes) old . pair) (old . pair))
            :test #'equal)
    =>  ((OLD . SPICE) ((OLD . SHOES) A . CONS) (A . CONS))

    (subst-if 5 #'listp tree1) =>  5
    (subst-if-not '(x) #'consp tree1) 
    =>  (1 X)

    tree1 =>  (1 (1 2) (1 2 3) (1 2 3 4))
    (nsubst 'x 3 tree1 :key #'(lambda (y) (and (listp y) (third y)))) 
    =>  (1 (1 2) X X)
    tree1 =>  (1 (1 2) X X)
    ```

* 副作用(Side Effects):

        nsubst, nsubst-if, 和 nsubst-if-not 可能修改树 tree 的树结构[tree structure].

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        substitute, nsubstitute, 章节 3.2.1 (编译器术语), 章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        这个 :test-not 参数被废弃了.

        函数 subst-if-not 和 nsubst-if-not 被废弃了.

        subst 的一个可能的定义:

    ```LISP
    (defun subst (old new tree &rest x &key test test-not key)
      (cond ((satisfies-the-test old tree :test test
                                  :test-not test-not :key key)
              new)
            ((atom tree) tree)
            (t (let ((a (apply #'subst old new (car tree) x))
                      (d (apply #'subst old new (cdr tree) x)))
                  (if (and (eql a (car tree))
                          (eql d (cdr tree)))
                      tree
                      (cons a d))))))
    ```


### <span id="F-TREE-EQUAL">函数 TREE-EQUAL</span>

* 语法(Syntax):

        tree-equal tree-1 tree-2 &key test test-not => generalized-boolean

* 参数和值(Arguments and Values):

        tree-1---一个树[tree].
        tree-2---一个树[tree].
        test---一个返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        test-not---一个返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        tree-equal 测试两个树是否是相同的形状并且有着相同的叶. 如果 tree-1 和 tree-2 都是原子[atom]并且满足测试条件[satisfy the test], 或者它们都是 cons 并且 tree-1 的 car 和 tree-2 的 car 是 tree-equal 的而 tree-1 的 cdr 和 tree-2 的 cdr 也是 tree-equal 的, 那么 tree-equal 返回 true. 否则, tree-equal 返回 false.

        tree-equal 递归地比较 cons 而不是其他有成分的对象[object].

        给 :test 或 :test-not 函数的第一个参数是 tree-1 或者 tree-1 的一个 car 或 cdr; 第二个参数是 tree-2 或 tree-2 的一个 car 或 cdr.

* 示例(Examples):

    ```LISP
    (setq tree1 '(1 (1 2))
          tree2 '(1 (1 2))) =>  (1 (1 2))
    (tree-equal tree1 tree2) =>  true
    (eql tree1 tree2) =>  false
    (setq tree1 '('a ('b 'c))
          tree2 '('a ('b 'c))) =>  ('a ('b 'c)) 
    =>  ((QUOTE A) ((QUOTE B) (QUOTE C)))
    (tree-equal tree1 tree2 :test 'eq) =>  true
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 tree-1 和 tree-2 都是环状的那么后果是不确定的.

* 参见(See Also):

        equal, 章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        这个 :test-not 参数被废弃了. 

### <span id="F-COPY-LIST">函数 COPY-LIST</span>

* 语法(Syntax):

        copy-list list => copy

* 参数和值(Arguments and Values):

        list---一个正规列表[proper list]或者一个点列表[dotted list].
        copy---一个列表[list].

* 描述(Description):

        返回列表 list 的一个拷贝[copy]. 如果列表 list 是一个点列表[dotted list], 那么产生的列表[list]也是一个点列表[dotted list].

        只有列表 list 的列表结构[list struct]被拷贝; 产生的列表中的元素[element]和给定列表 list 中的对应元素[element]相同.

* 示例(Examples):

    ```LISP
    (setq lst (list 1 (list 2 3))) =>  (1 (2 3))
    (setq slst lst) =>  (1 (2 3))
    (setq clst (copy-list lst)) =>  (1 (2 3))
    (eq slst lst) =>  true
    (eq clst lst) =>  false
    (equal clst lst) =>  true
    (rplaca lst "one") =>  ("one" (2 3))
    slst =>  ("one" (2 3))
    clst =>  (1 (2 3))
    (setf (caadr lst) "two") =>  "two"
    lst =>  ("one" ("two" 3))
    slst =>  ("one" ("two" 3))
    clst =>  (1 ("two" 3))
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果列表 list 是一个环状列表[circular list]那么后果是未定义的.

* 参见(See Also):

        copy-alist, copy-seq, copy-tree

* 注意(Notes):

        创建的拷贝和列表 list 是 equal 的, 但不是 eq 的. 


### <span id="F-LIST-LIST">函数 LIST, LIST*</span>

* 语法(Syntax):

        list &rest objects => list

        list* &rest objects+ => result

* 参数和值(Arguments and Values):

        object---一个对象[object].
        list---一个列表[list].
        result---一个对象[object].

* 描述(Description):

        list 返回一个包含提供的那些对象 objects 的列表[list].

        list* 类似于 list, 除了给 list 的最后一个实参[argument]为构造的最后一个 cons 的 car, 而给 list* 的最后一个实参[argument]是构造的最后一个 cons 的 cdr. 因此, 任何给定的对 list* 的调用总是产生比相同数量参数的 list 调用少一个 cons.

        如果给 list* 的最后一个实参[argument]是一个列表[list], 那么效果就是构造一个新的相似的列表[list], 但是有着额外元素被添加到前面, 这些元素和 list* 的前面实参[argument]对应.

        如果 list* 只接收到一个对象 object, 那么返回那个对象 object, 不管它是否为一个列表[list].

* 示例(Examples):

    ```LISP
    (list 1) =>  (1)
    (list* 1) =>  1
    (setq a 1) =>  1
    (list a 2) =>  (1 2)
    '(a 2) =>  (A 2)
    (list 'a 2) =>  (A 2)
    (list* a 2) =>  (1 . 2)
    (list) =>  NIL ;i.e.,  ()
    (setq a '(1 2)) =>  (1 2)
    (eq a (list* a)) =>  true
    (list 3 4 'a (car '(b . c)) (+ 6 -2)) =>  (3 4 A B 4)
    (list* 'a 'b 'c 'd) ==  (cons 'a (cons 'b (cons 'c 'd))) =>  (A B C . D)
    (list* 'a 'b 'c '(d e f)) =>  (A B C D E F)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        cons

* 注意(Notes):

        (list* x) ==  x


### <span id="F-LIST-LENGTH">函数 LIST-LENGTH</span>

* 语法(Syntax):

        list-length list => length

* 参数和值(Arguments and Values):

        list---一个正规列表[proper list]或一个环状列表[circular list].
        length---一个非负整数[integer], 或者 nil.

* 描述(Description):

        如果列表 list 是一个正规列表[proper list]就返回这个列表 list 的长度[length]. 如果列表 list 是一个环状列表[circular list]就返回 nil.

* 示例(Examples):

    ```LISP
    (list-length '(a b c d)) =>  4
    (list-length '(a (b c) d)) =>  3
    (list-length '()) =>  0
    (list-length nil) =>  0
    (defun circular-list (&rest elements)
      (let ((cycle (copy-list elements))) 
        (nconc cycle cycle)))
    (list-length (circular-list 'a 'b)) =>  NIL
    (list-length (circular-list 'a)) =>  NIL
    (list-length (circular-list)) =>  0
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 list 不是一个正规列表[proper list]或者一个环状列表[circular list], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        length

* 注意(Notes):

        list-length 可以通过以下方式来实现:

    ```LISP
    (defun list-length (x)  
      (do ((n 0 (+ n 2))           ;Counter.
            (fast x (cddr fast))    ;Fast pointer: leaps by 2.
            (slow x (cdr slow)))    ;Slow pointer: leaps by 1.
          (nil)
        ;; If fast pointer hits the end, return the count.
        (when (endp fast) (return n))
        (when (endp (cdr fast)) (return (+ n 1)))
        ;; If fast pointer eventually equals slow pointer,
        ;;  then we must be stuck in a circular list.
        ;; (A deeper property is the converse: if we are
        ;;  stuck in a circular list, then eventually the
        ;;  fast pointer will equal the slow pointer.
        ;;  That fact justifies this implementation.)
        (when (and (eq fast slow) (> n 0)) (return nil))))
    ```

### <span id="F-LISTP">函数 LISTP</span>

* 语法(Syntax):

        listp object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 list 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (listp nil) =>  true
    (listp (cons 1 2)) =>  true
    (listp (make-array 6)) =>  false
    (listp t) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        consp

* 注意(Notes):

        如果对象 object 是一个 cons, listp 不会检查对象 object 是否为一个正规列表[proper list]; 对于任何种类的列表[list]它都返回 true.

        (listp object) ==  (typep object 'list) ==  (typep object '(or cons null))


### <span id="F-MAKE-LIST">函数 MAKE-LIST</span>

* 语法(Syntax):

        make-list size &key initial-element => list

* 参数和值(Arguments and Values):

        size---一个非负整数[integer].
        initial-element---一个对象[object]. 默认是 nil.
        list---一个列表[list].

* 描述(Description):

        返回长度为给定大小 size 的列表[list], 其中每一个元素[element]都是初始化元素 initial-element.

* 示例(Examples):

    ```LISP
    (make-list 5) =>  (NIL NIL NIL NIL NIL)
    (make-list 3 :initial-element 'rah) =>  (RAH RAH RAH)
    (make-list 2 :initial-element '(1 2 3)) =>  ((1 2 3) (1 2 3))
    (make-list 0) =>  NIL ;i.e.,  ()
    (make-list 0 :initial-element 'new-element) =>  NIL 
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 size 不是一个非负整数[integer], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        cons, list

* 注意(Notes): None. 

### <span id="M-PUSH">宏 PUSH</span>

* 语法(Syntax):

        push item place => new-place-value

* 参数和值(Arguments and Values):

        item---一个对象[object].
        place---一个位置[place], 它的值[value]可能是任何对象[object].
        new-place-value---一个列表[list] (这个 place 的新值[value]).

* 描述(Description):

        push 在存储在 place 的列表[list]前面加上 item, 把产生的列表[list]存储到 place, 然后返回那个列表[list].

        关于 place 的子表达式形式[subform]求值[evaluation]的信息, 见章节 5.1.1.1 (位置的子表达式形式求值).

* 示例(Examples):

    ```LISP
    (setq llst '(nil)) =>  (NIL)
    (push 1 (car llst)) =>  (1)
    llst =>  ((1))
    (push 1 (car llst)) =>  (1 1)
    llst =>  ((1 1))
    (setq x '(a (b c) d)) =>  (A (B C) D)
    (push 5 (cadr x)) =>  (5 B C)  
    x =>  (A (5 B C) D)
    ```

* 副作用(Side Effects):

        place 的内容会被修改.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        pop, pushnew, 章节 5.1 (广义引用)

* 注意(Notes):

        (push item place) 的效果等价于

        (setf place (cons item place))

        除了这个 place 的子表达式形式[subform]只被求值一次, 并且这个 item 在 place 之前被求值. 


### <span id="M-POP">宏 POP</span>

* 语法(Syntax):

        pop place => element

* 参数和值(Arguments and Values):

        place---一个位置[place], 它的值[value]是一个列表[list] (可能, 但不是必须, 是一个点列表[dotted list]或环状列表[circular]).
        element---一个对象[object] (这个 place 的内容的 car).

* 描述(Description):

        pop 读取[read] place 的值[value], 记住获取到的列表的 car, 把这个列表[list]的 cdr 写[write]回到那个 place 中, 并且最后产生[yield]这个原始获取的列表[list]的 car 部分.

        关于 place 的子表达式形式[subform]求值[evaluation]的信息, 见章节 5.1.1.1 (位置的子表达式形式求值).

* 示例(Examples):

    ```LISP
    (setq stack '(a b c)) =>  (A B C)
    (pop stack) =>  A  
    stack =>  (B C)
    (setq llst '((1 2 3 4))) =>  ((1 2 3 4))
    (pop (car llst)) =>  1
    llst =>  ((2 3 4))
    ```

* 副作用(Side Effects):

        place 的内容会被修改.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        push, pushnew, 章节 5.1 (广义引用)

* 注意(Notes):

        (pop place) 的效果大致等价于

        (prog1 (car place) (setf place (cdr place)))

        除了后面的可能会求值 place 中的任意子表达式形式[subform]三次, 而 pop 只求值它们一次. 


### <span id="A-FSTFFSSENT">访问器 FIRST, SECOND, THIRD, FOURTH, FIFTH, SIXTH, SEVENTH, EIGHTH, NINTH, TENTH</span>

* 语法(Syntax):

        first list => object

        second list => object

        third list => object

        fourth list => object

        fifth list => object

        sixth list => object

        seventh list => object

        eighth list => object

        ninth list => object

        tenth list => object

        (setf (first list) new-object)

        (setf (second list) new-object)

        (setf (third list) new-object)

        (setf (fourth list) new-object)

        (setf (fifth list) new-object)

        (setf (sixth list) new-object)

        (setf (seventh list) new-object)

        (setf (eighth list) new-object)

        (setf (ninth list) new-object)

        (setf (tenth list) new-object)

* 参数和值(Arguments and Values):

        list---一个列表[list], 它可能是一个点列表[dotted list]或者一个环状列表[circular list].
        object, new-object---一个对象[object].

* 描述(Description):

        函数 first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, 和 tenth 分别访问列表 list 的第一, 第二, 第三, 第四, 第五, 第六, 第七, 第八, 第九, 和第十的元素[element]. 具体地说,

        (first list)    ==   (car list)
        (second list)   ==   (car (cdr list))
        (third list)    ==   (car (cddr list))
        (fourth list)   ==   (car (cdddr list))
        (fifth list)    ==   (car (cddddr list))
        (sixth list)    ==   (car (cdr (cddddr list)))
        (seventh list)  ==   (car (cddr (cddddr list)))
        (eighth list)   ==   (car (cdddr (cddddr list)))
        (ninth list)    ==   (car (cddddr (cddddr list)))
        (tenth list)    ==   (car (cdr (cddddr (cddddr list))))

        setf 也可以和这些函数中的任何一个一起使用来改变一个已存在的成分. 应用相同的等价性. 比如:

        (setf (fifth list) new-object) ==  (setf (car (cddddr list)) new-object)

* 示例(Examples):

    ```LISP
    (setq lst '(1 2 3 (4 5 6) ((V)) vi 7 8 9 10)) 
    =>  (1 2 3 (4 5 6) ((V)) VI 7 8 9 10)
    (first lst) =>  1
    (tenth lst) =>  10
    (fifth lst) =>  ((V))
    (second (fourth lst)) =>  5
    (sixth '(1 2 3)) =>  NIL
    (setf (fourth lst) "four") =>  "four"
    lst =>  (1 2 3 "four" ((V)) VI 7 8 9 10)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        car, nth

* 注意(Notes):

        first 功能上等价于 car, second 功能上等价于 cadr, third 功能上等价于 caddr, 并且 fourth 功能上等价于 cadddr.

        这里使用的序号是从一开始的, 相比于 nth 使用的从零开始的序号:

        (fifth x) ==  (nth 4 x)


### <span id="A-NTH">访问器 NTH</span>

* 语法(Syntax):

        nth n list => object

        (setf (nth n list) new-object)

* 参数和值(Arguments and Values):

        n---一个非负整数[integer].
        list---一个列表[list], 它可能是一个点列表[dotted list]或一个环状列表[circular list].
        object---一个对象[object].
        new-object---一个对象[object].

* 描述(Description):

        nth 查找列表 list 的第 n 个元素, 其中这个列表 list 的 car 是第 0 个元素. 具体来说,

        (nth n list) ==  (car (nthcdr n list))

        nth 可以被用于给 setf 指定一个 place. 具体来说,

        (setf (nth n list) new-object) ==  (setf (car (nthcdr n list)) new-object)

* 示例(Examples):

    ```LISP
    (nth 0 '(foo bar baz)) =>  FOO
    (nth 1 '(foo bar baz)) =>  BAR
    (nth 3 '(foo bar baz)) =>  NIL
    (setq 0-to-3 (list 0 1 2 3)) =>  (0 1 2 3)
    (setf (nth 2 0-to-3) "two") =>  "two"
    0-to-3 =>  (0 1 "two" 3)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        elt, first, nthcdr

* 注意(Notes): None. 

### <span id="F-ENDP">函数 ENDP</span>

* 语法(Syntax):

        endp list => generalized-boolean

* 参数和值(Arguments and Values):

        list---一个列表[list], 它可能是一个点列表[dotted list]或一个环状列表[circular list].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果列表 list 是一个空列表[empty list]就返回 true. 如果列表 list 是一个 cons 就返回 false.

* 示例(Examples):

    ```LISP
    (endp nil) =>  true
    (endp '(1 2)) =>  false
    (endp (cddr '(1 2))) =>  true
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 list 不是一个列表就应该发出一个 type-error 类型的错误.

* 参见(See Also): None.

* 注意(Notes):

        endp 的目的是测试正规列表的结束. 由于 endp 不会进入到一个 cons 中, 所以明确定义了传递给它点列表[dotted list]的情况. 然而, 如果通过在一个点列表[dotted list]上反复调用 cdr 来产生更短的"列表"并且使用 endp 来测试这些"列表", 当这个非 nil [non-nil]的原子[atom] (它事实上不是一个列表[list]) 最终称为给 endp 的参数时, 最后会产生一个有着不确定后果的情况. 由于这是使用 endp 的常用方式, 所以它是保守的编程风格, 并且与 endp 的意图一致, 即把 endp 当作一个在正规列表[proper list]上的函数, 而不是强制一个正规列表[proper list]的参数类型, 除非参数是原子的[atomic]. 


### <span id="F-NULL">函数 NULL</span>

* 语法(Syntax):

        null object => boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        boolean---一个 boolean.

* 描述(Description):

        如果对象 object 是一个空列表[empty list]就返回 t; 否则, 返回 nil.

* 示例(Examples):

    ```LISP
    (null '()) =>  T
    (null nil) =>  T
    (null t) =>  NIL
    (null 1) =>  NIL
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        not

* 注意(Notes):

        null 意图在于测试空列表[empty list]而 not 意图在于反转一个 boolean (或广义的 boolean [generalized boolean]). 操作上, null 和 not 计算出相同的结果; 使用哪一个是风格的问题.

        (null object) ==  (typep object 'null) ==  (eq object '())


### <span id="F-NCONC">函数 NCONC</span>

* 语法(Syntax):

        nconc &rest lists => concatenated-list

* 参数和值(Arguments and Values):

        list---除了最后一个的每个都必须是一个列表[list] (它可能是一个点列表[dotted list]但一定不是一个环状列表[circular list]); 最后的 list 可以是任何对象[object].
        concatenated-list---一个列表[list].

* 描述(Description):

        返回这些列表 lists 的一个串接列表[list]. 如果没有提供列表 lists, (nconc) 返回 nil. nconc 使用以下递归关系来定义:

        (nconc) =>  ()
        (nconc nil . lists) ==  (nconc . lists)
        (nconc list) =>  list
        (nconc list-1 list-2) ==  (progn (rplacd (last list-1) list-2) list-1)
        (nconc list-1 list-2 . lists) ==  (nconc (nconc list-1 list-2) . lists)

* 示例(Examples):

    ```LISP
    (nconc) =>  NIL
    (setq x '(a b c)) =>  (A B C)
    (setq y '(d e f)) =>  (D E F)
    (nconc x y) =>  (A B C D E F)
    x =>  (A B C D E F)
    ```

        注意, 在这个例子中, 现在那个 x 的值是不同的, 因为它的最后一个 cons 已经被 rplacd 为 y 的值. 如果 (nconc x y) 被再一次求值, 它会产生一个环状列表[circular list], 它的打印表示会是 (A B C D E F D E F D E F ...), 一直重复; 如果这个 *print-circle* 开关不是 nil, 它会被打印为 (A B C . #1=(D E F . #1#)).

    ```LISP
    (setq foo (list 'a 'b 'c 'd 'e)
          bar (list 'f 'g 'h 'i 'j)
          baz (list 'k 'l 'm)) =>  (K L M)
    (setq foo (nconc foo bar baz)) =>  (A B C D E F G H I J K L M)
    foo =>  (A B C D E F G H I J K L M)
    bar =>  (F G H I J K L M)
    baz =>  (K L M)

    (setq foo (list 'a 'b 'c 'd 'e)
          bar (list 'f 'g 'h 'i 'j)
          baz (list 'k 'l 'm)) =>  (K L M)
    (setq foo (nconc nil foo bar nil baz)) =>  (A B C D E F G H I J K L M) 
    foo =>  (A B C D E F G H I J K L M)
    bar =>  (F G H I J K L M)
    baz =>  (K L M)
    ```

* 副作用(Side Effects):

        这些列表 lists 会被修改而不是拷贝.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        append, concatenate

* 注意(Notes): None. 


### <span id="F-APPEND">函数 APPEND</span>

* 语法(Syntax):

        append &rest lists => result

* 参数和值(Arguments and Values):

        list---除了最后一个以外的每一个都必须是一个正规列表[proper list], 最后一个可能是任何对象[object].
        result---一个对象[object]. 这个会是一个列表[list], 除非最后一个 list 不是一个列表[list]并且所有前面的 lists 都是 null.

* 描述(Description):

        append 返回一个由那些列表 lists 的拷贝拼接而成的一个新列表. 那些列表 lists 保持不变; 这些列表 lists 中除了最后一个以外的每一个的列表结构[list struct]都会被拷贝. 最后一个参数不会被拷贝; 它成为前面那些列表 lists 拼接后的最后一个点对[dotted pair]的 cdr, 如果前面没有非空[non-empty]列表就直接返回.

* 示例(Examples):

    ```LISP
    (append '(a b c) '(d e f) '() '(g)) =>  (A B C D E F G)
    (append '(a b c) 'd) =>  (A B C . D)
    (setq lst '(a b c)) =>  (A B C)
    (append lst '(d)) =>  (A B C D)
    lst =>  (A B C)
    (append) =>  NIL
    (append 'a) =>  A
    ```LISP

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        nconc, concatenate

* 注意(Notes): None. 


### <span id="F-REVAPPEND-NRECONC">函数 REVAPPEND, NRECONC</span>

* 语法(Syntax):

        revappend list tail => result-list

        nreconc list tail => result-list

* 参数和值(Arguments and Values):

        list---一个正规列表[proper list].
        tail---一个对象[object].
        result-list---一个对象[object].

* 描述(Description):

        revappend 构造一个列表 list 的拷贝[copy[2]], 但是其中的元素[element]是以相反的顺序. 它接下来追加 (就像是通过 nconc) 那个 tail 到那个反转后的列表并返回那个结果.

        nreconc 反转在列表 list 中元素[element]的顺序 (就像是通过 nreverse). 它接下来追加 (就像是通过 nconc) 那个 tail 给那个反转后的列表并返回那个结果.

        产生的列表[list]和 tail 共享列表结构[list structure].

* 示例(Examples):

    ```LISP
    (let ((list-1 (list 1 2 3))
          (list-2 (list 'a 'b 'c)))
      (print (revappend list-1 list-2))
      (print (equal list-1 '(1 2 3)))
      (print (equal list-2 '(a b c))))
    >>  (3 2 1 A B C) 
    >>  T
    >>  T
    =>  T

    (revappend '(1 2 3) '()) =>  (3 2 1)
    (revappend '(1 2 3) '(a . b)) =>  (3 2 1 A . B)
    (revappend '() '(a b c)) =>  (A B C)
    (revappend '(1 2 3) 'a) =>  (3 2 1 . A)
    (revappend '() 'a) =>  A   ;degenerate case

    (let ((list-1 '(1 2 3))
          (list-2 '(a b c)))
      (print (nreconc list-1 list-2))
      (print (equal list-1 '(1 2 3)))
      (print (equal list-2 '(a b c))))
    >>  (3 2 1 A B C) 
    >>  NIL
    >>  T
    =>  T
    ```

* 副作用(Side Effects):

        revappend 不会修改它的任何一个实参[argument]. nreconc 允许去修改列表 list 但是不能修改 tail.

        虽然它可能被不同地实现, nreconc 被限制为有着和下面这个等价的副作用行为:

        (nconc (nreverse list) tail)

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        reverse, nreverse, nconc

* 注意(Notes):

        下面这些功能等价性是对的, 虽然好的实现[implementation]通常使用一个更快的算法来取得相同的效果:

        (revappend list tail) ==  (nconc (reverse list) tail)
        (nreconc list tail) ==  (nconc (nreverse list) tail)


### <span id="F-BUTLAST-NBUTLAST">函数 BUTLAST, NBUTLAST</span>

* 语法(Syntax):

        butlast list &optional n => result-list

        nbutlast list &optional n => result-list

* 参数和值(Arguments and Values):

        list---一个列表[list], 它可能是一个点列表[dotted list]但一定不是一个环状列表[circular list].
        n---一个非负整数[integer].
        result-list---一个列表[list].

* 描述(Description):

        butlast 返回列表 list 的一个拷贝, 其中最后 n 个 cons 会被省略. 如果 n 没有被提供, 它的值就是 1. 如果在列表 list 中的 cons 少于 n 个, 返回 nil, 并且在 nbutlast 的情况中, 列表 list 不会被修改.

        nbutlast 类似于 butlast, 但是 nbutlast 可以修改列表 list. 它把这个列表 list 从结尾开始的 n+1 个 cons 的 cdr 改变为 nil.

* 示例(Examples):

    ```LISP
    (setq lst '(1 2 3 4 5 6 7 8 9)) =>  (1 2 3 4 5 6 7 8 9)
    (butlast lst) =>  (1 2 3 4 5 6 7 8)
    (butlast lst 5) =>  (1 2 3 4)
    (butlast lst (+ 5 5)) =>  NIL
    lst =>  (1 2 3 4 5 6 7 8 9)
    (nbutlast lst 3) =>  (1 2 3 4 5 6)
    lst =>  (1 2 3 4 5 6)
    (nbutlast lst 99) =>  NIL
    lst =>  (1 2 3 4 5 6)
    (butlast '(a b c d)) =>  (A B C)
    (butlast '((a b) (c d))) =>  ((A B))
    (butlast '(a)) =>  NIL
    (butlast nil) =>  NIL
    (setq foo (list 'a 'b 'c 'd)) =>  (A B C D)
    (nbutlast foo) =>  (A B C)
    foo =>  (A B C)
    (nbutlast (list 'a)) =>  NIL
    (nbutlast '()) =>  NIL
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 list 不是一个正规列表[proper list]或一个点列表[dotted list]那么应该发出一个 type-error 类型[type]的错误. 如果 n 不是一个非负整数[integer]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also): None.

* 注意(Notes):

        (butlast list n) ==  (ldiff list (last list n))


### <span id="F-LAST">函数 LAST</span>

* 语法(Syntax):

        last list &optional n => tail

* 参数和值(Arguments and Values):

        list---一个列表[list], 它可能是一个点列表[dotted list]但一定不是一个环状列表[circular list].
        n---一个非负整数[integer]. 默认是 1.
        tail---一个对象[object].

* 描述(Description):

        last 返回列表 list 的最后 n 个 cons (不是最后 n 个元素). 如果列表 list 是 (), last 返回 ().

        如果 n 是 0, 那么终止这个列表 list 的原子会被返回. 如果 n 大于或等于列表 list 中的 cons 存储格的数量, 那么结果就是那个列表 list.

* 示例(Examples):

    ```LISP
    (last nil) =>  NIL
    (last '(1 2 3)) =>  (3)
    (last '(1 2 . 3)) =>  (2 . 3)
    (setq x (list 'a 'b 'c 'd)) =>  (A B C D)
    (last x) =>  (D)
    (rplacd (last x) (list 'e 'f)) x =>  (A B C D E F)
    (last x) =>  (F)

    (last '(a b c))   =>  (C)

    (last '(a b c) 0) =>  ()
    (last '(a b c) 1) =>  (C)
    (last '(a b c) 2) =>  (B C)
    (last '(a b c) 3) =>  (A B C)
    (last '(a b c) 4) =>  (A B C)

    (last '(a . b) 0) =>  B
    (last '(a . b) 1) =>  (A . B)
    (last '(a . b) 2) =>  (A . B)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果列表 list 是一个环状列表[circular list]那么后果是未定义的. 如果 n 不是一个非负整数[integer]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        butlast, nth

* 注意(Notes):

        以下代码可以被用于定义 last.

        (defun last (list &optional (n 1))
          (check-type n (integer 0))
          (do ((l list (cdr l))
                (r list)
                (i 0 (+ i 1)))
              ((atom l) r)
            (if (>= i n) (pop r))))


### <span id="F-LDIFF-TAILP">函数 LDIFF, TAILP</span>

* 语法(Syntax):

        ldiff list object => result-list

        tailp object list => generalized-boolean

* 参数和值(Arguments and Values):

        list---一个列表[list], 它可能是一个点列表[dotted list].
        object---一个对象[object].
        result-list---一个列表[list].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 和 list 的末端[tail]相同[same], tailp 返回 true; 否则, 它返回 false.

        如果对象 object 和 list 的末端[tail]相同[same], ldiff 返回一个包含列表 list 的列表结构[list structure]中在 object 之前的列表[list]元素[element]的新的[fresh]列表[list]; 否则, 它返回列表 list 的一个拷贝[copy[2]].

* 示例(Examples):

    ```LISP
    (let ((lists '#((a b c) (a b c . d))))
      (dotimes (i (length lists)) ()
        (let ((list (aref lists i)))
          (format t "~2&list=~S ~21T(tailp object list)~
                      ~44T(ldiff list object)~%" list)
            (let ((objects (vector list (cddr list) (copy-list (cddr list))
                                    '(f g h) '() 'd 'x)))
              (dotimes (j (length objects)) ()
                (let ((object (aref objects j)))
                  (format t "~& object=~S ~21T~S ~44T~S"
                          object (tailp object list) (ldiff list object))))))))
    >>  
    >>  list=(A B C)         (tailp object list)    (ldiff list object)
    >>   object=(A B C)      T                      NIL
    >>   object=(C)          T                      (A B)
    >>   object=(C)          NIL                    (A B C)
    >>   object=(F G H)      NIL                    (A B C)
    >>   object=NIL          T                      (A B C)
    >>   object=D            NIL                    (A B C)
    >>   object=X            NIL                    (A B C)
    >>  
    >>  list=(A B C . D)     (tailp object list)    (ldiff list object)
    >>   object=(A B C . D)  T                      NIL
    >>   object=(C . D)      T                      (A B)
    >>   object=(C . D)      NIL                    (A B C . D)
    >>   object=(F G H)      NIL                    (A B C . D)
    >>   object=NIL          NIL                    (A B C . D)
    >>   object=D            T                      (A B C)
    >>   object=X            NIL                    (A B C . D)
    =>  NIL
    ```LISP

* 副作用(Side Effects):

        不管是 ldiff 函数 tailp 都不会修改它的任何一个实参[argument].

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 list 不是一个正规列表[proper list]或者一个点列表[dotted list]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        set-difference

* 注意(Notes):

        如果列表 list 是一个环状列表[circular list], 当且仅当给定对象 object 是 list 的一个末端[tail]时 tailp 会确实地产生[yield]一个值[value]. 否则, 后果是未指定的: 一个检测环状的给定实现[implementation]必须返回 false, 但是由于一个实现[implementation]没有义务去检测这样一种情况[situation], 所以 tailp 可能会在不返回的情况下无限循环.

        tailp 可以通过如下来定义:

    ```LISP
    (defun tailp (object list)
      (do ((list list (cdr list)))
          ((atom list) (eql list object))
          (if (eql object list)
              (return t))))
    ```

        并且 ldiff 可以通过如下来定义:

    ```LISP
    (defun ldiff (list object)
      (do ((list list (cdr list))
          (r '() (cons (car list) r)))
          ((atom list)
          (if (eql list object) (nreverse r) (nreconc r list)))
        (when (eql object list)
          (return (nreverse r)))))
    ```


### <span id="F-NTHCDR">函数 NTHCDR</span>

* 语法(Syntax):

        nthcdr n list => tail

* 参数和值(Arguments and Values):

        n---一个非负整数[integer].
        list---一个列表[list], 它可能是一个点列表[dotted list]或一个环状列表[circular list].
        tail---一个对象[object].

* 描述(Description):

        返回通过成功调用 n 次 cdr 得到的列表 list 的末端[tail].

* 示例(Examples):

    ```LISP
    (nthcdr 0 '()) =>  NIL
    (nthcdr 3 '()) =>  NIL
    (nthcdr 0 '(a b c)) =>  (A B C)
    (nthcdr 2 '(a b c)) =>  (C)
    (nthcdr 4 '(a b c)) =>  ()
    (nthcdr 1 '(0 . 1)) =>  1

    (locally (declare (optimize (safety 3)))
      (nthcdr 3 '(0 . 1)))
    Error: Attempted to take CDR of 1.
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 n 不是一个非负整数[integer]那么应该发出一个 type-error 类型[type]的错误.

        对于大于 1 的整数 n, 通过 (nthcdr n list) 完成的错误检测和 (nthcdr (- n 1) (cdr list)) 相同; 见函数[function] cdr.

* 参见(See Also):

        cdr, nth, rest

* 注意(Notes): None. 


### <span id="A-REST">访问器 REST</span>

* 语法(Syntax):

        rest list => tail

        (setf (rest list) new-tail)

* 参数和值(Arguments and Values):

        list---一个列表[list], 它可能是一个点列表[dotted list]或一个环状列表[circular list].
        tail---一个对象[object].

* 描述(Description):

        rest 执行和 cdr 相同的操作, 但是记忆上与 first 互补. 具体来说,

        (rest list) ==  (cdr list)
        (setf (rest list) new-tail) ==  (setf (cdr list) new-tail)

* 示例(Examples):

    ```LISP
    (rest '(1 2)) =>  (2)
    (rest '(1 . 2)) =>  2
    (rest '(1)) =>  NIL
    (setq *cons* '(1 . 2)) =>  (1 . 2)
    (setf (rest *cons*) "two") =>  "two"
    *cons* =>  (1 . "two")
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        cdr, nthcdr

* 注意(Notes):

        当这个参数被主观上视作一个列表[list]而不是一个 cons 时, rest 通常在风格上优于 cdr. 


### <span id="F-MEMBER-ALL">函数 MEMBER, MEMBER-IF, MEMBER-IF-NOT</span>

* 语法(Syntax):

        member item list &key key test test-not => tail

        member-if predicate list &key key => tail

        member-if-not predicate list &key key => tail

* 参数和值(Arguments and Values):

        item---一个对象[object].
        list---一个正规列表[proper list].
        predicate---返回一个广义 boolean [generalized boolean]的单实参[argument]函数[function]的标识符[designator].
        test---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        test-not---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        key---一个单实参[argument]函数[function]的标识符[designator], 或者 nil.
        tail---一个列表[list].

* 描述(Description):

        member, member-if, 和 member-if-not 每一个都在列表 list 中搜索 item 或者一个满足测试条件[satisfy the test]的顶层元素. 给这个断言函数 predicate 的参数是列表 list 的一个元素.

        如果某个元素满足测试条件[satisfy the test], 这个列表 list 从这个元素开始到末端的尾部会被返回; 否则返回 nil.

        只在 list 的顶层搜索.

* 示例(Examples):

    ```LISP
    (member 2 '(1 2 3)) =>  (2 3)                                 
    (member 2 '((1 . 2) (3 . 4)) :test-not #'= :key #'cdr) =>  ((3 . 4))
    (member 'e '(a b c d)) =>  NIL

    (member-if #'listp '(a b nil c d)) =>  (NIL C D)
    (member-if #'numberp '(a #\Space 5/3 foo)) =>  (5/3 FOO)
    (member-if-not #'zerop 
                    '(3 6 9 11 . 12)
                    :key #'(lambda (x) (mod x 3))) =>  (11 . 12)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 list 不是一个正规列表[proper list]那么应该准备发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        find, position, 章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        这个 :test-not 参数被废弃了.

        函数[function] member-if-not 被废弃了.

        在下面这个中

        (member 'a '(g (a y) c a d e a f)) =>  (A D E A F)

        member 返回的值和列表[list]中以 a 开始的部分相同[identical]. 因此在 member 的结果上调用 rplaca 可以被用来修改列表[list]中 a 被找到的部分 (假定已经检测了这个 member 没有返回 nil). 


### <span id="F-MAP-ALL">函数 MAPC, MAPCAR, MAPCAN, MAPL, MAPLIST, MAPCON</span>

* 语法(Syntax):

        mapc function &rest lists+ => list-1

        mapcar function &rest lists+ => result-list

        mapcan function &rest lists+ => concatenated-results

        mapl function &rest lists+ => list-1

        maplist function &rest lists+ => result-list

        mapcon function &rest lists+ => concatenated-results

* 参数和值(Arguments and Values):

        function---接受和列表 lists 数量相同的实参[argument]的函数[function]标识符[designator].
        list---一个正规列表[proper list].
        list-1---第一个列表 list (它一定是一个正规列表[proper list]).
        result-list---一个列表[list].
        concatenated-results---一个列表[list].

* 描述(Description):

        映射操作应用函数 function 到参数的连续集合上, 其中一个参数是从每一个序列[sequence]获取而来. 除了 mapc 和 mapl, 结果都包含了函数 function 返回的结果. 在 mapc 和 mapl 的情况下, 产生的序列[sequence]是列表 list.

        函数 function 首先在所有索引为 0 的元素上调用, 然后在所有索引为 1 的元素上调用, 以此类推. result-type 指定了产生序列[sequence]的类型[type]. 如果函数 function 是一个符号[symbol], 它被强制转为[coerce]一个函数[function], 就像是通过 symbol-function 一样.

        mapcar 在那些列表 lists 的连续元素[element]上操作. 函数 function 被应用于每个列表 list 的第一个元素[element]上, 然后到每个列表 list 的第二个元素[element]上, 以此类推. 这个迭代操作在最短的列表耗尽时终止, 而在其他列表中的过量元素会被忽略. 由 mapcar 返回的值是对函数 function 连续调用的结果组成的列表.

        mapc 类似于 mapcar 除了应用函数 function 的结果不会被累积. 这个 list 参数会被返回.

        maplist 类似于 mapcar 除了函数 function 被应用于列表 lists 的连续子列表中. 函数 function 首先被应用到这些 lists 自身, 然后被应用到每个列表 list 的 cdr, 然后是每个列表的 cdr 的 cdr, 以此类推.

        mapl 类似于 maplist 除了应用函数 function 的结果不会被累积; list-1 会被返回.

        mapcan 和 mapcon 分别类似于 mapcar 和 maplist, 除了应用函数 function 的结果会通过使用 nconc 而不是 list 被组合到一个列表[list]中. 这也就是说,

        (mapcon f x1 ... xn)
          ==  (apply #'nconc (maplist f x1 ... xn))

        并且 mapcan 和 mapcar 之间的关系类似.

* 示例(Examples):

    ```LISP
    (mapcar #'car '((1 a) (2 b) (3 c))) =>  (1 2 3) 
    (mapcar #'abs '(3 -4 2 -5 -6)) =>  (3 4 2 5 6)
    (mapcar #'cons '(a b c) '(1 2 3)) =>  ((A . 1) (B . 2) (C . 3))

    (maplist #'append '(1 2 3 4) '(1 2) '(1 2 3)) 
    =>  ((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3)) 
    (maplist #'(lambda (x) (cons 'foo x)) '(a b c d))
    =>  ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D))
    (maplist #'(lambda (x) (if (member (car x) (cdr x)) 0 1)) '(a b a c d b c))
    =>  (0 0 1 0 1 1 1)
    ;An entry is 1 if the corresponding element of the input
    ;  list was the last instance of that element in the input list.

    (setq dummy nil) =>  NIL 
    (mapc #'(lambda (&rest x) (setq dummy (append dummy x)))
            '(1 2 3 4)
            '(a b c d e)
            '(x y z)) =>  (1 2 3 4) 
    dummy =>  (1 A X 2 B Y 3 C Z)                   

    (setq dummy nil) =>  NIL 
    (mapl #'(lambda (x) (push x dummy)) '(1 2 3 4)) =>  (1 2 3 4) 
    dummy =>  ((4) (3 4) (2 3 4) (1 2 3 4)) 

    (mapcan #'(lambda (x y) (if (null x) nil (list x y)))
              '(nil nil nil d e)
              '(1 2 3 4 5 6)) =>  (D 4 E 5) 
    (mapcan #'(lambda (x) (and (numberp x) (list x)))
              '(a 1 b c 3 4 d 5))
    =>  (1 3 4 5)
    ```

        在这个情况中函数被当作一个过滤器; 这是使用 mapcan 的标准 Lisp 风格.

    ```LISP
    (mapcon #'list '(1 2 3 4)) =>  ((1 2 3 4) (2 3 4) (3 4) (4)) 
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果任何 list 不是一个正规列表[proper list]那么应该准备发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        dolist, map, 章节 3.6 (遍历规则和副作用)

* 注意(Notes): None. 


### <span id="F-ACONS">函数 ACONS</span>

* 语法(Syntax):

        acons key datum alist => new-alist

* 参数和值(Arguments and Values):

        key---一个对象[object].
        datum---一个对象[object].
        alist---一个关联列表[association list].
        new-alist---一个关联列表[association list].

* 描述(Description):

        创建一个新的[fresh] cons, 其中的 cdr 是 alist 而 car 是另一个新的[fresh] cons, 这个新的 cons 的 car 是键 key 而 cdr 是对象 datum.

* 示例(Examples):

    ```LISP
    (setq alist '()) =>  NIL
    (acons 1 "one" alist) =>  ((1 . "one"))
    alist =>  NIL
    (setq alist (acons 1 "one" (acons 2 "two" alist))) =>  ((1 . "one") (2 . "two"))
    (assoc 1 alist) =>  (1 . "one")
    (setq alist (acons 1 "uno" alist)) =>  ((1 . "uno") (1 . "one") (2 . "two"))
    (assoc 1 alist) =>  (1 . "uno")
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        assoc, pairlis

* 注意(Notes):

        (acons key datum alist) ==  (cons (cons key datum) alist)


### <span id="F-ASSOC-ALL">函数 ASSOC, ASSOC-IF, ASSOC-IF-NOT</span>

* 语法(Syntax):

        assoc item alist &key key test test-not => entry

        assoc-if predicate alist &key key => entry

        assoc-if-not predicate alist &key key => entry

* 参数和值(Arguments and Values):

        item---一个对象[object].
        alist---一个关联列表[association list].
        predicate---返回一个广义 boolean [generalized boolean]的单实参[argument]函数[function]的标识符[designator].
        test---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        test-not---一个返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        key---一个单参数函数[function]的标识符[designator], 或者 nil.
        entry---一个 cons, 是 alist 的一个元素[element], 或者是 nil.

* 描述(Description):

        assoc, assoc-if, 和 assoc-if-not 返回在 alist 中的第一个 car 满足测试条件[satisfy the test]的 cons, 如果没有找到这样的 cons 就是 nil.

        对于 assoc, assoc-if, 和 assoc-if-not, 如果在 alist 中出现一个 nil 代替一个对, 那么它会被忽略.

* 示例(Examples):

    ```LISP
    (setq values '((x . 100) (y . 200) (z . 50))) =>  ((X . 100) (Y . 200) (Z . 50))
    (assoc 'y values) =>  (Y . 200)
    (rplacd (assoc 'y values) 201) =>  (Y . 201)
    (assoc 'y values) =>  (Y . 201)
    (setq alist '((1 . "one")(2 . "two")(3 . "three"))) 
    =>  ((1 . "one") (2 . "two") (3 . "three"))
    (assoc 2 alist) =>  (2 . "two")
    (assoc-if #'evenp alist) =>  (2 . "two")
    (assoc-if-not #'(lambda(x) (< x 3)) alist) =>  (3 . "three")
    (setq alist '(("one" . 1)("two" . 2))) =>  (("one" . 1) ("two" . 2))
    (assoc "one" alist) =>  NIL
    (assoc "one" alist :test #'equalp) =>  ("one" . 1)
    (assoc "two" alist :key #'(lambda(x) (char x 2))) =>  NIL 
    (assoc #\o alist :key #'(lambda(x) (char x 2))) =>  ("two" . 2)
    (assoc 'r '((a . b) (c . d) (r . x) (s . y) (r . z))) =>   (R . X)
    (assoc 'goo '((foo . bar) (zoo . goo))) =>  NIL
    (assoc '2 '((1 a b c) (2 b c d) (-7 x y z))) =>  (2 B C D)
    (setq alist '(("one" . 1) ("2" . 2) ("three" . 3)))
    =>  (("one" . 1) ("2" . 2) ("three" . 3))
    (assoc-if-not #'alpha-char-p alist
                  :key #'(lambda (x) (char x 0))) =>  ("2" . 2)
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 alist 不是一个关联列表[association list]那么应该准备发出一个 type-error 类型[type]的错误..

* 参见(See Also):

        rassoc, find, member, position, 章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        这个 :test-not 参数已经被废弃.

        函数[function] assoc-if-not 已经被废弃.

        有可能为了 "更新" alist 去 rplacd 这个 assoc 的结果, 假定它不是 nil.

        这两个表达式

        (assoc item list :test fn)

        和

        (find item list :test fn :key #'car)

        在意义上等价, 但是有一个例外: 如果 nil 出现在 alist 中替代一个对, 并且 item 是 nil, find 会计算 alist 中的 nil 的 car, 发现它等价于 item, 然后返回 nil, 反之 assoc 会忽略 alist 中的这个 nil 然后继续搜索一个实际的 car 为 nil 的 cons. 


### <span id="F-COPY-ALIST">函数 COPY-ALIST</span>

* 语法(Syntax):

        copy-alist alist => new-alist

* 参数和值(Arguments and Values):

        alist---一个关联列表[association list].
        new-alist---一个关联列表[association list].

* 描述(Description):

        copy-alist 返回 alist 的一个拷贝[copy].

        这个 alist 的列表结构[list structure]会被拷贝, 而 alist 中的 cons 元素[element]也会被拷贝 (仅仅只是作为 cons). 任何其他被 alist 引用的对象[object], 不管是直接还是间接的, 都会被继续共享.

* 示例(Examples):

    ```LISP
    (defparameter *alist* (acons 1 "one" (acons 2 "two" '())))
    *alist* =>  ((1 . "one") (2 . "two"))
    (defparameter *list-copy* (copy-list *alist*))
    *list-copy* =>  ((1 . "one") (2 . "two"))
    (defparameter *alist-copy* (copy-alist *alist*))
    *alist-copy* =>  ((1 . "one") (2 . "two"))
    (setf (cdr (assoc 2 *alist-copy*)) "deux") =>  "deux"
    *alist-copy* =>  ((1 . "one") (2 . "deux"))
    *alist* =>  ((1 . "one") (2 . "two"))
    (setf (cdr (assoc 1 *list-copy*)) "uno") =>  "uno"
    *list-copy* =>  ((1 . "uno") (2 . "two"))
    *alist* =>  ((1 . "uno") (2 . "two"))
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        copy-list

* 注意(Notes): None. 

### <span id="F-PAIRLIS">函数 PAIRLIS</span>

* 语法(Syntax):

        pairlis keys data &optional alist => new-alist

* 参数和值(Arguments and Values):

        keys---一个正规列表[proper list].
        data---一个正规列表[proper list].
        alist---一个关联列表[association list]. 默认是空列表[empty list].
        new-alist---一个关联列表[association list].

* 描述(Description):

        返回一个关联 keys 的元素到对应 data 中的元素的关联列表[association list]. 如果 keys 和 data 不是相同长度[length]那么后果是未定义的.

        如果提供了 alist, pairlis 返回一个修改后的 alist, 这些新的对被添加到它的前面. 这些新的对可能以向前或向后的顺序出现在产生的关联列表[association list]中. 下面这个的结果

        (pairlis '(one two) '(1 2) '((three . 3) (four . 19)))

        可能是

        ((one . 1) (two . 2) (three . 3) (four . 19))

        或

        ((two . 2) (one . 1) (three . 3) (four . 19))

* 示例(Examples):

    ```LISP
    (setq keys '(1 2 3)
            data '("one" "two" "three")
            alist '((4 . "four"))) =>  ((4 . "four"))
    (pairlis keys data) =>  ((3 . "three") (2 . "two") (1 . "one"))
    (pairlis keys data alist)
    =>  ((3 . "three") (2 . "two") (1 . "one") (4 . "four"))
    alist =>  ((4 . "four"))
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果键 keys 和 data 不是正规列表[proper list]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        acons

* 注意(Notes): None. 


### <span id="F-RASSOC-ALL">函数 RASSOC, RASSOC-IF, RASSOC-IF-NOT</span>

* 语法(Syntax):

        rassoc item alist &key key test test-not => entry

        rassoc-if predicate alist &key key => entry

        rassoc-if-not predicate alist &key key => entry

* 参数和值(Arguments and Values):

        item---一个对象[object].
        alist---一个关联列表[association list].
        predicate---返回一个广义 boolean [generalized boolean]的单实参[argument]函数[function]的标识符[designator].
        test---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        test-not---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        key---一个单实参[argument]函数[function]的标识符[designator], 或者 nil.
        entry---是 alist 中的一个 cons 元素[element], 或者是 nil.

* 描述(Description):

        rassoc, rassoc-if, 和 rassoc-if-not 返回 cdr 满足测试条件[satisfy the test]的第一个 cons. 如果没有找到这样的 cons, 就返回 nil.

        如果 nil 出现在 alist 中替代了一个对, 它会被忽略.

* 示例(Examples):

    ```LISP
    (setq alist '((1 . "one") (2 . "two") (3 . 3))) 
    =>  ((1 . "one") (2 . "two") (3 . 3))
    (rassoc 3 alist) =>  (3 . 3)
    (rassoc "two" alist) =>  NIL
    (rassoc "two" alist :test 'equal) =>  (2 . "two")
    (rassoc 1 alist :key #'(lambda (x) (if (numberp x) (/ x 3)))) =>  (3 . 3)
    (rassoc 'a '((a . b) (b . c) (c . a) (z . a))) =>  (C . A)
    (rassoc-if #'stringp alist) =>  (1 . "one")
    (rassoc-if-not #'vectorp alist) =>  (3 . 3)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        assoc, 章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        参数 :test-not 已经被废弃.

        函数[function] rassoc-if-not 已经被废弃.

        有可能为了 "更新" alist 去 rplacd 这个 rassoc 的结果, 假定它不是 nil.

        表达式

        (rassoc item list :test fn)

        和

        (find item list :test fn :key #'cdr)

        在意义上是等价的, 除了当这个 item 是 nil 并且 nil 出现在 alist 中替换一个对时. 见函数[function] assoc. 


### <span id="F-GET-PROPERTIES">函数 GET-PROPERTIES</span>

* 语法(Syntax):

        get-properties plist indicator-list => indicator, value, tail

* 参数和值(Arguments and Values):

        plist---一个属性列表[property list].
        indicator-list---一个 (指示符[indicator]的) 正规列表[proper list].
        indicator---一个对象[object], 它是 indicator-list 中的元素[element].
        value---一个对象[object].
        tail---一个列表[list].

* 描述(Description):

        get-properties 被用来同时查找多个属性列表[property list]条目中的任何一个.

        它在 plist 中搜索第一个指示符[indicator]和 indicator-list 中的其中一个对象相同[identical]的条目. 如果找到这样一个条目, 返回的 indicator 和 value 是这个指示符[property indicator]和它关联的属性值[property value], 而返回的 tail 是以找到的条目开始的 plist 的尾部[tail] (换句话说, 它的 car 就是那个 indicator). 如果没有找到这样的条目, 那么这个 indicator, value, 和 tail 都是 nil.

* 示例(Examples):

    ```LISP
    (setq x '()) =>  NIL
    (setq *indicator-list* '(prop1 prop2)) =>  (PROP1 PROP2)
    (getf x 'prop1) =>  NIL
    (setf (getf x 'prop1) 'val1) =>  VAL1
    (eq (getf x 'prop1) 'val1) =>  true
    (get-properties x *indicator-list*) =>  PROP1, VAL1, (PROP1 VAL1)
    x =>  (PROP1 VAL1)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        get, getf

* 注意(Notes): None. 


### <span id="A-GETF">访问器 GETF</span>

* 语法(Syntax):

        getf plist indicator &optional default => value

        (setf (getf place indicator &optional default) new-value)

* 参数和值(Arguments and Values):

        plist---一个属性列表[property list].
        place---一个位置[place], 它的值[value]是一个属性列表[property list].
        indicator---一个对象[object].
        default---一个对象[object]. 默认是 nil.
        value---一个对象[object].
        new-value---一个对象[object].

* 描述(Description):

        getf 在 plist 上查找一个属性指示符[property indicator]等于 indicator 的属性[property], 并且返回对应的属性值[property value]. 如果这里有多个带有那个属性指示符[property indicator]的属性[property[1]], getf 使用第一个这样的属性[property]. 如果这里没有带有那个属性指示符[property indicator]的属性[property], 返回 default.

        getf 的 setf 可能被用于关联一个新的对象[object]到由位置 place 持有的属性列表[proper list]中的一个已存在的指示符, 或者如果不存在就创建一个新的关联. 如果这里有多个带有那个属性指示符[property indicator]的属性[property[1]], getf 的 setf 会关联这个新值 new-value 到第一个这样的属性[property]. 当一个 getf 表达式形式[form]被用作一个 setf 的 place 时, 被提供的任何 default 根据正常的从左到右的求值规则被求值, 但是它的值[value]会被忽略.

        getf 的 setf 允许去写入[write] place 自身的值[value], 或者修改 place 所持有的列表结构[list structure]的任意部分, car 或 cdr.

* 示例(Examples):

    ```LISP
    (setq x '()) =>  NIL
    (getf x 'prop1) =>  NIL
    (getf x 'prop1 7) =>  7
    (getf x 'prop1) =>  NIL
    (setf (getf x 'prop1) 'val1) =>  VAL1
    (eq (getf x 'prop1) 'val1) =>  true
    (getf x 'prop1) =>  VAL1
    (getf x 'prop1 7) =>  VAL1
    x =>  (PROP1 VAL1)

    ;; Examples of implementation variation permitted.
    (setq foo (list 'a 'b 'c 'd 'e 'f)) =>  (A B C D E F)
    (setq bar (cddr foo)) =>  (C D E F)
    (remf foo 'c) =>  true
    foo =>  (A B E F)
    bar
    =>  (C D E F)
    OR=>  (C)
    OR=>  (NIL)
    OR=>  (C NIL)
    OR=>  (C D)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        get, get-properties, setf, 章节 5.1.2.2 (函数调用表达式形式作为位置)

* 注意(Notes):

        这里无法 (使用 getf) 去区分一个省略的属性和一个值为 default 的属性; 但是见 get-properties.

        注意, 在一个 setf 的情况中给 getf 提供一个默认值 default 有时候不是非常有趣的, 但这仍然是很重要的, 因为某些宏, 例如 push 和 incf, 需要一个数据可以被读取[read]和写入[write]的 place 参数. 在这样一个上下文中, 如果一个 default 参数被提供用于读取[read]的情况, 对于写入[write]的情况它必须也是语法上有效的. 比如,

    ```LISP
    (let ((plist '()))
      (incf (getf plist 'count 0))
      plist) =>  (COUNT 1)
    ```

### <span id="M-REMF">宏 REMF</span>

* 语法(Syntax):

        remf place indicator => generalized-boolean

* 参数和值(Arguments and Values):

        place---一个位置[place].
        indicator---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        remf 从存储在 place 中的属性列表[property list]中移除一个属性指示符[property indicator]和 indicator 相同[identical]的属性[property[1]]. 如果这里有多个带有相同[identical]键的属性[property[1]], remf 只移除第一个这样的属性[property]. 如果没有找到这样的属性[property] remf 就返回 false, 如果找到一个属性就返回 true.

        这个属性指示符[property indicator]和对应属性值[property value]会通过破坏性地拼接这个属性列表以未定义的顺序被移除. remf 允许去 setf place 或者去 setf place 所持有的列表结构[list structure]的任何部分, car 或 cdr.

        关于 place 的子表达式形式[subform]的求值[evaluation]的信息, 见章节 5.1.1.1 (位置的子表达式形式求值).

* 示例(Examples):

    ```LISP
    (setq x (cons () ())) =>  (NIL)
    (setf (getf (car x) 'prop1) 'val1) =>  VAL1
    (remf (car x) 'prop1) =>  true
    (remf (car x) 'prop1) =>  false
    ```

* 副作用(Side Effects):

        存储在 place 中的属性列表会被修改.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        remprop, getf

* 注意(Notes): None. 


### <span id="F-INTERSECTION-NINTERSECTION)">函数 INTERSECTION, NINTERSECTION</span>

* 语法(Syntax):

        intersection list-1 list-2 &key key test test-not => result-list

        nintersection list-1 list-2 &key key test test-not => result-list

* 参数和值(Arguments and Values):

        list-1---一个正规列表[proper list].
        list-2---一个正规列表[proper list].
        test---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        test-not---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        key---一个单参数函数[function]的标识符[designator], 或者 nil.
        result-list---一个列表[list].

* 描述(Description):

        intersection 和 nintersection 返回一个包含了同时出现在 list-1 和 list-2 中的每个元素的列表[list].

        nintersection 是 intersection 的破坏性的版本. 它执行相同的操作, 但是可能破坏 list-1 使用它的存储格来构造这个结果. list-2 不会被破坏.

        这个 intersection 操作符描述如下. 对于所有可能由 list-1 的一个元素[element]和 list-2 的一个元素[element]构成的有序对, :test 或 :test-not 被用于确定它们是否满足测试条件[satisfy the test]. 给 :test 或 :test-not 函数的第一个参数是 list-1 的一个元素; 第二个参数是 list-2 的一个元素. 如果没有提供 :test 或 :test-not, 就使用 eql. 如果在同一个函数调用中提供了 :test 和 :test-not 那么就是一个错误.

        如果提供了 :key (并且不是 nil), 它被用于从这个列表 list 元素中提取这个要被测试的部分. 给这个 :key 函数的参数是 list-1 或 list-2 的一个元素; 这个 :key 函数通常返回提供的元素的部分. 如果没有提供 :key 或者是 nil, 那么就使用这个 list-1 和 list-2 的元素.

        对于满足测试条件[satisfy the test]的每一个对, 这个对的两个元素中只有一个会被放到结果中. 一个列表[list]中的元素如果和另一个列表[list]中的元素都不满足测试条件[satisfy the test]就不会出现在结果中. 如果其中一个列表[list]包含了重复的元素, 那么在结果中也可能会重复.

        不保证元素出现在结果中的顺序会以任何特定方式反映参数的顺序. 如果合适的话结果列表可能和 list-1 或 list-2 共享存储格, 或者和 list-1 或 list-2 是 eq 的.

* 示例(Examples):

    ```LISP
    (setq list1 (list 1 1 2 3 4 a b c "A" "B" "C" "d")
          list2 (list 1 4 5 b c d "a" "B" "c" "D")) 
      =>  (1 4 5 B C D "a" "B" "c" "D")
    (intersection list1 list2) =>  (C B 4 1 1)
    (intersection list1 list2 :test 'equal) =>  ("B" C B 4 1 1)
    (intersection list1 list2 :test #'equalp) =>  ("d" "C" "B" "A" C B 4 1 1) 
    (nintersection list1 list2) =>  (1 1 4 B C)
    list1 =>  implementation-dependent ;e.g.,  (1 1 4 B C)
    list2 =>  implementation-dependent ;e.g.,  (1 4 5 B C D "a" "B" "c" "D")
    (setq list1 (copy-list '((1 . 2) (2 . 3) (3 . 4) (4 . 5))))
    =>  ((1 . 2) (2 . 3) (3 . 4) (4 . 5)) 
    (setq list2 (copy-list '((1 . 3) (2 . 4) (3 . 6) (4 . 8))))
    =>  ((1 . 3) (2 . 4) (3 . 6) (4 . 8)) 
    (nintersection list1 list2 :key #'cdr) =>  ((2 . 3) (3 . 4)) 
    list1 =>  implementation-dependent ;e.g.,  ((1 . 2) (2 . 3) (3 . 4)) 
    list2 =>  implementation-dependent ;e.g.,  ((1 . 3) (2 . 4) (3 . 6) (4 . 8)) 
    ```

* 副作用(Side Effects):

        nintersection 可以修改 list-1, 但不能修改 list-2.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 list-1 和 list-2 不是正规列表[proper list], 那么应该准备发出 type-error 类型[type]的错误.

* 参见(See Also):

        union, 章节 3.2.1 (编译器术语), 章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        这个 :test-not 参数已经被废弃

        因为这个 nintersection 副作用不是必须的, 它不应该被用于仅为了副作用(for-effect-only)的可移植代码中.


### <span id="F-ADJOIN">函数 ADJOIN</span>

* 语法(Syntax):

        adjoin item list &key key test test-not => new-list

* 参数和值(Arguments and Values):

        item---一个对象[object].
        list---一个正规列表[proper list].
        test---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        test-not---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[functioni]的标识符[designator].
        key---一个单实参[argument]函数[function]的标识符[designator], 或者 nil.
        new-list---一个列表[list].

* 描述(Description):

        测试 item 是否和列表 list 中的一个已存在的元素相同. 如果 item 不是一个已存在的元素, adjoin 把它添加到 list (就好像是通过 cons 一样) 并且返回产生的列表[list]; 否则, 没有东西会被添加并且原始的列表 list 会被返回.

        这个 test, test-not, 和 key 影响如何决定那个 item 是否和 list 中的一个元素[element]相同. 关于详情, 见章节 17.2.1 (满足一个两个参数的测试).

* 示例(Examples):

    ```LISP
    (setq slist '()) =>  NIL 
    (adjoin 'a slist) =>  (A) 
    slist =>  NIL 
    (setq slist (adjoin '(test-item 1) slist)) =>  ((TEST-ITEM 1)) 
    (adjoin '(test-item 1) slist) =>  ((TEST-ITEM 1) (TEST-ITEM 1)) 
    (adjoin '(test-item 1) slist :test 'equal) =>  ((TEST-ITEM 1)) 
    (adjoin '(new-test-item 1) slist :key #'cadr) =>  ((TEST-ITEM 1)) 
    (adjoin '(new-test-item 1) slist) =>  ((NEW-TEST-ITEM 1) (TEST-ITEM 1)) 
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 list 不是一个正规列表[proper list]那么应该准备发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        pushnew, 章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        这个 :test-not 参数已经被废弃

        (adjoin item list :key fn)
          ==  (if (member (fn item) list :key fn) list (cons item list))



### <span id="M-PUSHNEW">宏 PUSHNEW</span>

* 语法(Syntax):

        pushnew item place &key key test test-not
        => new-place-value

* 参数和值(Arguments and Values):

        item---一个对象[object].
        place---一个位置[place], 它的值是一个正规列表[proper list].
        test---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        test-not---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        key---一个单参数函数[function]的标识符[designator], 或者 nil.
        new-place-value---一个列表[list] (这个值[place]的新的值).

* 描述(Description):

        pushnew 测试 item 是否和存储在位置 place 的列表[list]中的一个已存在元素相同. 如果 item 没有和任何一个元素相同的话, 它就会被追加到 list 前面, 并且这个新的列表[list]被存储到位置 place 中.

        pushnew 返回一个存储在 place 中的新列表[list].

        item 是否已经为 place 中的列表[list]的成员是通过使用 :test 或 :test-not 比较决定的. 给 :test 或 :test-not 函数的第一个参数是 item; 第二个参数是 place 中的列表[list]的元素通过 :key 函数返回的 (如果提供的话).

        如果提供了 :key, 它被用于提取 item 和列表[list]元素中要被测试的部分, 就像 adjoin 一样.

        给 :key 函数的参数是存储在 place 中的列表[list]的元素. 这个 :key 函数通常返回列表[list]的元素的一部分. 如果没有提供 :key 或者是 nil, 就是那个列表[list]元素.

        关于位置 place 的子表达式形式[subform]求值[evaluation]的信息, 见章节 5.1.1.1 (位置的子表达式形式求值).

        在这个 item 已经是 place 所持有的列表[list]的成员的情况下, pushnew 事实上是否会为它的 place 执行存储表达式形式是依赖于具体实现的[implementation-dependent].

* 示例(Examples):

    ```LISP
    (setq x '(a (b c) d)) =>  (A (B C) D)
    (pushnew 5 (cadr x)) =>  (5 B C)   
    x =>  (A (5 B C) D)
    (pushnew 'b (cadr x)) =>  (5 B C)  
    x =>  (A (5 B C) D)
    (setq lst '((1) (1 2) (1 2 3))) =>  ((1) (1 2) (1 2 3))
    (pushnew '(2) lst) =>  ((2) (1) (1 2) (1 2 3))
    (pushnew '(1) lst) =>  ((1) (2) (1) (1 2) (1 2 3))
    (pushnew '(1) lst :test 'equal) =>  ((1) (2) (1) (1 2) (1 2 3))
    (pushnew '(1) lst :key #'car) =>  ((1) (2) (1) (1 2) (1 2 3)) 
    ```

* 副作用(Side Effects):

        这个 place 的内容可能被修改.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        push, adjoin, 章节 5.1 (广义引用)

* 注意(Notes):

        这个

        (pushnew item place :test p)

        的效果近似等价于

        (setf place (adjoin item place :test p))

        除了那个 place 的子表达式形式[subform]只会被求值一次, 并且 item 在 place 之前被求值. 


### <span id="F-SET-DIFFERENCE-ALL">函数 SET-DIFFERENCE, NSET-DIFFERENCE</span>

* 语法(Syntax):

        set-difference list-1 list-2 &key key test test-not => result-list

        nset-difference list-1 list-2 &key key test test-not => result-list

* 参数和值(Arguments and Values):

        list-1---一个正规列表[proper list].
        list-2---一个正规列表[proper list].
        test---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        test-not---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        key---一个单参数函数[function]的标识符[designator], 或者 nil.
        result-list---一个列表[list].

* 描述(Description):

        set-difference 返回一个在 list-1 中的但是没有出现在 list-2 中的元素的列表[list].

        nset-difference 是 set-difference 的破坏性版本. 它可能破坏 list-1.

        对于由 list-1 的一个元素和 list-2 的一个元素组成的所有可能的有序对, 这个 :test 或 :test-not 函数被用于确定它们是否满足测试条件[satisfy the test]. 给 :test 或 :test-not 函数的第一个参数是由 :key 函数(如果提供的话)返回的 list-1 的元素的一部分; 给 :test 或 :test-not 函数的第二个参数是由 :key 函数(如果提供的话)返回的 list-2 的元素的一部分.

        如果提供了 :key, 它的参数就是一个 list-1 或 list-2 的元素. 这个 :key 函数通常返回提供的元素的一部分. 如果没有提供 :key, 就使用 list-1 或 list-2 的元素.

        当且仅当一个 list-1 中的元素不匹配任何 list-2 中的元素时它会出现在结果中.

        这里不保证出现在结果中的顺序会以任何特定方式反映参数的顺序. 如果合适的话, 结果列表[list]可能和 list-1 或 list-2 共享存储格, 或者和 list-1 或 list-2 是 eq 的.

* 示例(Examples):

    ```LISP
    (setq lst1 (list "A" "b" "C" "d")
          lst2 (list "a" "B" "C" "d")) =>  ("a" "B" "C" "d")
    (set-difference lst1 lst2) =>  ("d" "C" "b" "A")
    (set-difference lst1 lst2 :test 'equal) =>  ("b" "A")
    (set-difference lst1 lst2 :test #'equalp) =>  NIL 
    (nset-difference lst1 lst2 :test #'string=) =>  ("A" "b")
    (setq lst1 '(("a" . "b") ("c" . "d") ("e" . "f")))
    =>  (("a" . "b") ("c" . "d") ("e" . "f")) 
    (setq lst2 '(("c" . "a") ("e" . "b") ("d" . "a")))
    =>  (("c" . "a") ("e" . "b") ("d" . "a")) 
    (nset-difference lst1 lst2 :test #'string= :key #'cdr)
    =>  (("c" . "d") ("e" . "f")) 
    lst1 =>  (("a" . "b") ("c" . "d") ("e" . "f")) 
    lst2 =>  (("c" . "a") ("e" . "b") ("d" . "a")) 

    ;; Remove all flavor names that contain "c" or "w".
    (set-difference '("strawberry" "chocolate" "banana"
                      "lemon" "pistachio" "rhubarb")
              '(#\c #\w)
              :test #'(lambda (s c) (find c s)))
    =>  ("banana" "rhubarb" "lemon")    ;One possible ordering.
    ```

* 副作用(Side Effects):

        nset-difference 可能破坏 list-1.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 list-1 和 list-2 不是正规列表[proper list]那么应该准备发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        章节 3.2.1 (编译器术语), 章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        这个 :test-not 参数已经被废弃 


### <span id="F-SET-EXCLUSIVE-OR-ALL">函数 SET-EXCLUSIVE-OR, NSET-EXCLUSIVE-OR</span>

* 语法(Syntax):

        set-exclusive-or list-1 list-2 &key key test test-not => result-list

        nset-exclusive-or list-1 list-2 &key key test test-not => result-list

* 参数和值(Arguments and Values):

        list-1---一个正规列表[proper list].
        list-2---一个正规列表[proper list].
        test---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        test-not---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        key---一个单参数函数[function]的标识符[designator], 或者 nil.
        result-list---一个列表[list].

* 描述(Description):

        set-exclusive-or 返回一个只出现在 list-1 和 list-2 其中之一的元素的列表.

        nset-exclusive-or 是 set-exclusive-or 的破坏性版本.

        对于由 list-1 的一个元素和 list-2 的一个元素组成的所有可能的有序对, 这个 :test 或 :test-not 函数被用于确定它们是否满足测试条件[satisfy the test].

        如果提供了 :key, 它被用于从 list-1 or list-2 元素中提取要被测试的部分. 给 :test 或 :test-not 函数的第一个参数是由 :key 函数(如果提供的话)返回的 list-1 的元素的一部分; 给 :test 或 :test-not 函数的第二个参数是由 :key 函数(如果提供的话)返回的 list-2 的元素的一部分. 如果没有提供 :key 或者是 nil, 就使用 list-1 或 list-2 元素.

        这个结果准确包含了 list-1 和 list-2 中没有匹配对的元素.

        这个 set-exclusive-or 的结果列表可能和 list-1 或 list-2 其中一个共享存储.

* 示例(Examples):

    ```LISP
    (setq lst1 (list 1 "a" "b")
          lst2 (list 1 "A" "b")) =>  (1 "A" "b")
    (set-exclusive-or lst1 lst2) =>  ("b" "A" "b" "a")
    (set-exclusive-or lst1 lst2 :test #'equal) =>  ("A" "a")
    (set-exclusive-or lst1 lst2 :test 'equalp) =>  NIL 
    (nset-exclusive-or lst1 lst2) =>  ("a" "b" "A" "b") 
    (setq lst1 (list (("a" . "b") ("c" . "d") ("e" . "f"))))
    =>  (("a" . "b") ("c" . "d") ("e" . "f"))
    (setq lst2 (list (("c" . "a") ("e" . "b") ("d" . "a"))))
    =>  (("c" . "a") ("e" . "b") ("d" . "a")) 
    (nset-exclusive-or lst1 lst2 :test #'string= :key #'cdr)
    =>  (("c" . "d") ("e" . "f") ("c" . "a") ("d" . "a")) 
    lst1 =>  (("a" . "b") ("c" . "d") ("e" . "f"))
    lst2 =>  (("c" . "a") ("d" . "a")) 
    ```

* 副作用(Side Effects):

        nset-exclusive-or 允许去修改 list-1 或 list-2 的列表结构[list structure]的任意部分, car 或 cdr.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 list-1 和 list-2 不是正规列表[proper list]那么应该准备发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        章节 3.2.1 (编译器术语), 章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        这个 :test-not 参数已经被废弃

        因为这个 nset-exclusive-or 副作用不是必须的, 所以它不应该被用于可移植代码中仅为了副作用(for-effect-only)的位置. 


### <span id="F-SUBSETP">函数 SUBSETP</span>

* 语法(Syntax):

        subsetp list-1 list-2 &key key test test-not => generalized-boolean

* 参数和值(Arguments and Values):

        list-1---一个正规列表[proper list].
        list-2---一个正规列表[proper list].
        test---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        test-not---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        key---一个单参数函数[function]的标识符[designator], 或者 nil.
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果 list-1 中的每个元素都匹配 list-2 中的某个元素 subsetp 就返回 true, 否则返回 false.

        一个列表元素是否和另一个列表元素相同是由关键字参数指定的函数决定的. 给 :test 或 :test-not 函数的第一个参数是由 :key 函数提取的 list-1 的元素的一部分; 给 :test 或 :test-not 函数的第二个参数是由 :key 函数提取的 list-2 的元素的一部分.

        给 :key 函数的参数是 list-1 或 list-2 的一个元素; 返回值是那个提供的列表元素的一部分. 如果没有提供 :key 或者是 nil, 那么这个 list-1 或 list-2 元素自身会被提供给 :test 或 :test-not 函数.

* 示例(Examples):

    ```LISP
    (setq cosmos '(1 "a" (1 2))) =>  (1 "a" (1 2))
    (subsetp '(1) cosmos) =>  true
    (subsetp '((1 2)) cosmos) =>  false
    (subsetp '((1 2)) cosmos :test 'equal) =>  true
    (subsetp '(1 "A") cosmos :test #'equalp) =>  true
    (subsetp '((1) (2)) '((1) (2))) =>  false
    (subsetp '((1) (2)) '((1) (2)) :key #'car) =>  true
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 list-1 和 list-2 不是正规列表[proper list]那么应该准备发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        这个 :test-not 参数已经被废弃 


### <span id="F-UNION-NUNION">函数 UNION, NUNION</span>

* 语法(Syntax):

        union list-1 list-2 &key key test test-not => result-list

        nunion list-1 list-2 &key key test test-not => result-list

* 参数和值(Arguments and Values):

        list-1---一个正规列表[proper list].
        list-2---一个正规列表[proper list].
        test---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        test-not---返回一个广义 boolean [generalized boolean]的两实参[argument]函数[function]的标识符[designator].
        key---一个单参数函数[function]的标识符[designator], 或者 nil.
        result-list---一个列表[list].

* 描述(Description):

        union 和 nunion 返回一个包含出现在 list-1 或 list-2 中的每一个元素的列表.

        对于由 list-1 的一个元素和 list-2 的一个元素组成的所有可能的有序对, 这个 :test 或 :test-not 函数被用于确定它们是否满足这个测试条件 test. 给 :test 或 :test-not 函数的第一个参数是由 :key 函数(如果提供的话)返回的 list-1 的元素的一部分; 给 :test 或 :test-not 函数的第二个参数是由 :key 函数(如果提供的话)返回的 list-2 的元素的一部分.

        给 :key 函数的参数是 list-1 或 list-2 的一个元素; 返回值是提供的那个元素的一部分. 如果没有提供 :key 或者是 nil, 那么这个 list-1 或 list-2 元素自身会被提供给 :test 或 :test-not 函数.

        对于每一个匹配序对, 这个序对的两个元素中的一个会出现在结果中. 任何来自于 list-1 或 list-2 并且在另一个中没有匹配元素的元素会出现在结果中.

        如果在 list-1 和 list-2 之间有重复的, 这些重复实例中只有一个会出现在结果中. 如果 list-1 或 list-2 其中有着重复的条目, 那么这些重复的条目可能会也可能不会出现在结果中.

        结果中元素的顺序不需要去以任何方式返回 list-1 或 list-2 中的顺序. 如果合适的话这个结果列表可能和 list-1 或 list-2 是 eq 的.

* 示例(Examples):

    ```LISP
    (union '(a b c) '(f a d))
    =>  (A B C F D)
    OR=>  (B C F A D)
    OR=>  (D F A B C)
    (union '((x 5) (y 6)) '((z 2) (x 4)) :key #'car)
    =>  ((X 5) (Y 6) (Z 2))
    OR=>  ((X 4) (Y 6) (Z 2))

    (setq lst1 (list 1 2 '(1 2) "a" "b")
          lst2 (list 2 3 '(2 3) "B" "C"))
    =>  (2 3 (2 3) "B" "C")
    (nunion lst1 lst2)
    =>  (1 (1 2) "a" "b" 2 3 (2 3) "B" "C") 
    OR=>  (1 2 (1 2) "a" "b" "C" "B" (2 3) 3)
    ```

* 副作用(Side Effects):

        nunion 允许去修改 list-1 或 list-2 的列表结构[list]的任意部分, car 或 cdr.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 list-1 和 list-2 不是正规列表[proper list]那么应该准备发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        intersection, 章节 3.2.1 (编译器术语), 章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        这个 :test-not 参数已经被废弃

        因为 nunion 副作用不是必须的, 所以它不应该被用于可移植代码中仅为了副作用(for-effect-only)位置. 


# 15. 数组

> * 15.1 [数组的概念](#ArrayConcepts)
> * 15.2 [数组的字典](#TheArraysDictionary)

## 15.1 <span id="ArrayConcepts">数组的概念</span>

> * 15.1.1 [数组元素](#ArrayElements)
> * 15.1.2 [特化的数组](#SpecializedArrays)

### 15.1.1 <span id="ArrayElements">数组元素</span>

一个数组[array]包含了一个称为为元素[element]的对象[object]的集合, 它们可以通过一个直角坐标系统而被单独的引用.

> * 15.1.1.1 [数组索引](#ArrayIndices)
> * 15.1.1.2 [数组维度](#ArrayDimensions)
> * 15.1.1.3 [数组秩](#ArrayRank)

#### 15.1.1.1 <span id="ArrayIndices">数组索引</span>

一个数组[array]元素[element]可以通过一个(可能是空的)索引序列来引用. 这个序列的长度必须等于这个数组[array]的秩[rank]. 每一个索引必须是一个小于对应数组[array]维数[dimension]的非负的 fixnum. 数组[array]索引是从 0 开始的. 

#### 15.1.1.2 <span id="ArrayDimensions">数组维度</span>

数组[array]的一个坐标轴称为一个维度[dimension].

每一个维度大小[dimension]都是一个非负 fixnum; 如果一个数组[array]的任意维度大小都是 0, 那么这个数组[array]就没有元素. 允许一个维度大小[dimension]是 0, 在这个情况下这个数组[array]没有元素, 并且任何尝试去访问[access]一个元素[element]都是一个错误. 然而, 这个数组[array]的其他属性, 比如这些维度大小[dimension]自身, 可能被使用.

##### 15.1.1.2.1 单独数组维度大小的实现限制

一个实现[implementation]可能在数组[array]的维度大小[dimension]上强加一个限制, 但是在这个限制上这里有一个最小要求. 见变量[variable] array-dimension-limit. 


#### 15.1.1.3 <span id="ArrayRank">数组秩</span>

一个数组[array]可以有任意数量的维度[dimension] (包括零). 这个维度的数量称为秩[rank].

如果一个数组[array]的秩[rank]是 0 那么就说这个数组是没有维度[dimension]的, 并且这些维度大小的乘积是 1 (见 array-total-size); 一个零维数组[array]因此只有一个单个元素.

> * 15.1.1.3.1 [向量](#Vectors)
> * 15.1.1.3.2 [多维数组](#MultiArrays)

##### 15.1.1.3.1 <span id="Vectors">向量</span>

一个秩[rank]为 1 的数组[array] (换句话说, 一个一维数组[array]) 被称为一个向量[vector].

###### 15.1.1.3.1.1 填充指针

一个填充指针[fill pointer]是一个不大于向量[vector]中元素[element]总数的非负整数[integer]. 不是所有的向量[vector]都有填充指针[fill pointer]. 见函数[function] make-array 和 adjust-array.

如果一个向量[vector]的一个元素[element]有着大于等于 0 但是小于这个填充指针[fill pointer] (如果有的话) 的索引, 那么就说它是有效的[active]. 对于一个没有填充指针[fill pointer]的数组[array], 所有元素[element]都被认为是有效的[active].

只有向量[vector]可以有填充指针[fill pointer]; 多维数组[array]没有. 可以创建一个存储被转移到有着填充指针[fill pointer]的向量[vector]的多维数组[array].

##### 15.1.1.3.2 <span id="MultiArrays">多维数组</span>

###### 15.1.1.3.2.1 多维数组的存储布局

多维数组[array]以行优先的顺序存储它们的成分; 这也就是说, 一个多维数组[array]内部被存储为一个一维数组[array], 其中多维度索引集有序地排列, 最后一个索引变化最快. 

###### 15.1.1.3.2.2 数组秩的实现限制

一个实现[implementation]可能在一个数组[array]秩[rank]上强加一个限制, 但是在这个限制上这里有一个最小的要求. 见变量[variable] array-rank-limit. 

### 15.1.2 <span id="SpecializedArrays">特化的数组</span>

一个数组[array]可以是一个普通[general]数组[array], 意味着每个元素[element]可以是任意对象[object], 或者它可能是一个特化[specialized]数组[array], 意味着每个元素[element]都有一个约束的类型[type].

"一个数组[array]被特化[specialized]为类型[type] <<\type>>" 的说法有时被用于强调一个数组[array]的元素类型[element type]. 即便当这个类型[type] <<\type>> 是 t 这个说法也是认可的, 尽管一个被特化[specialized]为类型[type] t 的数组[array]是一个普通[general]数组[array], 而不是一个特化[specialized]数组[array].

下面这段列出了一些可应用于数组[array]创建, 访问[access], 和信息操作的已定义的名字[defined name].

    adjust-array           array-has-fill-pointer-p  make-array                   
    adjustable-array-p     array-in-bounds-p         svref                        
    aref                   array-rank                upgraded-array-element-type  
    array-dimension        array-rank-limit          upgraded-complex-part-type   
    array-dimension-limit  array-row-major-index     vector                       
    array-dimensions       array-total-size          vector-pop                   
    array-displacement     array-total-size-limit    vector-push                  
    array-element-type     fill-pointer              vector-push-extend           

    Figure 15-1. 普通目的的数组相关的已定义名字

> * 15.1.2.1 [数组提升](#ArrayUpgrading)
> * 15.1.2.2 [特化数组的必要种类](#RKOSA)


#### 15.1.2.1 <span id="ArrayUpgrading">数组提升</span>

类型[type] T1 的提升数组元素类型[upgraded array element type] T2 是 T1 的超类型[supertype], 并且在 T1 可以被用作对象创建或类型区分的数组元素类型[array element type]时可以用来替换 T1.

在一个数组[array]创建期间, 需要的元素类型[element]被称为表达数组元素类型[expressed array element type]. 这个表达数组元素类型[expressed array element type]的提升数组元素类型[upgraded array element type]成为这个要被创建的数组[array]的实际数组元素类型[actual array element type].

类型[type]提升意味着在类型层次结构中向上移动. 一个类型[type]总是为它的提升数组元素类型[upgraded array element type]的子类型[subtype]. 同样, 如果一个类型[type] Tx 是另一个类型[type] Ty 的子类型[subtype], 那么 Tx 的提升数组元素类型[upgraded array element type]必须是 Ty 的提升数组元素类型[upgraded array element type]的子类型[subtype]. 两个互斥[disjoint]的类型[type]可以被提升为相同类型[type].

一个类型[type] T1 的提升数组元素类型[upgraded array element type] T2 是一个只有 T1 自身的函数; 这也就是说, 它独立于将要使用 T2 的数组[array]的任何其他属性, 例如秩[rank], 可调整性[adjustability], 填充指针[fill pointer], 或位移. 函数[function] upgraded-array-element-type 可以被符合规范的程序[conforming program]用来预测这个实现[implementation]会怎样提升[upgrade]一个给定类型[type]. 

#### 15.1.2.2 <span id="RKOSA">特化数组的必要种类</span>

元素[element]被约束为 character 类型[type]或 character 的子类型[subtype]的向量[vector]被称为字符串[string]. 字符串[string]是 string 类型[type]. 下一段中列出了和字符串[string]相关的已定义的名字[defined name].

字符串[string]是特化[specialized]数组[array], 逻辑上可以被包含在这一章中. 然而, 出于可读性的目的, 关于字符串[string]的大部分信息不会出现在这个章节中; 见章节 16 (字符串).

    char                string-equal         string-upcase  
    make-string         string-greaterp      string/=       
    nstring-capitalize  string-left-trim     string<        
    nstring-downcase    string-lessp         string<=       
    nstring-upcase      string-not-equal     string=        
    schar               string-not-greaterp  string>        
    string              string-not-lessp     string>=       
    string-capitalize   string-right-trim                   
    string-downcase     string-trim                         

    Figure 15-2. 操作字符串的操作符

元素[element]被约束为 bit 类型[type]的向量[vector]称为位向量[bit vector]. 位向量[bit vector]是 bit-vector 类型[type]的. 下一段中列出了在位数组[bit array]上操作的一些已定义的名字[defined name].

    bit        bit-ior   bit-orc2  
    bit-and    bit-nand  bit-xor   
    bit-andc1  bit-nor   sbit      
    bit-andc2  bit-not             
    bit-eqv    bit-orc1            

    Figure 15-3. 操作位数组的操作符

## 15.2 <span id="TheArraysDictionary">数组的字典</span>

> * [系统类 ARRAY](#SC-ARRAY)
> * [类型 SIMPLE-ARRAY](#T-SIMPLE-ARRAY)
> * [系统类 VECTOR](#SC-VECTOR)
> * [类型 SIMPLE-VECTOR](#T-SIMPLE-VECTOR)
> * [系统类 BIT-VECTOR](#SC-BIT-VECTOR)
> * [类型 SIMPLE-BIT-VECTOR](#T-SIMPLE-BIT-VECTOR)
> * [函数 MAKE-ARRAY](#F-MAKE-ARRAY)
> * [函数 ADJUST-ARRAY](#F-ADJUST-ARRAY)
> * [函数 ADJUSTABLE-ARRAY-P](#F-ADJUSTABLE-ARRAY-P)
> * [访问器 AREF](#A-AREF)
> * [函数 ARRAY-DIMENSION](#F-ARRAY-DIMENSION)
> * [函数 ARRAY-DIMENSIONS](#F-ARRAY-DIMENSIONS)
> * [函数 ARRAY-ELEMENT-TYPE](#F-ARRAY-ELEMENT-TYPE)
> * [函数 ARRAY-HAS-FILL-POINTER-P](#F-ARRAY-HAS-FILL-POINTER-P)
> * [函数 ARRAY-DISPLACEMENT](#F-ARRAY-DISPLACEMENT)
> * [函数 ARRAY-IN-BOUNDS-P](#F-ARRAY-IN-BOUNDS-P)
> * [函数 ARRAY-RANK](#F-ARRAY-RANK)
> * [函数 ARRAY-ROW-MAJOR-INDEX](#F-ARRAY-ROW-MAJOR-INDEX)
> * [函数 ARRAY-TOTAL-SIZE](#F-ARRAY-TOTAL-SIZE)
> * [函数 ARRAYP](#F-ARRAYP)
> * [访问器 FILL-POINTER](#A-FILL-POINTER)
> * [访问器 ROW-MAJOR-AREF](#A-ROW-MAJOR-AREF)
> * [函数 UPGRADED-ARRAY-ELEMENT-TYPE](#F-UPGRADED-ARRAY-ELEMENT-TYPE)
> * [常量 ARRAY-DIMENSION-LIMIT](#CV-ARRAY-DIMENSION-LIMIT)
> * [常量 ARRAY-RANK-LIMIT](#CV-ARRAY-RANK-LIMIT)
> * [常量 ARRAY-TOTAL-SIZE-LIMIT](#CV-ARRAY-TOTAL-SIZE-LIMIT)
> * [函数 SIMPLE-VECTOR-P](#F-SIMPLE-VECTOR-P)
> * [访问器 SVREF](#A-SVREF)
> * [函数 VECTOR](#F-VECTOR)
> * [函数 VECTOR-POP](#F-VECTOR-POP)
> * [函数 VECTOR-PUSH, VECTOR-PUSH-EXTEND](#F-V-PUSH-V-PUSH-EXTEND)
> * [函数 VECTORP](#F-VECTORP)
> * [访问器 BIT, SBIT](#A-BIT-SBIT)
> * [函数 BIT-AND, BIT-ANDC1, BIT-ANDC2, BIT-EQV, BIT-IOR, BIT-NAND, BIT-NOR, BIT-NOT, BIT-ORC1, BIT-ORC2, BIT-XOR](#F-BIT-ALL)
> * [函数 BIT-VECTOR-P](#F-BIT-VECTOR-P)
> * [函数 SIMPLE-BIT-VECTOR-P](#F-SIMPLE-BIT-VECTOR-P)


### <span id="SC-ARRAY">系统类 ARRAY</span>

* 类优先级列表(Class Precedence List):

        array, t

* 描述(Description):

        一个数组[array]包含了根据一个笛卡儿坐标系统排列的对象[object]. 一个数组[array]提供了一个从 fixnum 的集合 {i0,i1,...,ir-1} 到对应数组[array]元素[element]的映射, 其中 0 <=ij < dj, r 是这个数组的秩, 并且 dj 是这个数组的维度[dimension] j 的大小.

        当一个数组[array]被创建时, 请求它的创建的程序可能声明所有元素[element]为一个特定类型[type], 称为表达数组元素类型[expressed array element type]. 具体实现允许去提升[upgrade]这个类型来产生实际数组元素类型[actual array element type], 它是这个数组[array]被实际特化[specialized]的元素类型[element type]. 见函数[function] upgraded-array-element-type.

* 复合类型指定符类别(Compound Type Specifier Kind):

        详细的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        array [{element-type | *} [dimension-spec]]

        dimension-spec::= rank | * | ({dimension | *}*) 

* 复合类型指定符参数(Compound Type Specifier Arguments):

        dimension---一个有效数组维数[valid array dimension].
        element-type---一个类型指定符[type specifier].
        rank---一个非负 fixnum.

* 复合类型指定符描述(Compound Type Specifier Description):

        这个表示元素类型[element type], 秩[rank], 和维数[dimension]匹配给定 element-type, rank, 和 dimensions 的数组[array]的集合. 具体的说:

        如果 element-type 是符号[symbol] *, 数组[array]不会根据其元素类型[element type]被排除. 否则, 只包括那些实际数组元素类型[actual array element type]是 element-type 的提升结果的数组; 见章节 15.1.2.1 (数组提升).

        如果这个 dimension-spec 是一个 rank, 这个集合只包括那些有着那个 rank 的数组. 如果这个 dimension-spec 是 dimensions 的一个列表[list], 这个集合只包括那些有着由 dimensions 的长度[length]给定的秩[rank]并且有着指明的 dimensions 的数组; 在这个情况中, * 匹配对应维数[dimension]的任意值. 如果这个 dimension-spec 是符号[symbol] *, 这个集合不会被约束在秩[rank]或维数[dimension]的基础上.

* 参见(See Also):

        *print-array*, aref, make-array, vector, 章节 2.4.8.12 (井号A(#A)), 章节 22.1.3.8 (打印其他数组)

* 注意(Notes):

        注意类型 (array t) 是类型 (array *) 的一个适当的子类型[subtype]. 这个原因是类型 (array t) 是持有任何对象[object]的数组[array]的集合 (这些元素[element]是类型[type] t, 它包括所有对象[object]). 另一方面, 类型 (array *) 是所有数组[array]的集合, 包括例如只持有字符[character]的数组[array]. 类型 (array character) 不是类型 (array t) 的一个子类型[subtype]; 这两个集合是互斥[disjoint]的因为类型 (array character) 不是所有可以持有字符[character]的数组[array]的集合, 而是一组专门用来保存精确字符[character]并且没有其他对象[object]的数组的集合. 


### <span id="T-SIMPLE-ARRAY">类型 SIMPLE-ARRAY</span>

* 超类型(Supertypes):

        simple-array, array, t

* 描述(Description):

        一个存储没有被转移到另一个数组[array], 没有填充指针[fill pointer], 并且不是明显可调整[expressly adjustable]的数组[array]的类型[type]是类型[type] simple-array 的一个子类型[subtype]. 简单数组[simple array]概念允许实现使用特定的表示, 并允许用户声明某些值总是为简单数组[simple array].

        类型[type] simple-vector, simple-string, 和 simple-bit-vector 是类型[type] simple-array 的互斥[disjoint]的子类型[subtype], 对于它们分别意味着 (simple-array t (*)), 所有 c 为 character 类型[type]的子类型[subtype]的 (simple-array c (*)) 的并集, 以及 (simple-array bit (*)).

* 复合类型指定符类别(Compound Type Specifier Kind):

        详细的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        simple-array [{element-type | *} [dimension-spec]]

        dimension-spec::= rank | * | ({dimension | *}*) 

* 复合类型指定符参数(Compound Type Specifier Arguments):

        dimension---一个有效数组维度大小[valid array dimension].
        element-type---一个类型指定符[type specifier].
        rank---一个非负 fixnum.

* 复合类型指定符描述(Compound Type Specifier Description):

        这个复合类型指定符[compound type specifier]的处理方法和 array 类型[type]的复合类型指定符[compound type specifier]的处理方法完全相同, 除了这个集合被进一步约束为只包含简单数组[simple array].

* 注意(Notes):

        存储被转移的数组[displaced array], 带有填充指针[fill pointer]的向量[vector], 或实际可调整[actually adjustable]的数组[array]是否为简单数组[simple array]是依赖于具体实现的[implementation-dependent].

        (simple-array *) 不管元素类型引用了所有简单数组[simple array], (simple-array type-specifier) 只引用那些可以通过给定 type-specifier 作为 make-array 的 :element-type 参数得到的简单数组[simple array]. 


### <span id="SC-VECTOR">系统类 VECTOR</span>

* 类优先级列表(Class Precedence List):

        vector, array, sequence, t

* 描述(Description):

        任何一维数组[array]都是一个向量[vector].

        类型[type] vector 是类型[type] array 的一个子类型[subtype]; 对于所有类型[type] x, (vector x) 和 (array x (*)) 相同.

        类型[type] (vector t), 类型[type] string, 还有类型[type] bit-vector 是类型[type] vector 的互斥[disjoint]子类型[subtype].

* 复合类型指定符类别(Compound Type Specifier Kind):

        详细的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        vector [{element-type | *} [{size | *}]]

* 复合类型指定符参数(Compound Type Specifier Arguments):

        size---一个非负 fixnum.
        element-type---一个类型指定符[type specifier].

* 复合类型指定符描述(Compound Type Specifier Description):

        这个表示那个元素类型[element type]和维度大小[dimension]都匹配指定值的特化向量[vector]的集合. 具体来说:

        如果 element-type 是符号[symbol] *, 向量[vector]不会根据它们的元素类型[element type]被排除. 否则, 只有那些实际数组元素类型[actual array element type]是 element-type 提升[upgrade]的结果的那些向量会被包括进去; 见章节 15.1.2.1 (数组提升).

        如果指定了一个 size, 那么这个集合只包括那些仅有的维度大小[dimension]是 size 的向量. 如果符号[symbol] * 被指定而不是一个 size, 那么这个集合不会被约束在这个维度大小[dimension]的基础上.

* 参见(See Also):

        章节 15.1.2.2 (特化数组的必要种类), 章节 2.4.8.3 (井号左括号(#()), 章节 22.1.3.7 (打印其他向量), 章节 2.4.8.12 (井号A(#A))

* 注意(Notes):

        类型[type] (vector e s) 等价于类型[type] (array e (s)).

        类型[type] (vector bit) 有着名称 bit-vector.

        所有类型[type] (vector C) 的并集(其中 C 是 character 的任意子类型[subtype])有着名字 string.

        (vector *) 引用所有的向量[vector], 不管元素类型是什么, (vector type-specifier) 只引用那些可以通过给定 type-specifier 作为 make-array 的 :element-type 参数得到的向量[vector]. 


### <span id="T-SIMPLE-VECTOR">类型 SIMPLE-VECTOR</span>

* 超类型(Supertypes):

        simple-vector, vector, simple-array, array, sequence, t

* 描述(Description):

        一个存储没有被转移到另一个数组[array]中, 没有填充指针[fill pointer], 不是明显可调整[expressly adjustable]的并且可能持有任何类型[type]元素的向量[vector]是类型[type] simple-vector 的子类型[subtype].

        类型[type] simple-vector 类型[type] vector 的一个子类型[subtype], 并且是类型[type] (vector t) 的子类型[subtype].

* 复合类型指定符类别(Compound Type Specifier Kind):

        详细的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        simple-vector [size]

* 复合类型指定符参数(Compound Type Specifier Arguments):

        size---一个非负 fixnum, 或者符号[symbol] *. 默认是符号[symbol] *.

* 复合类型指定符描述(Compound Type Specifier Description):

        这个和 (simple-array t (size)) 是相同的. 


### <span id="SC-BIT-VECTOR">系统类 BIT-VECTOR</span>

* 类优先级列表(Class Precedence List):

        bit-vector, vector, array, sequence, t

* 描述(Description):

        一个位向量[bit vector]是一个元素类型[element type]为 bit 的向量[vector].

        这个 bit-vector 类型[type]是 vector 类型[type]的一个子类型[subtype], 对于 bit-vector 意味着 (vector bit).

* 复合类型指定符类别(Compound Type Specifier Kind):

        缩写的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        bit-vector [size]

* 复合类型指定符参数(Compound Type Specifier Arguments):

        size---一个非负 fixnum, 或者符号[symbol] *.

* 复合类型指定符描述(Compound Type Specifier Description):

        这个表示和类型[type] (array bit (size)) 相同的类型[type]; 这也就是说, 大小为 size 的位向量[bit vector]的集合.

* 参见(See Also):

        章节 2.4.8.4 (井号星号(#*)), 章节 22.1.3.6 (打印位向量), 章节 15.1.2.2 (特化数组的必要种类) 


### <span id="T-SIMPLE-BIT-VECTOR">类型 SIMPLE-BIT-VECTOR</span>

* 超类型(Supertypes):

        simple-bit-vector, bit-vector, vector, simple-array, array, sequence, t

* 描述(Description):

        一个不会被转移到另一个数组[array]中, 没有填充指针[fill pointer], 并且不是明显可调整[expressly adjustable]的位向量[bit vector]的类型[type]是类型[type] simple-bit-vector 的一个子类型[subtype].

* 复合类型指定符类别(Compound Type Specifier Kind):

        缩写的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        simple-bit-vector [size]

* 复合类型指定符参数(Compound Type Specifier Arguments):

        size---一个非负 fixnum, 或者符号[symbol] *. 默认是符号[symbol] *.

* 复合类型指定符描述(Compound Type Specifier Description):

        这个表示和类型[type] (simple-array bit (size)) 相同的类型; 这也就是说, 大小为 size 的简单位向量[simple bit vector]的集合. 


### <span id="F-MAKE-ARRAY">函数 MAKE-ARRAY</span>

* 语法(Syntax):

        make-array dimensions &key element-type initial-element initial-contents adjustable fill-pointer displaced-to displaced-index-offset
        => new-array

* 参数和值(Arguments and Values):

        dimensions---一个有效数组维度大小[valid array dimension]的列表[list]的标识符[designator].
        element-type---一个类型指定符[type specifier]. 默认是 t.
        initial-element---一个对象[object].
        initial-contents---一个对象[object].
        adjustable---一个广义 boolean [generalized boolean]. 默认是 nil.
        fill-pointer---这个要被创建的数组[array]的有效填充指针[valid fill pointer], 或者是 t 或 nil. 默认是 nil.
        displaced-to---一个数组[array]或 nil. 默认是 nil. 如果 initial-element 或 initial-contents 被提供了那么这个选项一定不能被提供.
        displaced-index-offset--- displaced-to 的一个有效数组行优先索引[valid array row-major index]. 默认是 0. 这个选项一定不能被提供, 除非提供了一个非 nil [non-nil]的 displaced-to.
        new-array---一个数组[array].

* 描述(Description):

        创建并返回一个由可以容纳 element-type 所给定的类型[type]的元素的最特化[specialized]类型[type]构成的数组[array]. 如果 dimensions 是 nil 那么一个零维数组[array]会被创建.

        dimensions 表示这个新数组的维度大小.

        element-type 表示要被存储到新数组 new-array 中的元素的类型[type]. 这个 new-array 实际上可以存储从 element-type 提升[upgrade]得到的类型[type]的任何对象[object]; 见章节 15.1.2.1 (数组提升).

        如果提供了 initial-element, 它被用于初始化 new-array 的每一个元素[element]. 如果提供了 initial-element, 它必须是 element-type 给定的类型[type]. 如果 :initial-contents 选项被提供了或者 displaced-to 是非 nil [non-nil], 那么 initial-element 不能被提供. 如果没有提供 initial-element, 那么后面去读取 new-array 的未初始化元素[element]的后果是未定义的, 除非提供了 initial-contents 或者 displaced-to 不是 nil.

        initial-contents 被用于初始化数组[array]的内容. 比如:

        (make-array '(4 2 3) :initial-contents
                    '(((a b c) (1 2 3))
                      ((d e f) (3 1 2))
                      ((g h i) (2 3 1))
                      ((j k l) (0 0 0))))

        initial-contents 由一个嵌套的序列[sequence]结构组成. 在这个结构中的层级的数量等价于数组[array]的秩. 这个嵌套的结构的每一个叶节点必须是 element-type 给定的类型[type]. 如果数组[array]是零维的, 那么 initial-contents 指定单个元素[element]. 否则, initial-contents 必须是一个长度和第一个维度相同的序列[sequence]; 每一个元素必须是一个维度大小为剩余维度大小的数组[array]的嵌套结构, 以此类推. 如果 initial-element 被提供了或者 displaced-to 非 nil [non-nil], 那么 initial-contents 不能被提供. 如果没有提供 initial-contents, 那么后面去读取 new-array 的未初始化元素的后果是未定义的, 除非提供了 initial-contents 或者 displaced-to 非 nil [non-nil].

        如果 adjustable 非 nil [non-nil], 那么这个数组就是明确可调整的[expressly adjustable] (所以实际上可调整的[actually adjustable]); 否则, 这个数组就不是明确可调整的[expressly adjustable] (这个数组是否为实际上可调整的[actually adjustable]是依赖于具体实现的[implementation-dependent]).

        如果 fill-pointer 非 nil [non-nil], 数组[array]必须是一维的; 这也就是说, 这个数组[array]必须是一个向量[vector]. 如果 fill-pointer 是 t, 这个向量[vector]的长度被用于初始化这个填充指针[fill pointer]. 如果 fill-pointer 是一个整数[integer], 它成为这个向量[vector]的初始填充指针[fill pointer].

        如果 displaced-to 非 nil [non-nil], make-array 会创建一个存储被转移的数组[displaced array]并且 displaced-to 就是那个存储被转移的数组[displaced array]的目标[target]. 在这个情况中, 如果 displaced-to 的实际数组元素类型[actual array element type]和要被创建的数组[array]的实际数组元素类型[actual array element type]不是类型等价的[type equivalent], 那么后果时未定义的. 如果 displaced-to 是 nil, 这个数组[array]就不是一个存储被转移的数组[displaced array].

        displaced-index-offset 被设置为这个数组[array]的索引偏移量. 当一个数组 A 在创建数组 B 时被给定用作给 make-array 的 :displaced-to 实参[argument], 那么数组 B 就被说是转移到数组 A. 在一个数组[array]中的元素的总数, 称为这个数组[array]的总大小, 被计算为所有维度的乘积. 这就需要 A 的总大小不小于 B 的总大小加上 displaced-index-offset 提供的 n 以后的大小. 这个转移的效果是数组 B 没有它自己的任何元素, 但是把到它自己的访问[access]被映射到对数组 A 的访问[access]. 这个映射处理这两个数组就好像它们是一维的, 以行优先的顺序获取元素, 并且映射一个对数组 B 的元素 k 的访问[access]到对数组 A 的第 k+n 个元素的访问[access].

        如果 make-array 被调用时 adjustable, fill-pointer, 和 displaced-to 都是 nil, 那么结果就是一个简单数组[simple array]. 如果 make-array 被调用时 adjustable, fill-pointer, 或 displaced-to 不止一个为 true, 产生的数组[array]是否为一个简单数组[simple array]是依赖于具体实现的[implementation-dependent].

        在创建数组 B 时, 当一个数组 A 被给定作为 make-array 的 :displaced-to 实参[argument]时, 那么就说数组 B 转移到了数组 A. 在一个数组[array]中的元素总数, 称为这个数组[array]的总大小, 通过所有维度的乘积计算出来. 如果 A 的总大小小于 B 加上 displaced-index-offset 提供的偏移 n 以后的总大小, 那么后果是未指定的. 这个转移的效果是数组 B 没有它自己的任何元素, 但是把到它自己的访问[access]被映射到对数组 A 的访问[access]. 这个映射处理这两个数组就好像它们是一维的, 以行优先的顺序获取元素, 并且映射一个对数组 B 的元素 k 的访问[access]到对数组 A 的第 k+n 个元素的访问[access].

* 示例(Examples):

    ```LISP
    (make-array 5) ;; Creates a one-dimensional array of five elements.
    (make-array '(3 4) :element-type '(mod 16)) ;; Creates a 
                    ;;two-dimensional array, 3 by 4, with four-bit elements.
    (make-array 5 :element-type 'single-float) ;; Creates an array of single-floats.

    (make-array nil :initial-element nil) =>  #0ANIL
    (make-array 4 :initial-element nil) =>  #(NIL NIL NIL NIL)
    (make-array '(2 4) 
                  :element-type '(unsigned-byte 2) 
                  :initial-contents '((0 1 2 3) (3 2 1 0)))
    =>  #2A((0 1 2 3) (3 2 1 0))
    (make-array 6
                  :element-type 'character 
                  :initial-element #\a 
                  :fill-pointer 3) =>  "aaa"
    ```

        以下是创建存储被转义的数组[displaced array]的示例.

    ```LISP
    (setq a (make-array '(4 3))) 
    =>  #<ARRAY 4x3 simple 32546632>
    (dotimes (i 4)
      (dotimes (j 3)
        (setf (aref a i j) (list i 'x j '= (* i j)))))
    =>  NIL
    (setq b (make-array 8 :displaced-to a
                          :displaced-index-offset 2))
    =>  #<ARRAY 8 indirect 32550757>
    (dotimes (i 8)
      (print (list i (aref b i))))
    >>  (0 (0 X 2 = 0)) 
    >>  (1 (1 X 0 = 0)) 
    >>  (2 (1 X 1 = 1)) 
    >>  (3 (1 X 2 = 2)) 
    >>  (4 (2 X 0 = 0)) 
    >>  (5 (2 X 1 = 2)) 
    >>  (6 (2 X 2 = 4)) 
    >>  (7 (3 X 0 = 0)) 
    =>  NIL
    ```

        这个最后一个例子依赖于那个数组[array]事实上以行优先顺序存储的事实.

    ```LISP
    (setq a1 (make-array 50))
    =>  #<ARRAY 50 simple 32562043>
    (setq b1 (make-array 20 :displaced-to a1 :displaced-index-offset 10))
    =>  #<ARRAY 20 indirect 32563346>
    (length b1) =>  20

    (setq a2 (make-array 50 :fill-pointer 10))
    =>  #<ARRAY 50 fill-pointer 10 46100216>
    (setq b2 (make-array 20 :displaced-to a2 :displaced-index-offset 10))
    =>  #<ARRAY 20 indirect 46104010>
    (length a2) =>  10
    (length b2) =>  20

    (setq a3 (make-array 50 :fill-pointer 10))
    =>  #<ARRAY 50 fill-pointer 10 46105663>
    (setq b3 (make-array 20 :displaced-to a3 :displaced-index-offset 10
                            :fill-pointer 5))
    =>  #<ARRAY 20 indirect, fill-pointer 5 46107432>
    (length a3) =>  10
    (length b3) =>  5
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        adjustable-array-p, aref, arrayp, array-element-type, array-rank-limit, array-dimension-limit, fill-pointer, upgraded-array-element-type

* 注意(Notes):

        这里没有指定去创建一个 adjustable-array-p 肯定返回 false 的数组[array]的方法. 这里没有指定去创建一个不是简单数组[simple array]的数组[array]的方法. 


### <span id="F-ADJUST-ARRAY">函数 ADJUST-ARRAY</span>

* 语法(Syntax):

        adjust-array array new-dimensions &key element-type initial-element initial-contents fill-pointer displaced-to displaced-index-offset
        => adjusted-array

* 参数和值(Arguments and Values):

        array---一个数组[array].
        new-dimensions---一个有效数组维度大小[valid array dimension]或者一个有效数组维度大小[valid array dimension]的列表[list].
        element-type---一个类型指定符[type specifier].
        initial-element---一个对象[object]. 如果提供了 initial-contents 或 displaced-to, 那么 initial-element 一定不能被提供.
        initial-contents---一个对象[object]. 如果数组[array]有着大于零的秩, 那么 initial-contents 由嵌套的序列[sequence]组成, 它的深度必须等于数组 array 的秩. 否则, 数组[array]是零维的并且 initial-contents 提供单个元素. 如果给定了 initial-element 或 displaced-to 那么 initial-contents 一定不能被提供.
        fill-pointer---一个要被创建的数组 array 的有效填充指针[valid fill pointer], 或者 t, 或者 nil. 默认是 nil.
        displaced-to---一个数组[array]或 nil. 如果提供了 displaced-to 那么 initial-elements 和 initial-contents 一定不能提供.
        displaced-index-offset---一个 (fixnum 0 n) 类型[type]的对象[object], 其中 n 是 (array-total-size displaced-to). 当且仅当提供了 displaced-to 那么displaced-index-offset 可以被提供.
        adjusted-array---一个数组[array].

* 描述(Description):

        adjust-array 改变数组 array 的维度大小或元素. 结果是一个和数组 array 相同类型[type]和秩的数组[array], 它是修改后的数组 array, 或者一个数组 array 所转移到的新创建的数组[array], 并且有着给定的新维数 new-dimensions.

        new-dimensions 指定了数组 array 的每一个维度大小[dimension].

        element-type 指定了产生的数组[array]的元素[element]类型[type]. 在提供了 element-type 的情况下, 如果 element-type 的提升数组元素类型[upgraded array element type]和数组 array 的实际数组元素类型[actual array element type]不相同那么后果是未指定的.

        如果提供了 initial-contents, 它的处理会像 make-array 一样. 在这个情况中数组 array 的原始内容不会出现在产生的数组[array]中.

        如果 fill-pointer 是一个整数[integer], 它就成为那个产生的数组[array]的填充指针[fill pointer]. 如果 fill-pointer 是符号 t, 它表示那个产生的数组[array]的大小被用作填充指针[fill pointer]. 如果 fill-pointer 是 nil, 它表示填充指针[fill pointer]应该保持原样.

        如果 displaced-to 是非 nil [non-nil], 那么就会创建一个存储被转移的数组[displaced array]. 产生的数组[array]和通过 displaced-to 给定的数组[array]共享内容. 那个产生的数组[array]不能包含比那个存储被转移的数组[displaced array]更多的元素. 如果没有提供 displaced-to 或者是 nil, 那么产生的数组[array]不是一个存储被转移的数组[displaced array]. 如果一个被创建的数组 A 转移到数组 B 并且后续数组 B 被给到 adjust-array, 数组 A 仍然会转移到数组 B. 虽然数组 array 可能是一个存储被转移的数组[displaced array], 但是产生的数组[array]不是一个存储被转移的数组[displaced array]除非提供了 displaced-to 并且不是 nil. 这个 adjust-array 和存储被转移的数组[displaced array]的交互就像下面给定的三个数组 A, B, 和 C 一样:

        A 在调用前后都没有被转移

            (adjust-array A ...)

            这个 A 的维数被修改, 并且内容会被适当重排. A 的额外元素来自于 initial-element. 这个 initial-contents 的使用会导致所有旧的内容被丢弃.

        A 在调用之前没有被转移, 但是在调用之后被转移到 C

            (adjust-array A ... :displaced-to C)

            A 中的原始内容不会出现在之后的 A 中; A 现在包含了 C 的内容, 而 C 不带有任何的重排.

        A 在这个调用之前被转移到 B, 在调用之后被转移到 C

            (adjust-array A ... :displaced-to B)
            (adjust-array A ... :displaced-to C)

            B 和 C 可能相同. 如果在这个 adjust-array 调用中没有提供 displaced-index-offset, 它默认为 0, 那么之后 B 中的内容可能不会出现在 A 中除非这样的内容也出现在 C 中; 在 B 中的旧的偏移位不会被保留.

        A 在调用前被转移到 B, 但是在调用后没有被转移.

            (adjust-array A ... :displaced-to B)
            (adjust-array A ... :displaced-to nil)

            A 得到一个新的 "数据区域(data region)", 而 B 的内容被拷贝到这个里面并保留已存在的旧元素; A 的另外的元素从 initial-element 中提取, 如果提供的话. 但是, 这个 initial-contents 的使用会导致所有旧的内容被丢弃.

        如果提供了 displaced-index-offset, 它指定了产生的数组[array]从它被转移到的数组[array]开始的偏移. 如果没有提供 displaced-index-offset, 偏移就是 0. 这个产生的数组[array]的大小加上偏移值不能超过那个它被转移到的数组[array]的大小.

        如果只提供了 new-dimensions 和一个 initial-element 参数, 数组 array 的那些元素仍然在产生的数组[array]的范围中出现. 产生的数组[array]中没有出现在数组[array]范围中的元素被初始化为 initial-element; 如果没有提供 initial-element, 后面在元素被初始化之前去读取 new-array 的这样的新元素的后果是未定义的.

        如果提供了 initial-contents 或 displaced-to, 那么数组 array 中的原始内容不会出现在新的数组[array]中.

        如果数组 array 被调整为一个小于它的填充指针[fill pointer]的大小并且没有提供 fill-pointer 参数, 这样一来它的填充指针[fill pointer]在这个过程中会被适当调整, 那么后果是未指定的.

        如果 A 被转移到 B, 如果 B 以一种不再有足够元素来满足 A 的方式被调整, 那么后果是未指定的.

        如果 adjust-array 被应用到一个实际上可调整[actually adjustable]的数组[array], 那么返回的数组[array]和数组 array 相等[identical]. 如果由 adjust-array 返回的数组[array]和数组 array 不同[distinct], 那么参数 array 不会被改变.

        注意, 如果一个数组[array] A 被转移到另一个数组[array] B, 而 B 被转移到另一个数组[array] C, 并且 B 被 adjust-array 修改, 那么 A 现在引用 B 中的调整的内容. 这个意味着一个实现不能折叠这个链来使 A 直接引用 C 而忘记了这个通过 B 的引用链. 但是, 缓存技术是允许的, 只要它们保留这里指定的语义.

* 示例(Examples):

    ```LISP
    (adjustable-array-p
      (setq ada (adjust-array
                  (make-array '(2 3)
                              :adjustable t
                              :initial-contents '((a b c) (1 2 3)))
                  '(4 6)))) =>  T 
    (array-dimensions ada) =>  (4 6) 
    (aref ada 1 1) =>  2 
    (setq beta (make-array '(2 3) :adjustable t))
    =>  #2A((NIL NIL NIL) (NIL NIL NIL)) 
    (adjust-array beta '(4 6) :displaced-to ada)
    =>  #2A((A B C NIL NIL NIL)
          (1 2 3 NIL NIL NIL)
          (NIL NIL NIL NIL NIL NIL) 
          (NIL NIL NIL NIL NIL NIL))
    (array-dimensions beta) =>  (4 6)
    (aref beta 1 1) =>  2 
    ```

        假设在 m 中的 4×4 数组看上去这样:

        #2A(( alpha     beta      gamma     delta )
            ( epsilon   zeta      eta       theta )
            ( iota      kappa     lambda    mu    )
            ( nu        xi        omicron   pi    ))

        那么下面这个的结果

        (adjust-array m '(3 5) :initial-element 'baz)

        是一个 3×5 的数组, 内容如下

        #2A(( alpha     beta      gamma     delta     baz )
            ( epsilon   zeta      eta       theta     baz )
            ( iota      kappa     lambda    mu        baz ))

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果提供了填充指针[fill pointer]并且是非 nil [non-nil]但是 array 没有填充指针[fill pointer], 那么就会发出一个 error 类型[type]的错误.

* 参见(See Also):

        adjustable-array-p, make-array, array-dimension-limit, array-total-size-limit, array

* 注意(Notes): None. 


### <span id="F-ADJUSTABLE-ARRAY-P">函数 ADJUSTABLE-ARRAY-P</span>

* 语法(Syntax):

        adjustable-array-p array => generalized-boolean

* 参数和值(Arguments and Values):

        array---一个数组[array].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        当且仅当给定那个数组 array 作为 adjust-array 的第一个实参[argument]可以返回一个相同[identical]的值[value]时这个函数返回 true.

* 示例(Examples):

    ```LISP
    (adjustable-array-p 
      (make-array 5
                  :element-type 'character 
                  :adjustable t 
                  :fill-pointer 3)) =>  true
    (adjustable-array-p (make-array 4)) =>  implementation-dependent
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果它的参数不是一个数组[array]应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        adjust-array, make-array

* 注意(Notes): None. 


### <span id="A-AREF">访问器 AREF</span>

* 语法(Syntax):

        aref array &rest subscripts => element

        (setf (aref array &rest subscripts) new-element)

* 参数和值(Arguments and Values):

        array---一个数组[array].
        subscripts---数组 array 的有效数组索引的一个列表[list].
        element, new-element---一个对象.

* 描述(Description):

        访问[access]由 subscripts 所指定的数组 array 元素[element]. 如果没有提供 subscripts 并且数组 array 是零维数的, aref 访问[access]数组 array 的单个元素.

        aref 忽略填充指针[fill pointer]. 允许使用 aref 去访问[access]任何数组 array 元素[element], 不管是否有效[active].

* 示例(Examples):

        如果变量 foo 命名一个 3×5 的数组, 第一个索引可以是 0, 1, 或 2, 并且第二个元素为 0, 1, 2, 3, 或 4. 数组元素可以通过使用函数[function] aref 来引用; 比如, (aref foo 2 1) 引用这个数组 array 的 (2, 1) 元素.

    ```LISP
    (aref (setq alpha (make-array 4)) 3) =>  implementation-dependent
    (setf (aref alpha 3) 'sirens) =>  SIRENS
    (aref alpha 3) =>  SIRENS
    (aref (setq beta (make-array '(2 4) 
                        :element-type '(unsigned-byte 2)
                        :initial-contents '((0 1 2 3) (3 2 1 0))))
            1 2) =>  1
    (setq gamma '(0 2))
    (apply #'aref beta gamma) =>  2
    (setf (apply #'aref beta gamma) 3) =>  3
    (apply #'aref beta gamma) =>  3
    (aref beta 0 2) =>  3
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        bit, char, elt, row-major-aref, svref, 章节 3.2.1 (编译器术语)

* 注意(Notes): None. 


### <span id="F-ARRAY-DIMENSION">函数 ARRAY-DIMENSION</span>

* 语法(Syntax):

        array-dimension array axis-number => dimension

* 参数和值(Arguments and Values):

        array---一个数组[array].
        axis-number---大于等于 0 并且小于这个数组 array 的秩[rank]的一个整数[integer].
        dimension---一个非负整数[integer].

* 描述(Description):

        array-dimension 返回数组 array 的 axis-number 维度[dimension[1]]的大小. (忽略任何填充指针[fill pointer].)

* 示例(Examples):

    ```LISP
    (array-dimension (make-array 4) 0) =>  4
    (array-dimension (make-array '(2 3)) 1) =>  3
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        array-dimensions, length

* 注意(Notes):

        (array-dimension array n) ==  (nth n (array-dimensions array))


### <span id="F-ARRAY-DIMENSIONS">函数 ARRAY-DIMENSIONS</span>

* 语法(Syntax):

        array-dimensions array => dimensions

* 参数和值(Arguments and Values):

        array---一个数组[array].
        dimensions---一个整数[integer]列表[list].

* 描述(Description):

        返回数组 array 维数[dimension]的一个列表[list]. (如果数组 array 是一个带有填充指针[fill pointer]的向量[vector], 那么就忽略那个填充指针[fill pointer].)

* 示例(Examples):

    ```LISP
    (array-dimensions (make-array 4)) =>  (4)
    (array-dimensions (make-array '(2 3))) =>  (2 3)
    (array-dimensions (make-array 4 :fill-pointer 2)) =>  (4)
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果它的参数不是一个数组[array], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        array-dimension

* 注意(Notes): None. 


### <span id="F-ARRAY-ELEMENT-TYPE">函数 ARRAY-ELEMENT-TYPE</span>

* 语法(Syntax):

        array-element-type array => typespec

* 参数和值(Arguments and Values):

        array---一个数组[array].
        typespec---一个类型指定符[type specifier].

* 描述(Description):

        返回表示这个数组 array 的实际数组元素类型[actual array element type]的类型指定符[type specifier]. (由于数组[array]提升[upgrade], 这个类型指定符[type specifier]在一些情况下表示这个数组 array 的表达数组元素类型[expressed array element type]的超类型[supertype].)

* 示例(Examples):

    ```LISP
    (array-element-type (make-array 4)) =>  T
    (array-element-type (make-array 12 :element-type '(unsigned-byte 8))) 
    =>  implementation-dependent
    (array-element-type (make-array 12 :element-type '(unsigned-byte 5)))
    =>  implementation-dependent
    ```

        (array-element-type (make-array 5 :element-type '(mod 5)))

        可以是 (mod 5), (mod 8), fixnum, t, 或者任何其他是 (mod 5) 的超类型[supertype]的类型.


* 受此影响(Affected By):

        具体实现[implementation].

* 异常情况(Exceptional Situations):

        如果它的参数不是一个数组[array], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        array, make-array, subtypep, upgraded-array-element-type

* 注意(Notes): None. 


### <span id="F-ARRAY-HAS-FILL-POINTER-P">函数 ARRAY-HAS-FILL-POINTER-P</span>

* 语法(Syntax):

        array-has-fill-pointer-p array => generalized-boolean

* 参数和值(Arguments and Values):

        array---一个数组[array].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果数组 array 有一个填充指针[fill pointer]就返回 true; 否则返回 false.

* 示例(Examples):

    ```LISP
    (array-has-fill-pointer-p (make-array 4)) =>  implementation-dependent
    (array-has-fill-pointer-p (make-array '(2 3))) =>  false
    (array-has-fill-pointer-p
      (make-array 8 
                  :fill-pointer 2 
                  :initial-element 'filler)) =>  true
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果它的参数不是一个数组[array], 应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        make-array, fill-pointer

* 注意(Notes):

        因为除了秩[rank]为 1 之外的数组[array]不能有一个填充指针[fill pointer], 当 array-has-fill-pointer-p 的参数为这样一个数组时总是返回 nil. 


### <span id="F-ARRAY-DISPLACEMENT">函数 ARRAY-DISPLACEMENT</span>

* 语法(Syntax):

        array-displacement array => displaced-to, displaced-index-offset

* 参数和值(Arguments and Values):

        array---一个数组[array].
        displaced-to---一个数组[array]或 nil.
        displaced-index-offset---一个非负 fixnum.

* 描述(Description):

        如果这个数组 array 是一个存储被转移的数组[displaced array], 返回这个数组[array]的 :displaced-to 和 :displaced-index-offset 选项的值[value] (见函数[function] make-array 和 adjust-array). 如果这个数组 array 不是一个存储被转移的数组[displaced array], 返回 nil 和 0.

        如果 array-displacement 在一个数组 array 上被调用, 对于这个数组一个非 nil [non-nil]对象[object]被提供作为给 make-array 或 adjust-array 的 :displaced-to 实参[argument], 它一定返回这个对象[object]作为它的第一个值. array-displacement 是否为任何其他数组返回一个非 nil [non-nil]主值[primary value]是依赖于具体实现的[implementation-dependent].

* 示例(Examples):

    ```LISP
    (setq a1 (make-array 5)) =>  #<ARRAY 5 simple 46115576>
    (setq a2 (make-array 4 :displaced-to a1
                            :displaced-index-offset 1))
    =>  #<ARRAY 4 indirect 46117134>
    (array-displacement a2)
    =>  #<ARRAY 5 simple 46115576>, 1
    (setq a3 (make-array 2 :displaced-to a2
                            :displaced-index-offset 2))
    =>  #<ARRAY 2 indirect 46122527>
    (array-displacement a3)
    =>  #<ARRAY 4 indirect 46117134>, 2
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 array 不是一个数组[array], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        make-array

* 注意(Notes): None. 


### <span id="F-ARRAY-IN-BOUNDS-P">函数 ARRAY-IN-BOUNDS-P</span>

* 语法(Syntax):

        array-in-bounds-p array &rest subscripts => generalized-boolean

* 参数和值(Arguments and Values):

        array---一个数组[array].
        subscripts---一个长度等价于数组 array 的秩[rank]的整数[integer]列表[list].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果 subscripts 都在数组 array 的边界内就返回 true; 否则返回 false. (如果 array 是一个带有填充指针[fill pointer]的向量[vector], 那么忽略那个填充指针[fill pointer].)

* 示例(Examples):

    ```LISP
    (setq a (make-array '(7 11) :element-type 'string-char))
    (array-in-bounds-p a 0  0) =>  true
    (array-in-bounds-p a 6 10) =>  true
    (array-in-bounds-p a 0 -1) =>  false
    (array-in-bounds-p a 0 11) =>  false
    (array-in-bounds-p a 7  0) =>  false
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        array-dimensions

* 注意(Notes):

        (array-in-bounds-p array subscripts)   
        ==  (and (not (some #'minusp (list subscripts)))


### <span id="F-ARRAY-RANK">函数 ARRAY-RANK</span>

* 语法(Syntax):

        array-rank array => rank

* 参数和值(Arguments and Values):

        array---一个数组[array].
        rank---一个非负整数[integer].

* 描述(Description):

        返回数组 array 的维度[dimension]数量.

* 示例(Examples):

    ```LISP
    (array-rank (make-array '())) =>  0
    (array-rank (make-array 4)) =>  1
    (array-rank (make-array '(4))) =>  1
    (array-rank (make-array '(2 3))) =>  2
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果它的参数不是一个数组[array]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        array-rank-limit, make-array

* 注意(Notes): None. 


### <span id="F-ARRAY-ROW-MAJOR-INDEX">函数 ARRAY-ROW-MAJOR-INDEX</span>

* 语法(Syntax):

        array-row-major-index array &rest subscripts => index

* 参数和值(Arguments and Values):

        array---一个数组[array].
        subscripts---数组 array 的有效数组索引的一个列表[list].
        index---数组 array 的一个有效数组行优先索引[valid array row-major index].

* 描述(Description):

        根据数组 array 的行优先顺序计算由 subscripts 指定的元素的位置, 返回从数组 array 的开始计算的位置的元素的偏移量.

        对于一个一维数组, array-row-major-index 的结果等于 subscript.

        array-row-major-index 忽略填充指针[fill pointer].

* 示例(Examples):

    ```LISP
    (setq a (make-array '(4 7) :element-type '(unsigned-byte 8)))
    (array-row-major-index a 1 2) =>  9
    (array-row-major-index 
        (make-array '(2 3 4) 
                    :element-type '(unsigned-byte 8)
                    :displaced-to a
                    :displaced-index-offset 4)
        0 2 1) =>  9
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes):

        一个没有错误检测的可能的 array-row-major-index 定义是

    ```LISP
    (defun array-row-major-index (a &rest subscripts)
      (apply #'+ (maplist #'(lambda (x y)
                                (* (car x) (apply #'* (cdr y))))
                          subscripts
                          (array-dimensions a))))
    ```


### <span id="F-ARRAY-TOTAL-SIZE">函数 ARRAY-TOTAL-SIZE</span>

* 语法(Syntax):

        array-total-size array => size

* 参数和值(Arguments and Values):

        array---一个数组[array].
        size---一个非负整数[integer].

* 描述(Description):

        返回这个数组 array 的数组总大小[array total size].

* 示例(Examples):

    ```LISP
    (array-total-size (make-array 4)) =>  4
    (array-total-size (make-array 4 :fill-pointer 2)) =>  4
    (array-total-size (make-array 0)) =>  0
    (array-total-size (make-array '(4 2))) =>  8
    (array-total-size (make-array '(4 0))) =>  0
    (array-total-size (make-array '())) =>  1
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果它的参数不是一个数组[array], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        make-array, array-dimensions

* 注意(Notes):

        如果这个数组 array 是一个带有填充指针[fill pointer]的向量[vector], 那么在计算这个数组总大小[array total size]时这个填充指针[fill pointer]会被忽略.

        由于没有参数的乘积是 1, 所以一个零维数组的数组总大小[array total size]是 1.

        (array-total-size x)
            ==  (apply #'* (array-dimensions x))
            ==  (reduce #'* (array-dimensions x))


### <span id="F-ARRAYP">函数 ARRAYP</span>

* 语法(Syntax):

        arrayp object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 array 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (arrayp (make-array '(2 3 4) :adjustable t)) =>  true
    (arrayp (make-array 6)) =>  true
    (arrayp #*1011) =>  true
    (arrayp "hi") =>  true
    (arrayp 'hi) =>  false
    (arrayp 12) =>  false
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        typep

* 注意(Notes):

        (arrayp object) ==  (typep object 'array)


### <span id="A-FILL-POINTER">访问器 FILL-POINTER</span>

* 语法(Syntax):

        fill-pointer vector => fill-pointer

        (setf (fill-pointer vector) new-fill-pointer)

* 参数和值(Arguments and Values):

        vector---一个带有填充指针[fill pointer]的向量[vector].
        fill-pointer, new-fill-pointer---向量 vector 的一个有效填充指针[valid fill pointer].

* 描述(Description):

        访问[access]向量 vector 的填充指针[fill pointer].

* 示例(Examples):

    ```LISP
    (setq a (make-array 8 :fill-pointer 4)) =>  #(NIL NIL NIL NIL)
    (fill-pointer a) =>  4
    (dotimes (i (length a)) (setf (aref a i) (* i i))) =>  NIL
    a =>  #(0 1 4 9)
    (setf (fill-pointer a) 3) =>  3
    (fill-pointer a) =>  3
    a =>  #(0 1 4)
    (setf (fill-pointer a) 8) =>  8
    a =>  #(0 1 4 9 NIL NIL NIL NIL)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 vector 不是一个带有填充指针[fill pointer]的向量[vector]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        make-array, length

* 注意(Notes):

        这里没有会移除向量[vector]的填充指针[fill pointer]的操作符[operator]. 


### <span id="A-ROW-MAJOR-AREF">访问器 ROW-MAJOR-AREF</span>

* 语法(Syntax):

        row-major-aref array index => element

        (setf (row-major-aref array index) new-element)

* 参数和值(Arguments and Values):

        array---一个数组[array].
        index---对于数组 array 的一个有效数组行优先索引[valid array row-major index].
        element, new-element---一个对象[object].

* 描述(Description):

        将数组[array]看作是一个向量[vector], 它以行优先的顺序查看其元素[element], 并且返回给定索引 index 引用的向量[vector]的元素[element].

        row-major-aref 和 setf 一起使用是有效的.

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        aref, array-row-major-index

* 注意(Notes):

        (row-major-aref array index) == 
          (aref (make-array (array-total-size array)
                            :displaced-to array
                            :element-type (array-element-type array))
                index)

        (aref array i1 i2 ...) == 
            (row-major-aref array (array-row-major-index array i1 i2))


### <span id="F-UPGRADED-ARRAY-ELEMENT-TYPE">函数 UPGRADED-ARRAY-ELEMENT-TYPE</span>

* 语法(Syntax):

        upgraded-array-element-type typespec &optional environment => upgraded-typespec

* 参数和值(Arguments and Values):

        typespec---一个类型指定符[type specifier].
        environment---一个环境[environment]对象[object]. 默认是 nil, 表示空词法环境[null lexical environment]和当前全局环境[global environment].
        upgraded-typespec---一个类型指定符[type specifier].

* 描述(Description):

        返回可以持有 typespec 所表示类型[type]的条目的最具体[specialized]数组[array]表示的元素类型[element type].

        这个 typespec 是 upgraded-typespec 的一个子类型[subtype] (并且可能类型等价[type equivalent]).

        如果 typespec 是 bit, 那么结果和 bit 是类型等价的[type equivalent]. 如果 typespec 是 base-char, 那么结果和 base-char 是类型等价的[type equivalent]. 如果 typespec 是 character, 那么结果和 character 是类型等价的[type equivalent].

        upgraded-array-element-type 的目的是去揭露一个实现如何执行这个提升[upgrade].

        这个环境 environment 被用于展开任何 typespec 中提及的衍生类型指定符[derived type specifier].

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        array-element-type, make-array

* 注意(Notes):

        除了存储分配的影响和正确处理这个可选的 environment 实参[argument]之外, upgraded-array-element-type 可以按如下定义:

        (defun upgraded-array-element-type (type &optional environment)
          (array-element-type (make-array 0 :element-type type)))


### <span id="CV-ARRAY-DIMENSION-LIMIT">常量 ARRAY-DIMENSION-LIMIT</span>

* 常量值(Constant Value):

        一个正的 fixnum, 它的准确大小是依赖于具体实现的[implementation-dependent], 但不小于 1024.

* 描述(Description):

        一个数组[array]的每个独立维度[dimension]的上边界.

* 示例(Examples): None.

* 参见(See Also):

        make-array

* 注意(Notes): None. 


### <span id="CV-ARRAY-RANK-LIMIT">常量 ARRAY-RANK-LIMIT</span>

* 常量值(Constant Value):

        一个正的 fixnum, 它的准确大小是依赖于具体实现的[implementation-dependent], 但是不小于 8.

* 描述(Description):

        一个数组[array]秩[rank]的上边界.

* 示例(Examples): None.

* 参见(See Also):

        make-array

* 注意(Notes): None. 

### <span id="CV-ARRAY-TOTAL-SIZE-LIMIT">常量 ARRAY-TOTAL-SIZE-LIMIT</span>

* 常量值(Constant Value):

        一个正的 fixnum, 准确大小是依赖于具体实现的[implementation-dependent], 但是不小于 1024.

* 描述(Description):

        一个数组[array]的数组总大小[array total size]的上限.

        具体实现[implementation]强加在数组总大小[array total size]的实际限制可能根据数组[array]的元素类型[element type]变化; 在这种情况中, 这个 array-total-size-limit 的值会是这些可能的限制中最小的.

* 示例(Examples): None.

* 参见(See Also):

        make-array, array-element-type

* 注意(Notes): None. 


### <span id="F-SIMPLE-VECTOR-P">函数 SIMPLE-VECTOR-P</span>

* 语法(Syntax):

        simple-vector-p object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果 object 是 simple-vector 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (simple-vector-p (make-array 6)) =>  true
    (simple-vector-p "aaaaaa") =>  false
    (simple-vector-p (make-array 6 :fill-pointer t)) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        simple-vector

* 注意(Notes):

        (simple-vector-p object) ==  (typep object 'simple-vector)


### <span id="A-SVREF">访问器 SVREF</span>

* 语法(Syntax):

        svref simple-vector index => element

        (setf (svref simple-vector index) new-element)

* 参数和值(Arguments and Values):

        simple-vector---一个简单向量[simple vector].
        index---simple-vector 的有效数组索引[valid array index].
        element, new-element---一个对象[object] (它的类型[type]是 simple-vector 的数组元素类型[array element type]的子类型[subtype]).

* 描述(Description):

        访问[access]由 index 指定的 simple-vector 中的元素[element].

* 示例(Examples):

    ```LISP
    (simple-vector-p (setq v (vector 1 2 'sirens))) =>  true
    (svref v 0) =>  1
    (svref v 2) =>  SIRENS
    (setf (svref v 1) 'newcomer) =>  NEWCOMER               
    v =>  #(1 NEWCOMER SIRENS)
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        aref, sbit, schar, vector, 章节 3.2.1 (编译器术语)

* 注意(Notes):

        svref 和 aref 相同除了它要求第一个参数为一个简单向量[simple vector].

        (svref v i) ==  (aref (the simple-vector v) i)


### <span id="F-VECTOR">函数 VECTOR</span>

* 语法(Syntax):

        vector &rest objects => vector

* 参数和值(Arguments and Values):

        object---一个对象[object].
        vector---一个 (vector t *) 类型[type]的向量[vector].

* 描述(Description):

        创建一个新的[fresh]简单普通向量[simple general vector], 它的大小对应于对象 objects 的数量.

        这个向量[vector]被初始化去包含这些对象 objects.

* 示例(Examples):

    ```LISP
    (arrayp (setq v (vector 1 2 'sirens))) =>  true
    (vectorp v) =>  true
    (simple-vector-p v) =>  true         
    (length v) =>  3
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        make-array

* 注意(Notes):

        vector 与 list 类似.

        (vector a1 a2 ... an)
          ==  (make-array (list n) :element-type t
                                  :initial-contents 
                                    (list a1 a2 ... an))


### <span id="F-VECTOR-POP">函数 VECTOR-POP</span>

* 语法(Syntax):

        vector-pop vector => element

* 参数和值(Arguments and Values):

        vector---一个带有填充指针[fill pointer]的向量[vector].
        element---一个对象[object].

* 描述(Description):

        向量 vector 的填充指针[fill pointer]递减一, 并且检索向量 vector 中由这个新的填充指针[fill pointer]所指示的元素[element].

* 示例(Examples):

    ```LISP
    (vector-push (setq fable (list 'fable))
                  (setq fa (make-array 8
                                      :fill-pointer 2
                                      :initial-element 'sisyphus))) =>  2 
    (fill-pointer fa) =>  3 
    (eq (vector-pop fa) fable) =>  true
    (vector-pop fa) =>  SISYPHUS 
    (fill-pointer fa) =>  1 
    ```

* 副作用(Side Effects):

        填充指针[fill pointer]递减一.

* 受此影响(Affected By):

        这个填充指针[fill pointer]的值.

* 异常情况(Exceptional Situations):

        如果向量 vector 没有一个填充指针[fill pointer]那么应该发出一个 type-error 类型[type]的错误.

        如果填充指针[fill pointer]是零, vector-pop 会发出一个 error 类型[type]的错误.

* 参见(See Also):

        vector-push, vector-push-extend, fill-pointer

* 注意(Notes): None. 

### <span id="F-V-PUSH-V-PUSH-EXTEND">函数 VECTOR-PUSH, VECTOR-PUSH-EXTEND</span>

* 语法(Syntax):

        vector-push new-element vector => new-index-p

        vector-push-extend new-element vector &optional extension => new-index

* 参数和值(Arguments and Values):

        new-element---一个对象[object].
        vector---一个带有填充指针[fill pointer]的向量[vector].
        extension---一个正整数[integer]. 默认是依赖于具体实现的[implementation-dependent].
        new-index-p---对于 vector 的一个有效数组索引[valid array index], 或者 nil.
        new-index---对于 vector 的一个有效数组索引[valid array index].

* 描述(Description):

        vector-push 和 vector-push-extend 存储新元素 new-element 到向量 vector 中. vector-push 尝试去存储 new-element 到 vector 的由填充指针[fill pointer]所表示的元素中, 并且对填充指针[fill pointer]加一. 如果 (>= (fill-pointer vector) (array-dimension vector 0)), 不管是 vector 还是它的填充指针[fill pointer]都不会被影响. 否则, 就会发生存储和递增并且 vector-push 返回这个填充指针[fill pointer]之前的值, 它比离开这个向量时的值小 1.

        vector-push-extend 就像 vector-push 除了当填充指针[fill pointer]太大时, vector 使用 adjust-array 来扩展这样它就可以包含更多元素. 如果这个 vector 必须要被扩展, 那么 extension 就是要被添加给它的最小数量的元素.

        vector-push 和 vector-push-extend 返回这个 new-element 在 vector 中的索引. 如果 (>= (fill-pointer vector) (array-dimension vector 0)), vector-push 返回 nil.

* 示例(Examples):

    ```LISP
    (vector-push (setq fable (list 'fable))
                  (setq fa (make-array 8 
                                      :fill-pointer 2
                                      :initial-element 'first-one))) =>  2 
    (fill-pointer fa) =>  3 
    (eq (aref fa 2) fable) =>  true
    (vector-push-extend #\X
                        (setq aa 
                              (make-array 5
                                          :element-type 'character
                                          :adjustable t
                                          :fill-pointer 3))) =>  3 
    (fill-pointer aa) =>  4 
    (vector-push-extend #\Y aa 4) =>  4 
    (array-total-size aa) =>  at least 5 
    (vector-push-extend #\Z aa 4) =>  5 
    (array-total-size aa) =>  9 ;(or more)
    ```

* 受此影响(Affected By):

        这个填充指针[fill pointer]的值.

        向量 vector 如何被创建.

* 异常情况(Exceptional Situations):

        如果 vector-push-extend 尝试去扩展向量 vector 而 vector 事实上是不可调整的[actually adjustable], 那么应该发出一个 error 类型[type]的错误.

        如果向量 vector 没有一个填充指针[fill pointer]那么应该发出一个 error 类型[type]的错误.

* 参见(See Also):

        adjustable-array-p, fill-pointer, vector-pop

* 注意(Notes): None. 


### <span id="F-VECTORP">函数 VECTORP</span>

* 语法(Syntax):

        vectorp object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 为 vector 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (vectorp "aaaaaa") =>  true
    (vectorp (make-array 6 :fill-pointer t)) =>  true
    (vectorp (make-array '(2 3 4))) =>  false
    (vectorp #*11) =>  true
    (vectorp #b11) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes):

        (vectorp object) ==  (typep object 'vector)


### <span id="A-BIT-SBIT">访问器 BIT, SBIT</span>

* 语法(Syntax):

        bit bit-array &rest subscripts => bit

        sbit bit-array &rest subscripts => bit

        (setf (bit bit-array &rest subscripts) new-bit)

        (setf (sbit bit-array &rest subscripts) new-bit)

* 参数和值(Arguments and Values):

        bit-array---对于 bit, 是一个位数组[bit array]; 对于 sbit, 一个简单位数组[simple bit array].
        subscripts---位数组 bit-array 的一个有效数组索引的列表[list].
        bit---一个比特[bit].

* 描述(Description):

        bit 和 sbit 访问[access]由 subscripts 指定的 bit-array 元素[element].
        
        当访问[access]元素[element]时, 这些函数[function]忽略填充指针[fill pointer].

* 示例(Examples):

    ```LISP
    (bit (setq ba (make-array 8 
                                :element-type 'bit 
                                :initial-element 1))
          3) =>  1
    (setf (bit ba 3) 0) =>  0
    (bit ba 3) =>  0
    (sbit ba 5) =>  1
    (setf (sbit ba 5) 1) =>  1
    (sbit ba 5) =>  1
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        aref, 章节 3.2.1 (编译器术语)

* 注意(Notes):

        bit 和 sbit 类似于 aref 除了它们要求数组[array]分别为一个位数组[bit array]和简单位数组[simple bit array].

        bit 和 sbit, 不像 char 和 schar, 允许第一个参数为一个任意秩[rank]的数组[array]. 


### <span id="F-BIT-ALL">函数 BIT-AND, BIT-ANDC1, BIT-ANDC2, BIT-EQV, BIT-IOR, BIT-NAND, BIT-NOR, BIT-NOT, BIT-ORC1, BIT-ORC2, BIT-XOR</span>

* 语法(Syntax):

        bit-and bit-array1 bit-array2 &optional opt-arg => resulting-bit-array

        bit-andc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array

        bit-andc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array

        bit-eqv bit-array1 bit-array2 &optional opt-arg => resulting-bit-array

        bit-ior bit-array1 bit-array2 &optional opt-arg => resulting-bit-array

        bit-nand bit-array1 bit-array2 &optional opt-arg => resulting-bit-array

        bit-nor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array

        bit-orc1 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array

        bit-orc2 bit-array1 bit-array2 &optional opt-arg => resulting-bit-array

        bit-xor bit-array1 bit-array2 &optional opt-arg => resulting-bit-array

        bit-not bit-array &optional opt-arg => resulting-bit-array

* 参数和值(Arguments and Values):

        bit-array, bit-array1, bit-array2---一个位数组[bit array].
        Opt-arg---一个位数组[bit array], 或 t, 或 nil. 默认是 nil.
        Bit-array, bit-array1, bit-array2, 和 opt-arg (如果是一个数组[array]) 必须全都是相同的秩[rank]和维数[dimension].
        resulting-bit-array---一个位数组[bit array].

* 描述(Description):

        这些函数在 bit-array1 和 bit-array2 上执行位逻辑操作并且返回一个秩[rank]和维数[dimension]匹配的数组[array], 如此以至于这个结果中的任何位都是有在这些参数的每一个的对应位上操作所产生的.

        在 bit-not 的情况下, 返回一个和 bit-array 秩[rank]和维数[dimension]匹配的数组[array], 这个数组包含了 bit-array 的一个所有位反转的拷贝.

        如果 opt-arg 是类型 (array bit) 那么这个结果的内容被破坏性地放置到 opt-arg 中. 如果 opt-arg 是符号 t, bit-array 或 bit-array1 会被这个结果替换; 如果 opt-arg 是 nil 或省略了, 那么就创建一个新的数组[array]来包含这个结果.

        下面这段指出有这些函数[function]中的每一个执行的逻辑操作.
                                                                                                       
    |函数                             |                        操作                                     |
    |---|---|
    |bit-and                          |                        and                                           |
    |bit-eqv                          |                        equivalence (exclusive nor)                   |
    |bit-not                          |                        complement                                    |
    |bit-ior                          |                        inclusive or                                  |
    |bit-xor                          |                        exclusive or                                  |
    |bit-nand                         |                        complement of bit-array1 and bit-array2       |
    |bit-nor                          |                        complement of bit-array1 or bit-array2        |
    |bit-andc1                        |                        and complement of bit-array1 with bit-array2  |
    |bit-andc2                        |                        and bit-array1 with complement of bit-array2  |
    |bit-orc1                         |                        or complement of bit-array1 with bit-array2   |
    |bit-orc2                         |                        or bit-array1 with complement of bit-array2   |
                                                                                                          
    Figure 15-4.  位数组上的位逻辑操作符 

* 示例(Examples):

    ```LISP
    (bit-and (setq ba #*11101010) #*01101011) =>  #*01101010
    (bit-and #*1100 #*1010) =>  #*1000      
    (bit-andc1 #*1100 #*1010) =>  #*0010
    (setq rba (bit-andc2 ba #*00110011 t)) =>  #*11001000
    (eq rba ba) =>  true
    (bit-not (setq ba #*11101010)) =>  #*00010101
    (setq rba (bit-not ba 
                        (setq tba (make-array 8 
                                              :element-type 'bit))))
    =>  #*00010101
    (equal rba tba) =>  true
    (bit-xor #*1100 #*1010) =>  #*0110
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        lognot, logand

* 注意(Notes): None. 


### <span id="F-BIT-VECTOR-P">函数 BIT-VECTOR-P</span>

* 语法(Syntax):

        bit-vector-p object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 bit-vector 类型[type]的就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (bit-vector-p (make-array 6 
                              :element-type 'bit 
                              :fill-pointer t)) =>  true
    (bit-vector-p #*) =>  true
    (bit-vector-p (make-array 6)) =>  false
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        typep

* 注意(Notes):

        (bit-vector-p object) ==  (typep object 'bit-vector)


### <span id="F-SIMPLE-BIT-VECTOR-P">函数 SIMPLE-BIT-VECTOR-P</span>

* 语法(Syntax):

        simple-bit-vector-p object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 simple-bit-vector 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (simple-bit-vector-p (make-array 6)) =>  false
    (simple-bit-vector-p #*) =>  true
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        simple-vector-p

* 注意(Notes):

        (simple-bit-vector-p object) ==  (typep object 'simple-bit-vector)


# 16. 字符串

> * 16.1 [字符串的概念](#StringConcepts)
> * 16.2 [字符串的字典](#TheStringsDictionary)

## 16.1 <span id="StringConcepts">字符串的概念</span>

### 16.1.1 字符串作为数组的含义

因为所有字符串[string]是数组[array], 所有可应用于数组[array]的规则也可以应用于字符串[string]. 见章节 15.1 (数组的概念).

比如, 字符串[string]可以有填充指针[fill pointer], 并且字符串[string]也服从应用于数组的元素类型[element type]提升[upgrade]的规则. 

### 16.1.2 STRING 的子类型

所有在字符串[string]上操作的函数也可以在字符串[string]的子类型[subtype]上操作.

然而, 如果一个字符[character]被插入到一个字符串[string]中而这个字符串[string]的元素类型[element type]不包括那个字符[character], 那么后果是未定义的. 

### 16.2 <span id="TheStringsDictionary">字符串的字典</span>

> * [系统类 STRING](#SC-STRING)
> * [类型 BASE-STRING](#T-BASE-STRING)
> * [类型 SIMPLE-STRING](#T-SIMPLE-STRING)
> * [类型 SIMPLE-BASE-STRING](#T-SIMPLE-BASE-STRING)
> * [函数 SIMPLE-STRING-P](#F-SIMPLE-STRING-P)
> * [访问器 CHAR, SCHAR](#A-CHAR-SCHAR)
> * [函数 STRING](#F-STRING)
> * [函数 STRING-UPCASE, STRING-DOWNCASE, STRING-CAPITALIZE, NSTRING-UPCASE, NSTRING-DOWNCASE, NSTRING-CAPITALIZE](#F-STRING-CASE)
> * [函数 STRING-TRIM, STRING-LEFT-TRIM, STRING-RIGHT-TRIM](#F-STRING-TRIM)
> * [函数 STRING=, STRING/=, STRING<, STRING>, STRING<=, STRING>=, STRING-EQUAL, STRING-NOT-EQUAL, STRING-LESSP, STRING-GREATERP, STRING-NOT-GREATERP, STRING-NOT-LESSP](#F-STRING-COMPARE)
> * [函数 STRINGP](#F-STRINGP)
> * [函数 MAKE-STRING](#F-MAKE-STRING)


### <span id="SC-STRING">系统类 STRING</span>

* 类优先级列表(Class Precedence List):

        string, vector, array, sequence, t

* 描述(Description):

        一个字符串[string]是一个元素[element]为类型[type] character 或 character 的一个子类型[subtype]的一个特化[specialized]向量[vector]. 当被用作对象创建时的类型指定符[type specifier]时, string 意味着 (vector character).

* 复合类型指定符类别(Compound Type Specifier Kind):

        缩写的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        string [size]

* 复合类型指定符参数(Compound Type Specifier Arguments):

        size---一个非负 fixnum, 或者符号[symbol] *.

* 复合类型指定符描述(Compound Type Specifier Description):

        对于所有 character 的子类型[subtype] c, 这个表示所有 (array c (size)) 类型[type]的并集; 这也就是说, 大小为 size 的字符串[string]的集合.

* 参见(See Also):

        章节 16.1 (字符串的概念), 章节 2.4.5 (双引号), 章节 22.1.3.4 (打印字符串) 


### <span id="T-BASE-STRING">类型 BASE-STRING</span>

* 超类型(Supertypes):

        base-string, string, vector, array, sequence, t

* 描述(Description):

        类型[type] base-string 等价于 (vector base-char). 这个基本字符串[base string]表示是可以持有一个标准字符[standard character]的任意序列的最有效字符串[string]表示.

* 复合类型指定符类别(Compound Type Specifier Kind):

        缩写的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        base-string [size]

* 复合类型指定符参数(Compound Type Specifier Arguments):

        size---一个非负 fixnum, 或者符号[symbol] *.

* 复合类型指定符描述(Compound Type Specifier Description):

        这个等价于类型 (vector base-char size); 换言之, 就是大小为 size 的基本字符串[base string的集合. 


### <span id="T-SIMPLE-STRING">类型 SIMPLE-STRING</span>

* 超类型(Supertypes):

        simple-string, string, vector, simple-array, array, sequence, t

* 描述(Description):

        一个简单字符串[simple string]是元素为 character 类型[type]或 character 的子类型[subtype]的一个特化的一维简单数组[simple array]. 当被用作对象创建时的类型指定符[type specifier]时, simple-string 意味着 (simple-array character (size)).

* 复合类型指定符类别(Compound Type Specifier Kind):

        缩写的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        simple-string [size]

* 复合类型指定符参数(Compound Type Specifier Arguments):

        size---一个非负 fixnum, 或者符号[symbol] *.

* 复合类型指定符描述(Compound Type Specifier Description):

        对于 character 的子类型[subtype] c, 这个表示所有 (simple-array c (size)) 类型[type]的并集; 换言之, 大小为 size 的简单字符串[simple string]的集合.


### <span id="T-SIMPLE-BASE-STRING">类型 SIMPLE-BASE-STRING</span>

* 超类型(Supertypes):

        simple-base-string, base-string, simple-string, string, vector, simple-array, array, sequence, t

* 描述(Description):

        类型[type] simple-base-string 等价于 (simple-array base-char (*)).

* 复合类型指定符类别(Compound Type Specifier Kind):

        缩写的.

* 复合类型指定符语法(Compound Type Specifier Syntax):

        simple-base-string [size]

* 复合类型指定符参数(Compound Type Specifier Arguments):

        size---一个非负 fixnum, 或者符号[symbol] *.

* 复合类型指定符描述(Compound Type Specifier Description):

        这个等价于类型 (simple-array base-char (size)); 换言之, 大小为 size 的简单[simple]基本字符串[base string]的集合. 


### <span id="F-SIMPLE-STRING-P">函数 SIMPLE-STRING-P</span>

* 语法(Syntax):

        simple-string-p object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 simple-string 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (simple-string-p "aaaaaa") =>  true
    (simple-string-p (make-array 6 
                                  :element-type 'character 
                                  :fill-pointer t)) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes):

        (simple-string-p object) ==  (typep object 'simple-string)


### <span id="A-CHAR-SCHAR">访问器 CHAR, SCHAR</span>

* 语法(Syntax):

        char string index => character

        schar string index => character

        (setf (char string index) new-character)

        (setf (schar string index) new-character)

* 参数和值(Arguments and Values):

        string---对于 char, 一个字符串[string]; 对于 schar, 一个简单字符串[simple string].
        index---字符串 string 的一个有效数组索引[valid array index].
        character, new-character---一个字符[character].

* 描述(Description):

        char 和 schar 访问[access]由索引 index 指定的字符串 string 中的元素[element].

        当访问[access]元素[element]时, char 忽略填充指针[fill pointer].

* 示例(Examples):

    ```LISP
    (setq my-simple-string (make-string 6 :initial-element #\A)) =>  "AAAAAA"
    (schar my-simple-string 4) =>  #\A
    (setf (schar my-simple-string 4) #\B) =>  #\B
    my-simple-string =>  "AAAABA"
    (setq my-filled-string
          (make-array 6 :element-type 'character
                        :fill-pointer 5
                        :initial-contents my-simple-string))
    =>  "AAAAB"
    (char my-filled-string 4) =>  #\B
    (char my-filled-string 5) =>  #\A
    (setf (char my-filled-string 3) #\C) =>  #\C
    (setf (char my-filled-string 5) #\D) =>  #\D
    (setf (fill-pointer my-filled-string) 6) =>  6
    my-filled-string =>  "AAACBD"
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        aref, elt, 章节 3.2.1 (编译器术语)

* 注意(Notes):

        (char s j) ==  (aref (the string s) j)


### <span id="F-STRING">函数 STRING</span>

* 语法(Syntax):

        string x => string

* 参数和值(Arguments and Values):

        x---一个字符串[string], 一个符号[symbol], 或者一个字符[character].
        string---一个字符串[string].

* 描述(Description):

        返回一个由 x 描述的字符串[string]; 具体来说:

            如果 x 是一个字符串[string], 就返回它.
            如果 x 是一个符号[symbol], 返回它的名字[name].
            如果 x 是一个字符[character], 那么返回包含这样一个字符[character]的字符串[string].
            string 可能执行额外的, 具体实现定义的[implementation-defined]转换.

* 示例(Examples):

    ```LISP
    (string "already a string") =>  "already a string"
    (string 'elm) =>  "ELM"
    (string #\c) =>  "c"
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        在一个转换既没有被这个规范也没有被具体实现[implementation]所定义的情况下, 就会发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        coerce, string (类型).

* 注意(Notes):

        coerce 可以被用于去转换一个字符[character]的序列[sequence]为一个字符串[string].

        prin1-to-string, princ-to-string, write-to-string, 或 format (带有一个 nil 的第一个参数) 可以被用于获取一个数字[number]或其他任何对象[object]的字符串[string]表示. 


### <span id="F-STRING-CASE">函数 STRING-UPCASE, STRING-DOWNCASE, STRING-CAPITALIZE, NSTRING-UPCASE, NSTRING-DOWNCASE, NSTRING-CAPITALIZE</span>

* 语法(Syntax):

        string-upcase string &key start end => cased-string

        string-downcase string &key start end => cased-string

        string-capitalize string &key start end => cased-string

        nstring-upcase string &key start end => string

        nstring-downcase string &key start end => string

        nstring-capitalize string &key start end => string

* 参数和值(Arguments and Values):

        string---一个字符串标识符[string designator]. 对于 nstring-upcase, nstring-downcase, 和 nstring-capitalize, 这个字符串标识符[string designator]必须是一个字符串[string].
        start, end---字符串 string 的边界索引标识符[bounding index designator]. 对于 start 和 end 默认分别是 0 和 nil.
        cased-string---一个字符串[string].

* 描述(Description):

        string-upcase, string-downcase, string-capitalize, nstring-upcase, nstring-downcase, nstring-capitalize 按照如下改变字符串 string 由 start 和 end 限定[bounded]的子序列的大小写:

        string-upcase

            string-upcase 返回一个和字符串 string 相似的字符串[string], 其中所有小写字符被对应大写字符替换. 更确切地说, 结果字符串[string]中的每个字符都通过应用 char-upcase 函数[function]到字符串 string 的对应字符上产生的.

        string-downcase

            string-downcase 类似于 string-upcase 除了所有大写字符被对应小写字符替换(使用 char-downcase).

        string-capitalize

            string-capitalize 产生一个字符串 string 的一个拷贝, 这样一来, 对于这个拷贝中的每一个词, 这个 "词" 的第一个字符[character], 如果有大小写[case], 就变为大写[uppercase]并且在这个词中的其他任何带有大小写[case]的字符[character]变为小写[lowercase]. 对于 string-capitalize 的目的, 一个"单词"被定义为一个连续的子序列, 由字母数字[alphanumeric]字符[character]组成, 每一端都用非字母数字[alphanumeric]字符[character]或字符串[string]的结尾分隔.

        nstring-upcase, nstring-downcase, nstring-capitalize

            nstring-upcase, nstring-downcase, 和 nstring-capitalize 分别等价于 string-upcase, string-downcase, 和 string-capitalize 除了它们修改字符串 string.

        对于 string-upcase, string-downcase, 和 string-capitalize, 字符串 string 不会被修改. 然而, 如果在字符串 string 中没有字符需要转换, 那么结果可能就是那个字符串 string 或者它的一个拷贝, 由实现判定.

* 示例(Examples):

    ```LISP
    (string-upcase "abcde") =>  "ABCDE"
    (string-upcase "Dr. Livingston, I presume?")
    =>  "DR. LIVINGSTON, I PRESUME?"
    (string-upcase "Dr. Livingston, I presume?" :start 6 :end 10)
    =>  "Dr. LiVINGston, I presume?"
    (string-downcase "Dr. Livingston, I presume?")
    =>  "dr. livingston, i presume?"

    (string-capitalize "elm 13c arthur;fig don't") =>  "Elm 13c Arthur;Fig Don'T"
    (string-capitalize " hello ") =>  " Hello "
    (string-capitalize "occlUDeD cASEmenTs FOreSTAll iNADVertent DEFenestraTION")
    =>   "Occluded Casements Forestall Inadvertent Defenestration"
    (string-capitalize 'kludgy-hash-search) =>  "Kludgy-Hash-Search"
    (string-capitalize "DON'T!") =>  "Don'T!"    ;not "Don't!"
    (string-capitalize "pipe 13a, foo16c") =>  "Pipe 13a, Foo16c"

    (setq str (copy-seq "0123ABCD890a")) =>  "0123ABCD890a"
    (nstring-downcase str :start 5 :end 7) =>  "0123AbcD890a"
    str =>  "0123AbcD890a"
    ```

* 副作用(Side Effects):

        nstring-upcase, nstring-downcase, 和 nstring-capitalize 适当地修改字符串 string 而不是构建一个新的字符串[string].

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        char-upcase, char-downcase

* 注意(Notes):

        结果总是和字符串 string 有着相同长度. 


### <span id="F-STRING-TRIM">函数 STRING-TRIM, STRING-LEFT-TRIM, STRING-RIGHT-TRIM</span>

* 语法(Syntax):

        string-trim character-bag string => trimmed-string

        string-left-trim character-bag string => trimmed-string

        string-right-trim character-bag string => trimmed-string

* 参数和值(Arguments and Values):

        character-bag---一个包含字符[character]的序列[sequence].
        string---一个字符串标识符[string designator].
        trimmed-string---一个字符串[string].

* 描述(Description):

        string-trim 返回字符串 string 的一个子字符串, 带有在 character-bag 中的所有字符, 除去开始和结尾. string-left-trim 也相似, 除了只脱去开头的字符; string-right-trim 只脱去结尾的字符.

        如果没有字符[character]需要从字符串 string 中被削减, 那么返回字符串 string 自身或者它的一个拷贝, 由这个实现来判定.

        所有这些函数[function]都会注意到这个填充指针[fill pointer].

* 示例(Examples):

    ```LISP
    (string-trim "abc" "abcaakaaakabcaaa") =>  "kaaak"
    (string-trim '(#\Space #\Tab #\Newline) " garbanzo beans
            ") =>  "garbanzo beans"
    (string-trim " (*)" " ( *three (silly) words* ) ")
    =>  "three (silly) words"

    (string-left-trim "abc" "labcabcabc") =>  "labcabcabc"
    (string-left-trim " (*)" " ( *three (silly) words* ) ")
    =>  "three (silly) words* ) "

    (string-right-trim " (*)" " ( *three (silly) words* ) ") 
    =>  " ( *three (silly) words"
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        这个具体实现[implementation].

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes): None. 


### <span id="F-STRING-COMPARE">函数 STRING=, STRING/=, STRING<, STRING>, STRING<=, STRING>=, STRING-EQUAL, STRING-NOT-EQUAL, STRING-LESSP, STRING-GREATERP, STRING-NOT-GREATERP, STRING-NOT-LESSP</span>

* 语法(Syntax):

        string= string1 string2 &key start1 end1 start2 end2 => generalized-boolean

        string/= string1 string2 &key start1 end1 start2 end2 => mismatch-index

        string< string1 string2 &key start1 end1 start2 end2 => mismatch-index

        string> string1 string2 &key start1 end1 start2 end2 => mismatch-index

        string<= string1 string2 &key start1 end1 start2 end2 => mismatch-index

        string>= string1 string2 &key start1 end1 start2 end2 => mismatch-index

        string-equal string1 string2 &key start1 end1 start2 end2 => generalized-boolean

        string-not-equal string1 string2 &key start1 end1 start2 end2 => mismatch-index

        string-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index

        string-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index

        string-not-greaterp string1 string2 &key start1 end1 start2 end2 => mismatch-index

        string-not-lessp string1 string2 &key start1 end1 start2 end2 => mismatch-index

* 参数和值(Arguments and Values):

        string1---一个字符串标识符[string designator].
        string2---一个字符串标识符[string designator].
        start1, end1---字符串 string1 的边界索引标识符[bounding index designator]. 对于 start 和 end 默认分别为 0 和 nil.
        start2, end2---字符串 string2 的边界索引标识符[bounding index designator]. 对于 start 和 end 默认分别为 0 和 nil.
        generalized-boolean---一个广义 boolean [generalized boolean].
        mismatch-index---字符串 string1 的一个边界索引[bounding index], 或者 nil.

* 描述(Description):

        这些函数 functions 在字符串 string1 和 string2 上执行字典式的比较. string= 和 string-equal 被称为等价性函数; 其他的称为不等性函数. 这些函数[function]执行的比较操作被限定为在字符串 string1 由 start1 和 end1 限制的子序列以及字符串 string2 由 start2 和 end2 限制的子序列.

        如果一个字符串 a 和一个字符串 b 有着相同数量的字符, 并且对应字符在 char= 或 char-equal 下是相同的[same], 那么就说这两个字符串是相等的.

        如果在一个字符串 a 和一个字符串 b 有区别的第一个位置中, 根据 char< 或 char-lessp, a 的字符小于 b 中的对应字符, 或者如果字符串 a 是字符串 b 的一个前缀(更短的长度并且匹配 a 中的所有字符), 那么字符串 a 小于字符串 b.

        如果这些字符串是相等的, 那么这些相等函数就返回一个 true 的广义 boolean, 否则就是 false.

        如果这些字符串不相等, 那么这些不相等的函数返回一个为 true 的不匹配索引 mismatch-index, 否则就是 false. 当这个不匹配索引 mismatch-index 是 true, 它是一个表示在两个子字符串中第一个不同的字符位置的整数[integer], 按照从 string1 的起始点开始的偏移位.

        这个比较有着以下这些结果的其中之一:

        string=

            如果提供的子字符串是相同长度并且在对应位置的字符是相同的[same], 那么 string= 返回 true; 否则它就是 false.

        string/=

            如果提供的子字符串是不同的, 那么 string/= 就是 true; 否则它就是 false.

        string-equal

            string-equal 类似于 string= 除了在大小写上的区别会被忽略; 如果 char-equal 对于两个字符是 true, 那么它们就被认为是相同的.

        string<

            如果 substring1 小于 substring2, 那么 string< 就是 true; 否则它就是 false.

        string>

            如果 substring1 大于 substring2, 那么 string> 就是 true; 否则它就是 false.

        string-lessp, string-greaterp

            string-lessp 和 string-greaterp 分别类似于 string< 和 string>, 除了忽略大小写字母之间的区别. 就好像是使用 char-lessp 而不是 char< 来比较字符.

        string<=

            如果 substring1 小于等于 substring2, 那么 string<= 就是 true; 否则它就是 false.

        string>=

            如果 substring1 大于等于 substring2, 那么 string>= 就是 true; 否则它就是 false.

        string-not-greaterp, string-not-lessp

            string-not-greaterp 和 string-not-lessp 分别类似于 string<= 和 string>=, 除了忽略字母大小写之间的区别. 就好像是使用 char-lessp 而不是 char< 来比较字符.

* 示例(Examples):

    ```LISP
    (string= "foo" "foo") =>  true
    (string= "foo" "Foo") =>  false
    (string= "foo" "bar") =>  false
    (string= "together" "frog" :start1 1 :end1 3 :start2 2) =>  true
    (string-equal "foo" "Foo") =>  true
    (string= "abcd" "01234abcd9012" :start2 5 :end2 9) =>  true
    (string< "aaaa" "aaab") =>  3
    (string>= "aaaaa" "aaaa") =>  4
    (string-not-greaterp "Abcde" "abcdE") =>  5
    (string-lessp "012AAAA789" "01aaab6" :start1 3 :end1 7
                                          :start2 2 :end2 6) =>  6
    (string-not-equal "AAAA" "aaaA") =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        char=

* 注意(Notes):

        如果 equal 应用于两个字符串[string], 那么 equal 调用 string=. 


### <span id="F-STRINGP">函数 STRINGP</span>

* 语法(Syntax):

        stringp object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 string 类型[type]就返回 true; 发在, 返回 false.

* 示例(Examples):

    ```LISP
    (stringp "aaaaaa") =>  true
    (stringp #\a) =>  false
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        typep, string (类型[type])

* 注意(Notes):

        (stringp object) ==  (typep object 'string)


### <span id="F-MAKE-STRING">函数 MAKE-STRING</span>

* 语法(Syntax):

        make-string size &key initial-element element-type => string

* 参数和值(Arguments and Values):

        size---一个有效数组维数[valid array dimension].
        initial-element---一个字符[character]. 默认是依赖于具体实现的[implementation-dependent].
        element-type---一个类型指定符[type specifier]. 默认是 character.
        string---一个简单字符串[simple string].

* 描述(Description):

        make-string 返回一个长度为 size 并且元素被初始化为 initial-element 的简单字符串[simple string].

        这个元素类型 element-type 命名这个字符串[string]中元素[element]的类型[type]; 一个字符串[string]由可以容纳给定类型[type]元素[element]的最具体[specialized]类型[type]构成.

* 示例(Examples):

    ```LISP
    (make-string 10 :initial-element #\5) =>  "5555555555"
    (length (make-string 10)) =>  10
    ```

* 受此影响(Affected By):

        这个具体实现[implementation].

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes): None. 


# 17. 序列

> * 17.1 [序列的概念](#SequenceConcepts)
> * 17.2 [关于测试函数的规则](#RulesTestFunctions)
> * 17.3 [序列的字典](#TheSequencesDictionary)


## 17.1 <span id="SequenceConcepts">序列的概念</span>

一个序列[sequence]是多个元素[element]的一个有序集合, 实现为一个向量[vector]或一个列表[list].

序列[sequence]可以由函数[function] make-sequence 创建, 其他创建 sequence 的子类型[subtype]的对象[object]的函数[function]也可以 (比如, list, make-list, mapcar, 和 vector).

一个序列函数[sequence function]是一个由这个规范定义的或者由具体实现[implementation]作为一个扩展所添加的一个操作一个或多个序列[sequence]上的函数[function]. 在一个序列函数[sequence function]必须构造并返回一个新的向量[vector]时, 它总是返回一个简单向量[simple vector]. 类似地, 任何构造的字符串[string]都会是简单字符串[simple string].

    concatenate        length              remove             
    copy-seq           map                 remove-duplicates  
    count              map-into            remove-if          
    count-if           merge               remove-if-not      
    count-if-not       mismatch            replace            
    delete             notany              reverse            
    delete-duplicates  notevery            search             
    delete-if          nreverse            some               
    delete-if-not      nsubstitute         sort               
    elt                nsubstitute-if      stable-sort        
    every              nsubstitute-if-not  subseq             
    fill               position            substitute         
    find               position-if         substitute-if      
    find-if            position-if-not     substitute-if-not  
    find-if-not        reduce                                 

    Figure 17-1. 标准序列函数

### 17.1.1 在必须为序列的参数上的普遍约束

通常, 被当作序列[sequence]的列表[list] (包括关联列表[association list]和属性列表[property list]) 必须是正规列表[proper list]. 


## 17.2 <span id="RulesTestFunctions">关于测试函数的规则</span>

> * 17.2.1 [满足一个两个参数的测试](#SatisfyingTwoArgumentTest)
> * 17.2.2 [满足一个单参数的测试](#SatisfyingOneArgumentTest)

### 17.2.1 <span id="SatisfyingTwoArgumentTest">满足一个两个参数的测试</span>

当通过下面这段列出的操作符[operator] F 在一个序列[sequence] S 的每一个元素[element] Ei 上迭代地考虑对象[object] O 时, 有时去控制操作符 F 测试 O 在 S 中的存在性的方式是有用的. 基于 :test 或 :test-not 实参[argument]所标识的一个函数[function]来提供这个控制.

    adjoin           nset-exclusive-or  search            
    assoc            nsublis            set-difference    
    count            nsubst             set-exclusive-or  
    delete           nsubstitute        sublis            
    find             nunion             subsetp           
    intersection     position           subst             
    member           pushnew            substitute        
    mismatch         rassoc             tree-equal        
    nintersection    remove             union             
    nset-difference  remove-duplicates                    

    Figure 17-2. 有两个参数的测试需要满足的操作符

这个对象 O 可能不会直接和 Ei 比较. 如果提供了一个 :key 实参[argument], 它就是要被调用的单参数[argument]的函数[function]的标识符[designator], 而每一个 Ei 作为一个实参[argument], 并且产生一个对象[object] Zi 被用作这个比较. (如果这里没有 :key 实参[argument], Zi 就是 Ei.)

这个由 :key 参数[argument]标识的函数[function]从不在 O 自身上调用. 然而, 如果这个函数在多个序列上操作 (比如, 就像发生在 set-difference), O 会是在其他序列的元素[element]上调用这个函数的结果.

如果提供给 F 的一个 :test 参数[argument], 那么它就是一个两参数[argument]函数[function]的标识符[designator], 参数为 O 和 Zi. 如果这个 :test 函数[function]返回表示 true 的广义 boolean [generalized boolean], 那么就说一个 Ei (或者, 有时候, 就说一个 O 和一个 Ei) 满足这个测试条件[satisfy the test].

如果提供 F 一个 :test-not 参数[argument], 那么它就是一个两参数[argument]函数[function]的标识符[designator], 参数是 O 和 Zi. 如果这个 :test-not 函数[function]返回一个表示 false 的广义 boolean [generalized boolean], 那么就说 Ei (或者, 有时候, 就说一个 O 和一个 Ei) 满足这个测试条件[satisfy the test].

如果 :test 和 :test-not 参数[argument]都没有提供, 那么处理方式就跟提供了一个 #'eql 的 :test 参数一样.

如果在对 F 的同一个调用[call]中 :test 和 :test-not 参数[argument]都提供了, 那么后果是未指定的.

#### 17.2.1.1 满足一个两个参数的测试的示例

```LISP
 (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'equal)
=>  (foo bar "BAR" "foo" "bar")
 (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'equalp)
=>  (foo bar "BAR" "bar")
 (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'string-equal)
=>  (bar "BAR" "bar")
 (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'string=)
=>  (BAR "BAR" "foo" "bar")

 (remove 1 '(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test-not #'eql)
=>  (1)
 (remove 1 '(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test-not #'=)
=>  (1 1.0 #C(1.0 0.0))
 (remove 1 '(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test (complement #'=))
=>  (1 1.0 #C(1.0 0.0))

 (count 1 '((one 1) (uno 1) (two 2) (dos 2)) :key #'cadr) =>  2

 (count 2.0 '(1 2 3) :test #'eql :key #'float) =>  1

 (count "FOO" (list (make-pathname :name "FOO" :type "X")  
                    (make-pathname :name "FOO" :type "Y"))
        :key #'pathname-name
        :test #'equal)
=>  2
```

### 17.2.2 <span id="SatisfyingOneArgumentTest">满足一个单参数的测试</span>

当使用下面这段中的函数[function]的其中一个时, 序列[sequence] S 的元素 E 不是基于章节 17.2.1 (满足一个两个参数的测试) 中描述的两参数[argument]断言[predicate]下对象 O 的存在或缺失来过滤, 而是基于单参数[argument]断言[predicate]来过滤.

    assoc-if       member-if           rassoc-if          
    assoc-if-not   member-if-not       rassoc-if-not      
    count-if       nsubst-if           remove-if          
    count-if-not   nsubst-if-not       remove-if-not      
    delete-if      nsubstitute-if      subst-if           
    delete-if-not  nsubstitute-if-not  subst-if-not       
    find-if        position-if         substitute-if      
    find-if-not    position-if-not     substitute-if-not  

    Figure 17-3. 有单参数的测试需要满足的操作符

元素 Ei 可能不会被直接考虑. 如果提供了一个 :key 参数[argument], 那么它就是一个单参数[argument]函数[function]的标识符[designator], 用每一个 Ei 作为一个实参[argument]来调用, 并且产生一个要被用来比较的对象[argument] Zi. (如果没有 :key 参数[argument], Zi 就是 Ei.)

在这个规范中定义的并且有着一个以 "-if" 结尾的名字的函数[function]接受一个单参数[argument] Zi 的函数[function]的标识符[designator]作为第一个参数[argument]. 如果这个 :test 函数[function]返回一个表示  true 的广义 boolean [generalized boolean], 那么就说一个 Ei 满足这个测试条件[satisfy the test].

在这个规范中定义的并且有着一个以 "-if-not" 结尾的名字的函数[function]接受一个单参数[argument] Zi 的函数[function]的标识符[designator]作为第一个参数[argument]. 如果这个 :test 函数[function]返回一个表示 false 的广义 boolean [generalized boolean], 那么就说一个 Ei 满足这个测试条件[satisfy the test].


#### 17.2.2.1 满足一个单参数的测试的示例

```LISP
 (count-if #'zerop '(1 #C(0.0 0.0) 0 0.0d0 0.0s0 3)) =>  4

 (remove-if-not #'symbolp '(0 1 2 3 4 5 6 7 8 9 A B C D E F))
=>  (A B C D E F)
 (remove-if (complement #'symbolp) '(0 1 2 3 4 5 6 7 8 9 A B C D E F))
=>  (A B C D E F)

 (count-if #'zerop '("foo" "" "bar" "" "" "baz" "quux") :key #'length)
=>  3
```

## 17.3 <span id="TheSequencesDictionary">序列的字典</span>

> * [系统类 SEQUENCE](#SC-SEQUENCE)
> * [函数 COPY-SEQ](#F-COPY-SEQ)
> * [访问器 ELT](#A-ELT)
> * [函数 FILL](#F-FILL)
> * [函数 MAKE-SEQUENCE](#F-MAKE-SEQUENCE)
> * [访问器 SUBSEQ](#A-SUBSEQ)
> * [函数 MAP](#F-MAP)
> * [函数 MAP-INTO](#F-MAP-INTO)
> * [函数 REDUCE](#F-REDUCE)
> * [函数 COUNT, COUNT-IF, COUNT-IF-NOT](#F-COUNT-ALL)
> * [函数 LENGTH](#F-LENGTH)
> * [函数 REVERSE, NREVERSE](#F-REVERSE-ALL)
> * [函数 SORT, STABLE-SORT](#F-SORT-ALL)
> * [函数 FIND, FIND-IF, FIND-IF-NOT](#F-FIND-ALL)
> * [函数 POSITION, POSITION-IF, POSITION-IF-NOT](#F-POSITION-ALL)
> * [函数 SEARCH](#F-SEARCH)
> * [函数 MISMATCH](#F-MISMATCH)
> * [函数 REPLACE](#F-REPLACE)
> * [函数 SUBSTITUTE, SUBSTITUTE-IF, SUBSTITUTE-IF-NOT, NSUBSTITUTE, NSUBSTITUTE-IF, NSUBSTITUTE-IF-NOT](#F-SUBSTITUTE-ALL)
> * [函数 CONCATENATE](#F-CONCATENATE)
> * [函数 MERGE](#F-MERGE)
> * [函数 REMOVE, REMOVE-IF, REMOVE-IF-NOT, DELETE, DELETE-IF, DELETE-IF-NOT](#F-REMOVE-ALL)
> * [函数 REMOVE-DUPLICATES, DELETE-DUPLICATES](#F-DUPLICATES-ALL)


### <span id="SC-SEQUENCE">系统类 SEQUENCE</span>

* 类优先级列表(Class Precedence List):

        sequence, t

* 描述(Description):

        序列[sequence]是对象[object]的有序集合, 这些对象称为序列[sequence]的元素[element].

        类型[type] vector 和类型[type] list 是类型[type] sequence 的互斥的[disjoint]子类型[subtype], 但没有必要是序列[sequence]的一个详尽分区[exhaustive partition].

        当把一个向量[vector]视作一个序列[sequence]时, 只有这个向量[vector]的有效[active]元素[element]被当作这个序列[sequence]的元素[element]; 这也就是说, 当给定的序列[sequence]被表示为向量[vector]时, 序列[sequence]操作遵守填充指针[fill pointer]. 


### <span id="F-COPY-SEQ">函数 COPY-SEQ</span>

* 语法(Syntax):

        copy-seq sequence => copied-sequence

* 参数和值(Arguments and Values):

        sequence---一个正规序列[proper sequence].
        copied-sequence---一个正规序列[proper sequence].

* 描述(Description):

        创建一个序列 sequence 的拷贝. 这个新的序列[sequence]中的元素[element]和给定序列 sequence 中的对应元素[element]是相同的[same].

        如果序列 sequence 是一个向量[vector], 那么结果就是秩[rank]为一的新的[fresh]简单数组[simple array], 并且有着和序列 sequence 相同的实际数组元素类型[actual array element type]. 如果序列 sequence 是一个列表[list], 那么结果就是一个新的[fresh]列表[list].

* 示例(Examples):

    ```LISP
    (setq str "a string") =>  "a string"
    (equalp str (copy-seq str)) =>  true
    (eql str (copy-seq str)) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果序列 sequence 不是一个正规序列[proper sequence], 那么应该准备发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        copy-list

* 注意(Notes):

        从功能的角度来看,

        (copy-seq x) ==  (subseq x 0)

        然而, 在这两种情况下, 程序员的意图通常是不同的. 


### <span id="A-ELT">访问器 ELT</span>

* 语法(Syntax):

        elt sequence index => object

        (setf (elt sequence index) new-object)

* 参数和值(Arguments and Values):

        sequence---一个正规序列[proper sequence].
        index---对于序列 sequence 的一个有效序列索引[valid sequence index].
        object---一个对象[object].
        new-object---一个对象[object].

* 描述(Description):

        访问[access]由索引 index 指定的序列 sequence 中的元素[element].

* 示例(Examples):

    ```LISP
    (setq str (copy-seq "0123456789")) =>  "0123456789"
    (elt str 6) =>  #\6
    (setf (elt str 0) #\#) =>  #\#
    str =>  "#123456789"
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 sequence 不是一个正规序列[proper sequence], 那么应该准备发出一个 type-error 类型[type]的错误. 如果 index 对于序列 sequence 的不是一个有效序列索引[valid sequence index], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        aref, nth, 章节 3.2.1 (编译器术语)

* 注意(Notes):

        aref 可能被用于访问[access]超出这个向量[vector]填充指针[fill pointer]的向量[vector]元素[element]. 


### <span id="F-FILL">函数 FILL</span>

* 语法(Syntax):

        fill sequence item &key start end => sequence

* 参数和值(Arguments and Values):

        sequence---一个正规序列[proper sequence].
        item---一个序列[sequence].
        start, end---序列 sequence 的边界索引标识符[bounding index designator]. 对于 start 和 end 默认分别是 0 和 nil.

* 描述(Description):

        用 item 替换由 start 和 end 限定[bounded]的序列 sequence 中的元素[element].

* 示例(Examples):

    ```LISP
    (fill (list 0 1 2 3 4 5) '(444)) =>  ((444) (444) (444) (444) (444) (444))
    (fill (copy-seq "01234") #\e :start 3) =>  "012ee"
    (setq x (vector 'a 'b 'c 'd 'e)) =>  #(A B C D E)
    (fill x 'z :start 1 :end 3) =>  #(A Z Z D E)
    x =>  #(A Z Z D E)
    (fill x 'p) =>  #(P P P P P)
    x =>  #(P P P P P)
    ```

* 副作用(Side Effects):

        序列 sequence 被破坏性地修改.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果序列 sequence 不是一个正规序列[proper sequence], 那么应该准备去发出一个 type-error 类型[type]的错误. 如果 start 不是一个非负整数[integer], 那么应该发出一个 type-error 类型[type]的错误. 如果 end 不是一个非负整数[integer]或者 nil, 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        replace, nsubstitute

* 注意(Notes):

        (fill sequence item) == (nsubstitute-if item (constantly t) sequence) 


### <span id="F-MAKE-SEQUENCE">函数 MAKE-SEQUENCE</span>

* 语法(Syntax):

        make-sequence result-type size &key initial-element => sequence

* 参数和值(Arguments and Values):

        result-type---一个 sequence 类型指定符[type specifier].
        size---一个非负整数[integer].
        initial-element---一个对象[object]. 默认值是依赖于具体实现的[implementation-dependent].
        sequence---一个正规序列[proper sequence].

* 描述(Description):

        返回一个 result-type 类型并且长度为 size 的序列[sequence], 其中的每一个元素[element]都被初始化为 initial-element.

        如果 result-type 是 list 的一个子类型[subtype], 那么结果会是一个列表[list].

        如果 result-type 是 vector 的一个子类型[subtype], 那么如果实现可以确定 result-type 指定的元素类型, 那么产生的数组的元素类型就是那个元素类型的提升[upgrade]的结果; 或者, 如果实现可以确定那个元素类型是未指定的 (或 *), 产生的元素类型就是 t; 否则, 发出一个错误.

* 示例(Examples):

    ```LISP
    (make-sequence 'list 0) =>  ()
    (make-sequence 'string 26 :initial-element #\.) 
    =>  ".........................."
    (make-sequence '(vector double-float) 2
                    :initial-element 1d0)
    =>  #(1.0d0 1.0d0)

    (make-sequence '(vector * 2) 3) should signal an error
    (make-sequence '(vector * 4) 3) should signal an error
    ```

* 受此影响(Affected By):

        这个具体实现[implementation].

* 异常情况(Exceptional Situations):

        如果 initial-element 不是一个可以被存储在产生的序列[sequence]中的对象[object], 那么后果是未指定的.

        如果 result-type 既不是一个 list 的可识别子类型[recognizable subtype], 也不是一个 vector 的可识别子类型[recognizable subtype], 那么就会发出一个 type-error 类型[type]的错误.

        如果 result-type 指定的元素的数量并且 size 和那个数量不同, 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        make-array, make-list

* 注意(Notes):

        (make-sequence 'string 5) ==  (make-string 5)               


### <span id="A-SUBSEQ">访问器 SUBSEQ</span>

* 语法(Syntax):

        subseq sequence start &optional end => subsequence

        (setf (subseq sequence start &optional end) new-subsequence)

* 参数和值(Arguments and Values):

        sequence---一个正规序列[proper sequence].
        start, end---序列 sequence 边界索引标识符[bounding index designator]. 对于 end 默认是 nil.
        subsequence---一个正规序列[proper sequence].
        new-subsequence---一个正规序列[proper sequence].

* 描述(Description):

        subseq 创建一个序列[sequence], 它是由 start 和 end 限定的 sequence 的子序列的一个拷贝.

        start 指定了原始序列 sequence 中的一个偏移位并且标记这个子序列的起始位置. end 标记这个子序列的最后一个元素的后面的位置.

        subseq 总是为一个结果分配一个新的序列[sequence]; 它从不与旧的序列[sequence]共享存储. 这个产生的子序列总是和 sequence 相同类型[type].

        如果序列 sequence 是一个向量[vector], 那么结果是一个新的[fresh]秩[rank]为一的有着和 sequence 相同实际数组元素类型[actual array element type]的简单数组[simple array]. 如果序列 sequence 是一个列表[list], 那么结果是一个新的[fresh]列表[list].

        setf 可以和 subseq 一起使用来破坏性地用一个新值的序列[sequence]中的元素[element]替换一个子序列的元素[element]. 如果这个子序列和那个新的序列不是相同长度, 更短长度的那个确定了要被替换的元素的数量. 在较长序列中末尾的剩余元素[element]在这个操作中不会被修改.

* 示例(Examples):

    ```LISP
    (setq str "012345") =>  "012345"
    (subseq str 2) =>  "2345"
    (subseq str 3 5) =>  "34"
    (setf (subseq str 4) "abc") =>  "abc"
    str =>  "0123ab"
    (setf (subseq str 0 2) "A") =>  "A"
    str =>  "A123ab"
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果序列 sequence 不是一个正规序列[proper sequence], 那么应该准备去发出一个 type-error 类型[type]的错误. 如果序列 new-subsequence 不是一个正规序列[proper sequence], 那么应该准备去发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        replace

* 注意(Notes): None. 


### <span id="F-MAP">函数 MAP</span>

* 语法(Syntax):

        map result-type function &rest sequences+ => result

* 参数和值(Arguments and Values):

        result-type -- 一个 sequence 类型指定符[type specifier], 或者 nil.
        function---一个函数标识符[function designator]. 函数 function 必须接受和 sequences 数量相同的参数.
        sequence---一个正规序列[proper sequence].
        result---如果 result-type 是一个类型指定符[type specifier]而不是 nil, 那么就是那个类型[type]表示的一个序列[sequence]; 否则 (如果 result-type 是 nil), 就是 nil.

* 描述(Description):

        应用函数 function 到参数的连续集合上, 这里的每一个参数从每个序列[sequence]中获取. 这个函数 function 首先在所有索引为 0 的元素上调用, 然后在所有索引为 1 的元素上, 以此类推. 这个 result-type 指定了产生的序列[sequence]的类型[type].

        如果 result-type 是 nil, 那么 map 返回 nil. 否则, map 返回一个序列[sequence], 其中第 j 个元素是应用函数 function 到每个序列 sequence 的第 j 个元素的结果. 结果序列[sequence]和这些序列 sequences 中最短的一个一样长. 如果应用函数 function 到那些序列 sequences 的连续元素的结果不能包含在一个给定的 result-type 类型[type]的序列[sequence]中, 那么后果是未指定的.

        如果这个 result-type 是 list 的一个子类型[subtype], 这个结果就是一个列表[list].

        如果 result-type 是 vector 的一个子类型[subtype], 那么如果实现可以确定 result-type 指定的元素类型, 那么产生的数组的元素类型就是那个元素类型的提升[upgrade]的结果; 或者, 如果实现可以确定那个元素类型是未指定的 (或 *), 产生的元素类型就是 t; 否则, 发出一个错误.

* 示例(Examples):

    ```LISP
    (map 'string #'(lambda (x y)
                      (char "01234567890ABCDEF" (mod (+ x y) 16)))
          '(1 2 3 4)
          '(10 9 8 7)) =>  "AAAA"
    (setq seq '("lower" "UPPER" "" "123")) =>  ("lower" "UPPER" "" "123")
    (map nil #'nstring-upcase seq) =>  NIL
    seq =>  ("LOWER" "UPPER" "" "123")
    (map 'list #'- '(1 2 3 4)) =>  (-1 -2 -3 -4)
    (map 'string
          #'(lambda (x) (if (oddp x) #\1 #\0))
          '(1 2 3 4)) =>  "1010"

    (map '(vector * 4) #'cons "abc" "de") should signal an error
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 result-type 不是 list 的一个可识别的子类型[recognizable subtype], 不是一个 vector 的可识别子类型[recognizable subtype], 并且不是 nil, 那么就会发出一个 type-error 类型[type]的错误.

        如果任何一个 sequence 不是一个正规序列[proper sequence], 那么应该准备发出一个 type-error 类型[sequence]的错误.

        如果 result-type 指定了元素的数量而这些序列 sequences 的最小长度和这个数量不同, 那么就会发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        章节 3.6 (遍历规则和副作用)

* 注意(Notes): None. 


### <span id="F-MAP-INTO">函数 MAP-INTO</span>

* 语法(Syntax):

        map-into result-sequence function &rest sequences => result-sequence

* 参数和值(Arguments and Values):

        result-sequence---一个正规序列[proper sequence].
        function---一个和序列 sequences 的数量相同参数[argument]的函数[function]标识符[designator].
        sequence---一个正规序列[proper sequence].

* 描述(Description):

        破坏性地修改 result-sequence 来包含依次应用函数 function 到参数序列 sequences 所产生的结果.

        result-sequence 和序列 sequences 的每个元素可以是一个列表[list]或者一个向量[vector]. 如果 result-sequence 和 sequences 的每一个元素长度都不相同, 当最短的序列[sequence] (这些 sequences 中的任何一个或者 result-sequence)耗尽时迭代终止. 如果 result-sequence 是一个带有填充指针[fill pointer]的向量[vector], 在决定要执行多少循环时, 这个填充指针[fill pointer]会被忽略, 然后这个填充指针[fill pointer]会被设置为函数 function 被应用的次数数量. 如果 result-sequence 比这些序列 sequences 中最短的一个长, 在 result-sequence 末尾的额外元素保持不变. 如果 result-sequence 是 nil, map-into 立即返回 nil, 因为 nil 是长度为 0 的序列[sequence].

        如果函数 function 有着副作用, 它首先在所有索引为 0 的元素上调用, 然后在所有索引为 1 上, 以此类推.

* 示例(Examples):

    ```LISP
    (setq a (list 1 2 3 4) b (list 10 10 10 10)) =>  (10 10 10 10)
    (map-into a #'+ a b) =>  (11 12 13 14)
    a =>  (11 12 13 14)
    b =>  (10 10 10 10)
    (setq k '(one two three)) =>  (ONE TWO THREE)
    (map-into a #'cons k a) =>  ((ONE . 11) (TWO . 12) (THREE . 13) 14)
    (map-into a #'gensym) =>  (#:G9090 #:G9091 #:G9092 #:G9093)
    a =>  (#:G9090 #:G9091 #:G9092 #:G9093)
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 result-sequence 不是一个正规序列[proper sequence], 那么应该发出一个 type-error 类型[type]的错误. 如果序列 sequence 不是一个正规序列[proper sequence], 那么应该准备去发出一个 type-error 类型[type]的错误.

* 参见(See Also): None.

* 注意(Notes):

        map-into 和 map 的区别在于它修改一个已存在的序列[sequence]而不是创建一个新的. 另外, map-into 只能用两个参数来调用, 而 map 需要至少三个参数.

        map-into 可以被定义为:

        (defun map-into (result-sequence function &rest sequences)
          (loop for index below (apply #'min 
                                        (length result-sequence)
                                        (mapcar #'length sequences))
                do (setf (elt result-sequence index)
                          (apply function
                                (mapcar #'(lambda (seq) (elt seq index))
                                        sequences))))
          result-sequence)


### <span id="F-REDUCE">函数 REDUCE</span>

* 语法(Syntax):

        reduce function sequence &key key from-end start end initial-value => result

* 参数和值(Arguments and Values):

        function---一个可以用零个或两个参数[argument]来调用的函数[function]的标识符[designator].
        sequence---一个正规序列[proper sequence].
        key---一个单参数函数[function]的标识符[designator], 或者 nil.
        from-end---一个广义 boolean [generalized boolean]. 默认是 false.
        start, end---序列 sequence 的边界索引标识符[bounding index designator]. 对于 start 和 end 默认分别为 0 或 nil.
        initial-value---一个对象[object].
        result---一个对象[object].

* 描述(Description):

        reduce 使用一个二元操作符, function, 来组合由 start 和 end 限定[bounded]的 sequence 的元素[element].

        这个函数 function 必须接受序列 sequence 的两个元素[element]作为参数[argument], 或者将这些元素[element]组合起来的结果. 这个函数 function 必须也可以接受没有参数的情况.

        如果提供了 key, 它被用于去提取值给 reduce. 这个 key 函数以那个归约的顺序暗示的顺序对序列 sequence 的每个元素应用一次, 除了 initial-value 的值以外, 如果提供的话. 这个 key 函数通常返回序列 sequence 的元素[element]的一部分. 如果 key 没有被提供或者是 nil, 那么就使用这个序列的元素[element]自身.

        这个归约时左结合的(left-associative), 除非 from-end 是 true 时, 在这个情况下是右结合的(right-associative).

        如果提供了 initial-value, 它会在这个子序列之前 (如果 from-end 是 true 就是在它之后) 被逻辑上替换并且包含在这个归约操作中.

        在正常的情况中, 这个 reduce 的结果是应用函数 function 到序列 sequence 的连续元素[element]对的组合结果. 如果这个子序列只包含了一个元素[element]并且没有给定 initial-value, 那么返回那个元素[element]并且函数 function 不会被调用. 如果这个子序列是空的并且给定了一个 initial-value, 那么返回这个 initial-value 并且函数 function 不会被调用. 如果这个子序列是空并且没有给定 initial-value, 那么这个函数 function 会用零个参数来调用, 然后 reduce 返回函数 function 的结果. 这是仅有的用两个以外的参数来调用函数 function 的情况.

* 示例(Examples):

    ```LISP
    (reduce #'* '(1 2 3 4 5)) =>  120
    (reduce #'append '((1) (2)) :initial-value '(i n i t)) =>  (I N I T 1 2)
    (reduce #'append '((1) (2)) :from-end t                  
                                :initial-value '(i n i t)) =>  (1 2 I N I T) 
    (reduce #'- '(1 2 3 4)) ==  (- (- (- 1 2) 3) 4) =>  -8
    (reduce #'- '(1 2 3 4) :from-end t)    ;Alternating sum.
    ==  (- 1 (- 2 (- 3 4))) =>  -2
    (reduce #'+ '()) =>  0
    (reduce #'+ '(3)) =>  3
    (reduce #'+ '(foo)) =>  FOO
    (reduce #'list '(1 2 3 4)) =>  (((1 2) 3) 4)
    (reduce #'list '(1 2 3 4) :from-end t) =>  (1 (2 (3 4)))
    (reduce #'list '(1 2 3 4) :initial-value 'foo) =>  ((((foo 1) 2) 3) 4)
    (reduce #'list '(1 2 3 4)
            :from-end t :initial-value 'foo) =>  (1 (2 (3 (4 foo))))
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果序列 sequence 不是一个正规序列[proper sequence], 那么应该准备去发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        章节 3.6 (遍历规则和副作用)

* 注意(Notes): None. 


### <span id="F-COUNT-ALL">函数 COUNT, COUNT-IF, COUNT-IF-NOT</span>

* 语法(Syntax):

        count item sequence &key from-end start end key test test-not => n

        count-if predicate sequence &key from-end start end key => n

        count-if-not predicate sequence &key from-end start end key => n

* 参数和值(Arguments and Values):

        item---一个对象[object].
        sequence---一个正规序列[proper sequence].
        predicate---一个返回一个广义 boolean [generalized boolean]的单参数[argument]函数[function]的标识符[designator].
        from-end---一个广义 boolean [generalized boolean]. 默认是 false.
        test---一个返回一个广义 boolean [generalized boolean]的两参数[argument]函数[function]的标识符[designator].
        test-not---一个返回一个广义 boolean [generalized boolean]的两参数[argument]函数[function]的标识符[designator].
        start, end---序列 sequence 的边界索引标识符[bounding index designator]. 对于 start 和 end 默认分别为 0 和 nil.
        key---一个单参数函数[function]的标识符[designator], 或 nil.
        n---一个小于等于序列 sequence 的长度[length]的非负整数[integer].

* 描述(Description):

        count, count-if, 和 count-if-not 计算并返回在序列 sequence 中由 start 和 end 限定[bounded]并满足测试条件[satisfy the test]的元素[element]的数量.

        这个 from-end 对结果没有直接影响. 然而, 如果 from-end 是 true, 这个序列 sequence 的元素[element]会以逆序提供给 test, test-not, 和 key 作为参数[argument], 它可能改变这些函数的副作用, 如果有的话.

* 示例(Examples):

    ```LISP
    (count #\a "how many A's are there in here?") =>  2
    (count-if-not #'oddp '((1) (2) (3) (4)) :key #'car) =>  2
    (count-if #'upper-case-p "The Crying of Lot 49" :start 4) =>  2 
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果序列 sequence 不是一个正规序列[proper sequence], 那么应该准备去发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        章节 17.2 (关于测试函数的规则), 章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        这个 :test-not 参数[argument]已经被废弃.

        函数[function] count-if-not 已经被废弃. 


### <span id="F-LENGTH">函数 LENGTH</span>

* 语法(Syntax):

        length sequence => n

* 参数和值(Arguments and Values):

        sequence---一个正规序列[proper sequence].
        n---一个非负整数[integer].

* 描述(Description):

        返回在序列 sequence 中的元素[element]数量.

        如果序列 sequence 是一个带有填充指针[fill pointer]的向量[vector], 返回由填充指针[fill pointer]指定的有效长度.

* 示例(Examples):

    ```LISP
    (length "abc") =>  3
    (setq str (make-array '(3) :element-type 'character 
                                :initial-contents "abc"
                                :fill-pointer t)) =>  "abc"
    (length str) =>  3
    (setf (fill-pointer str) 2) =>  2
    (length str) =>  2
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果序列 sequence 不是一个正规序列[proper sequence], 那么应该准备去发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        list-length, sequence

* 注意(Notes): None. 


### <span id="F-REVERSE-ALL">函数 REVERSE, NREVERSE</span>

* 语法(Syntax):

        reverse sequence => reversed-sequence

        nreverse sequence => reversed-sequence

* 参数和值(Arguments and Values):

        sequence---一个正规序列[proper sequence].
        reversed-sequence---一个序列[sequence].

* 描述(Description):

        reverse 和 nreverse 返回一个和序列 sequence 相同种类的新的序列[sequence], 包含相同的元素[element], 但是是以逆序的形式.

        reverse 和 nreverse 的区别在于 reverse 总是创建并返回一个新的序列[sequence], 反之 nreverse 可能修改并返回给定的序列 sequence. reverse 从不修改那个给定的序列 sequence.

        对于 reverse, 如果序列 sequence 是一个向量[vector], 那么那个结果是一个有着和 sequence 相同的实际数组元素类型[actual array element type]的新的[fresh]秩为一的简单数组[simple array]. 如果序列 sequence 是一个列表[list], 那么那个结果就是一个新的[fresh]列表[list].

        对于 nreverse, 如果序列 sequence 是一个向量[vector], 那么那个结果也是一个有着和 sequence 相同实际数组元素[actual array element type]的向量[vector]. 如果序列 sequence 是一个列表[list], 结果就是一个列表[list].

        对于 nreverse, 序列 sequence 可能被破坏并且重新使用来产生那个结果. 结果可能和序列 sequence 一样[identical], 也可能不一样. 具体来说, 当序列 sequence 是一个列表[list]时, nreverse 允许去 setf 序列 sequence 的列表结构[list structure]部分的 cons 的任何部分, car 或 cdr. 当序列 sequence 是一个向量[vecotr]时, nreverse 允许去重排序列 sequence 的元素来产生结果向量[vector].

* 示例(Examples):

    ```LISP
    (setq str "abc") =>  "abc"
    (reverse str) =>  "cba"
    str =>  "abc"
    (setq str (copy-seq str)) =>  "abc"
    (nreverse str) =>  "cba"
    str =>  implementation-dependent
    (setq l (list 1 2 3)) =>  (1 2 3)
    (nreverse l) =>  (3 2 1)
    l =>  implementation-dependent
    ```

* 副作用(Side Effects):

        nreverse 可能创建一个新序列[sequence], 或修改参数序列 sequence, 或两者都执行. (reverse 不会修改序列 sequence.)

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果序列 sequence 不是一个正规序列[proper sequence], 那么应该准备去发出一个 type-error 类型[type]的错误.

* 参见(See Also): None.

* 注意(Notes): None. 


### <span id="F-SORT-ALL">函数 SORT, STABLE-SORT</span>

* 语法(Syntax):

        sort sequence predicate &key key => sorted-sequence

        stable-sort sequence predicate &key key => sorted-sequence

* 参数和值(Arguments and Values):

        sequence---一个正规序列[proper sequence].
        predicate---一个返回一个广义 boolean [generalized boolean]的两参数函数[function]的标识符[designator].
        key---一个单参数函数[function]的标识符[designator], 或 nil.
        sorted-sequence---一个序列[sequence].

* 描述(Description):

        sort 和 stable-sort 根据断言 predicate 函数确定的顺序破坏性地对序列 sequence 排序.

        如果序列 sequence 是一个向量[vector], 那么结果是一个和 sequence 有着相同实际数组元素类型[actual array element type]的向量[vector]. 如果序列 sequence 是一个列表[list], 那么结果也是有一个列表[list].

        sort 通过将从元素中提取到的键提供给断言 predicate 来确定两个元素之间的关系. 给这个断言 predicate 函数的第一个参数是通过 key 函数(如果提供的话)提取的序列 sequence 的一个元素的一部分; 第二个参数是通过 key 函数(如果提供的话)提取的序列 sequence 的另一个元素的一部分. 如果第一个参数严格小于第二个参数(在某个适当的意义下), 那么断言 predicate 应该返回 true. 如果第一个参数大于或等于第二个参数(在某个适当的意义下), 那么这个断言 predicate 应该返回 false.

        给这个 key 函数的参数是这个序列 sequence 元素. 这个 key 函数的返回值称为给断言 predicate 的一个参数. 如果 key 没有被提供或者是 nil, 那么使用这个序列 sequence 的元素自身. 这里不保证这个 key 函数会被调用的次数.

        如果这个 key 和 predicate 总是返回, 那么这个排序操作总是会终止, 产生一个和序列 sequence 包含相同元素[element]的序列[sequence] (这也就是说, 结果是序列 sequence 的一个变换). 这是有保证的, 即便这个断言 predicate 并不始终表示一个总顺序 (在这个情况中这些元素[element]总是以一种不可预知的方式被搅乱, 但是没有元素[element]会被丢失). 如果这个 key 函数始终返回有意义的键, 并且这个断言 predicate 确实反映了在这些键上的某个总排序准则, 那么在 sorted-sequence 的这些元素[element]会根据那个顺序被正确排序.

        这个由 sort 执行的排序操作不保证稳定. 由断言 predicate 认为是相同的元素可能或可能不会保持它们的原始顺序. 如果 (funcall predicate x y) 和 (funcall predicate y x) 都是 false, 那么这个断言 predicate 认为两个元素 x 和 y 是相等的. stable-sort 保证稳定性.

        这个排序操作在所有情况下都可以是破坏性的. 在一个向量[vector]参数的情况下, 这是通过对元素进行适当的处理来实现的. 在一个列表[list]的情况下, 这个列表[list]会按照和 nreverse 相同的方式被破坏性地重排.

* 示例(Examples):

    ```LISP
    (setq tester (copy-seq "lkjashd")) =>  "lkjashd"
    (sort tester #'char-lessp) =>  "adhjkls"
    (setq tester (list '(1 2 3) '(4 5 6) '(7 8 9))) =>  ((1 2 3) (4 5 6) (7 8 9))
    (sort tester #'> :key #'car)  =>  ((7 8 9) (4 5 6) (1 2 3)) 
    (setq tester (list 1 2 3 4 5 6 7 8 9 0)) =>  (1 2 3 4 5 6 7 8 9 0)
    (stable-sort tester #'(lambda (x y) (and (oddp x) (evenp y))))
    =>  (1 3 5 7 9 2 4 6 8 0)
    (sort (setq committee-data
                (vector (list (list "JonL" "White") "Iteration")
                        (list (list "Dick" "Waters") "Iteration")
                        (list (list "Dick" "Gabriel") "Objects")
                        (list (list "Kent" "Pitman") "Conditions")
                        (list (list "Gregor" "Kiczales") "Objects")
                        (list (list "David" "Moon") "Objects")
                        (list (list "Kathy" "Chapman") "Editorial")
                        (list (list "Larry" "Masinter") "Cleanup")
                        (list (list "Sandra" "Loosemore") "Compiler")))
          #'string-lessp :key #'cadar)
    =>  #((("Kathy" "Chapman") "Editorial")
        (("Dick" "Gabriel") "Objects")
        (("Gregor" "Kiczales") "Objects")
        (("Sandra" "Loosemore") "Compiler")
        (("Larry" "Masinter") "Cleanup")
        (("David" "Moon") "Objects")
        (("Kent" "Pitman") "Conditions")
        (("Dick" "Waters") "Iteration")
        (("JonL" "White") "Iteration"))
    ;; Note that individual alphabetical order within `committees'
    ;; is preserved.
    (setq committee-data 
          (stable-sort committee-data #'string-lessp :key #'cadr))
    =>  #((("Larry" "Masinter") "Cleanup")
        (("Sandra" "Loosemore") "Compiler")
        (("Kent" "Pitman") "Conditions")
        (("Kathy" "Chapman") "Editorial")
        (("Dick" "Waters") "Iteration")
        (("JonL" "White") "Iteration")
        (("Dick" "Gabriel") "Objects")
        (("Gregor" "Kiczales") "Objects")
        (("David" "Moon") "Objects"))
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果序列 sequence 不是一个正规序列[proper sequence], 那么应该准备去发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        merge, 章节 3.2.1 (编译器术语), 章节 3.6 (遍历规则和副作用), 章节 3.7 (破坏性操作)

* 注意(Notes):

        如果序列 sequence 是一个向量[vector], 那么这个结果可能或可能不是一个简单的, 并且可能或可能不会和序列 sequence 相同[identical]. 


### <span id="F-FIND-ALL">函数 FIND, FIND-IF, FIND-IF-NOT</span>

* 语法(Syntax):

        find item sequence &key from-end test test-not start end key => element

        find-if predicate sequence &key from-end start end key => element

        find-if-not predicate sequence &key from-end start end key => element

* 参数和值(Arguments and Values):

        item---一个对象[object].
        sequence---一个正规序列[proper sequence].
        predicate---返回一个广义 boolean [generalized boolean]的单参数[argument]函数[function]的标识符[designator].
        from-end---一个广义 boolean [generalized boolean]. 默认是 false.
        test---返回一个广义 boolean [generalized boolean]的两个参数[argument]的函数[function]的标识符[designator].
        test-not---返回一个广义 boolean [generalized boolean]的两个参数[argument]的函数[function]的标识符[designator].
        start, end---序列 sequence 的边界索引标识符[bounding index designator]. 对于 start 和 end 默认分别为 0 和 nil.
        key---一个单参数函数[function]的标识符[designator], 或者 nil.
        element---序列 sequence 的一个元素[element], 或者 nil.

* 描述(Description):

        find, find-if, 和 find-if-not 每一个都搜索序列 sequence 中由 start 和 end 限定[bounded], 满足断言[satisfy the predicate] predicate 或满足测试条件[satisfy the test] test 或 test-not 的一个元素[element], 视情况而定.

        如果 from-end 是 true, 那么结果是满足测试条件[satisfy the test] test 的最右边的元素.

        如果这个序列 sequence 包含了一个满足这个测试条件[satisfy the test] test 的元素[element], 那么就会返回最左边或最右边的序列元素, 取决于 from-end; 否则返回 nil.

* 示例(Examples):

    ```LISP
    (find #\d "here are some letters that can be looked at" :test #'char>)
    =>  #\Space 
    (find-if #'oddp '(1 2 3 4 5) :end 3 :from-end t) =>  3
    (find-if-not #'complexp                                    
                '#(3.5 2 #C(1.0 0.0) #C(0.0 1.0))
                :start 2) =>  NIL 
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果序列 sequence 不是一个正规序列[proper sequence], 那么应该准备去发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        position, 章节 17.2 (关于测试函数的规则), 章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        这个 :test-not 参数[argument]已经被废弃.

        这个 find-if-not 函数[function]已经被废弃. 


### <span id="F-POSITION-ALL">函数 POSITION, POSITION-IF, POSITION-IF-NOT</span>

* 语法(Syntax):

        position item sequence &key from-end test test-not start end key => position

        position-if predicate sequence &key from-end start end key => position

        position-if-not predicate sequence &key from-end start end key => position

* 参数和值(Arguments and Values):

        item---一个对象[object].
        sequence---一个正规序列[proper sequence].
        predicate---一个返回广义 boolean [generalized boolean]的单参数函数[function]的标识符[designator].
        from-end---一个广义 boolean [generalized boolean]. 默认是 false.
        test---一个返回广义 boolean [generalized boolean]的两个参数[argument]函数[function]的标识符[designator].
        test-not---一个返回广义 boolean [generalized boolean]的两个参数[argument]函数[function]的标识符[designator].
        start, end---序列 sequence 的边界索引标识符[bounding index designator]. 对于 start 和 end 默认分别是 0 和 nil.
        key---一个单参数函数[function]的标识符[designator], 或者 nil.
        position---序列 sequence 的一个边界索引[bounding index], 或者 nil.

* 描述(Description):

        position, position-if, 和 position-if-not 每一个都搜索序列 sequence 来查找一个满足测试条件[satisfies the test]的元素[element].

        返回的 position 是在序列 sequence 中满足测试条件[satisfies the test]的最左边 (如果 from-end 是 true) 或者最右边 (如果 from-end 是 false) 的元素[element]. 返回的索引是相对于整个序列 sequence 的左端, 不管那个 start, end, 或是 from-end 的值.

* 示例(Examples):

    ```LISP
    (position #\a "baobab" :from-end t) =>  4
    (position-if #'oddp '((1) (2) (3) (4)) :start 1 :key #'car) =>  2
    (position 595 '()) =>  NIL
    (position-if-not #'integerp '(1 2 3 4 5.0)) =>  4 
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果序列 sequence 不是一个正规序列[proper sequence], 那么应该准备发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        find, 章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        这个 :test-not 参数[argument]已经被废弃.

        函数[function] position-if-not 已经被废弃. 


### <span id="F-SEARCH">函数 SEARCH</span>

* 语法(Syntax):

        search sequence-1 sequence-2 &key from-end test test-not key start1 start2 end1 end2
        => position

* 参数和值(Arguments and Values):

        Sequence-1---一个序列[sequence].
        Sequence-2---一个序列[sequence].
        from-end---一个广义 boolean [generalized boolean]. 默认是 false.
        test---一个返回广义 boolean [generalized boolean]的两个参数[argument]函数[function]的标识符[designator].
        test-not---一个返回广义 boolean [generalized boolean]的两个参数[argument]函数[function]的标识符[designator].
        key---一个单参数函数[functin]的标识符[designator], 或 nil.
        start1, end1---序列 sequence-1 的边界索引标识符[bounding index designator]. 对于 start1 和 end1 默认分别是 0 和 nil.
        start2, end2---序列 sequence-2 的边界索引标识符[bounding index designator]. 对于 start2 和 end2 默认分别是 0 和 nil.
        position---序列 sequence-2 的边界索引[bounding index], 或 nil.

* 描述(Description):

        搜索序列 sequence-2 来查找一个匹配序列 sequence-1 的子序列.
<!-- 这里的第一个 from-end 原文是 start-end -->
        具体实现可以选择以任何顺序搜索序列 sequence-2; 这里不保证这个测试被执行的数量. 比如, 当 from-end 是 true, 这个序列 sequence 事实上可能从左到右被搜索而不是从右到左 (但是不管在那种情况下都会返回最右边的匹配子序列). 如果这个搜索成功了, search 返回那个最左边或最右边匹配子序列的第一个元素在序列 sequence-2 中的偏移位, 取决于 from-end; 否则 search 返回 nil.

        如果 from-end 是 true, 那么那个最右边的匹配子序列的最左边的元素的索引会被返回.

* 示例(Examples):

    ```LISP
    (search "dog" "it's a dog's life") =>  7
    (search '(0 1) '(2 4 6 1 3 5) :key #'oddp) =>  2
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        这个 :test-not 参数[argument]已经被废弃. 


### <span id="F-MISMATCH">函数 MISMATCH</span>

* 语法(Syntax):

        mismatch sequence-1 sequence-2 &key from-end test test-not key start1 start2 end1 end2
        => position

* 参数和值(Arguments and Values):

        Sequence-1---一个序列[sequence].
        Sequence-2---一个序列[sequence].
        from-end---一个广义 boolean [generalized boolean]. 默认是 false.
        test---一个返回广义 boolean [generalized boolean]的两个参数[argument]函数[function]的标识符[designator].
        test-not---一个返回广义 boolean [generalized boolean]的两个参数[argument]函数[function]的标识符[designator].
        start1, end1---序列 sequence-1 的边界索引标识符[bounding index designator]. 对于 start1 和 end1 默认分别是 0 和 nil.
        start2, end2---序列 sequence-2 的边界索引标识符[bounding index designator]. 对于 start2 和 end2 默认分别是 0 和 nil.
        key---一个单参数函数[function]的标识符[designator], 或者 nil.
        position---序列 sequence-1 的边界索引[bounding index], 或者 nil.

* 描述(Description):

        这个序列 sequence-1 和序列 sequence-2 的指定子序列按元素比较.

        这个 key 参数同时被用于序列 sequence-1 和序列 sequence-2.

        如果序列 sequence-1 和序列 sequence-2 是相同长度并且每个元素都匹配, 那么结果就是 false. 否则, 结果是一个非负整数[integer], 表示那两个子序列不匹配的位置在序列 sequence-1 中最左边或最右边索引, 取决于 from-end. 如果一个子序列短于另一个或者是另一个的匹配前缀, 那么结果就是相对于序列 sequence-1 的最后一个测试位置之后的索引.

        如果 from-end 是 true, 那么返回一加上这些序列 sequences 不同的最右边位置的索引. 实际上, 这些子序列在它们的右边对齐; 于是, 最后一个元素会被比较, 然后是倒数第二个元素, 以此类推. 返回的那个索引是相对于序列 sequence-1 的索引.

* 示例(Examples):

    ```LISP
    (mismatch "abcd" "ABCDE" :test #'char-equal) =>  4
    (mismatch '(3 2 1 1 2 3) '(1 2 3) :from-end t) =>  3
    (mismatch '(1 2 3) '(2 3 4) :test-not #'eq :key #'oddp) =>  NIL
    (mismatch '(1 2 3 4 5 6) '(3 4 5 6 7) :start1 2 :end2 4) =>  NIL 
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        这个 :test-not 参数[argument]已经被废弃. 


### <span id="F-REPLACE">函数 REPLACE</span>

* 语法(Syntax):

        replace sequence-1 sequence-2 &key start1 end1 start2 end2 => sequence-1

* 参数和值(Arguments and Values):

        sequence-1---一个序列[sequence].
        sequence-2---一个序列[sequence].
        start1, end1---序列 sequence-1 的边界索引标识符[bounding index designator]. 对于 start1 和 end1 默认分别是 0 和 nil.
        start2, end2---序列 sequence-2 的边界索引标识符[bounding index designator]. 对于 start2 和 end2 默认分别是 0 和 nil.

* 描述(Description):

        通过用由 start2 和 end2 限定[bounded]的子序列 subsequence-2 的元素[element]来替换子序列 subsequence-1 中由 start1 和 end1 限定[bounded]的元素[element]来破坏性地修改序列 sequence-1.

        通过从序列 sequence-2 拷贝连续的元素[element]到序列 sequence-1, 序列 sequence-1 被破坏性地修改. 序列 sequence-2 中由 start2 和 end2 限定[bounded]的子序列的元素[element]会被拷贝到序列 sequence-1 中由 start1 和 end1 限定的子序列中. 如果这些序列不是相同长度, 那么较短的长度决定了要拷贝多少个元素[element]; 在较长的子序列末尾处的额外元素[element]不会被涉及到这个操作. 被拷贝的数量可以表达为:

        (min (- end1 start1) (- end2 start2))

        如果序列 sequence-1 和序列 sequence-2 是相同的[same]对象[object]并且被修改的区域与被复制的区域重叠, 那么就好像整个源区域被拷贝到另一个位置然后再拷贝回目标区域. 然而, 如果 sequence-1 和 sequence-2 是不同的, 但是被修改的区域与被复制的区域重叠 (或许是由于共享列表结构或者存储被转移数组[array]), 那么在这个 replace 操作后, 要被修改的序列 sequence-1 的子序列会有不可预测的内容. 如果序列 sequence-2 的元素不是一个可以被存储到序列 sequence-1 中的类型[type], 那么就是一个错误.

* 示例(Examples):

    ```LISP
    (replace "abcdefghij" "0123456789" :start1 4 :end1 7 :start2 4) 
    =>  "abcd456hij"
    (setq lst "012345678") =>  "012345678"
    (replace lst lst :start1 2 :start2 0) =>  "010123456"
    lst =>  "010123456"
    ```

* 副作用(Side Effects):

        这个序列 sequence-1 会被修改.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        fill

* 注意(Notes): None. 


### <span id="F-SUBSTITUTE-ALL">函数 SUBSTITUTE, SUBSTITUTE-IF, SUBSTITUTE-IF-NOT, NSUBSTITUTE, NSUBSTITUTE-IF, NSUBSTITUTE-IF-NOT</span>

* 语法(Syntax):

        substitute newitem olditem sequence &key from-end test test-not start end count key
        => result-sequence

        substitute-if newitem predicate sequence &key from-end start end count key
        => result-sequence

        substitute-if-not newitem predicate sequence &key from-end start end count key
        => result-sequence

        nsubstitute newitem olditem sequence &key from-end test test-not start end count key
        => sequence

        nsubstitute-if newitem predicate sequence &key from-end start end count key
        => sequence

        nsubstitute-if-not newitem predicate sequence &key from-end start end count key
        => sequence

* 参数和值(Arguments and Values):

        newitem---一个对象[object].
        olditem---一个对象[object].
        sequence---一个正规序列[proper sequence].
        predicate---返回广义 boolean [generalized boolean]的单参数[argumet]函数[function]的标识符[designator].
        from-end---一个广义 boolean [generalized boolean]. 默认是 false.
        test---返回广义 boolean [generalized boolean]的两个参数[argument]函数[function]的标识符[designator].
        test-not---返回广义 boolean [generalized boolean]的两个参数[argument]函数[function]的标识符[designator].
        start, end---序列 sequence 的边界索引标识符[bounding index designator]. 对于 start 和 end 默认分别为 0 和 nil.
        count---一个整数[integer]或 nil. 默认是 nil.
        key---一个单参数函数[function]的标识符[designator], 或者 nil.
        result-sequence---一个序列[sequence].

* 描述(Description):

        substitute, substitute-if, 和 substitute-if-not 返回序列 sequence 的一个拷贝, 其中每个满足测试条件[satisfy the test]的元素[element]都被替换为 newitem.

        nsubstitute, nsubstitute-if, 和 nsubstitute-if-not 分别类似于 substitute, substitute-if, 和 substitute-if-not, 除了它们可能修改序列 sequence.

        如果序列 sequence 是一个向量[vector], 那么结果是一个和 sequence 有着相同实际数组元素类型[actual array element type]的向量[vector]. 如果序列 sequence 是一个列表[list], 那么结果也是有一个列表[list].

        如果提供了 count, 限制要被修改的元素的数量; 如果满足测试条件[satisfy the test]的元素[element]超过 count 个, 那么那些元素中只有最左边或最右边的和 count 指定的一样多的元素[element]会被替换, 取决于 from-end. 如果提供了 count 并且是负的, 那么这个行为就好像提供了零一样. 如果 count 是 nil, 所有匹配的项都会被影响.

        只有提供了 count 时 (并且非 nil [non-nil]), 提供一个为 true 的 from-end 是有关系的; 在这个情况中, 只有最右边 count 个满足测试条件[satisfy the test]的元素[element]会被移除 (而不是最左边).

        predicate, test, 和 test-not 对于每个序列[sequence]元素[element]可能被调用不止一次, 并且它们的副作用可能以任意顺序发生.

        所有这些函数的结果是一个和 sequence 有着相同类型[type]的序列[sequence], 它们有着相同的元素除了那些由 start 和 end 限定[bounded]并且满足测试条件[satisfy the test]的被替换为 newitem.

        substitute, substitute-if, 和 substitute-if-not 返回的一个序列[sequence]可能和序列 sequence 共享结构, 或者如果没有元素需要被改变那么就是和输入序列 sequence 相同的[identical].

        nsubstitute 和 nsubstitute-if 需要去 setf 任何序列 sequence 中需要被替换为 newitem 的 car (如果序列 sequence 是一个列表[list]) 或 aref (如果 sequence 是一个向量[vector]). 如果序列 sequence 是一个列表[list], 这些顶层列表[list]的 cdr 都不会被修改.

* 示例(Examples):

    ```LISP
    (substitute #\. #\SPACE "0 2 4 6") =>  "0.2.4.6"
    (substitute 9 4 '(1 2 4 1 3 4 5)) =>  (1 2 9 1 3 9 5)
    (substitute 9 4 '(1 2 4 1 3 4 5) :count 1) =>  (1 2 9 1 3 4 5)
    (substitute 9 4 '(1 2 4 1 3 4 5) :count 1 :from-end t)
    =>  (1 2 4 1 3 9 5)
    (substitute 9 3 '(1 2 4 1 3 4 5) :test #'>) =>  (9 9 4 9 3 4 5)

    (substitute-if 0 #'evenp '((1) (2) (3) (4)) :start 2 :key #'car)
    =>  ((1) (2) (3) 0)
    (substitute-if 9 #'oddp '(1 2 4 1 3 4 5)) =>  (9 2 4 9 9 4 9)
    (substitute-if 9 #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t)
    =>  (1 2 4 1 3 9 5)

    (setq some-things (list 'a 'car 'b 'cdr 'c)) =>  (A CAR B CDR C)
    (nsubstitute-if "function was here" #'fboundp some-things
                    :count 1 :from-end t) =>  (A CAR B "function was here" C)
    some-things =>  (A CAR B "function was here" C)
    (setq alpha-tester (copy-seq "ab ")) =>  "ab "
    (nsubstitute-if-not #\z #'alpha-char-p alpha-tester) =>  "abz"
    alpha-tester =>  "abz"
    ```

* 副作用(Side Effects):

        nsubstitute, nsubstitute-if, 和 nsubstitute-if-not 序列 sequence.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果序列 sequence 不是一个正规序列[proper sequence], 那么应该准备去发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        subst, nsubst, 章节 3.2.1 (编译器术语), 章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        如果序列 sequence 是一个向量[vector], 那么结果可能或可能不是简单的, 并且可能或可能不会和序列 sequence 相同[identical].

        这个 :test-not 参数[argument]已经被废弃.

        函数 substitute-if-not 和 nsubstitute-if-not 已经被废弃.

        nsubstitute 和 nsubstitute-if 可以被用于只为了副作用(for-effect-only)的代码中.

        因为副作用变体(比如, nsubstitute)可能会改变被遍历的路径, 它们在共享或循环结构中出现的副作用在和它们的无副作用替代比较时可能表现出令人惊讶的不同. 为了观察到这个, 细想以下副作用行为, 它可能被某些实现展现出来:

    ```LISP
    (defun test-it (fn)
      (let ((x (cons 'b nil)))
        (rplacd x x)
        (funcall fn 'a 'b x :count 1)))
    (test-it #'substitute) =>  (A . #1=(B . #1#))
    (test-it #'nsubstitute) =>  (A . #1#)
    ```


### <span id="F-CONCATENATE">函数 CONCATENATE</span>

* 语法(Syntax):

        concatenate result-type &rest sequences => result-sequence

* 参数和值(Arguments and Values):

        result-type---一个 sequence 类型指定符[type specifier].
        sequences---一个序列[sequence].
        result-sequence---一个 result-type 类型[type]的正规序列[proper sequence].

* 描述(Description):

        concatenate 返回一个包含了所有这些序列 sequences 的单独元素的序列[sequence], 按照它们被提供的顺序. 这个序列[sequence]是 result-type 类型[type]的, 这个类型[type]必须是类型 sequence 的一个子类型[subtype].

        所有这些序列 sequences 都会被拷贝; 这个结果不会和这些序列 sequences 的任何一个共享结构. 因此, 如果只提供了一个序列 sequence 并且它是 result-type 类型的, concatenate 需要去拷贝这个序列 sequence 而不是简单地返回它.

        如果这些元素 sequences 的任何一个元素不能是这些结果序列[sequence]的一个元素, 那么就是一个错误. 如果这个 result-type 是 list 的一个子类型[subtype], 结果会是一个列表[list].

        如果 result-type 是 vector 的一个子类型[subtype], 那么如果实现可以确定 result-type 指定的元素类型, 那么产生的数组的元素类型就是那个元素类型提升[upgrade]的结果; 或者, 如果实现可以确定那个元素类型是未指定的 (或 *), 产生的元素类型就是 t; 否则, 发出一个错误.

* 示例(Examples):

    ```LISP
    (concatenate 'string "all" " " "together" " " "now") =>  "all together now"
    (concatenate 'list "ABC" '(d e f) #(1 2 3) #*1011)
    =>  (#\A #\B #\C D E F 1 2 3 1 0 1 1)
    (concatenate 'list) =>  NIL

      (concatenate '(vector * 2) "a" "bc") should signal an error
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 result-type 既不是 list 的一个可识别子类型[recognizable subtype], 也不是 vector 的一个可识别子类型[recognizable subtype], 那么就会发出一个错误.

        如果 result-type 指定的元素的数量和这些序列 sequences 的总数在数量上不同, 那么就会发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        append

* 注意(Notes): None. 


### <span id="F-MERGE">函数 MERGE</span>

* 语法(Syntax):

        merge result-type sequence-1 sequence-2 predicate &key key => result-sequence

* 参数和值(Arguments and Values):

        result-type---一个 sequence 类型指定符[type specifier].
        sequence-1---一个序列[sequence].
        sequence-2---一个序列[sequence].
        predicate---返回广义 boolean [generalized boolean]的两个参数函数[function]的标识符[designator].
        key---一个单参数函数[function]的标识符[designator], 或者 nil.
        result-sequence---一个 result-type 类型[type]的正规序列[proper sequence].

* 描述(Description):

        根据断言 predicate 决定的顺序破坏性地合并 sequence-1 和 sequence-2. merge 通过把从这些序列元素中提取到的键给定到断言 predicate 来决定两个元素之间的关系.

        给这个 predicate 函数的第一个参数是由 key 返回的序列 sequence-1 的一个元素 (如果提供的话); 第二个参数是由 key 返回的序列 sequence-2 的元素 (如果提供的话). 当且仅当这个断言 predicate 的第一个参数严格小于第二个参数时(在一些适当的意义上), 它应该返回 true. 如果第一个参数大于或等于第二个参数 (在一些适当的意义上), 那么断言 predicate 应该返回 false. 如果 (funcall predicate x y) 和 (funcall predicate y x) 都产生[yield] false, 那么 merge 把这两个元素 x 和 y 认为是相等的.

        给 key 的参数是序列 sequence 的元素. 通常地, 这个 key 的返回值成为给断言 predicate 的参数. 如果没有提供 key 或者是 nil, 那么就使用这个序列元素自身. 这个 key 对于每个序列[sequence]元素[element]可能被执行不止一次, 那么它的副作用可能以任意顺序发生.

        如果 key 和 predicate 返回了, 那么这个合并操作就会终止. 合并两个序列[sequence] x 和 y 的结果是一个类型 result-type 的新序列[sequence] z, 这样一来 z 的长度是 x 和 y 的总和, 并且 z 包含了 x 和 y 的所有元素. 如果 x1 和 x2 是 x 的两个元素, 并且在 x 中 x1 在 x2 前面, 那么在 z 中 x1 也在 x2 前面, 而对于 y 的元素也类型. 总之, z 是 x 和 y 的交错.

        如果 x 和 y 根据断言 predicate 被正确地排序, 那么 z 也会被正确排序. 如果 x 或 y 没有被这样排序, 那么 z 不会被排序, 但它仍然是 x 和 y 的交错.

        这个合并操作保证稳定的; 如果根据这个断言 predicate, 两个或更多元素被断言 predicate 认为是相等的, 那么在结果中来自于序列 sequence-1 的元素会在序列 sequence-2 的元素之前.

        sequence-1 和/或 sequence-2 可能会被破坏.

        如果这个 result-type 是 list 的一个子类型[subtype], 结果可能是一个列表[list].

        如果 result-type 是 vector 的一个子类型[subtype], 那么如果实现可以确定 result-type 指定的元素类型, 那么产生的数组的元素类型就是那个元素类型提升[upgrade]的结果; 或者, 如果实现可以确定那个元素类型是未指定的 (或 *), 产生的元素类型就是 t; 否则, 发出一个错误.

* 示例(Examples):

    ```LISP
    (setq test1 (list 1 3 4 6 7))
    (setq test2 (list 2 5 8))
    (merge 'list test1 test2 #'<) =>  (1 2 3 4 5 6 7 8)
    (setq test1 (copy-seq "BOY"))
    (setq test2 (copy-seq :nosy"))
    (merge 'string test1 test2 #'char-lessp) =>  "BnOosYy"
    (setq test1 (vector ((red . 1) (blue . 4))))
    (setq test2 (vector ((yellow . 2) (green . 7))))
    (merge 'vector test1 test2 #'< :key #'cdr) 
    =>  #((RED . 1) (YELLOW . 2) (BLUE . 4) (GREEN . 7)) 

    (merge '(vector * 4) '(1 5) '(2 4 6) #'<) should signal an error
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 result-type 既不是 list 的一个可识别子类型[recognizable subtype], 也不是 vector 的一个可识别子类型[recognizable subtype], 那么就会发出一个错误.

        如果 result-type 指定的元素的数量和这些序列 sequence-1 和 sequence-2 的长度在数量上不同, 那么就会发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        sort, stable-sort, 章节 3.2.1 (编译器术语), 章节 3.6 (遍历规则和副作用)

* 注意(Notes): None. 


### <span id="F-REMOVE-ALL">函数 REMOVE, REMOVE-IF, REMOVE-IF-NOT, DELETE, DELETE-IF, DELETE-IF-NOT</span>

* 语法(Syntax):

        remove item sequence &key from-end test test-not start end count key => result-sequence

        remove-if test sequence &key from-end start end count key => result-sequence

        remove-if-not test sequence &key from-end start end count key => result-sequence

        delete item sequence &key from-end test test-not start end count key => result-sequence

        delete-if test sequence &key from-end start end count key => result-sequence

        delete-if-not test sequence &key from-end start end count key => result-sequence

* 参数和值(Arguments and Values):

        item---一个对象[object].
        sequence---一个正规序列[proper sequence].
        test---返回广义 boolean [generalized boolean]的单参数[argument]函数[function]的标识符[designator].
        from-end---一个广义 boolean [generalized boolean]. 默认是 false.
        test---一个返回广义 boolean [generalized boolean]的两参数[argument]函数[function]的标识符[designator].
        test-not---返回广义 boolean [generalized boolean]的两参数[function]函数[function]的标识符[designator].
        start, end---序列 sequence 的边界索引标识符[bounding index designator]. 对于 start 和 end 默认分别为 0 和 nil.
        count---一个整数[integer]或 nil. 默认是 nil.
        key---一个单参数[argument]函数[function]的标识符[designator], 或者 nil.
        result-sequence---一个序列[sequence].

* 描述(Description):

        remove, remove-if, 和 remove-if-not 返回一个序列, 这个序列中满足测试条件[satisfy the test]的元素[element]已经被移出.

        delete, delete-if, 和 delete-if-not 分别类似于 remove, remove-if, 和 remove-if-not, 但是它们修改序列 sequence.

        如果序列 sequence 是一个向量[vector], 那么结果是一个和 sequence 有着相同实际数组元素类型[actual array element type]的向量[vector]. 如果序列 sequence 是一个列表[list], 那么结果也是有一个列表[list].

        提供一个为 true 的 from-end 只有在这个 count 被提供时起作用; 在这个情况下只有最右边满足测试条件[satisfy the test]的 count 个元素会被删除.

        count, 如果提供的话, 限制要被移除或删除的元素的数量; 如果超过 count 个元素满足测试条件[satisfy the test], 那么这些元素只有最右边或最左边由 count 指定的数量会被删除, 取决于 from-end. 如果 count 被提供并且是负的, 那么这个行为就跟提供了零一样. 如果 count 是 nil, 那么所有匹配的项都会被影响.

        对于所有这些函数, 元素在结果中被移除的顺序和它们在序列 sequence 中的一样.

        remove, remove-if, remove-if-not 返回一个和序列 sequence 相同类型[type]的序列[sequence], 并且有着相同的元素[element], 除了那些在 start 和 end 限定[bounded]的子序列中满足测试条件[satisfy the test]的会被移除. 这是一个非破坏性的操作. 如果任何元素需要被移除, 那么结果就是一个拷贝. 这个 remove 的结果可能和序列 sequence 共享结构; 如果没有元素需要被移除, 这个结果可能和输入的序列 sequence 是相同的.

        delete, delete-if, 和 delete-if-not 返回一个和序列 sequence 相同类型[type]的序列[sequence], 并且有着相同的元素[element], 除了那些在 start 和 end 限定[bounded]的子序列中满足测试条件[satisfy the test]的会被删除. 序列 sequence 可能被破坏并且被用于构造这个结果; 然而, 这个结果可能和序列 sequence 相同[identical], 也可能不同.

        delete, 当序列 sequence 是一个列表[list]时, 允许去 setf 这个序列 sequence 中的顶层列表结构的任何部分, car 或 cdr. 当序列 sequence 是一个向量[vector]时, delete 允许去改变这个向量的维数大小来滑动它的元素到新的位置, 在没有交换它们的情况下产生这个结果向量[vector].

        delete-if 被约束为表现得像下面这样:

        (delete nil sequence
                    :test #'(lambda (ignore item) (funcall test item))
                    ...)

* 示例(Examples):

    ```LISP
    (remove 4 '(1 3 4 5 9)) =>  (1 3 5 9)
    (remove 4 '(1 2 4 1 3 4 5)) =>  (1 2 1 3 5)
    (remove 4 '(1 2 4 1 3 4 5) :count 1) =>  (1 2 1 3 4 5)
    (remove 4 '(1 2 4 1 3 4 5) :count 1 :from-end t) =>  (1 2 4 1 3 5)
    (remove 3 '(1 2 4 1 3 4 5) :test #'>) =>  (4 3 4 5)
    (setq lst '(list of four elements)) =>  (LIST OF FOUR ELEMENTS)
    (setq lst2 (copy-seq lst)) =>  (LIST OF FOUR ELEMENTS)
    (setq lst3 (delete 'four lst)) =>  (LIST OF ELEMENTS)
    (equal lst lst2) =>  false
    (remove-if #'oddp '(1 2 4 1 3 4 5)) =>  (2 4 4)
    (remove-if #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t) 
    =>  (1 2 4 1 3 5)
    (remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9) :count 2 :from-end t)
    =>  (1 2 3 4 5 6 8)
    (setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)
    (delete 4 tester) =>  (1 2 1 3 5)
    (setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)
    (delete 4 tester :count 1) =>  (1 2 1 3 4 5)
    (setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)
    (delete 4 tester :count 1 :from-end t) =>  (1 2 4 1 3 5)
    (setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)
    (delete 3 tester :test #'>) =>  (4 3 4 5)
    (setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)
    (delete-if #'oddp tester) =>  (2 4 4)
    (setq tester (list 1 2 4 1 3 4 5)) =>  (1 2 4 1 3 4 5)
    (delete-if #'evenp tester :count 1 :from-end t) =>  (1 2 4 1 3 5)    
    (setq tester (list 1 2 3 4 5 6)) =>  (1 2 3 4 5 6) 
    (delete-if #'evenp tester) =>  (1 3 5) 
    tester =>  implementation-dependent

    (setq foo (list 'a 'b 'c)) =>  (A B C)
    (setq bar (cdr foo)) =>  (B C)
    (setq foo (delete 'b foo)) =>  (A C)
    bar =>  ((C)) or ...
    (eq (cdr foo) (car bar)) =>  T or ...
    ```

* 副作用(Side Effects):

        对于 delete, delete-if, 和 delete-if-not, sequence 可能被破坏并被用于构造这个结果.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果序列 sequence 不是一个正规序列[proper sequence], 那么应该准备去发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        章节 3.2.1 (编译器术语), 章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        如果序列 sequence 是一个向量[vector], 那么结果可能也可能不是简单的, 并且可能也可能不会和序列 sequence 相同[identical].

        这个 :test-not 参数[argument]已经被废弃.

        函数 delete-if-not 和 remove-if-not 已经被废弃. 


### <span id="F-DUPLICATES-ALL">函数 REMOVE-DUPLICATES, DELETE-DUPLICATES</span>

* 语法(Syntax):

        remove-duplicates sequence &key from-end test test-not start end key
        => result-sequence

        delete-duplicates sequence &key from-end test test-not start end key
        => result-sequence

* 参数和值(Arguments and Values):

        sequence---一个正规序列[proper sequence].
        from-end---一个广义 boolean [generalized boolean]. 默认是 false.
        test---返回广义 boolean [generalized boolean]的两参数[argument]函数[function]的标识符[designator].
        test-not---返回广义 boolean [generalized boolean]的两参数[argument]函数[function]的标识符[designator].
        start, end---序列 sequence 的边界索引标识符[bounding index designator]. 对于 start 和 end 默认分别是 0 和 nil.
        key---一个单参数函数[function]的标识符[designator], 或者 nil.
        result-sequence---一个序列[sequence].

* 描述(Description):

        remove-duplicates 返回序列 sequence 的一个被修改的拷贝, 其中任何匹配出现在序列 sequence 中另一个元素的元素已经被移除.

        如果序列 sequence 是一个向量[vector], 那么结果是一个和 sequence 有着相同实际数组元素类型[actual array element type]的向量[vector]. 如果序列 sequence 是一个列表[list], 那么结果也是有一个列表[list].

        delete-duplicates 类似于 remove-duplicates, 但是 delete-duplicates 可能修改序列 sequence.

        序列 sequence 的元素是成对的[pairwise]比较, 如果任意两个匹配, 那么更早出现在序列 sequence 中的那个会被丢弃, 除非 from-end 是 true, 在这个情况下在序列 sequence 中较晚的那个会被丢弃.

        remove-duplicates 和 delete-duplicates 返回一个和序列 sequence 相同类型[type]的序列[sequence], 其中足够的元素被移除以致于没有两个剩余元素是匹配的. 在这个结果中剩余元素的顺序和它们出现在序列 sequence 中的顺序是一样的.

        remove-duplicates 返回一个可能和序列 sequence 共享的序列[sequence], 如果没有元素需要被移除, 那么可能返回一个和序列 sequence 相同[identical]的序列[sequence].

        delete-duplicates, 当序列 sequence 是一个列表[list], 允许去 setf 这个序列 sequence 中的顶层列表结构的任何部分, car 或 cdr. 当序列 sequence 是一个向量[vector]时, delete 允许去改变这个向量[vector]的维数大小去滑动它的元素到新的位置, 在没有交换它们的情况下产生这个结果向量[vector].

* 示例(Examples):

    ```LISP
    (remove-duplicates "aBcDAbCd" :test #'char-equal :from-end t) =>  "aBcD"
    (remove-duplicates '(a b c b d d e)) =>  (A C B D E)
    (remove-duplicates '(a b c b d d e) :from-end t) =>  (A B C D E)
    (remove-duplicates '((foo #\a) (bar #\%) (baz #\A))
        :test #'char-equal :key #'cadr) =>  ((BAR #\%) (BAZ #\A))
    (remove-duplicates '((foo #\a) (bar #\%) (baz #\A)) 
        :test #'char-equal :key #'cadr :from-end t) =>  ((FOO #\a) (BAR #\%))
    (setq tester (list 0 1 2 3 4 5 6))
    (delete-duplicates tester :key #'oddp :start 1 :end 6) =>  (0 4 5 6)
    ```

* 副作用(Side Effects):

        delete-duplicates 可能破坏性地修改序列 sequence.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果序列 sequence 不是一个正规序列[proper sequence], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        章节 3.2.1 (编译器术语), 章节 3.6 (遍历规则和副作用)

* 注意(Notes):

        如果序列 sequence 是一个序列[vector], 那么结果可能也可能不是简单的, 并且可能和序列 sequence 相同[identical], 也可能不同.

        这个 :test-not 参数[argument]已经被废弃.

        这些函数对于转换序列 sequence 为适合表示集合的规范形式是非常有用. 


# 18. 哈希表

> * 18.1 [哈希表的概念](#HashTableConcepts)
> * 18.2 [哈希表的字典](#TheHashTablesDictionary)

## 18.1 <span id="HashTableConcepts">哈希表的概念</span>

> * 18.1.1 [哈希表操作](#HashTableOperations)
> * 18.1.2 [修改哈希表的键](#ModifyingHashTableKeys)


### 18.1.1 <span id="HashTableOperations">哈希表操作</span>

下面这段列出了一些可以应用于哈希表[hash table]的已定义的名字[defined name]. 下面规则应用于哈希表[hash table].

-- 一个哈希表[hash table]只能关联一个值和一个给定的键. 如果尝试去添加一个给定的键的第二个值, 第二个值会替换第一个. 因此, 添加一个值到哈希表[hash table]是一个破坏性操作; 这个哈希表[hash table]会被修改.

-- 这里有四种哈希表[hash table]: 键是使用 eq 来比较的那些, 键是使用 eql 来比较的那些, 键是使用 equal 来比较的那些, 以及键是使用 equalp 来比较的那些.

-- 哈希表[hash table]由 make-hash-table 创建. gethash 被用于搜索一个键以及找到那个关联的值. 新的条目会使用 setf 和 gethash 来添加到哈希表[hash table]中. remhash 被用于移除一个条目. 比如:

    ```LISP
    (setq a (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32536573>
    (setf (gethash 'color a) 'brown) =>  BROWN
    (setf (gethash 'name a) 'fred) =>  FRED
    (gethash 'color a) =>  BROWN, true
    (gethash 'name a) =>  FRED, true
    (gethash 'pointy a) =>  NIL, false
    ```

    在这个例子中, 符号 color 和 name 被用作键, 而符号 brown 和 fred 被用作关联的值. 这个哈希表[hash table]中有两个值, 一个关联是从 color 到 brown, 而另一个关联是从 name 到 fred.

-- 一个键和一个值可以是任何对象[object].

-- 一个条目在哈希表[hash table]中的存在性可以由 gethash 返回的第二个值[secondary value]来决定.

    clrhash           hash-table-p     remhash  
    gethash           make-hash-table  sxhash   
    hash-table-count  maphash                   

    Figure 18-1. Hash-table 已定义的名字 

### 18.1.2 <span id="ModifyingHashTableKeys">修改哈希表的键</span>

提供给 make-hash-table 的 :test 参数的函数指定了它创建的哈希表[hash table]的 '等价性测试(equivalence test)'.

如果存在一组对象[object] (或潜在对象[object]), 在修改之前, 和一个对象[object]是等价的, 但在随后的情况下不再是等价的, 那么相对于等价性测试那个对象[object]就是被'可见地修改'的.

如果一个对象[object] O1 被用作哈希表[hash table] H 中的一个键并且接下来相对于 H 的等价性测试被可见地修改, 那么如果 O1 或任何在这个等价性测试下等价于 O1 的对象[object] O2 (不管在这个修改之前或之后) 在后面对 H 的操作中被用作一个键, 后果是未指定的. 即便 O1 被可见地修改并且接着被再次修改来撤销这个可见的修改, 那么使用 O1 作为一个 key 的后果也是未指定的.

下面是哈希表[hash table]必须支持的相对于等价性测试可见的修改的规范. 这些修改是用成员的修改来描述的, 并且是递归地定义的. 这个对象[object]的成员的可见修改是这个对象[object]的可见修改.

> * 18.1.2.1 [关于 EQ 和 EQL 的对象可见修改](#VM-EQ-EQL)
> * 18.1.2.2 [关于 EQUAL 的对象可见修改](#VM-EQUAL)
> * 18.1.2.3 [关于 EQUALP 的对象可见修改](#VM-EQUALP)
> * 18.1.2.4 [通过语言扩展的可见修改](#VM-LanguageExtensions)


#### 18.1.2.1 <span id="VM-EQ-EQL">关于 EQ 和 EQL 的对象可见修改</span>

没有提供标准化[standardized]函数[function]能够对于 eq 或 eql 可见地修改一个对象[object]. 

#### 18.1.2.2 <span id="VM-EQUAL">关于 EQUAL 的对象可见修改</span>

作为 equal 的行为的结果, 对于没有在这个章节中被显式提及的对象[object]的可见修改的规则衍生自那些在章节 18.1.2.1 (关于 EQ 和 EQL 的对象可见修改) 中提及的.

##### 18.1.2.2.1 关于 EQUAL 的 cons 可见修改

对一个 cons 的 car 或 cdr 的任何可见修改都被当作是对于 equal 可见的修改. 


##### 18.1.2.2.2 关于 EQUAL 的字符串和位向量的可见修改

对于一个 bit-vector 类型[type]或 string 类型[type]的向量[vector], 对这个向量[vector]的一个有效[active]元素[element]或者对这个向量[vector]的长度[length] (如果它实际上是可调整的[actually adjustable]或者有着一个填充指针[fill pointer])的任何可见修改都被认为是对于 equal 的可见修改. 


#### 18.1.2.3 <span id="VM-EQUALP">关于 EQUALP 的对象可见修改</span>

作为 equalp 的行为的结果, 对于没有在这个章节中被显式提及的对象[object]的可见修改的规则衍生自那些在章节 18.1.2.2 (关于 EQUAL 的对象可见修改) 中提及的.

##### 18.1.2.3.1 关于 EQUALP 的结构体可见修改

对一个结构体[structure]的槽[slot]的任何可见修改都被当作是对于 equalp 可见的修改. 

##### 18.1.2.3.2 关于 EQUALP 的数组可见修改

在一个数组[array]中, 对一个有效[active]元素[element], 填充指针[fill pointer] (如果这个数组[array]可以并且确实有一个的话), 或者维度大小[dimension] (如果这个数组[array]实际上是可调整的[actually adjustable])的任何可见修改都会被当作相对于 equalp 可见的修改. 

##### 18.1.2.3.3 关于 EQUALP 的哈希表可见修改

在一个哈希表[hash table]中, 对这个哈希表[hash table]中的条目数量, 键, 或者和那些键关联的值的任何可见修改都会被当作相对于 equalp 可见的修改.

注意, 对于这些键修改的可见性取决于这个哈希表[hash table]的等价性测试, 而不是 equalp 的说明. 

#### 18.1.2.4 <span id="VM-LanguageExtensions">通过语言扩展的可见修改</span>

通过提供额外的更改函数(或者对于已存在的更改函数提供额外行为)来扩展这个语言的具体实现[implementation]必须记录这些扩展的使用如何与等价性测试和哈希表[hash table]搜索相互作用.

通过为哈希表[hash table]定义额外的可接受的等价性测试 (给 make-hash-table 的 :test 参数提供额外的值)来扩展这个语言的具体实现[implementation]必须记录这些测试的可见部分. 

## 18.2 <span id="TheHashTablesDictionary">哈希表的字典</span>

> * [系统类 HASH-TABLE](#SC-HASH-TABLE)
> * [函数 MAKE-HASH-TABLE](#F-MAKE-HASH-TABLE)
> * [函数 HASH-TABLE-P](#F-HASH-TABLE-P)
> * [函数 HASH-TABLE-COUNT](#F-HASH-TABLE-COUNT)
> * [函数 HASH-TABLE-REHASH-SIZE](#F-HASH-TABLE-REHASH-SIZE)
> * [函数 HASH-TABLE-REHASH-THRESHOLD](#F-HASH-TABLE-REHASH-THRESHOLD)
> * [函数 HASH-TABLE-SIZE](#F-HASH-TABLE-SIZE)
> * [函数 HASH-TABLE-TEST](#F-HASH-TABLE-TEST)
> * [访问器 GETHASH](#A-GETHASH)
> * [函数 REMHASH](#F-REMHASH)
> * [函数 MAPHASH](#F-MAPHASH)
> * [宏 WITH-HASH-TABLE-ITERATOR](#M-WITH-HASH-TABLE-ITERATOR)
> * [函数 CLRHASH](#F-CLRHASH)
> * [函数 SXHASH](#F-SXHASH)


### <span id="SC-HASH-TABLE">系统类 HASH-TABLE</span>

* 类优先级列表(Class Precedence List):

        hash-table, t

* 描述(Description):

        哈希表[hash table]提供了一个方式来映射任何对象[object] (一个键[key])到一个关联的对象[object] (一个值[value]).

* 参见(See Also):

        章节 18.1 (哈希表的概念), 章节 22.1.3.13 (打印其他对象)

* 注意(Notes):

        其目的是通过一个哈希散列机制实现这个映射, 就像 The Art of Computer Programming, Volume 3 (pp506-549) 的章节 6.4 "Hashing" 中描述的那样. 尽管有这样的意图, 符合规范的实现[conforming implementation]不需要去使用任何特定的技巧来实现这个映射. 


### <span id="F-MAKE-HASH-TABLE">函数 MAKE-HASH-TABLE</span>

* 语法(Syntax):

        make-hash-table &key test size rehash-size rehash-threshold => hash-table

* 参数和值(Arguments and Values):

        test---函数[function] eq, eql, equal, 或 equalp 其中之一的标识符[designator]. 默认是 eql.
        size---一个非负整数[integer]. 默认是依赖于具体实现的[implementation-dependent].
        rehash-size---一个 (or (integer 1 *) (float (1.0) *)) 类型[type]的实数[real]. 默认是依赖于具体实现的[implementation-dependent].
        rehash-threshold---一个 (real 0 1) 类型[type]的实数[real]. 默认是依赖于具体实现的[implementation-dependent].
        hash-table---一个哈希表[hash table].

* 描述(Description):

        创建并返回一个新的哈希表[hash table].

        test 决定了如何比较这些键[key]. 如果一个对象[object]在这个测试条件 test 下和这个哈希表 hash-table 中的某个条目的键[key]是相同的[same], 就说这个对象[object]出现在这个哈希表 hash-table 中.

        size 是一个对于具体实现[implementation]的暗示, 表示关于在这个哈希表 hash-table 中分配的初始空间的大小. 这个信息和 rehash-threshold 相联系来控制这个表增长之前应该可以插入的条目的合适数量. 实际的大小可能在 size 到下一个'好的'大小; 比如, 一些具体实现[implementation]可能会舍入到下一个质数.

        rehash-size 指定了当 hash-table 变得足够多以致于需要再散列时需要增长的最小数量; 见下面的 rehash-theshold. 如果 rehash-size 是一个整数[integer], 这个表的预期增长率是加法的并且这个整数[integer]就是要增加的条目数; 如果它是一个浮点数[float], 这个表的预期增长率是乘法的并且这个浮点数[float]就是新的大小和旧的大小的比值. 和 size 一样, 这个增长的实际大小可能会被舍入.

        rehash-threshold 指定了在 hash-table 必须增长前它可以的达到的完整大小. 它指定了最大期望的 hash-table 占用级别(occupancy level).

        这个 rehash-size 和 rehash-threshold 的值[value]不会强迫具体实现[implementation]使用任何特定的方法来计算哈希表 hash-table 何时要被扩展以及扩展的大小. 这样的决定是依赖于具体实现的[implementation-dependent], 这些值[value]只是程序员[programmer]对实现[implementation]的提示, 并且允许具体实现[implementation]去忽略它们.

* 示例(Examples):

    ```LISP
    (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 46142754>
    (setf (gethash "one" table) 1) =>  1
    (gethash "one" table) =>  NIL, false
    (setq table (make-hash-table :test 'equal)) =>  #<HASH-TABLE EQUAL 0/139 46145547>
    (setf (gethash "one" table) 1) =>  1
    (gethash "one" table) =>  1, T
    (make-hash-table :rehash-size 1.5 :rehash-threshold 0.7) 
    =>  #<HASH-TABLE EQL 0/120 46156620>
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        gethash, hash-table

* 注意(Notes): None. 


### <span id="F-HASH-TABLE-P">函数 HASH-TABLE-P</span>

* 语法(Syntax):

        hash-table-p object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 hash-table 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32511220>
    (hash-table-p table) =>  true
    (hash-table-p 37) =>  false
    (hash-table-p '((a . 1) (b . 2))) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes):

        (hash-table-p object) ==  (typep object 'hash-table)


### <span id="F-HASH-TABLE-COUNT">函数 HASH-TABLE-COUNT</span>

* 语法(Syntax):

        hash-table-count hash-table => count

* 参数和值(Arguments and Values):

        hash-table---一个哈希表[hash table].
        count---一个非负整数[integer].

* 描述(Description):

        返回在这个哈希表 hash-table 中的条目的数量. 如果 hash-table 刚刚被创建或者重新被清理 (见 clrhash) 那么条目数量就是 0.

* 示例(Examples):

    ```LISP
    (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32115135>
    (hash-table-count table) =>  0
    (setf (gethash 57 table) "fifty-seven") =>  "fifty-seven"
    (hash-table-count table) =>  1
    (dotimes (i 100) (setf (gethash i table) i)) =>  NIL
    (hash-table-count table) =>  100
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        clrhash, remhash, gethash 的 setf

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        hash-table-size

* 注意(Notes):

        下面的关系在功能上是正确的, 尽管在实践中使用 hash-table-count 可能要快得多:

        (hash-table-count table) == 
        (loop for value being the hash-values of table count t) == 
        (let ((total 0))
          (maphash #'(lambda (key value)
                        (declare (ignore key value))
                        (incf total))
                    table)
          total)


### <span id="F-HASH-TABLE-REHASH-SIZE">函数 HASH-TABLE-REHASH-SIZE</span>

* 语法(Syntax):

        hash-table-rehash-size hash-table => rehash-size

* 参数和值(Arguments and Values):

        hash-table---一个哈希表[hash table].
        rehash-size---一个 (or (integer 1 *) (float (1.0) *)) 类型[type]的实数[real].

* 描述(Description):

        返回哈希表 hash-table 的当前再散列大小, 适合用于 make-hash-table 的调用中来产生一个带有和 hash-table 当前状态对应的状态的哈希表[hash table].

* 示例(Examples):

    ```LISP
    (setq table (make-hash-table :size 100 :rehash-size 1.4))
    =>  #<HASH-TABLE EQL 0/100 2556371>
    (hash-table-rehash-size table) =>  1.4
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 hash-table 不是一个哈希表[hash table]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        make-hash-table, hash-table-rehash-threshold

* 注意(Notes):

        如果这个哈希表被创建时带有一个表示再散列大小的整数[integer], 表示再散列时这个 hash-table 的增长率是加法的; 否则, 结果是一个浮点数[float], 表示再散列时这个 hash-table 的增长率是乘法的. 然而, 这个值只是给具体实现[implementation]的建议; 再散列时这个 hash-table 增长的实际数量是依赖于具体实现的[implementation-dependent]. 


### <span id="F-HASH-TABLE-REHASH-THRESHOLD">函数 HASH-TABLE-REHASH-THRESHOLD</span>

* 语法(Syntax):

        hash-table-rehash-threshold hash-table => rehash-threshold

* 参数和值(Arguments and Values):

        hash-table---一个哈希表[hash table].
        rehash-threshold---一个 (real 0 1) 类型[type]的实数[real].

* 描述(Description):

        返回这个 hash-table 的当前再散列阈值, 它适合用于 make-hash-table 的调用中来产生一个带有和 hash-table 当前状态对应的状态的哈希表[hash table].

* 示例(Examples):

    ```LISP
    (setq table (make-hash-table :size 100 :rehash-threshold 0.5))
    =>  #<HASH-TABLE EQL 0/100 2562446>
    (hash-table-rehash-threshold table) =>  0.5
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 hash-table 不是一个哈希表[hash table]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        make-hash-table, hash-table-rehash-size

* 注意(Notes): None. 


### <span id="F-HASH-TABLE-SIZE">函数 HASH-TABLE-SIZE</span>

* 语法(Syntax):

        hash-table-size hash-table => size

* 参数和值(Arguments and Values):

        hash-table---一个哈希表[hash table].
        size---一个非负整数[integer].

* 描述(Description):

        返回这个 hash-table 的当前大小, 适合用于 make-hash-table 的调用中来产生一个带有和 hash-table 当前状态对应的状态的哈希表[hash table].

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 hash-table 不是一个哈希表[hash table]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        hash-table-count, make-hash-table

* 注意(Notes): None.


### <span id="F-HASH-TABLE-TEST">函数 HASH-TABLE-TEST</span>

* 语法(Syntax):

        hash-table-test hash-table => test

* 参数和值(Arguments and Values):

        hash-table---一个哈希表[hash table].
        test---一个函数标识符[function designator]. 对于这四个标准化[standardlized]的哈希表[hash table]测试函数[function] (见 make-hash-table), 返回的这个 test 值总是为一个符号[symbol]. 如果一个具体实现[implementation]允许额外的测试条件, 那么这些测试条件是否作为函数[function]对象[object]或函数名字[function name]返回是依赖于具体实现的[implementation-dependent].

* 描述(Description):

        返回在这个 hash-table 中用来比较键[key]的测试条件.

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 hash-table 不是一个哈希表[hash table]那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        make-hash-table

* 注意(Notes): None. 


### <span id="A-GETHASH">访问器 GETHASH</span>

* 语法(Syntax):

        gethash key hash-table &optional default => value, present-p

        (setf (gethash key hash-table &optional default) new-value)

* 参数和值(Arguments and Values):

        key---一个对象[object].
        hash-table---一个哈希表[hash table].
        default---一个对象[object]. 默认是 nil.
        value---一个对象[object].
        present-p---一个广义 boolean [generalized boolean].

* 描述(Description):

        value 是一个在 hash-table 中键[key]在这个 hash-table 的等价性测试条件下和 key 相同[same]的对象[object]. 如果这里没有这样的条目, value 就是那个默认值 default.

        如果找到一个条目, 那么 present-p 就是 true; 否则, 它就是 false.

        setf 可以和 gethash 一起使用来修改和给定的键[key]关联的一个值[value], 或者去添加一个新的条目. 当一个 gethash 表达式形式[form]被用作一个 setf 位置时, 任何提供的默认值 default 都根据正常的从左到右的求值规则被求值, 但是它的值[value]会被忽略.

* 示例(Examples):

    ```LISP
    (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32206334>
    (gethash 1 table) =>  NIL, false
    (gethash 1 table 2) =>  2, false
    (setf (gethash 1 table) "one") =>  "one"
    (setf (gethash 2 table "two") "two") =>  "two"
    (gethash 1 table) =>  "one", true
    (gethash 2 table) =>  "two", true
    (gethash nil table) =>  NIL, false
    (setf (gethash nil table) nil) =>  NIL 
    (gethash nil table) =>  NIL, true
    (defvar *counters* (make-hash-table)) =>  *COUNTERS*
    (gethash 'foo *counters*) =>  NIL, false
    (gethash 'foo *counters* 0) =>  0, false
    (defmacro how-many (obj) `(values (gethash ,obj *counters* 0))) =>  HOW-MANY
    (defun count-it (obj) (incf (how-many obj))) =>  COUNT-IT
    (dolist (x '(bar foo foo bar bar baz)) (count-it x))
    (how-many 'foo) =>  2
    (how-many 'bar) =>  3
    (how-many 'quux) =>  0
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        remhash

* 注意(Notes):

        第二个值[secondary value], present-p, 可以被用于区分一个缺失的条目和一个有着默认值 default 的已存在条目. 


### <span id="F-REMHASH">函数 REMHASH</span>

* 语法(Syntax):

        remhash key hash-table => generalized-boolean

* 参数和值(Arguments and Values):

        key---一个对象[object].
        hash-table---一个哈希表[hash table].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        移除 hash-table 中 key 表示的条目, 如果存在的话. 如果这里有这样一个条目就返回 true, 否则返回 false.

* 示例(Examples):

    ```LISP
    (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32115666>
    (setf (gethash 100 table) "C") =>  "C"
    (gethash 100 table) =>  "C", true
    (remhash 100 table) =>  true
    (gethash 100 table) =>  NIL, false
    (remhash 100 table) =>  false
    ```

* 副作用(Side Effects):

        这个 hash-table 会被修改.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes): None. 


### <span id="F-MAPHASH">函数 MAPHASH</span>

* 语法(Syntax):

        maphash function hash-table => nil

* 参数和值(Arguments and Values):

        function---一个两参数[argument]函数[function]的标识符[designator], 这两个参数为那个键[key]和值[value].
        hash-table---一个哈希表[hash table].

* 描述(Description):

        在这个哈希表 hash-table 的所有条目上迭代. 对于每一个条目, 用两个参数[argument]调用这个函数 function--就是那个条目的键[key]和值[value].

        如果在一个 maphash 正在进行时尝试从 hash-table 移除或添加一个条目, 那么后果是未指定的, 其中有两个例外: 这个函数 function 可以使用 gethash 的 setf 来改变当前正在被处理的条目的值[value]部分, 或者它可以使用 remhash 来移除这个条目.

* 示例(Examples):

    ```LISP
    (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32304110>
    (dotimes (i 10) (setf (gethash i table) i)) =>  NIL
    (let ((sum-of-squares 0))
        (maphash #'(lambda (key val) 
                    (let ((square (* val val)))
                      (incf sum-of-squares square)
                      (setf (gethash key table) square)))
                table)
        sum-of-squares) =>  285
    (hash-table-count table) =>  10
    (maphash #'(lambda (key val)
                  (when (oddp val) (remhash key table)))
              table) =>  NIL
    (hash-table-count table) =>  5
    (maphash #'(lambda (k v) (print (list k v))) table)
    (0 0) 
    (8 64) 
    (2 4) 
    (6 36) 
    (4 16) 
    =>  NIL
    ```

* 副作用(Side Effects):

        没有, 除了任何可能由函数 function 实现的副作用.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        loop, with-hash-table-iterator, 章节 3.6 (遍历规则和副作用)

* 注意(Notes): None. 


### <span id="M-WITH-HASH-TABLE-ITERATOR">宏 WITH-HASH-TABLE-ITERATOR</span>

* 语法(Syntax):

        with-hash-table-iterator (name hash-table) declaration* form* => result*

* 参数和值(Arguments and Values):

        name---一个适合用作给 macrolet 的第一个参数的名字.
        hash-table---一个表达式形式[form], 求值一次, 它应该产生一个哈希表[hash table].
        declaration---一个 declare 表达式[expression]; 不求值.
        forms---一个隐式的 progn [implicit progn].
        results---由表达式 forms 返回的值[value].

* 描述(Description):

        在这个主体的词法作用域中, name 通过 macrolet 被定义, 这样一来连续的对 (name) 的调用会一个接一个返回这个哈希表[hash table]中的项, 这个哈希表通过只求值一次 hash-table 来获取.

        一个 (name) 返回以下三个值:

        1. 一个广义 boolean [generalized boolean], 如果返回一个条目就是 true.
        2. 这个 hash-table 条目的键.
        3. 这个 hash-table 条目的值.

        在所有条目已经通过连续调用 (name) 返回后, 只有一个值会被返回, 也就是 nil.

        如果一个迭代的任何隐式的内部状态被返回到这个 with-hash-table-iterator 表达式形式[form]的动态范围以外, 比如通过从这个调用表达式形式[form]返回某个闭包[closure].

        with-hash-table-iterator 的任意数量的调用可以是嵌套的, 并且最里边的那个的主体可以调用所有这些局部建立的宏[macro], 假定所有这些宏[macro]都有着不同[distinct]的名字.

* 示例(Examples):

        以下函数应该在任何哈希表[hash table]上返回 t, 如果 with-hash-table-iterator 的使用和对应 maphash 的使用不一致, 那么应该发出一个错误.

    ```LISP
    (defun test-hash-table-iterator (hash-table)
      (let ((all-entries '())
            (generated-entries '())
            (unique (list nil)))
        (maphash #'(lambda (key value) (push (list key value) all-entries))
                  hash-table)
        (with-hash-table-iterator (generator-fn hash-table)
          (loop     
            (multiple-value-bind (more? key value) (generator-fn)
              (unless more? (return))
              (unless (eql value (gethash key hash-table unique))
                (error "Key ~S not found for value ~S" key value))
              (push (list key value) generated-entries))))
        (unless (= (length all-entries)
                    (length generated-entries)
                    (length (union all-entries generated-entries
                                  :key #'car :test (hash-table-test hash-table))))
          (error "Generated entries and Maphash entries don't correspond"))
        t))
    ```

        下面这个可以是 maphash 通过 with-hash-table-iterator 实现的可接受定义.

    ```LISP
    (defun maphash (function hash-table)
      (with-hash-table-iterator (next-entry hash-table)
        (loop (multiple-value-bind (more key value) (next-entry)
                (unless more (return nil))
                (funcall function key value)))))
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果这个由 with-hash-table-iterator 建立的名为 name 的局部函数在它已经返回 false 作为它的主值[primary value]之后被调用, 后果是未定义的.

* 参见(See Also):

        章节 3.6 (遍历规则和副作用)

* 注意(Notes): None. 


### <span id="F-CLRHASH">函数 CLRHASH</span>

* 语法(Syntax):

        clrhash hash-table => hash-table

* 参数和值(Arguments and Values):

        hash-table---一个哈希表[hash table].

* 描述(Description):

        从 hash-table 中移除所有条目, 然后返回一个空的哈希表[hash table].

* 示例(Examples):

    ```LISP
    (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32004073>
    (dotimes (i 100) (setf (gethash i table) (format nil "~R" i))) =>  NIL
    (hash-table-count table) =>  100
    (gethash 57 table) =>  "fifty-seven", true
    (clrhash table) =>  #<HASH-TABLE EQL 0/120 32004073>
    (hash-table-count table) =>  0
    (gethash 57 table) =>  NIL, false
    ```

* 副作用(Side Effects):

        这个 hash-table 会被修改.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes): None. 


### <span id="F-SXHASH">函数 SXHASH</span>

* 语法(Syntax):

        sxhash object => hash-code

* 参数和值(Arguments and Values):

        object---一个对象[object].
        hash-code---一个非负 fixnum.

* 描述(Description):

        sxhash 返回对象 object 的一个哈希值.

        这个哈希值计算的方式是依赖于具体实现的[implementation-dependent], 但是受限于某些约束条件:

        1. (equal x y) 意味着 (= (sxhash x) (sxhash y)).

        2. 对于任意两个对象[object], x 和 y, 它们两个都是位向量[bit vector], 字符[character], cons, 数字[number], 路径名[pathname], 字符串[string], 或符号[symbol], 并且都是相似的[similar], 那么 (sxhash x) 和 (sxhash y) 产生[yield]相同的数学值, 即便 x 和 y 只存在于同一实现[implementation]的 Lisp 镜像[Lisp image]. 见章节 3.2.4 (编译后文件中的字面化对象).

        3. 对于一个对象[object]的 hash-code 在单个会话[session]中总是相同的[same], 假定对于等价性测试条件 equal 这个对象[object]没有被可见修改. 见章节 18.1.2 (修改哈希表的键).

        4. 这个 hash-code 用于散列. 这对符合标准的实现[conforming implementation]没有任何可验证的约束, 但其目的是一个实现应该作出善意的努力, 以生成在非负 fixnum 范围内分布良好的 hash-code.

        5. 这个 hash-code 必须终止, 即便这个对象 object 包含了环.

* 示例(Examples):

    ```LISP
    (= (sxhash (list 'list "ab")) (sxhash (list 'list "ab"))) =>  true
    (= (sxhash "a") (sxhash (make-string 1 :initial-element #\a))) =>  true
    (let ((r (make-random-state)))
      (= (sxhash r) (sxhash (make-random-state r))))
    =>  implementation-dependent
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        这个具体实现[implementation].

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes):

        很多常见的散列需要都是通过 make-hash-table 和在哈希表[hash table]上相关的函数满足的. sxhash 的目的是在预定义的抽象不充分的地方使用. 它的主要目的是让用户能够方便地实现比哈希表[hash table]提供的更复杂的散列范例.

        sxhash 返回的哈希值不需要和任何其他 Common Lisp 中的函数[function]使用的散列策略相关.

        对于类型[type] equal 的对象[object]用 eq 比较, 条目 3 要求这个 hash-code 基于这个对象标识的某个不变的特性. 另一个合法的实现技术是让 sxhash 为这些对象[object]分配(和缓存)一个随机的哈希值, 因为这里没有要求那个相似[similar]但是不是 eq 的对象有着相同的哈希值.

        虽然依据符号[symbol]的名字[name]和符号[symbol]可访问[accessible]的包[package]都为符号[symbol]定义了相似性[similarity], 条目 3 不允许使用包[package]信息来计算哈希值, 因为对一个符号的包状态的改变对于 equal 是不可见的. 


# 19. 文件名

> * 19.1 [文件名概述](#OverviewFilenames)
> * 19.2 [路径名](#Pathnames)
> * 19.3 [逻辑路径名](#LogicalPathnames)
> * 19.4 [文件名字典](#TheFilenamesDictionary)


## 19.1 <span id="OverviewFilenames">文件名概述</span>

这里有很多种文件系统[file system], 它们的表面语法细节, 以及它们潜在的能力和结构上都有很大的不同. 由 Common Lisp 提供的用于引用和操作文件[file]的工具选择与多类型的文件系统[file system]兼容, 同时最小化了不同文件系统[file system]之间的程序可见差异.

因为文件系统[file system]在命名文件[file]的约定上有区别, 这里有两种不同的方式来表示文件名[filename]: 作为名称字符串[namestring]和作为路径名[pathname].

> * 19.1.1 [名称字符串作为文件名](#NamestringsFilenames)
> * 19.1.2 [路径名作为文件名](#PathnamesFilenames)
> * 19.1.3 [解析名称字符串为路径名](#ParseNamestrIntoPathnames)


### 19.1.1 <span id="NamestringsFilenames">名称字符串作为文件名</span>

一个名称字符串[namestring]是表示文件名[filename]的一个字符串[string].

通常, 名称字符串[namestring]的语法涉及到具体实现定义[implementation-defined]的规约的使用, 通常是指命名文件[file]所在的文件系统[file system]的惯例. 仅有的例外是一个逻辑路径名[logical pathname]的名称字符串[namestring]的语法, 它被定义在这个规范中; 见章节 19.3.1 (逻辑路径名名称字符串的语法).

一个符合规范的程序[conforming program]永远不能无条件地使用一个字面化[literal]的名称字符串[namestring], 而不是一个逻辑路径名[logical pathname]的名称字符串[namestring]因为 Common Lisp 没有定义任何保证可移植的名称字符串[namestring]的语法, 除了逻辑路径名[logical pathname]的名称字符串. 然而, 一个符合规范的程序[conforming program], 如果足够小心, 可以成功地操纵用户提供的包含或引用不可移植的名称字符串[namestring]的数据.

一个名称字符串[namestring]可以通过函数[function] pathname 或 parse-namestring 强制转为路径名[pathname]. 


### 19.1.2 <span id="PathnamesFilenames">路径名作为文件名</span>

路径名[pathname]是结构化的对象[object], 可以用一种独立于具体实现的[implementation-independent]方式表示底层文件系统[file system]本地使用的文件名[filename].

另外, 路径名[pathname]还可以表示某些部分组成的文件名[filename], 对于这些路径名底层文件系统[file system]可能没有特定的名称字符串[namestring]表示.

一个路径名[pathname]不需要对应任何实际上已存在的文件, 并且多个路径名[pathname]可以引用相同文件. 比如, 这个带有一个 :newest 版本的路径名[pathname]可能和一个带有除了某个数字作为版本以外相同成分的路径名[pathname]引用相同的文件. 事实上, 随着时间推移一个带有版本 :newest 的路径名[pathname]可能引用不同的文件, 因为这样一个路径名[pathname]的意义取决于文件系统的状态.

某些文件系统[file system]自然地为它们的文件名[filename]使用一个结构模型, 而其他的则没有. 在 Common Lisp 路径名[pathname]模型中, 所有文件名[filename]都被视作有着一个特定结构, 即便那个结构没有反映在底层文件系统[file system]中. 由路径名[pathname]暗示的结构和底层文件系统[file system]所使用的结构(如果有的话)之间的映射性质是由具体实现定义的[implementation-defined].

每一个路径名[pathname]都有六个成员: 一个主机(host), 一个设备(device), 一个目录(directory), 一个名字(name), 一个类型(type), 和一个版本(version). 通过用路径名[pathname]来命名文件[file], 即使在文件系统[file system]中看起来很不一样, Common Lisp 程序可以以相同的方式工作. 关于这些成分的详细描述, 见章节 19.2.1 (路径名成员).

这些路径名[pathname]成员到每个文件系统[file system]的特有概念的映射是由具体实现定义的[implementation-defined]. 在特定的实现[implementation]中存在可想到的路径名[pathname]没有映射到语法有效的文件名[filename]. 一个具体实现[implementation]可能使用多种策略去尝试找到一个映射; 例如, 一个实现[implementation]可能会悄悄地截断超过底层文件系统施加的长度限制的文件名[filename], 或者忽略文件系统[file system]不提供支持的某些路径名[pathname]成员. 如果没有找到这样一个映射, 就会发出一个 file-error 类型[type]的错误.

这个映射和关联的错误发出的时间是依赖于具体实现的[implementation-dependent]. 具体来说, 它可能出现在这个路径名[pathname]被构造时, 把一个路径名[pathname]强制转为名称字符串[namestring]时, 或者尝试去打开[open]或访问这个路径名[pathname]表示的文件[file]时.

下面这段列出了一些可应用于路径名[pathname]的已定义的名字[defined name].

    *default-pathname-defaults*  namestring          pathname-name          
    directory-namestring         open                pathname-type          
    enough-namestring            parse-namestring    pathname-version       
    file-namestring              pathname            pathnamep              
    file-string-length           pathname-device     translate-pathname     
    host-namestring              pathname-directory  truename               
    make-pathname                pathname-host       user-homedir-pathname  
    merge-pathnames              pathname-match-p    wild-pathname-p        

    Figure 19-1. 路径名操作

### 19.1.3 <span id="ParseNamestrIntoPathnames">解析名称字符串为路径名</span>

解析是一个被用于转换一个名称字符串[namestring]为一个路径名[pathname]的操作. 除了在解析逻辑路径名[logical pathname]名称字符串[namestring]时, 这个操作是依赖于具体实现的[implementation-dependent], 因为这个名称字符串[namestring]的格式是依赖于具体实现的[implementation-dependent].

一个符合规范的实现[conforming implementation]可以在它的路径名[pathname]表示中自由地包含其他文件系统[file system]特性并且提供一个可以处理名称字符串[namestring]中这样的说明的解析器. 符合规范的程序[conforming program]一定不能依赖这样的特性, 因为这些特性不是可移植的. 

## 19.2 <span id="Pathnames">路径名</span>

> * 19.2.1 [路径名成员](#PathnameComponents)
> * 19.2.2 [解释路径名成员值](#InterpretPathnameCompValues)
> * 19.2.3 [合并路径名](#MergingPathnames)

### 19.2.1 <span id="PathnameComponents">路径名成员</span>

一个路径名[pathname]有六个成员: 一个主机(host), 一个设备(device), 一个目录(directory), 一个名字(name), 一个类型(type), 和一个版本(version).

#### 19.2.1.1 路径名主机成员

文件所在的文件系统的名称，或者逻辑主机[logical host]的名称.

#### 19.2.1.2 路径名设备成员

在许多主机文件系统中对应于"设备"或"文件结构"概念: 就是包含这些文件的逻辑或物理设备的名字. 

#### 19.2.1.3 路径名目录成员

在许多主机文件系统中对应于"目录"概念: 就是一组相关文件的名字. 

#### 19.2.1.4 路径名名字成员

一组文件的"名称"部分, 可以认为是概念上相关的. 

#### 19.2.1.5 路径名类型成员

在许多主机文件系统中对应于"文件类型"或"扩展"概念. 这说明了这是什么类型的文件. 这个成员总是为一个字符串[string], nil, :wild, 或 :unspecific. 

#### 19.2.1.6 路径名版本成员

对应于许多主机文件系统中的"版本号"概念.

这个版本是一个整数[integer]或者是下面列表中的一个符号[symbol]: nil, :wild, :unspecific, 或 :newest (指在读取文件时, 文件系统中已经存在的最大版本号, 或者在编写新文件时比文件系统中已有的版本号更大的版本号). 具体实现可以定义其他特别的版本符号[symbol]. 


### 19.2.2 <span id="InterpretPathnameCompValues">解释路径名成员值</span>

> * 19.2.2.1 [成员值中的字符串](#StringsComponentValues)
> * 19.2.2.2 [特殊路径名成员值](#SpecPathnameComponentValues)
> * 19.2.2.3 [通配符路径名上的限制](#RestrictionWildcardPathnames)
> * 19.2.2.4 [检查路径名成员的限制](#RestrictionExamPathnameComponents)
> * 19.2.2.5 [构造路径名的限制](#RestrictConstructPathnames)

#### 19.2.2.1 <span id="StringsComponentValues">成员值中的字符串</span>

##### 19.2.2.1.1 路径名成员中的特殊字符

路径名[pathname]成员值中的字符串[string]从不包含表示路径名[pathname]字段之间分隔符的特殊字符[character], 比如 Unix 文件名[filename]中的斜杠[slash]. 分隔符字符[character]是否允许作为一个路径名[pathname]成员中字符串[string]的一部分是具体实现定义的[implementation-defined]; 然而, 如果具体实现[implementation]确实允许这个, 它必须在构造一个名称字符串[namestring]时, 安排正确地"引用"文件系统[file system]的字符. 例如,

```LISP
 ;; In a TOPS-20 implementation, which uses ^V to quote 
 (NAMESTRING (MAKE-PATHNAME :HOST "OZ" :NAME "<TEST>"))
=>  #P"OZ:PS:^V<TEST^V>"
NOT=>  #P"OZ:PS:<TEST>"
```

##### 19.2.2.1.2 路径名成员中的大小写

名称字符串[namestring]总是使用本地文件系统的大小写[case]约定, 但是操纵路径名[pathname]成员的 Common Lisp 函数[function]允许调用者通过给 :case 参数提供一个值去选择两种表示成员值大小写[case]约定中的任意一种. 下一段列出了和允许 :case 参数的路径名[pathname]相关函数:

    make-pathname    pathname-directory  pathname-name  
    pathname-device  pathname-host       pathname-type  

    Figure 19-2. 使用 :CASE 参数的路径名函数

###### 19.2.2.1.2.1 路径名成员中的本地大小写

对于 Figure 19-2 中的函数, :case 参数的一个 :local 值 (对于这些函数的默认值) 表示这些函数应该接受并产生成员值中的字符串[string], 就好像它们已经根据主机文件系统[file system]的大小写[case]约定表示了一样.

如果这个文件系统[file system]两种大小写[case]都支持, 在这个协议下作为路径名[pathname]成员值给定或接收的字符串[string]将与写入的字符串一样使用. 如果这个文件系统只支持一种大小写[case], 那么这个字符串[string]会被转成那个大小写[case]. 


###### 19.2.2.1.2.2 路径名成员中的通用大小写

对于 Figure 19-2 中的函数, :case 参数的一个 :common 值表示这些函数[function]应该根据以下约定接受和产生成员值中的字符串[string]:

* 所有都是大写[uppercase]意味着使用一个文件系统习惯的大小写[case].
* 所有都是小写[lowercase]字母表示使用与习惯情况相反的大小写[case].
* 混合大小写[case]就表示自身.

注意, 这些约定以这样一种方式被选择: 从 :local 转换到 :common 并转换回 :local 信息保持不变. 


#### 19.2.2.2 <span id="SpecPathnameComponentValues">特殊路径名成员值</span>

##### 19.2.2.2.1 NIL 作为一个成员值

作为一个路径名[pathname]成员值, nil 表示这个成员是"没有被填充"; 见章节 19.2.3 (合并路径名).

任何路径名[pathname]成员值可以是 nil.

在构造一个路径名[pathname]时, 在主机成员的 nil 可能意味着一个默认主机而不是在某些实现[implementation]中的一个实际的 nil. 


##### 19.2.2.2.2 :WILD 作为一个成员值

如果 :wild 是一个路径名[pathname]成员的值, 那个成员被认为是一个通配符, 它可以匹配任何东西.

一个符合规范的程序[conforming program]必须准备好遇到一个值: :wild 作为任何路径名[pathname]成员的值, 或者作为目录成员的值列表[list]的元素[element].

在构造一个路径名[pathname]时, 一个符合规范的程序[conforming program]可能使用 :wild 作为目录, 名字, 类型, 或版本成员的其中一个或所有的值, 但是一定不能使用 :wild 作为主机, 或设备成员的值.

在构造一个路径名[pathname]时如果 :wild 被用作这个目录成员的值, 效果等价于指定 (:absolute :wild-inferiors), 或者等价于一个不支持 :wild-inferiors 的文件系统[file system]的 (:absolute :wild). 

##### 19.2.2.2.3 :UNSPECIFIC 作为成员值

如果 :unspecific 是一个路径名[pathname]的成员值, 这个成员就被认为是"缺失的"或者在这个这个路径名[pathname]表示的文件名[filename]中"没有意义的".

在这个实现[implementation]可以访问的任何给定文件系统[file system]的任何成员上, 一个 :unspecific 值是否被允许是具体实现定义的[implementation-defined]. 一个符合规范的程序[conforming program]一定不能无条件使用一个 :unspecific 作为一个路径名[pathname]成员的值, 因为这样一个值不保证在所有实现都是允许的. 然而, 一个符合规范的程序[conforming program], 如果足够小心, 可以成功地操纵用户提供的包含或引用不可移植的路径名[pathname]成员的数据. 当然, 一个符合规范的程序[conforming program]应该为一个路径名[pathname]的任何成员都可能是 :unspecific 的可能性做好准备.

当读取[read[1]]任何路径名[pathname]成员的值时, 符合规范的程序[conforming program]应该对值为 :unspecific 有所准备.

当写入[write[1]]任何路径名[pathname成员的值时, 如果 :unspecific 在文件系统[file system]中被赋予给一个路径名[pathname], 那么其后果是没有定义的, 因为它没有意义.

###### 19.2.2.2.3.1 成员值 NIL 和 :UNSPECIFIC 之间的联系

如果一个路径名[pathname]被转换为一个名称字符串[namestring], 返回符号[symbol] nil 和 :unspecific 导致要被处理的那个域就像是空的一样. 这也就是说, nil 和 :unspecific 都导致这个成员不会出现在名称字符串[namestring]中.

然而, 在合并一个路径名[pathname]和一个默认值集合时, 只有一个成员的 nil 值会被那个成员的默认值替换, 而一个 :unspecific 值会被留下来就好像这个域已经被"填充"了; 见函数[function] merge-pathnames 和章节 19.2.3 (合并路径名). 


#### 19.2.2.3 <span id="RestrictionWildcardPathnames">通配符路径名上的限制</span>

通配符路径名[pathname]可以和 directory 一起使用, 但是不能和 open 一起使用, 并且从 wild-pathname-p 返回 true. 在检查通配符路径名[pathname]的通配符成员时, 符合规范的程序[conforming program]必须准备好在任何成员或目录成员的列表[list]的任何元素中遇到下列附加值:

* 符号[symbol] :wild, 它匹配任何东西.

* 一个包含依赖于具体实现[implementation-dependent]的特殊通配字符[character]的字符串[string].

* 任何对象[object], 表示依赖于具体实现[implementation-dependent]的一个通配符模式. 


#### 19.2.2.4 <span id="RestrictionExamPathnameComponents">检查路径名成员的限制</span>

一个符合条件的程序[conforming program]必须为以下情况做准备: 作为路径名[pathname]成员的值来读取[read[1]]的可能的对象[object]的空间, 要比一个符合规范的程序[conforming program]允许被写入[write[1]]到这样一个成员的可能的对象[object]的空间大得多.

尽管在这个章节的子章节, 在章节 19.2.2.2 (特殊路径名成员值), 还有章节 19.2.2.3 (通配符路径名上的限制) 中讨论的值可以被应用于读取成员值时可见的值, 而对于构造路径名, 应用了更多的限制性规则; 见章节 19.2.2.5 (构造路径名的限制).

在检查路径名[pathname]成员时, 符合规范的程序[conforming program]应该知道以下限制.

##### 19.2.2.4.1 检查路径名主机成员的限制

什么对象[object]被用于表示这个主机是依赖于具体实现的[implementation-dependent]. 

##### 19.2.2.4.2 检查路径名设备成员的限制

这个设备可能是一个字符串[string], :wild, :unspecific, 或 nil.

注意, 这个 :wild 可能产生于读取[read[1]]这个路径名[pathname]成员的尝试中, 即便限制可移植程序写入[write[1]]这样的成员值; 见章节 19.2.2.3 (通配符路径名上的限制) 以及章节 19.2.2.5 (构造路径名的限制). 


##### 19.2.2.4.3 检查路径名目录成员的限制

目录可能是一个字符串[string], :wild, :unspecific, 或 nil.

目录可以是一个字符串[string]和符号[symbol]的列表[list]. 这个列表的 car 是符号 :absolute 或 :relative 其中之一, 表示:

:absolute

    一个 car 为符号 :absolute 的列表[list]表示一个以根目录开始的目录路径. 列表 (:absolute) 表示根目录. 列表 (:absolute "foo" "bar" "baz") 表示 Unix 中的 "/foo/bar/baz" 目录 (可能的大小写[case]除外).

:relative

    一个 car 为符号 :relative 的列表[list]表示一个以默认目录开始的目录路径. 列表 (:relative) 有着和 nil 相同的意义, 因此没有被使用. 列表 (:relative "foo" "bar") 表示默认目录中名为 "foo" 的目录中的 "bar" 目录.

这个列表[list]的每一个剩余元素都是一个字符串[string]或符号[symbol].

每一个字符串[string]命名目录结构中的单个层级. 这些字符串[string]应该只包含目录名字自身---没有标点符号.

在这个列表[list]的任何位置, 都可以使用符号[symbol]来表示特殊的文件符号, 而不是一个字符串[string]. 下面一段列出的符号[symbol]有着标准意义. 如果有必要去表示不能用标准字符串[string]和符号[system]表示的文件系统的特性, 允许具体实现去添加和 string 互斥的任意类型[type]的额外对象[object].

给一个文件系统提供任何非字符串[string], 包含下面列出的任意符号[symbol], 如果它们对于这个文件系统是没有意义的, 那么就会发出一个 file-error 类型[type]的错误. 比如, Unix 在大部分实现不支持 :wild-inferiors.

    符号              意义                                             
    :wild            目录结构中一级的通配符匹配
    :wild-inferiors  目录结构中任意数量的通配符匹配    
    :up              在目录结构中向上一级 (语义)         
    :back            在目录结构中向上一级 (语法)        

    Figure 19-3. 目录成员中的特殊标记

下面的注释适用于前面这段:

无效组合

    使用 :absolute 或 :wild-inferiors 后立即跟着 :up 或 :back 会发出一个 file-error 类型[type]的错误.

语法 vs 语义

    "语法" 意味着那个 :back 动作只依赖于这个路径名[pathname], 不依赖这个文件系统的内容.

    "语义" 意味着那个 :up 的动作依赖于文件系统的内容; 为了解决一个路径名[pathname]包含了 :up 到一个目录成员只包含 :absolute 和字符串[string]的路径名[pathname]需要探索这个文件系统的问题.

    :up 和 :back 的区别仅在于文件系统支持多个目录名, 或许是通过符号链接. 例如, 假设这里有一个目录 (:absolute "X" "Y" "Z") 链接到 (:absolute "A" "B" "C") 并且这里也存在目录 (:absolute "A" "B" "Q") 和 (:absolute "X" "Y" "Q"). 那么 (:absolute "X" "Y" "Z" :up "Q") 表示 (:absolute "A" "B" "Q") 而 (:absolute "X" "Y" "Z" :back "Q") 表示 (:absolute "X" "Y" "Q")


###### 19.2.2.4.3.1 非分层文件系统中的目录成员

在非分层文件系统[file system]中, 一个路径名[pathname]的目录成员的仅有的有效列表[list]值是 (:absolute string) 和 (:absolute :wild). :relative 目录和关键字 :wild-inferiors, :up, 和 :back 在非分层文件系统[file system]中是不使用的. 


##### 19.2.2.4.4 检查路径名名称成员的限制

名称可以是一个字符串[string], :wild, :unspecific, 或 nil. 


##### 19.2.2.4.5 检查路径名类型成员的限制

类型可以是一个字符串[string], :wild, :unspecific, 或 nil. 


##### 19.2.2.4.6 检查路径名版本成员的限制

这个版本可以是任何符号[symbol]或整数[integer].

在读取, 覆盖, 追加, 代替, 或列出现有文件[file]的目录时, 符号 :newest 引用已经存在于文件系统[file system]中最大的版本数字. 在创建一个新的文件时, 符号 :newest 引用大于任何已存在版本数字的最小的版本数字.

符号 nil, :unspecific, 和 :wild 有着特殊意义和限制; 见章节 19.2.2.2 (特殊路径名成员值) 和章节 19.2.2.5 (构造路径名的限制).

其他符号[system]和整数[integer]有着具体实现定义[implementation-defined]的意义.


##### 19.2.2.4.7 关于路径名版本成员的注意事项

建议, 但不是必须, 具体实现执行以下操作:

* 使用从 1 开始的正整数[integer]作为版本数字.

* 识别符号 :oldest 来表示最小的已存在版本数字.

* 为其他特殊版本使用关键字[keyword]. 


#### 19.2.2.5 <span id="RestrictConstructPathnames">构造路径名的限制</span>

从成员来构造一个路径名[pathname]时, 符合规范的程序必须遵守这些规则:

* 任何成员可以是 nil. 在一些实现中, 主机中的 nil 可能意味着一个默认主机而不是一个实际的 nil.

* 主机, 设备, 目录, 名字, 以及类型可以是字符串[string]. 在这些字符串[string]中的字符[character]的类型和数量上有着依赖于具体实现[implementation-dependent]的限制.

* 目录可以是一个字符串[string]和符号[system]的列表[list]. 在这个列表[list]的长度和内容上有着依赖于具体实现[implementation-dependent]的限制.

* 版本可以是 :newest.

* 任何成员都可以从另一个路径名[pathname]的相应成员中获取. 当两个路径名[pathname]是对于不同的文件系统时 (在支持多文件系统的实现中), 会出现一个适当的转换. 如果没有任何有意义的转换, 就会出现错误. 这个 "适当" 和 "有意义" 的定义是依赖于具体实现的.

* 对于某些成员, 一个实现可能支持其他的值, 但是一个可移植程序不能使用这些值. 一个符合规范的程序可以使用依赖于具体实现[implementation-dependent]的值但是这会使它变得不可移植; 例如, 它可能只有在 Unix 文件系统中正常工作. 

### 19.2.3 <span id="MergingPathnames">合并路径名</span>

合并操作接受一个带有未填充成员的路径名[pathname], 并从默认值中为这些成员提供值.

如果一个成员的值是 nil, 那么那个成员会被认为是未填充的. 如果一个成员的值是任何非 nil [non-nil]对象[object], 包括 :unspecific, 那么那个成员会被认为是已填充的.

除了显式指定的以外, 对于操作或查询文件系统[file system]中的文件[file]的函数, 在访问这个文件系统[file system]前, 提供给这个函数的路径名参数会和 \*default-pathname-defaults* 合并(就像是通过 merge-pathnames 一样).

#### 19.2.3.1 合并路径名的示例

虽然下面这些示例可能只有在允许 :unspecific 出现在指定位置并且允许四字母类型成员的实现[implementation]中执行, 但是它们可以用来说明路径名[pathname]合并的基本概念.

    ```LISP
    (pathname-type 
      (merge-pathnames (make-pathname :type "LISP")
                        (make-pathname :type "TEXT")))
    =>  "LISP"

    (pathname-type 
      (merge-pathnames (make-pathname :type nil)
                        (make-pathname :type "LISP")))
    =>  "LISP"

    (pathname-type 
      (merge-pathnames (make-pathname :type :unspecific)
                        (make-pathname :type "LISP")))
    =>  :UNSPECIFIC
    ```


## 19.3 <span id="LogicalPathnames">逻辑路径名</span>

> * 19.3.1 [逻辑路径名名称字符串的语法](#SyntaxLogicalPathnameNamestr)
> * 19.3.2 [逻辑路径名成员](#LogicalPathnameComponents)


### 19.3.1 <span id="SyntaxLogicalPathnameNamestr">逻辑路径名名称字符串的语法</span>

逻辑路径名[logical pathname]名称字符串[namestring]的语法如下. (注意, 与本文档中的许多符号描述不同, 这是对字符序列的语法描述, 而不是对象的结构描述.)

    logical-pathname::= [host host-marker]  
                        [relative-directory-marker] {directory directory-marker}*  
                        [name] [type-marker type [version-marker version]] 

    host::= word 

    directory::= word | wildcard-word | wild-inferiors-word 

    name::= word | wildcard-word 

    type::= word | wildcard-word 

    version::= pos-int | newest-word | wildcard-version 

    host-marker---一个冒号[colon].

    relative-directory-marker---一个分号[semicolon].

    directory-marker---一个分号[semicolon].

    type-marker---一个点[dot].

    version-marker---一个点[dot].

    wild-inferiors-word---两个字符的序列 "**" (两个星号[asterisk]).

    newest-word---六个字符的序列 "newest" 或者六个字符的序列 "NEWEST".

    wildcard-version---一个星号[asterisk].

    wildcard-word---一个或多个星号[asterisk], 大写字母, 数字, 以及连字符, 包含至少一个星号[asterisk], 其中没有相邻的两个星号[asterisk].

    word---一个或多个大写字母, 数字, 以及连字符.

    pos-int---一个正整数[integer].

#### 19.3.1.1 关于解析逻辑路径名名称字符串的额外信息

##### 19.3.1.1.1 逻辑路径名名称字符串的主机部分

这个主机(host)必须已经被定义为一个逻辑路径名[logical pathname]主机; 这个可以通过 logical-pathname-translations 的 setf 来完成.

逻辑路径名[logical pathname]主机名 "SYS" 为具体实现保留了. 这个 SYS: 逻辑路径名[logical pathname]的存在性和意义是具体实现定义的[implementation-defined].

##### 19.3.1.1.2 逻辑路径名名称字符串的设备部分

这里没有逻辑路径名[logical pathname]设备的语法, 因为一个逻辑路径名[logical pathname]的设备成员总是为 :unspecific; 见章节 19.3.2.1 (一个逻辑路径名的未指定成员). 

##### 19.3.1.1.3 逻辑路径名名称字符串的目录部分

如果在这些 directory 之前有一个 relative-directory-marker, 这个目录成员会被解析为是相对的[relative]; 否则, 这个目录成员会被解析为绝对的[absolute].

如果指定了一个 wild-inferiors-marker, 它被解析为 :wild-inferiors. 

##### 19.3.1.1.4 逻辑路径名名称字符串的类型部分

一个源码文件[source file]的逻辑路径名[logical pathname]的类型(type)是 "LISP". 这应该被转换成任何在物理路径名中合适的类型. 

##### 19.3.1.1.5 逻辑路径名名称字符串的版本部分

一些文件系统[file system]没有版本[version]. 对于这样一个文件系统[file system], 逻辑路径名[logical pathname]的转换会忽略版本[version]. 这意味着程序不能依赖于能够存储一个由逻辑路径名[logical pathname]命名的文件的多个版本.

如果指定了一个 wildcard-version, 它被解析为 :wild. 

##### 19.3.1.1.6 逻辑路径名名称字符串的通配符

在一个 wildcard-word 中的每一个星号[asterisk]匹配零或多个字符的序列. 这个 wildcard-word "*" 解析为 :wild; 其他 wildcard-word 解析为字符串[string]. 


##### 19.3.1.1.7 逻辑路径名名称字符串的小写字母

在解析 words 和 wildcard-words 时, 小写字母会被转换为大写的. 

##### 19.3.1.1.8 逻辑路径名名称字符串的其他语法

在一个逻辑路径名[logical pathname]名称字符串[namestring]中使用除了这里指定的以外的字符的后果是不确定的.

使用任何没有在这里指定的值作为一个逻辑路径名[logical pathname]的成员的后果是不确定的. 

### 19.3.2 <span id="LogicalPathnameComponents">逻辑路径名成员</span>

#### 19.3.2.1 一个逻辑路径名的未指定成员

一个逻辑路径名[logical pathname]的设备成员总是为 :unspecific; 没有逻辑路径名[logical pathname]的其他成员可以是 :unspecific. 

#### 19.3.2.2 空字符串作为逻辑路径名的成员

空字符串, "", 不是一个逻辑路径名[logical pathname]任意成员的有效值. 

## 19.4 <span id="TheFilenamesDictionary">文件名字典</span>

> * [系统类 PATHNAME](#SC-PATHNAME)
> * [系统类 LOGICAL-PATHNAME](#SC-LOGICAL-PATHNAME)
> * [函数 PATHNAME](#F-PATHNAME)
> * [函数 MAKE-PATHNAME](#F-MAKE-PATHNAME)
> * [函数 PATHNAMEP](#F-PATHNAMEP)
> * [函数 PATHNAME-HOST, PATHNAME-DEVICE, PATHNAME-DIRECTORY, PATHNAME-NAME, PATHNAME-TYPE, PATHNAME-VERSION](#F-PATHNAME-ALL)
> * [函数 LOAD-LOGICAL-PATHNAME-TRANSLATIONS](#F-LOAD-LOGICAL-PATHNAME-TRANSLATIONS)
> * [访问器 LOGICAL-PATHNAME-TRANSLATIONS](#A-LOGICAL-PATHNAME-TRANSLATIONS)
> * [函数 LOGICAL-PATHNAME](#F-LOGICAL-PATHNAME)
> * [变量 *DEFAULT-PATHNAME-DEFAULTS*](#V-DEFAULT-PATHNAME-DEFAULTS)
> * [函数 NAMESTRING, FILE-NAMESTRING, DIRECTORY-NAMESTRING, HOST-NAMESTRING, ENOUGH-NAMESTRING](#F-NAMESTRING-ALL)
> * [函数 PARSE-NAMESTRING](#F-PARSE-NAMESTRING)
> * [函数 WILD-PATHNAME-P](#F-WILD-PATHNAME-P)
> * [函数 PATHNAME-MATCH-P](#F-PATHNAME-MATCH-P)
> * [函数 TRANSLATE-LOGICAL-PATHNAME](#F-TRANSLATE-LOGICAL-PATHNAME)
> * [函数 TRANSLATE-PATHNAME](#F-TRANSLATE-PATHNAME)
> * [函数 MERGE-PATHNAMES](#F-MERGE-PATHNAMES)

### <span id="SC-PATHNAME">系统类 PATHNAME</span>

* 类优先级列表(Class Precedence List):

        pathname, t

* 描述(Description):

        一个路径名[pathname]是一个表示一个文件名[filename]的结构化对象[object].

        这里有两种路径名[pathname]---物理路径名[physical pathname]和逻辑路径名[logical pathname]. 


### <span id="SC-LOGICAL-PATHNAME">系统类 LOGICAL-PATHNAME</span>

* 类优先级列表(Class Precedence List):

        logical-pathname, pathname, t

* 描述(Description):

        一个使用独立于具体实现[implementation-independent]的名称字符串[namestring]语法并且有着独立于具体实现[implementation-independent]的成员值的路径名[pathname]. 逻辑路径名[logical pathname]不会直接引用文件名[filename].

* 参见(See Also):

        章节 20.1 (文件系统概念), 章节 2.4.8.14 (井号P(#P)), 章节 22.1.3.11 (打印路径名) 


### <span id="F-PATHNAME">函数 PATHNAME</span>

* 语法(Syntax):

        pathname pathspec => pathname

* 参数和值(Arguments and Values):

        pathspec---一个路径名标识符[pathname designator].
        pathname---一个路径名[pathname].

* 描述(Description):

        返回路径名标识符 pathspec 表示的路径名[pathname].

        如果这个 pathspec 标识符[designator]是一个流[stream], 那么这个流[stream]可以是打开的或关闭的; 不管在哪种情况, 返回的路径名 pathname 对应被用于打开这个文件[file]的对应文件名[filename]. 在一个文件流[file stream]被关闭后, pathname 还是返回和它被打开时相同的路径名[pathname].

        如果这个 pathspec 标识符[designator]是通过打开一个逻辑路径名[logical pathname]所创建的一个文件流[file stream], 那么就返回一个逻辑路径名[logical pathname].

* 示例(Examples):

    ```LISP
    ;; There is a great degree of variability permitted here.  The next
    ;; several examples are intended to illustrate just a few of the many
    ;; possibilities.  Whether the name is canonicalized to a particular
    ;; case (either upper or lower) depends on both the file system and the
    ;; implementation since two different implementations using the same
    ;; file system might differ on many issues.  How information is stored
    ;; internally (and possibly presented in #S notation) might vary,
    ;; possibly requiring `accessors' such as PATHNAME-NAME to perform case
    ;; conversion upon access.  The format of a namestring is dependent both
    ;; on the file system and the implementation since, for example, one
    ;; implementation might include the host name in a namestring, and
    ;; another might not.  #S notation would generally only be used in a
    ;; situation where no appropriate namestring could be constructed for use
    ;; with #P.
    (setq p1 (pathname "test"))
    =>  #P"CHOCOLATE:TEST" ; with case canonicalization (e.g., VMS)
    OR=>  #P"VANILLA:test"   ; without case canonicalization (e.g., Unix)
    OR=>  #P"test"
    OR=>  #S(PATHNAME :HOST "STRAWBERRY" :NAME "TEST")
    OR=>  #S(PATHNAME :HOST "BELGIAN-CHOCOLATE" :NAME "test")
    (setq p2 (pathname "test"))
    =>  #P"CHOCOLATE:TEST"
    OR=>  #P"VANILLA:test"
    OR=>  #P"test"
    OR=>  #S(PATHNAME :HOST "STRAWBERRY" :NAME "TEST")
    OR=>  #S(PATHNAME :HOST "BELGIAN-CHOCOLATE" :NAME "test")
    (pathnamep p1) =>  true
    (eq p1 (pathname p1)) =>  true
    (eq p1 p2)
    =>  true
    OR=>  false
    (with-open-file (stream "test" :direction :output)
      (pathname stream))
    =>  #P"ORANGE-CHOCOLATE:>Gus>test.lisp.newest"
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        pathname, logical-pathname, 章节 20.1 (文件系统概念), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes): None. 


### <span id="F-MAKE-PATHNAME">函数 MAKE-PATHNAME</span>

* 语法(Syntax):

        make-pathname &key host device directory name type version defaults case
        => pathname

* 参数和值(Arguments and Values):

        host---一个有效物理路径名主机[valid physical pathname host]. 复杂的缺省行为; 见下方.
        device---一个有效路径名设备[valid pathname device]. 复杂的缺省行为; 见下方.
        directory---一个有效路径名目录[valid pathname directory]. 复杂的缺省行为; 见下方.
        name---一个有效路径名名称[valid pathname name]. 复杂的缺省行为; 见下方.
        type---一个有效路径名类型[valid pathname type]. 复杂的缺省行为; 见下方.
        version---一个有效路径名版本[valid pathname version]. 复杂的缺省行为; 见下方.
        defaults---一个路径名标识符[pathname designator]. 默认是一个主机成员和 *default-pathname-defaults* 的主机成员相同, 而其他成员都是 nil 的路径名[pathname].
        case---:common 或 :local 其中之一. 默认是 :local.
        pathname---一个路径名[pathname].

* 描述(Description):

        从提供的关键字参数中构造并返回一个路径名[pathname].

        在由 host, device, directory, name, type, 和 version 显式提供的成员被填充之后, merge-pathnames 使用的合并规则被用于填充 defaults 提供的默认值中的任何未提供的成员.

        只要构造了路径名[pathname], 就可以在适当的情况下规范化成员. 关于可以提供给每个成员的参数的解释, 见章节 19.2.1 (路径名成员).

        如果提供了 case, 它会像章节 19.2.2.1.2 (路径名成员中的大小写) 描述的那样被处理.

        当且仅当产生的这个路径名 pathname 的主机成员是一个逻辑主机[logical host]或者是一个命名已定义的逻辑主机[logical host]的字符串[string]时, 这个路径名 pathname 是一个逻辑路径名[logical pathname].

        如果这个 directory 是一个字符串[string], 它应该是一个顶层目录的名字, 并且不应该包含任何标点符号字符; 这就是说, 指定一个字符串[string], str, 等价于指定列表 (:absolute str). 指定符号 :wild 等价于指定列表 (:absolute :wild-inferiors), 或者在一个不支持 :wild-inferiors 的文件系统中就是 (:absolute :wild).

* 示例(Examples):

    ```LISP
    ;; Implementation A -- an implementation with access to a single
    ;;  Unix file system.  This implementation happens to never display
    ;;  the `host' information in a namestring, since there is only one host. 
    (make-pathname :directory '(:absolute "public" "games")
                    :name "chess" :type "db")
    =>  #P"/public/games/chess.db" 

    ;; Implementation B -- an implementation with access to one or more
    ;;  VMS file systems.  This implementation displays `host' information
    ;;  in the namestring only when the host is not the local host.
    ;;  It uses a double colon to separate a host name from the host's local
    ;;  file name.
    (make-pathname :directory '(:absolute "PUBLIC" "GAMES")
                    :name "CHESS" :type "DB")
    =>  #P"SYS$DISK:[PUBLIC.GAMES]CHESS.DB" 
    (make-pathname :host "BOBBY"
                    :directory '(:absolute "PUBLIC" "GAMES")
                    :name "CHESS" :type "DB")
    =>  #P"BOBBY::SYS$DISK:[PUBLIC.GAMES]CHESS.DB" 

    ;; Implementation C -- an implementation with simultaneous access to
    ;;  multiple file systems from the same Lisp image.  In this 
    ;;  implementation, there is a convention that any text preceding the
    ;;  first colon in a pathname namestring is a host name.
    (dolist (case '(:common :local))
      (dolist (host '("MY-LISPM" "MY-VAX" "MY-UNIX"))
        (print (make-pathname :host host :case case
                              :directory '(:absolute "PUBLIC" "GAMES")
                              :name "CHESS" :type "DB"))))
    >>  #P"MY-LISPM:>public>games>chess.db"
    >>  #P"MY-VAX:SYS$DISK:[PUBLIC.GAMES]CHESS.DB"
    >>  #P"MY-UNIX:/public/games/chess.db"
    >>  #P"MY-LISPM:>public>games>chess.db" 
    >>  #P"MY-VAX:SYS$DISK:[PUBLIC.GAMES]CHESS.DB" 
    >>  #P"MY-UNIX:/PUBLIC/GAMES/CHESS.DB" 
    =>  NIL
    ```

* 受此影响(Affected By):

        文件系统[file system].

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        merge-pathnames, pathname, logical-pathname, 章节 20.1 (文件系统概念), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes):

        可移植程序不应该为任何成员提供 :unspecific. 见章节 19.2.2.2.3 (:UNSPECIFIC 作为成员值). 


### <span id="F-PATHNAMEP">函数 PATHNAMEP</span>

* 语法(Syntax):

        pathnamep object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 pathname 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (setq q "test")  =>  "test"
    (pathnamep q) =>  false
    (setq q (pathname "test"))
    =>  #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME "test" :TYPE NIL
          :VERSION NIL)
    (pathnamep q) =>  true 
    (setq q (logical-pathname "SYS:SITE;FOO.SYSTEM"))
    =>  #P"SYS:SITE;FOO.SYSTEM"
    (pathnamep q) =>  true
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes):

        (pathnamep object) ==  (typep object 'pathname)


### <span id="F-PATHNAME-ALL">函数 PATHNAME-HOST, PATHNAME-DEVICE, PATHNAME-DIRECTORY, PATHNAME-NAME, PATHNAME-TYPE, PATHNAME-VERSION</span>

* 语法(Syntax):

        pathname-host pathname &key case => host

        pathname-device pathname &key case => device

        pathname-directory pathname &key case => directory

        pathname-name pathname &key case => name

        pathname-type pathname &key case => type

        pathname-version pathname => version

* 参数和值(Arguments and Values):

        pathname---一个路径名标识符[pathname designator].
        case---:local 或 :common 其中之一. 默认是 :local.
        host---一个有效路径名主机[valid pathname host].
        device---一个有效路径名设备[valid pathname device].
        directory---一个有效路径名目录[valid pathname directory].
        name---一个有效路径名名称[valid pathname name].
        type---一个有效路径名类型[valid pathname type].
        version---一个有效路径名版本[valid pathname version].

* 描述(Description):

        这些函数返回路径名 pathname 的成员.

        如果这个 pathname 标识符[designator]是一个路径名[pathname], 它表示被用于打开这个文件的名字. 这可能是, 但不一定是文件的实际名称.

        如果提供了 case, 它会像章节 19.2.2.1.2 (路径名成员中的大小写) 中描述的那样被处理.

* 示例(Examples):

    ```LISP
    (setq q (make-pathname :host "KATHY"
                            :directory "CHAPMAN" 
                            :name "LOGIN" :type "COM"))
    =>  #P"KATHY::[CHAPMAN]LOGIN.COM"
    (pathname-host q) =>  "KATHY"
    (pathname-name q) =>  "LOGIN"
    (pathname-type q) =>  "COM"

    ;; Because namestrings are used, the results shown in the remaining
    ;; examples are not necessarily the only possible results.  Mappings
    ;; from namestring representation to pathname representation are 
    ;; dependent both on the file system involved and on the implementation
    ;; (since there may be several implementations which can manipulate the
    ;; the same file system, and those implementations are not constrained
    ;; to agree on all details). Consult the documentation for each
    ;; implementation for specific information on how namestrings are treated
    ;; that implementation.

    ;; VMS
    (pathname-directory (parse-namestring "[FOO.*.BAR]BAZ.LSP"))
    =>  (:ABSOLUTE "FOO" "BAR")
    (pathname-directory (parse-namestring "[FOO.*.BAR]BAZ.LSP") :case :common)
    =>  (:ABSOLUTE "FOO" "BAR")

    ;; Unix
    (pathname-directory "foo.l") =>  NIL
    (pathname-device "foo.l") =>  :UNSPECIFIC
    (pathname-name "foo.l") =>  "foo"
    (pathname-name "foo.l" :case :local) =>  "foo"
    (pathname-name "foo.l" :case :common) =>  "FOO"
    (pathname-type "foo.l") =>  "l"
    (pathname-type "foo.l" :case :local) =>  "l"
    (pathname-type "foo.l" :case :common) =>  "L"
    (pathname-type "foo") =>  :UNSPECIFIC
    (pathname-type "foo" :case :common) =>  :UNSPECIFIC
    (pathname-type "foo.") =>  ""
    (pathname-type "foo." :case :common) =>  ""
    (pathname-directory (parse-namestring "/foo/bar/baz.lisp") :case :local)
    =>  (:ABSOLUTE "foo" "bar")
    (pathname-directory (parse-namestring "/foo/bar/baz.lisp") :case :local)
    =>  (:ABSOLUTE "FOO" "BAR")
    (pathname-directory (parse-namestring "../baz.lisp"))
    =>  (:RELATIVE :UP)
    (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/BAR/../Mum/baz"))
    =>  (:ABSOLUTE "foo" "BAR" :UP "Mum")
    (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/BAR/../Mum/baz") :case :common)
    =>  (:ABSOLUTE "FOO" "bar" :UP "Mum")
    (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/*/bar/baz.l"))
    =>  (:ABSOLUTE "foo" :WILD "bar")
    (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/*/bar/baz.l") :case :common)
    =>  (:ABSOLUTE "FOO" :WILD "BAR")

    ;; Symbolics LMFS
    (pathname-directory (parse-namestring ">foo>**>bar>baz.lisp"))
    =>  (:ABSOLUTE "foo" :WILD-INFERIORS "bar")
    (pathname-directory (parse-namestring ">foo>*>bar>baz.lisp"))
    =>  (:ABSOLUTE "foo" :WILD "bar")
    (pathname-directory (parse-namestring ">foo>*>bar>baz.lisp") :case :common)
    =>  (:ABSOLUTE "FOO" :WILD "BAR")
    (pathname-device (parse-namestring ">foo>baz.lisp")) =>  :UNSPECIFIC
    ```

* 受此影响(Affected By):

        这个具体实现[implementation]和主机文件系统[file system].

* 异常情况(Exceptional Situations):

        如果它的第一个参数不是一个路径名[pathname], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        pathname, logical-pathname, 章节 20.1 (文件系统概念), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes): None. 


### <span id="F-LOAD-LOGICAL-PATHNAME-TRANSLATIONS">函数 LOAD-LOGICAL-PATHNAME-TRANSLATIONS</span>

* 语法(Syntax):

        load-logical-pathname-translations host => just-loaded

* 参数和值(Arguments and Values):

        host---一个字符串[string].
        just-loaded---一个广义 boolean [generalized boolean].

* 描述(Description):

        搜索并加载一个名为 host 的逻辑主机[logical host]的定义, 如果它没有被定义的话. 这个搜索的具体性质是具体实现定义的[implementation-defined].

        如果已经定义了这个主机 host , 则不会尝试查找或加载定义, 并且返回 false. 如果这个主机 host 还没有被定义, 但是成功找到并加载了一个定义, 就返回 true. 否则, 发出一个错误.

* 示例(Examples):

    ```LISP
    (translate-logical-pathname "hacks:weather;barometer.lisp.newest")
    >>  Error: The logical host HACKS is not defined.
    (load-logical-pathname-translations "HACKS")
    >>  ;; Loading SYS:SITE;HACKS.TRANSLATIONS
    >>  ;; Loading done.
    =>  true
    (translate-logical-pathname "hacks:weather;barometer.lisp.newest")
    =>  #P"HELIUM:[SHARED.HACKS.WEATHER]BAROMETER.LSP;0"
    (load-logical-pathname-translations "HACKS")
    =>  false
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果没有找到定义, 就会发出一个 error 类型[type]的错误.

* 参见(See Also):

        logical-pathname

* 注意(Notes):

        逻辑路径名[logical pathname]定义不止会被实现者创建, 也会被程序员[programmer]创建. 因此, 重要的是要记录搜索策略. 比如, 一个具体实现[implementation]可能定义了一个主机的定义要在某个特定已命名目录中称为"host.translations"的文件中找到.


### <span id="A-LOGICAL-PATHNAME-TRANSLATIONS">访问器 LOGICAL-PATHNAME-TRANSLATIONS</span>

* 语法(Syntax):

        logical-pathname-translations host => translations

        (setf (logical-pathname-translations host) new-translations)

* 参数和值(Arguments and Values):

        host--一个逻辑主机标识符[logical host designator].
        translations, new-translations---一个列表[list].

* 描述(Description):

        返回这个主机的转化列表[list]. 每一个转化都是一个两元素的列表[list]: from-wildcard 和 to-wildcard. 任何额外的元素都是具体实现定义的[implementation-defined]. from-wildcard 是一个主机为 host 的逻辑路径名[logical pathname]. to-wildcard 是一个路径名[pathname].

        (setf (logical-pathname-translations host) translations) 设置一个逻辑路径名[logical pathname]主机的转换列表[list]. 如果 host 是一个之前没有被用作一个逻辑路径名[logical pathname]主机的字符串[string], 那么就会定义一个新的逻辑路径名[logical pathname]主机; 否则一个已存在的主机转换会被替换. 逻辑路径名[logical pathname]主机名字使用 string-equal 比较.

        在设置这个转换列表时, 每个 from-wildcard 都可以是一个逻辑路径名[logical pathname], 它的主机为 host 或者一个可通过 (parse-namestring string host) 解析的逻辑路径名[logical pathname]名称字符串, 其中 host 表示由 parse-namestring 定义的合适对象[object]. 每个 to-wildcard 可以是可通过 (pathname to-wildcard) 强制转为一个路径名[pathname]的任何东西. 如果 to-wildcard 强制转为一个逻辑路径名[logical pathname], translate-logical-pathname 会在使用它时执行重复的转化步骤.

        host 是一个逻辑路径名[logical pathname]的主机成员或是一个已经通过 logical-pathname-translations 的 setf 被定义为一个逻辑路径名[logical pathname]主机名字的字符串.

* 示例(Examples):

    ```LISP
    ;;;A very simple example of setting up a logical pathname host.  No
    ;;;translations are necessary to get around file system restrictions, so
    ;;;all that is necessary is to specify the root of the physical directory
    ;;;tree that contains the logical file system.
    ;;;The namestring syntax on the right-hand side is implementation-dependent.
    (setf (logical-pathname-translations "foo")
          '(("**;*.*.*"              "MY-LISPM:>library>foo>**>")))
    
    ;;;Sample use of that logical pathname.  The return value
    ;;;is implementation-dependent.          
    (translate-logical-pathname "foo:bar;baz;mum.quux.3")
    =>  #P"MY-LISPM:>library>foo>bar>baz>mum.quux.3"
    
    ;;;A more complex example, dividing the files among two file servers
    ;;;and several different directories.  This Unix doesn't support
    ;;;:WILD-INFERIORS in the directory, so each directory level must
    ;;;be translated individually.  No file name or type translations
    ;;;are required except for .MAIL to .MBX.
    ;;;The namestring syntax on the right-hand side is implementation-dependent.
    (setf (logical-pathname-translations "prog")
          '(("RELEASED;*.*.*"        "MY-UNIX:/sys/bin/my-prog/")
            ("RELEASED;*;*.*.*"      "MY-UNIX:/sys/bin/my-prog/*/")
            ("EXPERIMENTAL;*.*.*"    "MY-UNIX:/usr/Joe/development/prog/")
            ("EXPERIMENTAL;DOCUMENTATION;*.*.*"
                                      "MY-VAX:SYS$DISK:[JOE.DOC]")
            ("EXPERIMENTAL;*;*.*.*"  "MY-UNIX:/usr/Joe/development/prog/*/")
            ("MAIL;**;*.MAIL"        "MY-VAX:SYS$DISK:[JOE.MAIL.PROG...]*.MBX")))

    ;;;Sample use of that logical pathname.  The return value
    ;;;is implementation-dependent.          
    (translate-logical-pathname "prog:mail;save;ideas.mail.3")
    =>  #P"MY-VAX:SYS$DISK:[JOE.MAIL.PROG.SAVE]IDEAS.MBX.3"

    ;;;Example translations for a program that uses three files main.lisp,
    ;;;auxiliary.lisp, and documentation.lisp.  These translations might be
    ;;;supplied by a software supplier as examples.

    ;;;For Unix with long file names
    (setf (logical-pathname-translations "prog")
          '(("CODE;*.*.*"             "/lib/prog/")))

    ;;;Sample use of that logical pathname.  The return value
    ;;;is implementation-dependent.          
    (translate-logical-pathname "prog:code;documentation.lisp")
    =>  #P"/lib/prog/documentation.lisp"

    ;;;For Unix with 14-character file names, using .lisp as the type
    (setf (logical-pathname-translations "prog")
          '(("CODE;DOCUMENTATION.*.*" "/lib/prog/docum.*")
            ("CODE;*.*.*"             "/lib/prog/")))

    ;;;Sample use of that logical pathname.  The return value
    ;;;is implementation-dependent.          
    (translate-logical-pathname "prog:code;documentation.lisp")
    =>  #P"/lib/prog/docum.lisp"

    ;;;For Unix with 14-character file names, using .l as the type
    ;;;The second translation shortens the compiled file type to .b
    (setf (logical-pathname-translations "prog")
          `(("**;*.LISP.*"            ,(logical-pathname "PROG:**;*.L.*"))
            (,(compile-file-pathname (logical-pathname "PROG:**;*.LISP.*"))
                                      ,(logical-pathname "PROG:**;*.B.*"))
            ("CODE;DOCUMENTATION.*.*" "/lib/prog/documentatio.*")
            ("CODE;*.*.*"             "/lib/prog/")))

    ;;;Sample use of that logical pathname.  The return value
    ;;;is implementation-dependent.          
    (translate-logical-pathname "prog:code;documentation.lisp")
    =>  #P"/lib/prog/documentatio.l"

    ;;;For a Cray with 6 character names and no directories, types, or versions.
    (setf (logical-pathname-translations "prog")
          (let ((l '(("MAIN" "PGMN")
                      ("AUXILIARY" "PGAUX")
                      ("DOCUMENTATION" "PGDOC")))
                (logpath (logical-pathname "prog:code;"))
                (phypath (pathname "XXX")))
            (append
              ;; Translations for source files
              (mapcar #'(lambda (x)
                          (let ((log (first x))
                                (phy (second x)))
                            (list (make-pathname :name log
                                                  :type "LISP"
                                                  :version :wild
                                                  :defaults logpath)
                                  (make-pathname :name phy
                                                  :defaults phypath))))
                      l)
              ;; Translations for compiled files
              (mapcar #'(lambda (x)
                          (let* ((log (first x))
                                  (phy (second x))
                                  (com (compile-file-pathname
                                        (make-pathname :name log
                                                        :type "LISP"
                                                        :version :wild
                                                        :defaults logpath))))
                            (setq phy (concatenate 'string phy "B"))
                            (list com
                                  (make-pathname :name phy
                                                  :defaults phypath))))
                      l))))

    ;;;Sample use of that logical pathname.  The return value
    ;;;is implementation-dependent.          
    (translate-logical-pathname "prog:code;documentation.lisp")
    =>  #P"PGDOC"
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 host 没有被正确提供, 就会发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        logical-pathname, 章节 19.1.2 (路径名作为文件名)

* 注意(Notes):

        具体实现可以定义在逻辑路径名[logical pathname]主机上操作的额外函数[function], 比如去指定额外的转化规则或选项. 


### <span id="F-LOGICAL-PATHNAME">函数 LOGICAL-PATHNAME</span>

* 语法(Syntax):

        logical-pathname pathspec => logical-pathname

* 参数和值(Arguments and Values):

        pathspec---一个逻辑路径名[logical pathname], 一个逻辑路径名[logical pathname]名称字符串[namestring], 或者一个流[stream].
        logical-pathname---一个逻辑路径名[logical pathname].

* 描述(Description):

        logical-pathname 把 pathspec 转换为一个逻辑路径名[logical pathname]并返回这个新的逻辑路径名[logical pathname]. 如果 pathspec 是一个逻辑路径名[logical pathname]名称字符串[namestring], 它应该包含一个主机成员以及它跟随的冒号[colon]. 如果 pathspec 是一个流[stream], 它应该是一个可以让 pathname 返回一个逻辑路径名[logical pathname]的流[stream].

        如果 pathspec 是一个流[stream], 这个流[stream]可以是打开的或者关闭的. 在一个文件被关闭后 logical-pathname 返回一个和这个文件打开时它返回的相同的逻辑路径名[logical pathname]. 如果 pathspec 是一个使用 make-two-way-stream, make-echo-stream, make-broadcast-stream, make-concatenated-stream, make-string-input-stream, 或 make-string-output-stream 所创建的流[stream], 那么就是一个错误.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 pathspec 没有被正确提供, 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        logical-pathname, translate-logical-pathname, 章节 19.3 (逻辑路径名)

* 注意(Notes): None. 


### <span id="V-DEFAULT-PATHNAME-DEFAULTS">变量 *DEFAULT-PATHNAME-DEFAULTS*</span>

* 值类型(Value Type):

        一个路径名[pathname]对象[object].

* 初始值(Initial Value):

        一个依赖于具体实现[implementation-dependent]的路径名[pathname], 通常是在 Common Lisp 启动时当前的工作目录中.

* 描述(Description):

        一个路径名[pathname], 当一个函数[function]需要一个默认的路径名[pathname]但是没有提供时被用作默认值.

* 示例(Examples):

    ```LISP
    ;; This example illustrates a possible usage for a hypothetical Lisp running on a
    ;; DEC TOPS-20 file system.  Since pathname conventions vary between Lisp 
    ;; implementations and host file system types, it is not possible to provide a
    ;; general-purpose, conforming example.
    *default-pathname-defaults* =>  #P"PS:<FRED>"
    (merge-pathnames (make-pathname :name "CALENDAR"))
    =>  #P"PS:<FRED>CALENDAR"
    (let ((*default-pathname-defaults* (pathname "<MARY>")))
      (merge-pathnames (make-pathname :name "CALENDAR")))
    =>  #P"<MARY>CALENDAR"
    ```

* 受此影响(Affected By):

        具体实现[implementation].

* 参见(See Also): None.

* 注意(Notes): None. 


### <span id="F-NAMESTRING-ALL">函数 NAMESTRING, FILE-NAMESTRING, DIRECTORY-NAMESTRING, HOST-NAMESTRING, ENOUGH-NAMESTRING</span>

* 语法(Syntax):

        namestring pathname => namestring

        file-namestring pathname => namestring

        directory-namestring pathname => namestring

        host-namestring pathname => namestring

        enough-namestring pathname &optional defaults => namestring

* 参数和值(Arguments and Values):

        pathname---一个路径名标识符[pathname designator].
        defaults---一个路径名标识符[pathname designator]. 默认是 *default-pathname-defaults* 的值.
        namestring---一个字符串[string]或 nil.

* 描述(Description):

        这些函数转换路径名 pathname 为一个名称字符串. 由路径名 pathname 表示的名称以一种依赖于具体实现[implementation-dependent]的规范形式作为名称字符串[namestring]返回.

        namestring 返回路径名 pathname 的完整形式.

        file-namestring 只返回路径名 pathname 的名称, 类型, 和版本成员.

        directory-namestring 返回目录名部分.

        host-namestring 返回主机名部分.

        enough-namestring 返回一个缩写的名称字符串, 当相对于默认值 defaults 考虑时, 它仅足以识别由 pathname 命名的文件. 在所有情况下, 它要求

            (merge-pathnames (enough-namestring pathname defaults) defaults)
            ==  (merge-pathnames (parse-namestring pathname nil defaults) defaults)

        并且这个 enough-namestring 的结果是满足这个标准的最短的合理字符串[string].

        不可能通过将三个较短的名称字符串[namestring]以某种顺序连接在一起来构造一个有效的名称字符串[namestring].

* 示例(Examples):

    ```
    (namestring "getty")            
    =>  "getty"
    (setq q (make-pathname :host "kathy" 
                            :directory 
                              (pathname-directory *default-pathname-defaults*)
                            :name "getty")) 
    =>  #S(PATHNAME :HOST "kathy" :DEVICE NIL :DIRECTORY directory-name 
          :NAME "getty" :TYPE NIL :VERSION NIL)
    (file-namestring q) =>  "getty"
    (directory-namestring q) =>  directory-name
    (host-namestring q) =>  "kathy" 

    ;;;Using Unix syntax and the wildcard conventions used by the
    ;;;particular version of Unix on which this example was created:
    (namestring
      (translate-pathname "/usr/dmr/hacks/frob.l"
                          "/usr/d*/hacks/*.l"
                          "/usr/d*/backup/hacks/backup-*.*"))
    =>  "/usr/dmr/backup/hacks/backup-frob.l"
    (namestring
      (translate-pathname "/usr/dmr/hacks/frob.l"
                          "/usr/d*/hacks/fr*.l"
                          "/usr/d*/backup/hacks/backup-*.*"))
    =>  "/usr/dmr/backup/hacks/backup-ob.l"
    
    ;;;This is similar to the above example but uses two different hosts,
    ;;;U: which is a Unix and V: which is a VMS.  Note the translation
    ;;;of file type and alphabetic case conventions.
    (namestring
      (translate-pathname "U:/usr/dmr/hacks/frob.l"
                          "U:/usr/d*/hacks/*.l"
                          "V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*"))
    =>  "V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-FROB.LSP"
    (namestring
      (translate-pathname "U:/usr/dmr/hacks/frob.l"
                          "U:/usr/d*/hacks/fr*.l"
                          "V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*"))
    =>  "V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-OB.LSP"
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        truename, merge-pathnames, pathname, logical-pathname, 章节 20.1 (文件系统概念), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes): None. 


### <span id="F-PARSE-NAMESTRING">函数 PARSE-NAMESTRING</span>

* 语法(Syntax):

        parse-namestring thing &optional host default-pathname &key start end junk-allowed
        => pathname, position

* 参数和值(Arguments and Values):

        thing---一个字符串[string], 一个路径名[pathname], 或者一个和文件相关的流[stream associated with a file].
        host---一个有效路径名主机[valid pathname host], 一个逻辑主机[logical host], 或者 nil.
        default-pathname---一个路径名标识符[pathname designator]. 默认是 *default-pathname-defaults* 的值.
        start, end---thing 的边界索引标识符[bounding index designator]. 对于 start 和 end 默认是 0 和 nil.
        junk-allowed---一个广义 boolean [generalized boolean]. 默认是 false.
        pathname---一个路径名[pathname], 或 nil.
        position---thing 的一个边界索引标识符[bounding index designator].

* 描述(Description):

        转换 thing 为一个路径名[pathname].

        主机 host 提供一个相对于解析发生的主机名.

        如果 thing 是一个和一个文件关联的流[stream associated with a file], 处理的过程就好像用来打开那个文件[file]的路径名[pathname]已经被提供了一样.

        如果 thing 是一个路径名[pathname], 主机 host 和 thing 的主机成员会被比较. 如果它们匹配, 立即返回两个值: thing 和 start; 否则 (如果它们不匹配), 发出一个错误.

        否则 (如果 thing 是一个字符串[string]), parse-namestring 在这个 thing 中由 start 和 end 限定的子字符串中解析一个文件[file]的名字.

        如果 thing 是一个字符串[string]那么这个 thing 中由 start 和 end 限定[bounded]的子字符串按照如下被解析为一个路径名[pathname]:

        * 如果 host 是一个逻辑主机[logical host]那么 thing 解析为主机 host 上的一个逻辑路径名[logical pathname]名称字符串[namestring].

        * 如果 host 是 nil 并且 thing 是一个包含一个显式主机的语法有效的逻辑路径名[logical pathname]名称字符串[namestring], 那么它被解析为一个逻辑路径名[logical pathname]名称字符串[namestring].

        * 如果 host 是 nil, default-pathname 是一个逻辑路径名[logical pathname], 并且 thing 是一个没有一个显式主机的语法有效的逻辑路径名[logical pathname]名称字符串[namestring], 那么它被解析为一个在 default-pathname 主机成员的主机上的逻辑路径名[logical pathname]名称字符串[namestring].

        * 否则, 这个 thing 的解析是具体实现定义的[implementation-defined].

        在第一个情况中, 这个逻辑路径名[logical pathname]名称字符串的主机部分和它跟随的冒号[colon]是可选的.

        如果这个名称字符串的主机部分和 host 都出现了但是不匹配, 就会发出一个错误.

        如果 junk-allowed 是 true, 那么主值[primary value]就是解析的路径名[pathname], 如果没有找到语法正确的路径名[pathname], 那么就是 nil. 如果 junk-allowed 是 false, 那么整个字符串子字符串会被扫描, 而主值[primary value]就是解析的路径名[pathname].

        在每个情况中, 第二个值[secondary value]是 thing 中终止这个解析的索引, 或者如果这个解析在这个子字符串末尾终止, 就是超出这个子字符串的索引 (如果 junk-allowed 是 false, 情况总是如此).

        解析一个空[null]字符串[string]总是成功的, 产生一个所有成员等于 nil (除了主机)的路径名[pathname].

        如果 thing 包含一个显式主机名而没有显式的设备名, 那么 parse-namestring 是否会为那个 host 提供标准默认设备作为产生的路径名[pathname]的设备成员是由具体实现定义的[implementation-defined].

* 示例(Examples):

    ```LISP
    (setq q (parse-namestring "test"))  
    =>  #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME "test" 
          :TYPE NIL :VERSION NIL)
    (pathnamep q) =>  true
    (parse-namestring "test") 
    =>  #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME "test"
          :TYPE NIL :VERSION NIL), 4
    (setq s (open xxx)) =>  #<Input File Stream...>
    (parse-namestring s) 
    =>  #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME xxx 
          :TYPE NIL :VERSION NIL), 0
    (parse-namestring "test" nil nil :start 2 :end 4 )
    =>  #S(PATHNAME ...), 15
    (parse-namestring "foo.lisp")
    =>  #P"foo.lisp"
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 junk-allowed 是 false, 如果 thing 不完全由一个路径名[pathname]的表示组成, 可能任何一边包围着空格[whitespace[1]]字符(如果这符合实现的文化约定), 那么就会发出一个 error 类型[type]的错误.

        如果提供了 host 并且不是 nil, 那么 thing 会包含一个明显的主机名, 如果这些主机不匹配就会发出一个 error 类型[type]的错误.

        如果 thing 是一个逻辑路径名[logical pathname]名称字符串并且如果这个名称字符串的主机部分和 host 都出现但是不匹配, 就会发出一个 error 类型[type]的错误.

* 参见(See Also):

        pathname, logical-pathname, 章节 20.1 (文件系统概念), 章节 19.2.2.2.3 (:UNSPECIFIC 作为成员值), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes): None. 


### <span id="F-WILD-PATHNAME-P">函数 WILD-PATHNAME-P</span>

* 语法(Syntax):

        wild-pathname-p pathname &optional field-key => generalized-boolean

* 参数和值(Arguments and Values):

        pathname---一个路径名标识符[pathname designator].
        field-key---:host, :device :directory, :name, :type, :version 其中之一, 或者 nil.
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        wild-pathname-p 检验 pathname 中通配符成员的存在性.

        如果 pathname 是一个路径名[pathname] (就像是由 pathname 返回的), 那么它就表示被用来打开这个文件的名字. 这可能, 但不是必须, 是这个文件的实际名字.

        如果没有提供 field-key 或者是 nil, 如果 pathname 有着任何通配符成员, 那么 wild-pathname-p 返回 true, 如果 pathname 没有通配符成员那么就是 nil. 如果 field-key 是非 nil [non-nil], 如果表示的 pathname 的成员是一个通配符, 那么 wild-pathname-p 返回 true, 如果那个成员不是一个通配符就返回 nil.

* 示例(Examples):

    ```LISP
    ;;;The following examples are not portable.  They are written to run
    ;;;with particular file systems and particular wildcard conventions.
    ;;;Other implementations will behave differently.  These examples are
    ;;;intended to be illustrative, not to be prescriptive.
    
    (wild-pathname-p (make-pathname :name :wild)) =>  true
    (wild-pathname-p (make-pathname :name :wild) :name) =>  true
    (wild-pathname-p (make-pathname :name :wild) :type) =>  false
    (wild-pathname-p (pathname "s:>foo>**>")) =>  true ;Lispm
    (wild-pathname-p (pathname :name "F*O")) =>  true ;Most places
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 pathname 不是一个路径名[pathname], 一个字符串[string], 或者一个和文件关联的流[stream associated with a file], 那么就会发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        pathname, logical-pathname, 章节 20.1 (文件系统概念), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes):

        不是所有的实现在所有域中都支持通配符. 见章节 19.2.2.2.2 (:WILD 作为一个成员值) 和章节 19.2.2.3 (通配符路径名上的限制). 


### <span id="F-PATHNAME-MATCH-P">函数 PATHNAME-MATCH-P</span>

* 语法(Syntax):

        pathname-match-p pathname wildcard => generalized-boolean

* 参数和值(Arguments and Values):

        pathname---一个路径名标识符[pathname designator].
        wildcard---一个通配[wild]路径名[pathname]的标识符[designator].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果路径名 pathname 匹配通配符 wildcard 那么 pathname-match-p 就返回 true, 否则返回 nil. 这个匹配规则是具体实现定义的[implementation-defined], 但是应该和 directory 一致. wildcard 的缺失成员默认为 :wild.

        对于路径名 pathname 是一个通配路径名[pathname]也是有效的; 在路径名 pathname 中的一个通配符域只能匹配 wildcard 的一个通配符域(换句话说, pathname-match-p 是可交换的). 对于 wildcard 是一个非通配路径名[pathname]也是有效的.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 pathname 或 wildcard 不是一个路径名[pathname], 字符串[string], 或者一个和文件关联的流[stream associated with a file], 就会发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        directory, pathname, logical-pathname, 章节 20.1 (文件系统概念), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes): None. 


### <span id="F-TRANSLATE-LOGICAL-PATHNAME">函数 TRANSLATE-LOGICAL-PATHNAME</span>

* 语法(Syntax):

        translate-logical-pathname pathname &key => physical-pathname

* 参数和值(Arguments and Values):

        pathname---一个路径名标识符[pathname designator], 或者一个逻辑路径名[logical pathname]名称字符串[namestring].
        physical-pathname---一个物理路径名[physical pathname].

* 描述(Description):

        把路径名 pathname 转换为一个物理路径名[physical pathname], 并返回它.

        如果 pathname 是一个流[stream], 那么这个流[stream]可以是打开的或关闭的. 在文件关闭之后 translate-logical-pathname 还是返回和这个文件打开时返回的相同的物理路径名. 如果路径名 pathname 是一个用 make-two-way-stream, make-echo-stream, make-broadcast-stream, make-concatenated-stream, make-string-input-stream, make-string-output-stream 创建的流[stream], 那就是一个错误.

        如果 pathname 是一个逻辑路径名[logical pathname]名称字符串, 这个逻辑路径名[logical pathname]名称字符串的主机部分和它跟随的冒号[colon]就是必须的.

        pathname 首先被强制转为一个路径名[pathname]. 如果这个强制转换后的路径名 pathname 是一个物理路径名, 它会被返回. 如果这个强制转换后的路径名 pathname 是一个逻辑路径名[logical pathname], 这个逻辑路径名[logical pathname]主机第一个匹配的转换 (根据 pathname-match-p) 会被应用, 就像是通过调用 translate-pathname 的一样. 如果这个结果是一个逻辑路径名[logical pathname], 会重复这个过程. 当这个结果最终为一个物理路径名时, 它会被返回. 如果没有匹配的转换, 就会发出一个错误.

        translate-logical-pathname 可能执行额外的转换, 通常是将文件类型转换为本地命名约定, 以适应长度有限的物理文件系统, 或者处理特殊的字符需求, 例如将连字符转换为下划线或大写字母到小写. 任何这样的额外转换都是具体实现定义的[implementation-defined]. 某些实现没有额外的转换.

        这里没有为 translate-logical-pathname 指定关键字参数, 但是具体实现允许通过添加关键字参数来扩展它.

* 示例(Examples):

        见 logical-pathname-translations.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 pathname 没有被正确提供, 就会发出一个 type-error 类型[type]的错误.

        如果没有匹配的转换, 就会发出一个 file-error 类型[type]的错误.

* 参见(See Also):

        logical-pathname, logical-pathname-translations, logical-pathname, 章节 20.1 (文件系统概念), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes): None. 


### <span id="F-TRANSLATE-PATHNAME">函数 TRANSLATE-PATHNAME</span>

* 语法(Syntax):

        translate-pathname source from-wildcard to-wildcard &key
        => translated-pathname

* 参数和值(Arguments and Values):

        source---一个路径名标识符[pathname designator].
        from-wildcard---一个路径名标识符[pathname designator].
        to-wildcard---一个路径名标识符[pathname designator].
        translated-pathname---一个路径名[pathname].

* 描述(Description):

        translate-pathname 把源 source (它匹配 from-wildcard) 转换为一个匹配 to-wildcard 的对应路径名, 并且返回这个对应路径名[pathname].

        这个产生的路径名[pathname]是 to-wildcard, 其中每一个通配符或缺失的域由 source 中的部分替换. 一个 "通配符域(wildcard field)" 是一个带有一个 :wild 值的路径名成员[pathname], 一个列表[list]值的目录成员的 :wild 元素, 或者是一个成员的具体实现定义[implementation-defined]的部分, 例如一些实现支持的复杂通配符字符串 "foo*bar" 中的 "*". 一个添加例如正则表达式这样的其他通配符特性的具体实现必须定义 translate-pathname 如何扩展到这些特性的. 一个 "缺失的域(missing field)" 是一个带有 nil 值的路径名[pathname]成员.

        这个 source 被拷贝到产生的路径名[pathname]的部分是具体实现定义的[implementation-defined]. 通常它是由所涉及的文件系统的用户接口协议决定的. 通常, 它是与 from-wildcard 的通配符域相匹配的源的一部分, 它的位置与 to-wildcard 的通配符或缺失域相同. 如果在 from-wildcard 的那个位置没有通配符域, 那么通常它是源 source 的整个对应路径名[pathname]成员, 或者在一个列表[list]值的目录成员中, 就是对应的整个列表[list]元素.

        在拷贝源 source 的一个部分到产生的路径名[pathname]期间, 可能发生额外的具体实现定义[implementation-defined]的大小写[case]或文件命名惯例的转换, 尤其是当 from-wildcard 和 to-wildcard 是不同主机的时候.

        source 是一个通配符路径名[pathname]是有效的; 通常这个会产生一个通配符结果. from-wildcard 和/或 to-wildcard 为非通配符路径名[pathname]也是有效的.

        这里没有为 translate-pathname 指定关键字参数, 但是允许具体实现通过添加关键字参数来扩展它.

        translate-pathname 将源 source 的习惯用例映射到输出路径名[pathname]的习惯用例中.<!--TODO customary case 习惯用例 ？？-->

* 示例(Examples):

    ```LISP
    ;; The results of the following five forms are all implementation-dependent.
    ;; The second item in particular is shown with multiple results just to 
    ;; emphasize one of many particular variations which commonly occurs.
    (pathname-name (translate-pathname "foobar" "foo*" "*baz")) =>  "barbaz"
    (pathname-name (translate-pathname "foobar" "foo*" "*"))
    =>  "foobar"
    OR=>  "bar"
    (pathname-name (translate-pathname "foobar" "*"    "foo*")) =>  "foofoobar"
    (pathname-name (translate-pathname "bar"    "*"    "foo*")) =>  "foobar"
    (pathname-name (translate-pathname "foobar" "foo*" "baz*")) =>  "bazbar"

    (defun translate-logical-pathname-1 (pathname rules)
      (let ((rule (assoc pathname rules :test #'pathname-match-p)))
        (unless rule (error "No translation rule for ~A" pathname))
        (translate-pathname pathname (first rule) (second rule))))
    (translate-logical-pathname-1 "FOO:CODE;BASIC.LISP"
                          '(("FOO:DOCUMENTATION;" "MY-UNIX:/doc/foo/")
                            ("FOO:CODE;"          "MY-UNIX:/lib/foo/")
                            ("FOO:PATCHES;*;"     "MY-UNIX:/lib/foo/patch/*/")))
    =>  #P"MY-UNIX:/lib/foo/basic.l"

    ;;;This example assumes one particular set of wildcard conventions
    ;;;Not all file systems will run this example exactly as written
    (defun rename-files (from to)
      (dolist (file (directory from))
        (rename-file file (translate-pathname file from to))))
    (rename-files "/usr/me/*.lisp" "/dev/her/*.l")
      ;Renames /usr/me/init.lisp to /dev/her/init.l
    (rename-files "/usr/me/pcl*/*" "/sys/pcl/*/")
      ;Renames /usr/me/pcl-5-may/low.lisp to /sys/pcl/pcl-5-may/low.lisp
      ;In some file systems the result might be /sys/pcl/5-may/low.lisp
    (rename-files "/usr/me/pcl*/*" "/sys/library/*/")
      ;Renames /usr/me/pcl-5-may/low.lisp to /sys/library/pcl-5-may/low.lisp
      ;In some file systems the result might be /sys/library/5-may/low.lisp
    (rename-files "/usr/me/foo.bar" "/usr/me2/")
      ;Renames /usr/me/foo.bar to /usr/me2/foo.bar
    (rename-files "/usr/joe/*-recipes.text" "/usr/jim/cookbook/joe's-*-rec.text")
      ;Renames /usr/joe/lamb-recipes.text to /usr/jim/cookbook/joe's-lamb-rec.text
      ;Renames /usr/joe/pork-recipes.text to /usr/jim/cookbook/joe's-pork-rec.text
      ;Renames /usr/joe/veg-recipes.text to /usr/jim/cookbook/joe's-veg-rec.text
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 source, from-wildcard, 或 to-wildcard 中的任意一个不是一个路径名[pathname], 一个字符串[string], 或者一个和文件关联的流[stream associated with a file], 那么就会发出一个 type-error 类型[type]的错误.

        (pathname-match-p source from-wildcard) 必须是 true, 否则就会发出一个 error 类型[type]的错误.

* 参见(See Also):

        namestring, pathname-host, pathname, logical-pathname, 章节 20.1 (文件系统概念), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes):

        translate-pathname 的确切行为不能由 Common Lisp 语言来决定, 必须允许更改, 取决于涉及的文件系统的用户接口协议.

        下面是一个实现指南. 一个文件系统通过依次检查三个路径名[pathname]中的每一个片段来执行这个操作, 其中一个片段是一个路径名[pathname]成员或者一个结构化成员的列表[list]元素, 比如一个层次目录. from-wildcard 和 to-wildcard 中的分层目录元素通过它们是否为通配符来匹配, 而不是通过目录层次结构中的深度. 如果在 to-wildcard 中的这个片段出现并且不是通配的, 它会被拷贝到这个结果中. 如果在 to-wildcard 中的这个片段是 :wild 或 nil, 在 source 中的这个片段会被拷贝到这个结果中. 否则, 在 to-wildcard 中的这个片段可以是一个像 "foo*bar" 这样的复杂通配符并且在 from-wildcard 中的这个片段应该是通配的; 在 source 中, 与 from-wildcard 中片段的通配符部分匹配的部分将取代 to-wildcard 中的通配符部分, 产生的值被用到结果中. 


### <span id="F-MERGE-PATHNAMES">函数 MERGE-PATHNAMES</span>

* 语法(Syntax):

        merge-pathnames pathname &optional default-pathname default-version
        => merged-pathname

* 参数和值(Arguments and Values):

        pathname---一个路径名标识符[pathname designator].
        default-pathname---一个路径名标识符[pathname designator]. 默认是 *default-pathname-defaults* 的值[value].
        default-version---一个有效路径名版本[pathname designator]. 默认是 :newest.
        merged-pathname---一个路径名[pathname].

* 描述(Description):

        从路径名 pathname 来构造一个路径名[pathname], 用 default-pathname 和 default-version 的对应值来填充任何未指定的成员.

        路径名成员的默认情况是通过填充从另一个路径名[pathname]中提取的成员来完成的. 这对于像有输入文件和输出文件的程序特别有用. 输出路径名的未指定的成员将来自输入路径名, 除了类型不应该默认为输入路径名的类型, 而是来自于程序输出的适当的默认类型; 比如, 见函数[function] compile-file-pathname.

        如果没有提供版本, 就使用默认版本 default-version. 如果 default-version 是 nil, 那么版本成员会保持不变.

        如果路径名 pathname 显式指定一个主机而不是一个设备, 并且如果 default-pathname 主机成员匹配路径名 pathname 的主机成员, 那么这个设备会取自这个 default-pathname; 否则这个设备会是那个主机的默认文件设备. 如果 pathname 没有指定一个主机, 设备, 目录, 名称, 或类型, 那么每一个这样的元素会拷贝自 default-pathname. 如果 pathname 没有指定一个名称, 那么这个版本(如果没有提供的话)会拷贝自 default-pathname, 就像其他成员一样. 如果 pathname 确实指定了一个名称, 那么这个版本不会被 default-pathname 所影响. 如果这个过程导致版本丢失, 就使用默认版本 default-version. 如果主机的文件名语法提供了一种方法来输入不带名称或类型的版本, 用户可以让名称和类型默认，但是提供一个与 default-pathname 中的版本不同的版本.

        如果 pathname 是一个流[stream], pathname 实际上变为 (pathname pathname). merge-pathnames 可以在一个打开的或关闭的流[stream]上被使用.

        如果 pathname 是一个路径名[pathname]它就表示被用于打开那个文件的名字. 这个可能但不是必须是那个文件的实际名字.

        当 default-pathname 是一个逻辑路径名[logical pathname], 或者当这个名称字符串[namestring]以一个已定义的逻辑主机[logical host]名后面跟着一个冒号[colon]开始时, merge-pathnames 识别一个逻辑路径名[logical pathname]名称字符串[namestring]. 在这两种情况的第一种时, 这个逻辑路径名[logical pathname]名称字符串[namestring]的主机部分和它跟随的冒号[colon]都是可选的.

        当且仅当 merge-pathnames 的第一个参数是一个逻辑路径名[logical pathname], 或它的第一个参数是一个带有显式主机的逻辑路径名[logical pathname]名称字符串[namestring], 或者它的第一个参数没有指定一个主机并且 default-pathname 是一个逻辑路径名[logical pathname]时, merge-pathnames 返回一个逻辑路径名[logical pathname].

        路径名[pathname]合并对一个相对目录特别处理. 如果 (pathname-directory pathname) 是一个 car 为 :relative 的列表[list], 并且 (pathname-directory default-pathname) 是一个列表[list], 那么合并的目录就是

        (append (pathname-directory default-pathname)
                (cdr  ;remove :relative from the front
                  (pathname-directory pathname)))

        的值, 除非产生的列表[list]包含一个跟在 :back 后面的字符串[string]或 :wild, 这样的话它们两个都会被移除. 这个删除冗余的 :back 关键字[keyword]的操作会重复尽可能多次. 如果 (pathname-directory default-pathname) 不是一个列表[list]或者 (pathname-directory pathname) 不是一个 car 为 :relative 的列表[list], 那么合并的目录就是 (or (pathname-directory pathname) (pathname-directory default-pathname))

        merge-pathnames 将路径名 pathname 的习惯用例映射到输出路径名的习惯用例中.<!--TODO customary case 习惯用例 ？？-->

* 示例(Examples):

    ```LISP
    (merge-pathnames "CMUC::FORMAT"
                      "CMUC::PS:<LISPIO>.FASL")
    =>  #P"CMUC::PS:<LISPIO>FORMAT.FASL.0"
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        *default-pathname-defaults*, pathname, logical-pathname, 章节 20.1 (文件系统概念), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes):

        最终的结果是, 如果只提供一个名称, 那么主机, 设备, 目录和类型将来自 default-pathname, 但是版本将来自 default-version. 如果什么都没提供或者只提供了目录, 那么名字, 类型, 和版本都一起来自于 default-pathname. 


# 20. 文件

> * 20.1 [文件系统概念](#FileSystemConcepts)
> * 20.2 [文件的字典](#TheFilesDictionary)

## 20.1 <span id="FileSystemConcepts">文件系统概念</span>

这个章节描述 Common Lisp 对文件系统的接口. 这个接口所使用的模型假定这些文件[file]由文件名[filename]来命名, 这样一个文件名[filename]可以由一个路径名[pathname]对象[object]来表示, 并且给定一个路径名[pathname], 可以构造一个流[stream], 连接到它所代表的文件名[filename]的文件[file].

关于打开和关闭文件[file], 以及操作它们的内容的信息, 见章节 21 (流).

下面这段列出了可应用于文件[file]和目录的一些操作符[operator].

    compile-file  file-length      open            
    delete-file   file-position    probe-file      
    directory     file-write-date  rename-file     
    file-author   load             with-open-file  

    Figure 20-1. 文件和目录操作符

> * 20.1.1 [从流到路径名的强制转换](#CoercionStreamsPathnames)
> * 20.1.2 [在打开或关闭的流上的文件操作](#FileOptOpenClosedStreams)
> * 20.1.3 [真实的名字](#Truenames)

### 20.1.1 <span id="CoercionStreamsPathnames">从流到路径名的强制转换</span>

与文件相关联的流[stream associated with a file]要么是文件流[file stream], 要么是同义流[synonym stream], 其目标是与文件相关联的流[stream associated with a file]. 这样的流可以被用作路径名标识符[pathname designator].

通常, 当与文件相关联的流[stream associated with a file]用作路径名标识符[pathname designator]时, 它表示用来打开文件[file]的路径名[pathname]; 这可能是, 但不必须是文件[file]的实际名称.

一些函数, 如 truename 和 delete-file, 以一种不同的方式强制把流[stream]转换到路径名[pathname], 这涉及到引用打开的实际文件, 该文件可能是也可能不是最初打开名称的文件. 这样的特殊情况总是会被特别标记出来并且不会是默认的. 

### 20.1.2 <span id="FileOptOpenClosedStreams">在打开或关闭的流上的文件操作</span>

执行文件[file]操作的许多函数[function]都接受打开[open]或关闭[close]的流[stream]作为参数[argument]; 见章节 21.1.3 (给标准函数的流参数).

这些函数[function]中, 下面这段列出来的这些区别对待打开[open]或关闭[close]的流[stream].

    delete-file  file-author      probe-file  
    directory    file-write-date  truename    

    Figure 20-2. 区别对待打开和关闭的流的文件函数

由于文件系统[file system]对打开[open]的流[stream]的处理可能在不同的实现[implementation]之间有很大的不同, 但是对于某些函数来说, 关闭[close]的流[stream]可能是最可靠的参数[argument]---特别是在下一段中的那些. 比如, 在某些文件系统[file system]中, 打开[open]的文件[file]是用临时的名称写入的, 直到关闭[close]时才重命名, 和/或 直到关闭[close]前都保持不可见. 通常情况下, 任何旨在成为可移植的代码都应该谨慎使用这些函数[function].

    directory  probe-file  truename  

    Figure 20-3. 关闭的流可以更好工作的文件函数 


### 20.1.3 <span id="Truenames">真实的名字</span>

很多文件系统[file system]允许超过一个文件名[filename]来表示一个特定的文件[file].

即使在可能有多个名称的地方, 大多数文件系统[file system]都有一个在这种情况下生成规范文件名[filename]的惯例. 这样一个规范的文件名[filename] (或者表示这样一个文件名[filename]的路径名[pathname])被称为真实名字[truename].

一个文件的真实名字[truename]可能有别于这个文件[file]的其他文件名[filename], 因为文件系统中存在符号链接、版本号、逻辑设备转换, Common Lisp 中的逻辑路径名[logical pathname]转换, 或文件系统[file system]的其他因素.

对于每个文件[file]来说, 文件[file]的真实名字[truename]通常是唯一的, 但不是必须是唯一的. 比如, 一个带有硬链接的 Unix 文件[file]可以有多个真实名字[truename].

#### 20.1.3.1 真实名字的示例

比如, 一个带有文件[file] PS:<JOE>FOO.TXT.1 和 PS:<JOE>FOO.TXT.2 的 DEC TOPS-20 系统可能允许第二个文件被引用为 PS:<JOE>FOO.TXT.0, 因为这个 ".0" 标记表示几个文件[file]的 "最新" 版本. 在同一个文件系统[file system]中, 一个 "逻辑设备" "JOE:" 可能被用来引用 PS:<JOE>, 这样一来名字 JOE:FOO.TXT.2 或 JOE:FOO.TXT.0 可能引用 PS:<JOE>FOO.TXT.2. 在所有这些情况中, 这个文件的真实名字[truename]可能是 PS:<JOE>FOO.TXT.2.

如果一个文件[file]是到另一个文件[file]的符号链接 (在一个允许这东西的文件系统[file system]中), 在跟踪任何符号链接之后, 通常将真实名称[truename]作为该文件的规范名称; 这就是说, 它是那个文件[file]的规范名称, 如果打开该文件[file]的输入[input]流[stream], 该文件的内容将可用.

在要去创建文件[file]的情况下 (这就是说, 打开到这样一个文件[file]的输出[output]流[stream]), 这个文件[file]准确的真实名字[truename]直到这个流[stream]被关闭前可能是不知道的. 在这个情况下, 对于这样一个流[stream], 在它关闭前后函数[function] truename 可能返回不同的值. 事实上, 在它关闭前, 返回的名字在该文件系统[file system]中可能不是一个有效的名字---比如, 当一个文件要被写入时, 它可能具有版本 :newest, 并且即使在所有文件都有数字版本的文件系统[file system]中, 当文件关闭时它也可能只具有特定的数字值. 


## 20.2 <span id="TheFilesDictionary">文件的字典</span>

> * [函数 DIRECTORY](#F-DIRECTORY)
> * [函数 PROBE-FILE](#F-PROBE-FILE)
> * [函数 ENSURE-DIRECTORIES-EXIST](#F-ENSURE-DIRECTORIES-EXIST)
> * [函数 TRUENAME](#F-TRUENAME)
> * [函数 FILE-AUTHOR](#F-FILE-AUTHOR)
> * [函数 FILE-WRITE-DATE](#F-FILE-WRITE-DATE)
> * [函数 RENAME-FILE](#F-RENAME-FILE)
> * [函数 DELETE-FILE](#F-DELETE-FILE)
> * [状况类型 FILE-ERROR](#CT-FILE-ERROR)
> * [函数 FILE-ERROR-PATHNAME](#F-FILE-ERROR-PATHNAME)


### <span id="F-DIRECTORY">函数 DIRECTORY</span>

* 语法(Syntax):

        directory pathspec &key => pathnames

* 参数和值(Arguments and Values):

        pathspec---一个路径名标识符[pathname designator], 它可能包含通配符[wild]成员.
        pathnames---一个物理路径名[physical pathnames]列表[list].

* 描述(Description):

        确定文件系统中存在的哪个文件具有匹配 pathspec 的名称(如果有的话), 并且返回一个对应那些文件[file]的真实名字[truename]的新[fresh]路径名[pathname]列表[list].

        可以扩展一个具体实现[implementation]来接受给 directory 的具体实现定义[implementation-defined]的关键字参数.

* 示例(Examples): None.

* 受此影响(Affected By):

        主机计算机的文件系统.

* 异常情况(Exceptional Situations):

        如果尝试去获取一个目录列表不成功, 就会发出一个 file-error 类型[type]的错误.

* 参见(See Also):

        pathname, logical-pathname, ensure-directories-exist, 章节 20.1 (文件系统概念), 章节 20.1.2 (在打开或关闭的流上的文件操作), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes):

        如果这个 pathspec 不是通配的[wild], 产生的列表会包含零个或一个元素.

        Common Lisp 在给 directory 的参数列表中指定 "&key", 即便没有定义给 directory 的标准[standardized]关键字参数. 在符合规范的程序[conforming program]中可能使用 ":allow-other-keys t" 来忽略任何由程序传递的具体实现[implementation]不支持的额外的关键字.


### <span id="F-PROBE-FILE">函数 PROBE-FILE</span>

* 语法(Syntax):

        probe-file pathspec => truename

* 参数和值(Arguments and Values):

        pathspec---一个路径名标识符[pathname designator].
        truename---一个物理路径名[physical pathnames]或 nil.

* 描述(Description):

        probe-file 测试一个文件是否存在.

        如果这里没有名为 pathspec 的文件, 那么 probe-file 返回 false, 否则返回这个 pathspec 的真实名字[truename].

        如果这个 pathspec 标识符[designator]是一个打开的流[stream], 这个 probe-file 产生它关联的文件[file]的真实名字[truename]. 如果 pathspec 是一个流[stream], 不管打开或是关闭的, 它会被强制转换为一个路径名[pathname], 就像是通过函数[function] pathname 一样.

* 示例(Examples): None.

* 受此影响(Affected By):

        主机计算机的文件系统.

* 异常情况(Exceptional Situations):

        如果 pathspec 是通配的[wild], 那么应该发出一个 file-error 类型[type]的错误.

        如果文件系统[file system]不能执行请求的操作, 那么应该发出一个 file-error 类型[type]的错误.

* 参见(See Also):

        truename, open, ensure-directories-exist, pathname, logical-pathname, 章节 20.1 (文件系统概念), 章节 20.1.2 (在打开或关闭的流上的文件操作), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes): None. 


### <span id="F-ENSURE-DIRECTORIES-EXIST">函数 ENSURE-DIRECTORIES-EXIST</span>

* 语法(Syntax):

        ensure-directories-exist pathspec &key verbose => pathspec, created

* 参数和值(Arguments and Values):

        pathspec---一个路径名标识符[pathname designator].
        verbose---一个广义 boolean [generalized boolean].
        created---一个广义 boolean [generalized boolean].

* 描述(Description):

        检验这些包含了那个指定的文件[file]的目录是否实际存在, 如果不存在就尝试去创建它们.

        如果那些包含目录不存在并且如果 verbose 是 true, 那么这个实现[implementation]允许 (但不是必须) 去执行输出到标准输出[standard output]中来说明哪些目录被创建. 如果那些包含目录存在, 或者如果 verbose 是 false, 这个函数不执行输出.

        主值[primary value]是那个给定的 pathspec, 这样一来这个操作符可以直接和其他文件操作表达式组合起来. 如果创建了任何目录, 那么第二个值[secondary value] created 就是 true.

* 示例(Examples): None.

* 受此影响(Affected By):

        主机计算机的文件系统.

* 异常情况(Exceptional Situations):

        如果这个 pathspec 的主机, 设备, 或目录部分是通配的[wild], 那么就会发出一个 file-error 类型[type]的错误.

        如果这个目录创建不成功, 那么就会发出一个 file-error 类型[type]的错误; 如果发生了这个, 可能是这样的情况: 在文件系统中被请求的创建实际上没有发生、发生一部分或者全部发生.

* 参见(See Also):

        probe-file, open, 章节 19.1.2 (路径名作为文件名)

* 注意(Notes): None. 


### <span id="F-TRUENAME">函数 TRUENAME</span>

* 语法(Syntax):

        truename filespec => truename

* 参数和值(Arguments and Values):

        filespec---一个路径名标识符[pathname designator].
        truename---一个物理路径名[physical pathnames].

* 描述(Description):

        truename 尝试去寻找由 filespec 表示的文件[file]并且返回它的真实名字[truename]. 如果这个 filespec 标识符[designator]是一个打开的流[stream], 就使用它关联的文件[file]. 如果 filespec 是一个流[stream], 不管这个流[stream]是打开还是关闭的, truename 都可以被使用. 允许 truename 在这个流[stream]被关闭后返回比这个流[stream]打开时更具体的信息. 如果 filespec 是一个路径名[pathname], 那么它表示被用来打开文件的名字. 这可能但不必须是该文件的实际名称.

* 示例(Examples):

    ```LISP
    ;; An example involving version numbers.  Note that the precise nature of
    ;; the truename is implementation-dependent while the file is still open.
    (with-open-file (stream ">vistor>test.text.newest")
      (values (pathname stream)
              (truename stream)))
    =>  #P"S:>vistor>test.text.newest", #P"S:>vistor>test.text.1"
    OR=>  #P"S:>vistor>test.text.newest", #P"S:>vistor>test.text.newest"
    OR=>  #P"S:>vistor>test.text.newest", #P"S:>vistor>_temp_._temp_.1"

    ;; In this case, the file is closed when the truename is tried, so the
    ;; truename information is reliable.
    (with-open-file (stream ">vistor>test.text.newest")
      (close stream)
      (values (pathname stream)
              (truename stream)))
    =>  #P"S:>vistor>test.text.newest", #P"S:>vistor>test.text.1"

    ;; An example involving TOP-20's implementation-dependent concept 
    ;; of logical devices -- in this case, "DOC:" is shorthand for
    ;; "PS:<DOCUMENTATION>" ...
    (with-open-file (stream "CMUC::DOC:DUMPER.HLP")
      (values (pathname stream)
              (truename stream)))
    =>  #P"CMUC::DOC:DUMPER.HLP", #P"CMUC::PS:<DOCUMENTATION>DUMPER.HLP.13"
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果不能为给定的 filespec 在这个文件系统[file system]中定位到合适的文件[file], 或者如果这个文件系统[file system]没有执行这个请求的操作, 那么就会发出一个 file-error 类型[type]的错误.

        如果路径名是通配的[wild], 那么就会发出一个 file-error 类型[type]的错误.

* 参见(See Also):

        pathname, logical-pathname, 章节 20.1 (文件系统概念), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes):

        truename 可以用来解释由文件系统[file system]执行的任何文件名[filename]转换. 


### <span id="F-FILE-AUTHOR">函数 FILE-AUTHOR</span>

* 语法(Syntax):

        file-author pathspec => author

* 参数和值(Arguments and Values):

        pathspec---一个路径名标识符[pathname designator].
        author---一个字符串[string]或 nil.

* 描述(Description):

        返回一个命名由 pathspec 指定的文件[file]的作者的字符串[string], 如果不能确定作者的名字, 就返回 nil.

* 示例(Examples):

    ```LISP
    (with-open-file (stream ">relativity>general.text")
      (file-author s))
    =>  "albert"
    ```

* 受此影响(Affected By):

        主机计算机的文件系统.

        由 pathspec 命名的文件[file]的其他用户.

* 异常情况(Exceptional Situations):

        如果 pathspec 是通配的[wild], 那么应该发出一个 file-error 类型[type]的错误.

        如果文件系统[file system]不能执行请求的操作, 那么应该发出一个 file-error 类型[type]的错误.

* 参见(See Also):

        pathname, logical-pathname, 章节 20.1 (文件系统概念), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes): None. 


### <span id="F-FILE-WRITE-DATE">函数 FILE-WRITE-DATE</span>

* 语法(Syntax):

        file-write-date pathspec => date

* 参数和值(Arguments and Values):

        pathspec---一个路径名标识符[pathname designator].
        date---一个通用时间[universal time]或 nil.

* 描述(Description):

        返回一个表示由 pathspec 指定的文件[file]最后一次被写入(或创建)时的通用时间[universal time], 或者如果不能确定这样一个时间就返回 nil.

* 示例(Examples):

    ```LISP
    (with-open-file (s "noel.text" 
                        :direction :output :if-exists :error)
      (format s "~&Dear Santa,~2%I was good this year.  ~
                    Please leave lots of toys.~2%Love, Sue~
                ~2%attachments: milk, cookies~%")
      (truename s))
    =>  #P"CUPID:/susan/noel.text"
    (with-open-file (s "noel.text")
      (file-write-date s))
    =>  2902600800
    ```

* 受此影响(Affected By):

        主机计算机的文件系统.

* 异常情况(Exceptional Situations):

        如果 pathspec 是通配的[wild], 那么应该发出一个 file-error 类型[type]的错误.

        如果文件系统[file system]不能执行请求的操作, 那么应该发出一个 file-error 类型[type]的错误.

* 参见(See Also):

        章节 25.1.4.2 (通用时间(Universal Time)), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes): None. 


### <span id="F-RENAME-FILE">函数 RENAME-FILE</span>

* 语法(Syntax):

        rename-file filespec new-name => defaulted-new-name, old-truename, new-truename

* 参数和值(Arguments and Values):

        filespec---一个路径名标识符[pathname designator].
        new-name---一个路径名标识符[pathname designator]而不是一个流[stream].
        defaulted-new-name---一个路径名[pathname].
        old-truename---一个物理路径名[physical pathname].
        new-truename---一个物理路径名[physical pathname].

* 描述(Description):

        rename-file 以这样一种方式修改文件系统: 由 filespec 表示的文件被重命名为 defaulted-new-name.

        指定一个包含通配[wild]成员的文件名是一个错误的, 在文件系统不允许一个 nil 成员的情况中 filespec 包含一个 nil 成员, 或者由于在文件系统不允许一个 nil 成员的情况中来自 filespec 的 new-name 的默认缺失成员包含一个 nil 也是错误的.

        如果 new-name 是一个逻辑路径名[logical pathname], rename-file 返回一个逻辑路径名[logical pathname]作为它的主值[primary value].

        如果成功 rename-file 三个值. 主值[primary value], defaulted-new-name, 是 new-name 和任何缺失的成员组合而成的名字, 这些缺失成员通过执行一个 merge-pathnames 操作来填充, 使用 filespec 作为默认值. 第二个值[secondary value], old-truename, 是那个文件[file]被重命名之前的真实名字[truename]. 第三个值[tertiary value], new-truename, 是那个文件[file]被重命名之后的真实名字[truename].

        如果这个 filespec 标识符[designator]是一个打开的流[stream], 那么这个流[stream]自身和那个和它关联的文件[file]会被影响 (如果这个文件系统[file system]允许的话).

* 示例(Examples):

    ```LISP
    ;; An example involving logical pathnames.
    (with-open-file (stream "sys:chemistry;lead.text"
                            :direction :output :if-exists :error)
      (princ "eureka" stream)
      (values (pathname stream) (truename stream)))
    =>  #P"SYS:CHEMISTRY;LEAD.TEXT.NEWEST", #P"Q:>sys>chem>lead.text.1"
    (rename-file "sys:chemistry;lead.text" "gold.text")
    =>  #P"SYS:CHEMISTRY;GOLD.TEXT.NEWEST",
      #P"Q:>sys>chem>lead.text.1",
      #P"Q:>sys>chem>gold.text.1"
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果重命名操作不成功, 那么就会发出一个 file-error 类型[type]的错误.

        如果 filespec 是通配的[wild], 那么可能会发出一个 file-error 类型[type]的错误.

* 参见(See Also):

        truename, pathname, logical-pathname, 章节 20.1 (文件系统概念), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes): None. 


### <span id="F-DELETE-FILE">函数 DELETE-FILE</span>

* 语法(Syntax):

        delete-file filespec => t

* 参数和值(Arguments and Values):

        filespec---一个路径名标识符[pathname designator].

* 描述(Description):

        删除由 filespec 指定的文件[file].

        如果这个 filespec 标识符[designator]是一个打开的流[stream], 那么 filespec 和与它关联的文件都会被影响 (如果文件系统允许的话), 在这个情况下 filespec 可能被立即关闭, 并且这个删除可能是立即的或延时的直到 filespec 被显式关闭, 依赖于这个文件系统的需要.

        删除一个不存在文件的尝试是否被认为是成功的是依赖于具体实现的[implementation-dependent].

        如果 delete-file 成功了就返回 true, 如果没有就发出一个 file-error 类型[type]的错误.

        如果 filespec 有一个通配[wild]成员, 或者如果 filespec 有一个 nil 成员并且这个文件系统不允许一个 nil 成员, 那么后果是未定义的.

* 示例(Examples):

    ```LISP
    (with-open-file (s "delete-me.text" :direction :output :if-exists :error))
    =>  NIL
    (setq p (probe-file "delete-me.text")) =>  #P"R:>fred>delete-me.text.1"
    (delete-file p) =>  T
    (probe-file "delete-me.text") =>  false
    (with-open-file (s "delete-me.text" :direction :output :if-exists :error)
      (delete-file s))
    =>  T
    (probe-file "delete-me.text") =>  false
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果这个删除操作不成功, 那么就会发出一个 file-error 类型[type]的错误

        如果 filespec 是通配的[wild], 那么可能会发出一个 file-error 类型[type]的错误.

* 参见(See Also):

        pathname, logical-pathname, 章节 20.1 (文件系统概念), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes): None. 


### <span id="CT-FILE-ERROR">状况类型 FILE-ERROR</span>

* 类优先级列表(Class Precedence List):

        file-error, error, serious-condition, condition, t

* 描述(Description):

        这个 file-error 类型[type]由以下错误状况组成: 发生在尝试去打开或关闭一个文件期间的错误状况, 或者在某些与一个文件系统的底层交互中的错误状况. 这个 "违规路径名(offending pathname)" 通过给 make-condition 的 :pathnameinitialization 参数来初始化, 并且可以通过函数[function] file-error-pathname 来访问.

* 参见(See Also):

        file-error-pathname, open, probe-file, directory, ensure-directories-exist 


### <span id="F-FILE-ERROR-PATHNAME">函数 FILE-ERROR-PATHNAME</span>

* 语法(Syntax):

        file-error-pathname condition => pathspec

* 参数和值(Arguments and Values):

        condition---一个 file-error 类型[type]的状况[condition].
        pathspec---一个路径名标识符[pathname designator].

* 描述(Description):

        返回一个 file-error 类型[type]的状况[condition]的 "违规路径名(offending pathname)".

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

* 参见(See Also):

        file-error, 章节 9 (状况)

* 注意(Notes): None. 


# 21. 流

> * 21.1 [流的概念](#StreamConcepts)
> * 21.2 [流的字典](#TheStreamsDictionary)

## 21.1 <span id="StreamConcepts">流的概念</span>

> * 21.1.1 [流的介绍](#IntroductionStreams)
> * 21.1.2 [流变量](#StreamVariables)
> * 21.1.3 [给标准函数的流参数](#StreamArgStandFun)
> * 21.1.4 [复合流上的限制](#RestrictCompositeStreams)

### 21.1.1 <span id="IntroductionStreams">流的介绍</span>

流[stream]是一个对象[object], 它可以与输入或输出函数一起使用, 以确定该操作的字符[character]或字节[byte]合适的源或接收器. 一个字符[character]流[stream]是一个字符的源或接收器. 一个二进制[binary]流[stream]是一个字节[byte]的源或接收器.

一些操作可以在任何种类的流[stream]上执行; 下一段中提供了一个标准化[standardized]操作的列表, 这些操作对任何类型的流[stream]都有用

    close                 stream-element-type  
    input-stream-p        streamp              
    interactive-stream-p  with-open-stream     
    output-stream-p                            

    Figure 21-1. 一些一般用途的流操作

其他操作只对特定的流[stream]类型[type]有意义. 比如, read-char 只定义给字符[character]流[stream]而 read-byte 只定义给二进制[binary]流[stream].

> * 21.1.1.1 [抽象的流分类](#AbstractClassStreams1)
> * 21.1.1.2 [抽象的流分类](#AbstractClassStreams2)
> * 21.1.1.3 [流的其他子类](#OtherSubclassesStream)

#### 21.1.1.1 <span id="AbstractClassStreams1">抽象的流分类</span>

##### 21.1.1.1.1 输入, 输出, 和双向流

一个流[stream], 不管是字符[character]流[stream]或二进制[binary]流[stream], 都可以是一个输入[input]流[stream] (数据源), 一个输出[output]流[stream] (数据的接收器), 两者都是, 或者 (比如, 当 ":direction :probe" 给定给 open 时) 都不是.

下一段中展示了和输入[input]流[stream]相关的操作符[operator].

    clear-input  read-byte            read-from-string            
    listen       read-char            read-line                   
    peek-char    read-char-no-hang    read-preserving-whitespace  
    read         read-delimited-list  unread-char                 

    Figure 21-2. 和输入流相关的操作符.

下一段中展示了和输出[output]流[stream]相关的操作符[operator].

    clear-output   prin1            write            
    finish-output  prin1-to-string  write-byte       
    force-output   princ            write-char       
    format         princ-to-string  write-line       
    fresh-line     print            write-string     
    pprint         terpri           write-to-string  

    Figure 21-3. 和输出流相关的操作符.

一个同时为输入[input]流[stream]和输出[output]流[stream]的流[stream]被称为双向[bidirectional]流[stream]. 见函数[function] input-stream-p 和 output-stream-p.

任何在 Figure 21-2 或 Figure 21-3 列出的操作符[operator]可以和双向[bidirectional]流[stream]一起使用. 另外, 下一段列出了与双向[bidirectional]流[stream]相关的操作符[operator]列表.

    y-or-n-p  yes-or-no-p    

    Figure 21-4. 和双向流相关的操作符. 


##### 21.1.1.1.2 打开和关闭的流

流[stream]可以是打开的[open]或关闭的[closed].

除非被显式指定, 否则创建和返回流[stream]的操作返回的是打开的[open]流[stream].

关闭流[stream]的操作标志着它作为数据来源或接收器的结束, 允许实现[implementation]收回其内部数据结构, 并释放在打开时可能被这个流[stream]锁定的任何外部资源.

除非被显式指定, 否则当一个关闭的[closed]流[stream]被用于需要一个流[stream]的地方时后果是未定义的.

对于一个关闭的[closed]流[stream], 把流[stream]强制转换为路径名[pathname]是允许的; 在一些情况下, 例如在一个真实名字[truename]计算中, 对于一个打开的[open]流[stream]和同一个流[stream]被关闭[close]后的结果是不同的. 

##### 21.1.1.1.3 交互式流

交互式流[interactive stream]是可以在上面执行交互式查询的一种流.

一个交互式流[interactive stream]的准确定义是具体实现定义的[implementation-defined], 并且可能依赖于底层操作系统. 一些实现[implementation]可能选择用来识别交互式流[interactive stream]特征的例子包括:

* 这个流[stream]与一个人 (或等价物) 联系在一起, 程序可以提示信息并期望根据提示接收不同的输入.

* 该程序期望提示输入并支持 "正常的输入编辑".

* read-char 可能等待用户在返回之前去输入一些东西而不是立即返回一个字符或 end-of-file.

将一些流[stream]划分为交互式流[interactive stream]的一般意图是为了让它们与包含批处理 (或后台或命令文件) 输入的流区分开来. 到批处理流的输出通常被丢弃或保存以供以后查看, 因此对此类流的交互式查询可能没有预期的效果.

终端 I/O [terminal I/O]可能是也可能不是一个交互式流[interactive stream]. 

#### 21.1.1.2 <span id="AbstractClassStreams2">抽象的流分类</span>

##### 21.1.1.2.1 文件流

一些流[stream], 称为文件流[file stream], 提供了对文件[file]的访问. 一个 file-stream 类[class]的对象[object]被用来表示一个文件流[file stream].

打开一个文件[file]的基础操作是 open, 它通常返回一个文件流[file stream] (详情见它的目录条目). 关闭一个流[stream]的基础操作是 close. 宏 with-open-file 是用来表达在给定代码[code]主体的持续时间内打开一个文件[file]并确保在退出该主体时关闭那个产生的流[stream]的常用习惯.

#### 21.1.1.3 <span id="OtherSubclassesStream">流的其他子类</span>

类[class] stream 有许多由这个规范定义的子类[subclass]. 下面这段展示了关于这些子类的一些信息.

    类                  相关操作符             
    broadcast-stream     make-broadcast-stream         
                        broadcast-stream-streams      
    concatenated-stream  make-concatenated-stream      
                        concatenated-stream-streams   
    echo-stream          make-echo-stream              
                        echo-stream-input-stream      
                        echo-stream-output-stream     
    string-stream        make-string-input-stream      
                        with-input-from-string        
                        make-string-output-stream     
                        with-output-to-string         
                        get-output-stream-string      
    synonym-stream       make-synonym-stream           
                        synonym-stream-symbol         
    two-way-stream       make-two-way-stream           
                        two-way-stream-input-stream   
                        two-way-stream-output-stream  

    Figure 21-5. 和特定的流相关的已定义的名字


### 21.1.2 <span id="StreamVariables">流变量</span>

值[value]必须是流[steam]的变量[variable]有时称为流变量[stream variable].

特定的流变量[stream variable]被这个规范定义为在没有指定特定流[stream]的各种情况[situation]下, 作为适当的输入或输出源. 下一段中是标准化[standardized]流变量[stream variable]的完整列表. 如果任何时候这些变量[variable]的任意一个的值[value]不是一个打开的[open]流[stream], 后果是未定义的.

    词汇术语          变量名      
    调试 I/O          *debug-io*         
    错误输出          *error-output*     
    查询 I/O          *query-io*         
    标准输入          *standard-input*   
    标准输出          *standard-output*  
    终端 I/O          *terminal-io*      
    跟踪输出          *trace-output*     

    Figure 21-6. 标准化流变量

注意, 按照惯例, 标准化[standardized]流变量[stream variable]如果一定是输入[input]流[stream], 那么就以 "-input*" 结尾, 如果一定是输出[output]流[stream]那么就以 "-output*" 结尾, 如果一定是双向[bidirectional]流[stream]就以 "-io*" 结尾.

用户程序可以赋值[assign]或绑定[bind]任何标准化[standardized]流变量[stream variable], 除了 \*terminal-io\*. 


### 21.1.3 <span id="StreamArgStandFun">给标准函数的流参数</span>

下面这段中的操作符[operator]接受打开[open]或关闭[closed]的流[stream]作为流[stream]参数[argument].

    broadcast-stream-streams     file-author       pathnamep                     
    close                        file-namestring   probe-file                    
    compile-file                 file-write-date   rename-file                   
    compile-file-pathname        host-namestring   streamp                       
    concatenated-stream-streams  load              synonym-stream-symbol         
    delete-file                  logical-pathname  translate-logical-pathname    
    directory                    merge-pathnames   translate-pathname            
    directory-namestring         namestring        truename                      
    dribble                      open              two-way-stream-input-stream   
    echo-stream-input-stream     open-stream-p     two-way-stream-output-stream  
    echo-stream-ouput-stream     parse-namestring  wild-pathname-p               
    ed                           pathname          with-open-file                
    enough-namestring            pathname-match-p                                

    Figure 21-7. 接受打开或关闭的流的操作符

下面这段中的操作符[operator]只接受打开[open]的流[stream]作为流[stream]参数[argument].

    clear-input               output-stream-p          read-char-no-hang           
    clear-output              peek-char                read-delimited-list         
    file-length               pprint                   read-line                   
    file-position             pprint-fill              read-preserving-whitespace  
    file-string-length        pprint-indent            stream-element-type         
    finish-output             pprint-linear            stream-external-format      
    force-output              pprint-logical-block     terpri                      
    format                    pprint-newline           unread-char                 
    fresh-line                pprint-tab               with-open-stream            
    get-output-stream-string  pprint-tabular           write                       
    input-stream-p            prin1                    write-byte                  
    interactive-stream-p      princ                    write-char                  
    listen                    print                    write-line                  
    make-broadcast-stream     print-object             write-string                
    make-concatenated-stream  print-unreadable-object  y-or-n-p                    
    make-echo-stream          read                     yes-or-no-p                 
    make-synonym-stream       read-byte                                            
    make-two-way-stream       read-char                                            

    Figure 21-8. 只接受打开的流的操作符

### 21.1.4 <span id="RestrictCompositeStreams">复合流上的限制</span>

如果一个复合流[composite stream]的任意成员在这个复合流[composite stream]被关闭[close]之前关闭[close], 那么后果是未定义的.

如果 synonym-stream 流符号[synonym stream symbol]从它被创建到它被关闭[close]这段时间都没有被绑定[bound]到一个打开的[open]流[stream], 那么后果是未定义的. 

## 21.2 <span id="TheStreamsDictionary">流的字典</span>

> * [系统类 STREAM](#SC-STREAM)
> * [系统类 BROADCAST-STREAM](#SC-BROADCAST-STREAM)
> * [系统类 CONCATENATED-STREAM](#SC-CONCATENATED-STREAM)
> * [系统类 ECHO-STREAM](#SC-ECHO-STREAM)
> * [系统类 FILE-STREAM](#SC-FILE-STREAM)
> * [系统类 STRING-STREAM](#SC-STRING-STREAM)
> * [系统类 SYNONYM-STREAM](#SC-SYNONYM-STREAM)
> * [系统类 TWO-WAY-STREAM](#SC-TWO-WAY-STREAM)
> * [函数 INPUT-STREAM-P, OUTPUT-STREAM-P](#F-INPUT-AND-OUTPUT-STREAM-P)
> * [函数 INTERACTIVE-STREAM-P](#F-INTERACTIVE-STREAM-P)
> * [函数 OPEN-STREAM-P](#F-OPEN-STREAM-P)
> * [函数 STREAM-ELEMENT-TYPE](#F-STREAM-ELEMENT-TYPE)
> * [函数 STREAMP](#F-STREAMP)
> * [函数 READ-BYTE](#F-READ-BYTE)
> * [函数 WRITE-BYTE](#F-WRITE-BYTE)
> * [函数 PEEK-CHAR](#F-PEEK-CHAR)
> * [函数 READ-CHAR](#F-READ-CHAR)
> * [函数 READ-CHAR-NO-HANG](#F-READ-CHAR-NO-HANG)
> * [函数 TERPRI, FRESH-LINE](#F-TERPRI-FRESH-LINE)
> * [函数 UNREAD-CHAR](#F-UNREAD-CHAR)
> * [函数 WRITE-CHAR](#F-WRITE-CHAR)
> * [函数 READ-LINE](#F-READ-LINE)
> * [函数 WRITE-STRING, WRITE-LINE](#F-WRITE-STRING-WRITE-LINE)
> * [函数 READ-SEQUENCE](#F-READ-SEQUENCE)
> * [函数 WRITE-SEQUENCE](#F-WRITE-SEQUENCE)
> * [函数 FILE-LENGTH](#F-FILE-LENGTH)
> * [函数 FILE-POSITION](#F-FILE-POSITION)
> * [函数 FILE-STRING-LENGTH](#F-FILE-STRING-LENGTH)
> * [函数 OPEN](#F-OPEN)
> * [函数 STREAM-EXTERNAL-FORMAT](#F-STREAM-EXTERNAL-FORMAT)
> * [宏 WITH-OPEN-FILE](#M-WITH-OPEN-FILE)
> * [函数 CLOSE](#F-CLOSE)
> * [宏 WITH-OPEN-STREAM](#M-WITH-OPEN-STREAM)
> * [函数 LISTEN](#F-LISTEN)
> * [函数 CLEAR-INPUT](#F-CLEAR-INPUT)
> * [函数 FINISH-OUTPUT, FORCE-OUTPUT, CLEAR-OUTPUT](#F-FINISH-AND-FORCE-AND-CLEAR-OUTPUT)
> * [函数 Y-OR-N-P, YES-OR-NO-P](#F-Y-OR-N-P-YES-OR-NO-P)
> * [函数 MAKE-SYNONYM-STREAM](#F-MAKE-SYNONYM-STREAM)
> * [函数 SYNONYM-STREAM-SYMBOL](#F-SYNONYM-STREAM-SYMBOL)
> * [函数 BROADCAST-STREAM-STREAMS](#F-BROADCAST-STREAM-STREAMS)
> * [函数 MAKE-BROADCAST-STREAM](#F-MAKE-BROADCAST-STREAM)
> * [函数 MAKE-TWO-WAY-STREAM](#F-MAKE-TWO-WAY-STREAM)
> * [函数 TWO-WAY-STREAM-INPUT-STREAM, TWO-WAY-STREAM-OUTPUT-STREAM](#F-T-W-S-INPUT-AND-OUTPUT-STREAM)
> * [函数 ECHO-STREAM-INPUT-STREAM, ECHO-STREAM-OUTPUT-STREAM](#F-ECHO-STREAM-INPUT-AND-OUTPUT-STREAM)
> * [函数 MAKE-ECHO-STREAM](#F-MAKE-ECHO-STREAM)
> * [函数 CONCATENATED-STREAM-STREAMS](#F-CONCATENATED-STREAM-STREAMS)
> * [函数 MAKE-CONCATENATED-STREAM](#F-MAKE-CONCATENATED-STREAM)
> * [函数 GET-OUTPUT-STREAM-STRING](#F-GET-OUTPUT-STREAM-STRING)
> * [函数 MAKE-STRING-INPUT-STREAM](#F-MAKE-STRING-INPUT-STREAM)
> * [函数 MAKE-STRING-OUTPUT-STREAM](#F-MAKE-STRING-OUTPUT-STREAM)
> * [宏 WITH-INPUT-FROM-STRING](#M-WITH-INPUT-FROM-STRING)
> * [宏 WITH-OUTPUT-TO-STRING](#M-WITH-OUTPUT-TO-STRING)
> * [变量 *DEBUG-IO*, *ERROR-OUTPUT*, *QUERY-IO*, *STANDARD-INPUT*, *STANDARD-OUTPUT*, *TRACE-OUTPUT*](#V-IO-ALL)
> * [变量 *TERMINAL-IO*](#V-TERMINAL-IO)
> * [状况类型 STREAM-ERROR](#CT-STREAM-ERROR)
> * [函数 STREAM-ERROR-STREAM](#F-STREAM-ERROR-STREAM)
> * [状况类型 END-OF-FILE](#CT-END-OF-FILE)


### <span id="SC-STREAM">系统类 STREAM</span>

* 类优先级列表(Class Precedence List):

        stream, t

* 描述(Description):

        一个流[stream]是一个可以和一个输入或输出函数一起使用来确定该操作的字符[character]或字节[byte]的适当源或接收器的对象.

        关于更多完整信息, 见章节 21.1 (流的概念).

* 也见(See Also):

        章节 21.1 (流的概念), 章节 22.1.3.13 (打印其他对象), 章节 22 (打印器), 章节 23 (读取器) 


### <span id="SC-BROADCAST-STREAM">系统类 BROADCAST-STREAM</span>

* 类优先级列表(Class Precedence List):

        broadcast-stream, stream, t

* 描述(Description):

        一个广播流[broadcast stream]是一个输出[output]流[stream], 它和一个包含零个或多个输出[output]流[list]的集合关联, 这样一来发送到这个广播流[broadcast stream]的任何输出会作为输出传递到每一个关联的输出[output]流[stream]上. (如果一个广播流[broadcast stream]没有成员流, 那么所有到广播流[broadcast stream]的输出会被丢弃.)

        可以在一个广播流[broadcast stream]上执行的操作的集合是可应用到它关联的那些输出[output]流[list]的操作的交集.

        一些输出操作 (比如, fresh-line) 返回基于这个操作时流的状态的值[value]. 由于每个成员流的这些值[value]可能不同, 有必要具体描述它们的返回值:

        * stream-element-type 从最后一个成员流中返回这个值, 如果这里没有成员流就返回 t.

        * fresh-line returns 从最后一个成员流中返回这个值, 如果这里没有成员流就返回 nil.

        * 函数 file-length, file-position, file-string-length, 和 stream-external-format 从最后一个成员流来返回值; 如果这里没有成员流, file-length 和 file-position 返回 0, file-string-length 返回 1, 而 stream-external-format 返回 :default.

        * 函数 streamp 和 output-stream-p 对于广播流[broadcast stream]总是返回 true.

        * 函数 open-stream-p 检验这个广播流[broadcast stream]是否打开[open[2]], 而不是它的成员流是否打开[open].

        * 函数 input-stream-p 和 interactive-stream-p 返回一个具体实现定义的[implementation-defined]广义 boolean [generalized boolean]值.

        * 对于输入操作 clear-input, listen, peek-char, read-byte, read-char-no-hang, read-char, read-line, 和 unread-char, 如果所指示的操作被执行, 其后果是未定义的. 然而, 一个实现[implementation]允许去定义这样一个行为作为依赖于具体实现[implementation-dependent]的扩展.

        对于任何上面或这个文档的其他地方没有显式指定返回值的输出操作, 定义了这样一个操作返回的值[value]是在它的最后一个成员流上执行这个操作产生的值[value]; 在前面所有的流[stream]上执行这个操作产生的值会被丢弃. 如果这里没有成员流, 那么这个值是依赖于具体实现的[implementation-dependent]. 

* 也见(See Also):

        broadcast-stream-streams, make-broadcast-stream 


### <span id="SC-CONCATENATED-STREAM">系统类 CONCATENATED-STREAM</span>

* 类优先级列表(Class Precedence List):

        concatenated-stream, stream, t

* 描述(Description):

        一个拼接流[concatenated stream]是一个输入[input]流[stream], 它是一个包含零个或多个输入[input]流[stream]的复合流[composite stream], 这样一来可以从拼接流[concatenated stream]中读取的数据序列与可以从每个组成流[stream]中读取的数据序列的拼接相同.

        来自拼接流[concatenated stream]的输入从第一个相关的输入[input]流[stream]中获取, 直到它到达文件的末尾[end of file[1]]; 然后这个流[stream]会被丢弃, 然后后续的输入取自于下一个输入[input]流[stream], 以此类推. 在相关输入[input]流[stream]上的文件结束[end of file]总是由拼接流[concatenated stream]无形地管理---拼接流[concatenated stream]的客户端看到文件结束[end of file]的唯一时间是尝试从拼接流[concatenated stream]获取数据, 但是它没有剩余的输入[input]流[stream]来获取这些数据.

* 也见(See Also):

        concatenated-stream-streams, make-concatenated-stream 


### <span id="SC-ECHO-STREAM">系统类 ECHO-STREAM</span>

* 类优先级列表(Class Precedence List):

        echo-stream, stream, t

* 描述(Description):

        一个回显流[echo stream]是一个双向[bidirectional]流[stream], 它从一个关联的输入[input]流[stream]中得到它的输入并且发送它的输出到一个关联的输出[output]流[stream].

        所有从输入[input]流[stream]中获取的输入都与输出[output]流[stream]相呼应. 无论输入是在遇到之后立即回显, 还是在从输入[input]流[stream]中读取之后回显, 是依赖于具体实现的[implementation-dependent].

* 也见(See Also):

        echo-stream-input-stream, echo-stream-output-stream, make-echo-stream 


### <span id="SC-FILE-STREAM">系统类 FILE-STREAM</span>

* 类优先级列表(Class Precedence List):

        file-stream, stream, t

* 描述(Description):

        一个 file-stream 类型[type]的对象[object]是一个直接源和接收器都是一个文件[file]的流[stream]. 这样一个流通过 open 和 with-open-file 显式创建, 以及通过像 load 这样的处理文件[file]的函数[function]隐式打开.

* 也见(See Also):

        load, open, with-open-file 


### <span id="SC-STRING-STREAM">系统类 STRING-STREAM</span>

* 类优先级列表(Class Precedence List):

        string-stream, stream, t

* 描述(Description):

        一个字符串流[string stream]是一个从关联字符串[string]读取输入或将输出写入到一个关联字符串[string]的流[stream].

        一个字符串流[string stream]的流元素类型[stream element type]总是为 character 类型[type]的子类型[subtype].

* 也见(See Also):

        make-string-input-stream, make-string-output-stream, with-input-from-string, with-output-to-string 


### <span id="SC-SYNONYM-STREAM">系统类 SYNONYM-STREAM</span>

* 类优先级列表(Class Precedence List):

        synonym-stream, stream, t

* 描述(Description):

        同义流[synonym stream]是一个为另一个流[stream]的别名的流[stream], 它是一个动态变量[dynamic variable]的值[value], 这个变量的名字[name]是这个同义流[synonym stream]的同义流符号[synonym stream symbol].

        任何在一个同义流[synonym stream]上的操作会在一个流[stream]上被执行, 这个流是由那个同义流符号[synonym stream symbol]命名的动态变量[dynamic variable]的值[value]. 如果那个变量[variable]的值[value]要改变, 或者如果那个变量[variable]的值[value]要被绑定[bound], 那么这个流[stream]会操作在那个变量[variable]的新值[value]上.

* 也见(See Also):

        make-synonym-stream, synonym-stream-symbol 


### <span id="SC-TWO-WAY-STREAM">系统类 TWO-WAY-STREAM</span>

* 类优先级列表(Class Precedence List):

        two-way-stream, stream, t

* 描述(Description):

        一个从一个关联输入[input]流[stream]中接收它的输入并且发送它的输出到一个关联的输出[output]流[stream]的双向[bidirectional]复合流[composite stream].

* 也见(See Also):

        make-two-way-stream, two-way-stream-input-stream, two-way-stream-output-stream 


### <span id="F-INPUT-AND-OUTPUT-STREAM-P">函数 INPUT-STREAM-P, OUTPUT-STREAM-P</span>

* 语法(Syntax):

        input-stream-p stream => generalized-boolean

        output-stream-p stream => generalized-boolean

* 参数和值(Arguments and Values):

        stream---一个流[stream].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果流 stream 是一个输入[input]流[stream], input-stream-p 返回 true; 否则, 返回 false.

        如果流 stream 是一个输出[output]流[stream], output-stream-p 返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (input-stream-p *standard-input*) =>  true
    (input-stream-p *terminal-io*) =>  true
    (input-stream-p (make-string-output-stream)) =>  false

    (output-stream-p *standard-output*) =>  true
    (output-stream-p *terminal-io*) =>  true
    (output-stream-p (make-string-input-stream "jr")) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 stream 不是一个流[stream], 那么应该发出一个 type-error 类型[type]的错误.

* 也见(See Also): None.

* 注意(Notes): None. 


### <span id="F-INTERACTIVE-STREAM-P">函数 INTERACTIVE-STREAM-P</span>

* 语法(Syntax):

        interactive-stream-p stream => generalized-boolean

* 参数和值(Arguments and Values):

        stream---一个流[stream].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果流 stream 是一个交互式流[interactive stream], 就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (when (> measured limit)
      (let ((error (round (* (- measured limit) 100)
                          limit)))
        (unless (if (interactive-stream-p *query-io*)
                    (yes-or-no-p "The frammis is out of tolerance by ~D%.~@
                                  Is it safe to proceed? " error)
                    (< error 15))  ;15% is acceptable
          (error "The frammis is out of tolerance by ~D%." error))))
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 stream 不是一个流[stream], 那么应该发出一个 type-error 类型[type]的错误.

* 也见(See Also):

        章节 21.1 (流的概念)

* 注意(Notes): None. 


### <span id="F-OPEN-STREAM-P">函数 OPEN-STREAM-P</span>

* 语法(Syntax):

        open-stream-p stream => generalized-boolean

* 参数和值(Arguments and Values):

        stream---一个流[stream].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果流 stream 是一个打开[open]的流[stream]就返回 true; 否则, 返回 false.

        直到流[stream]被 close 显式关闭, 或者直到退出 with-output-to-string, with-open-file, with-input-from-string, 或 with-open-stream 表达式形式[form]而被隐式关闭之前, 流[stream]都是打开的.

* 示例(Examples):

    ```LISP
    (open-stream-p *standard-input*) =>  true
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        close.

* 异常情况(Exceptional Situations):

        如果 stream 不是一个流[stream], 那么应该发出一个 type-error 类型[type]的错误.

* 也见(See Also): None.

* 注意(Notes): None. 


### <span id="F-STREAM-ELEMENT-TYPE">函数 STREAM-ELEMENT-TYPE</span>

* 语法(Syntax):

        stream-element-type stream => typespec

* 参数和值(Arguments and Values):

        stream---一个流[stream].
        typespec---一个类型指定符[type specifier].

* 描述(Description):

        stream-element-type 返回一个类型指定符[type specifier], 表示可以从流 stream 中读到或写入到流 stream 中的对象[object]的类型[type].

        由 open 创建的流[stream]有着被约束为 integer 或一个 character 类型[type]的子类型[subtype]的元素类型[element type].

* 示例(Examples):

    ```LISP
    ;; Note that the stream must accomodate at least the specified type,
    ;; but might accomodate other types.  Further note that even if it does
    ;; accomodate exactly the specified type, the type might be specified in
    ;; any of several ways.
    (with-open-file (s "test" :element-type '(integer 0 1)
                              :if-exists :error
                              :direction :output)
      (stream-element-type s))
    =>  INTEGER
    OR=>  (UNSIGNED-BYTE 16)
    OR=>  (UNSIGNED-BYTE 8)
    OR=>  BIT
    OR=>  (UNSIGNED-BYTE 1)
    OR=>  (INTEGER 0 1)
    OR=>  (INTEGER 0 (2))
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 stream 不是一个流[stream], 那么应该发出一个 type-error 类型[type]的错误.

* 也见(See Also): None.

* 注意(Notes): None.


### <span id="F-STREAMP">函数 STREAMP</span>

* 语法(Syntax):

        streamp object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 stream 类型[type]就返回 true; 否则, 返回 false.

        如果对象 object 是一个流[stream], streamp 不会被这个流[stream]是打开的[open]还是关闭的所影响.

* 示例(Examples):

    ```LISP
    (streamp *terminal-io*) =>  true
    (streamp 1) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 也见(See Also): None.

* 注意(Notes):

        (streamp object) ==  (typep object 'stream)


### <span id="F-READ-BYTE">函数 READ-BYTE</span>

* 语法(Syntax):

        read-byte stream &optional eof-error-p eof-value => byte

* 参数和值(Arguments and Values):

        stream---一个二进制[binary]输入[input]流[stream].
        eof-error-p---一个广义 boolean [generalized boolean]. 默认是 true.
        eof-value---一个对象[object]. 默认是 nil.
        byte---一个整数[integer], 或者是 eof-value.

* 描述(Description):

        read-byte 从流 stream 中读取并返回一个字节.

        如果到达了文件的末尾[end of file[2]]并且 eof-error-p 是 false, 那么返回这个 eof-value.

* 示例(Examples):

    ```LISP
    (with-open-file (s "temp-bytes" 
                        :direction :output
                        :element-type 'unsigned-byte)
        (write-byte 101 s)) =>  101
    (with-open-file (s "temp-bytes" :element-type 'unsigned-byte)
        (format t "~S ~S" (read-byte s) (read-byte s nil 'eof)))
    >>  101 EOF
    =>  NIL
    ```

* 副作用(Side Effects):

        修改流 stream.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 stream 不是一个流[stream], 那么应该发出一个 type-error 类型[type]的错误.

        如果 stream 不是一个二进制[binary]输入[input]流[stream], 那么应该发出一个 error 类型[type]的错误.

        如果在流 stream 中没有剩余字节[byte]并且 eof-error-p 是 true, 就会发出一个 end-of-file 类型[type]的错误.

* 也见(See Also):

        read-char, read-sequence, write-byte

* 注意(Notes): None. 


### <span id="F-WRITE-BYTE">函数 WRITE-BYTE</span>

* 语法(Syntax):

        write-byte byte stream => byte

* 参数和值(Arguments and Values):

        byte---一个流[stream]的流元素类型[stream element type]的整数[integer].
        stream---一个二进制[binary]输出[output]流[stream].

* 描述(Description):

        write-byte 向流 stream 写入一个字节 byte.

* 示例(Examples):

    ```LISP
    (with-open-file (s "temp-bytes" 
                        :direction :output
                        :element-type 'unsigned-byte)
        (write-byte 101 s)) =>  101
    ```

* 副作用(Side Effects):

        流 stream 会被修改.

* 受此影响(Affected By):

        流 stream 的元素类型[element type].

* 异常情况(Exceptional Situations):

        如果 stream 不是一个流[stream], 那么应该发出一个 type-error 类型[type]的错误. 如果 stream 不是一个二进制[binary]输出[output]流[stream], 那么应该发出一个 error 类型[type]的错误.

        如果 byte 不是流 stream 的一个流元素类型[stream element type]的整数[integer], 可能会发出一个 type-error 类型[type]的错误.

* 也见(See Also):

        read-byte, write-char, write-sequence

* 注意(Notes): None. 


### <span id="F-PEEK-CHAR">函数 PEEK-CHAR</span>

* 语法(Syntax):

        peek-char &optional peek-type input-stream eof-error-p eof-value recursive-p => char

* 参数和值(Arguments and Values):

        peek-type---一个字符[character]或 t 或 nil.
        input-stream---输入[input]流标识符[stream designator]. 默认是标准输入[standard input].
        eof-error-p---一个广义 boolean [generalized boolean]. 默认是 true.
        eof-value---一个对象[object]. 默认是 nil.
        recursive-p---一个广义 boolean [generalized boolean]. 默认是 false.
        char---一个字符[character]或 eof-value.

* 描述(Description):

        peek-char 在没有实际读取的情况下获取流 input-stream 中的下一个字符, 这样就可以在以后的时间里读取这个字符. 它还可以用于跳过并丢弃输入流 input-stream 中的中间字符, 直到找到一个特定的字符为止.

        如果没有提供 peek-type 或者是 nil, peek-char 返回要从 input-stream 中读取的下一个字符, 实际上没有把它从 input-stream 中移除. 下一次从 input-stream 完成输入时, 这个字符仍然在那里. 如果 peek-type 是 t, 那么 peek-char 跳过空白[whitespace[2]]字符[character], 但是不跳过注释, 然后在下一个字符执行窥视操作. 最后一个被检验的字符, 开始一个对象[object]的那个, 不会从 input-stream 中被移除. 如果 peek-type 是一个字符[character], 那么 peek-char 跳过输入字符直到找到一个和那个字符 char= 的字符[character]; 那个字符留在 input-stream 中.

        如果到达了文件的末尾[end of file[2]]并且 eof-error-p 是 false, 就返回 eof-value.

        如果 recursive-p 是 true, 这个调用预期会被嵌入到一个更高层次的对 read 或一个 Lisp 读取器[Lisp reader]使用的相似函数[function]的调用中.

        当 input-stream 是一个回显流[echo stream]时, 只是被窥视的字符不会被回显. 在这个 peek-type 不是 nil 的情况中, 通过 peek-char 传递的这些字符会被当作通过 read-char 一样处理, 因此, 除非它们被 unread-char 标记出来否则就会被回显.

* 示例(Examples):

    ```LISP
    (with-input-from-string (input-stream "    1 2 3 4 5")
        (format t "~S ~S ~S" 
                (peek-char t input-stream)
                (peek-char #\4 input-stream)
                (peek-char nil input-stream)))
    >>  #\1 #\4 #\4
    =>  NIL
    ```

* 受此影响(Affected By):

        *readtable*, *standard-input*, *terminal-io*.

* 异常情况(Exceptional Situations):

        如果 eof-error-p 是 true 并且到达文件的末尾[end of file[2]], 就会发出一个 end-of-file 类型[type]的错误.

        如果 peek-type 是一个字符[character], 到达文件的末尾[end of file[2]], 并且 eof-error-p 是 true, 就会发出一个 end-of-file 类型[type]的错误.

        如果 recursive-p 是 true 到达文件的末尾[end of file[2]], 就会发出一个 end-of-file 类型[type]的错误.

* 也见(See Also): None.

* 注意(Notes): None. 


### <span id="F-READ-CHAR">函数 READ-CHAR</span>

* 语法(Syntax):

        read-char &optional input-stream eof-error-p eof-value recursive-p => char

* 参数和值(Arguments and Values):

        input-stream---一个输入[input]流标识符[stream designator]. 默认是标准输入.
        eof-error-p---一个广义 boolean [generalized boolean]. 默认是 true.
        eof-value---一个对象[object]. 默认是 nil.
        recursive-p---一个广义 boolean [generalized boolean]. 默认是 false.
        char---一个字符[character]或 eof-value.

* 描述(Description):

        read-char 从 input-stream 返回下一个字符[character].

        当 input-stream 是一个回显流[echo string]时, 在第一次看到这个字符时这个字符在 input-stream 上被回显. 不被 read-char 所回显的字符是 unread-char 放在那里的那些, 因此被认为已经在之前的一次对 read-char 的调用中得到了回显.

        如果 recursive-p 是 true, 这个调用预期会被嵌入到一个更高层次的对 read 或一个 Lisp 读取器[Lisp reader]使用的相似函数[function]的调用中.

        如果到达文件的末尾[end of file[2]]并且 eof-error-p 是 false, 就返回 eof-value.

* 示例(Examples):

    ```LISP
    (with-input-from-string (is "0123")
        (do ((c (read-char is) (read-char is nil 'the-end)))
            ((not (characterp c)))
        (format t "~S " c)))
    >>  #\0 #\1 #\2 #\3
    =>  NIL
    ```

* 受此影响(Affected By):

        *standard-input*, *terminal-io*.

* 异常情况(Exceptional Situations):

        如果在一个字符可以被读取之前到达文件的末尾[end of file[2]], 并且 eof-error-p 是 true, 就会发出一个 end-of-file 类型[type]的错误.

* 也见(See Also):

        read-byte, read-sequence, write-char, read

* 注意(Notes):

        对应的输入函数是 write-char. 


### <span id="F-READ-CHAR-NO-HANG">函数 READ-CHAR-NO-HANG</span>

* 语法(Syntax):

        read-char-no-hang &optional input-stream eof-error-p eof-value recursive-p => char

* 参数和值(Arguments and Values):

        input-stream -- 一个输入[input]流标识符[stream designator]. 默认是标准输入[standard input].
        eof-error-p---一个广义 boolean [generalized boolean]. 默认是 true.
        eof-value---一个对象[object]. 默认是 nil.
        recursive-p---一个广义 boolean [generalized boolean]. 默认是 false.
        char---一个字符[character]或 nil 或 eof-value.

* 描述(Description):

        如果一个字符可用, read-char-no-hang 就从 input-stream 返回一个字符. 如果没有字符可用, read-char-no-hang 就返回 nil.

        如果 recursive-p 是 true, 这个调用预期会被嵌入到一个更高层次的对 read 或一个 Lisp 读取器[Lisp reader]使用的相似函数[function]的调用中.

        如果到达文件末尾[end of file[2]]并且 eof-error-p 是 false, 就返回 eof-value.

* 示例(Examples):

    ```LISP
    ;; This code assumes an implementation in which a newline is not
    ;; required to terminate input from the console.
    (defun test-it ()
      (unread-char (read-char))
      (list (read-char-no-hang) 
            (read-char-no-hang) 
            (read-char-no-hang)))
    =>  TEST-IT
    ;; Implementation A, where a Newline is not required to terminate
    ;; interactive input on the console.
    (test-it)
    >>  a
    =>  (#\a NIL NIL)
    ;; Implementation B, where a Newline is required to terminate
    ;; interactive input on the console, and where that Newline remains
    ;; on the input stream.
    (test-it)
    >>  a<NEWLINE>
    =>  (#\a #\Newline NIL)
    ```

* 受此影响(Affected By):

        *standard-input*, *terminal-io*.

* 异常情况(Exceptional Situations):

        当 eof-error-p 是 true 时, 如果到达文件末尾[end of file[2]], 就会发出一个 end-of-file 类型[type]的错误.

* 也见(See Also):

        listen

* 注意(Notes):

        read-char-no-hang 准确地像 read-char, 除了如果有必要去等待来获取一个字符 (比如来自于键盘), 会在没有等待的情况下立即返回 nil. 


### <span id="F-TERPRI-FRESH-LINE">函数 TERPRI, FRESH-LINE</span>

* 语法(Syntax):

        terpri &optional output-stream => nil

        fresh-line &optional output-stream => generalized-boolean

* 参数和值(Arguments and Values):

        output-stream -- 一个输出[output]流标识符[stream designator]. 默认是标准输出[standard output].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        terpri 输出一个新行[newline]到 output-stream 中.

        fresh-line 类似于 terpri 但是当且仅当这个 output-stream 没有在一行的开头时输出一个新行[newline]. 如果出于某个原因不能确定这个, 那么无论怎样都会输出一个新行[newline]. 如果 fresh-line 输出一个新行[newline]就返回 true; 否则它返回 false.

* 示例(Examples):

    ```LISP
    (with-output-to-string (s)
        (write-string "some text" s)
        (terpri s)
        (terpri s)
        (write-string "more text" s))
    =>  "some text

    more text"
    (with-output-to-string (s)
        (write-string "some text" s)
        (fresh-line s)
        (fresh-line s)
        (write-string "more text" s))
    =>  "some text
    more text"
    ```

* 副作用(Side Effects):

        这个 output-stream 会被修改.

* 受此影响(Affected By):

        *standard-output*, *terminal-io*.

* 异常情况(Exceptional Situations):

        None.

* 也见(See Also): None.

* 注意(Notes):

      terpri 和下面这个效果是一样的

      (write-char #\Newline output-stream)


### <span id="F-UNREAD-CHAR">函数 UNREAD-CHAR</span>

* 语法(Syntax):

        unread-char character &optional input-stream => nil

* 参数和值(Arguments and Values):

        character---一个字符[characater]; 必须是从 input-stream 读到的最后一个字符[character].
        input-stream---一个输入[input]流标识符[stream designator]. 默认是标准输入[standard input].

* 描述(Description):

        unread-char 把 character 放置回 input-stream 的前面, 这样一来它会再一次成为 input-stream 中的下一个字符.

        当 input-stream 是一个回显流[echo stream]时, 不要尝试去撤销字符 character 已经在 input-stream 上完成的任何回显. 然而, 通过 unread-char 放置在 input-stream 的字符以这样方式被标记来抑制后面通过 read-char 的再回显.

        在同一个流[stream]上连续两次调用 unread-char 时, 如果中间没有在这个流[stream]上调用 read-char (或者某个其他隐式读取字符的输入操作), 那么就会发生一个错误.

        调用 peek-char 或 read-char 会提交所有前面的字符. 在 peek-char 返回的任何字符之前调用 unread-char (包括由 peek-char 传递的那些非 nil [non-nil] peek-type 类型的字符) 的后果是不确定的. 特别是, 在 peek-char 之后调用 unread-char 的后果是未指定的.

* 示例(Examples):

    ```LISP
    (with-input-from-string (is "0123")
        (dotimes (i 6)
          (let ((c (read-char is)))
            (if (evenp i) (format t "~&~S ~S~%" i c) (unread-char c is)))))
    >>  0 #\0
    >>  2 #\1
    >>  4 #\2
    =>  NIL
    ```LISP

* 受此影响(Affected By):

        *standard-input*, *terminal-io*.

* 异常情况(Exceptional Situations): None.

* 也见(See Also):

        peek-char, read-char, 章节 21.1 (流的概念)

* 注意(Notes):

        unread-char 旨在成为一种有效的机制, 允许 Lisp 读取器[Lisp reader]和其他解析器在输入流 input-stream 中执行一个字符的展望. 


### <span id="F-WRITE-CHAR">函数 WRITE-CHAR</span>

* 语法(Syntax):

        write-char character &optional output-stream => character

* 参数和值(Arguments and Values):

        character---一个字符[character].
        output-stream -- 一个输出[output]流标识符[stream designator]. 默认是标准输出[standard output].

* 描述(Description):

        write-char 把字符 character 输出到 output-stream.

* 示例(Examples):

    ```LISP
    (write-char #\a)
    >>  a
    =>  #\a
    (with-output-to-string (s) 
      (write-char #\a s)
      (write-char #\Space s)
      (write-char #\b s))
    =>  "a b"
    ```

* 副作用(Side Effects):

        流 output-stream 会被修改.

* 受此影响(Affected By):

        *standard-output*, *terminal-io*.

* 异常情况(Exceptional Situations): None.

* 也见(See Also):

        read-char, write-byte, write-sequence

* 注意(Notes): None. 


### <span id="F-READ-LINE">函数 READ-LINE</span>

* 语法(Syntax):

        read-line &optional input-stream eof-error-p eof-value recursive-p
        => line, missing-newline-p

* 参数和值(Arguments and Values):

        input-stream---一个输入[input]流标识符[stream designator]. 默认是标准输入[standard input].
        eof-error-p---一个广义 boolean [generalized boolean]. 默认是 true.
        eof-value---一个对象[object]. 默认是 nil.
        recursive-p---一个广义 boolean [generalized boolean]. 默认是 false.
        line---一个字符串[string]或 eof-value.
        missing-newline-p---一个广义 boolean [generalized boolean].

* 描述(Description):

        从 input-stream 读取一个文本行, 由一个新行[newline]标识或文件末尾[end of file]来结尾.

        如果 recursive-p 是 true, 那么预期这个调用会被嵌入到一个更高层次的对 read 或一个 Lisp 读取器[Lisp Reader]使用的类似函数[function]的调用中.

        这个主值[primary value], line, 是读取到的那行, 表示为一个字符串[string] (如果有这个字符串[string]的话, 不带末尾的新行[newline]标识). 如果 eof-error-p 是 false 并且在读到任何字符[character]之前到达 input-stream 的文件末尾[end of file], 返回 eof-value 作为这个 line.

        第二个值[secondary value], missing-newline-p, 是一个广义 boolean [generalized boolean], 如果 line 是由新行[newline]标识来终止的就是 false, 如果 line 由 input-stream 文件结尾[end of file]来终止(或者如果这个 line 就是 eof-value)就是 true .

* 示例(Examples):

    ```LISP
    (setq a "line 1
    line2")
    =>  "line 1
    line2"
    (read-line (setq input-stream (make-string-input-stream a)))
    =>  "line 1", false
    (read-line input-stream)
    =>  "line2", true
    (read-line input-stream nil nil)
    =>  NIL, true
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        *standard-input*, *terminal-io*.

* 异常情况(Exceptional Situations):

        如果在这行中任何字符被读取到之前就到达文件的末尾[end of file[2]], 如果 eof-error-p 是 true 就会发出一个错误.

* 也见(See Also):

        read

* 注意(Notes):

        对应输出函数是 write-line.


### <span id="F-WRITE-STRING-WRITE-LINE">函数 WRITE-STRING, WRITE-LINE</span>

* 语法(Syntax):

        write-string string &optional output-stream &key start end => string

        write-line string &optional output-stream &key start end => string

* 参数和值(Arguments and Values):

        string---一个字符串[string].
        output-stream -- 一个输出[output]流标识符[stream designator]. 默认是标准输出[standard output].
        start, end---字符串 string 的边界索引标识符[bounding index designator]. 对于 start 和 end 默认分别为 0 和 nil.

* 描述(Description):

        write-string 把字符串 string 由 start 和 end 限定[bounded]的子字符串的字符[character]写到 output-stream 中. write-line 做相同的事, 但是会在之后输出一个换行标识.

* 示例(Examples):

    ```LISP
    (prog1 (write-string "books" nil :end 4) (write-string "worms"))
    >>  bookworms
    =>  "books"
    (progn (write-char #\*)
            (write-line "test12" *standard-output* :end 5) 
            (write-line "*test2")
            (write-char #\*)
            nil)
    >>  *test1
    >>  *test2
    >>  *
    =>  NIL
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        *standard-output*, *terminal-io*.

* 异常情况(Exceptional Situations): None.

* 也见(See Also):

        read-line, write-char

* 注意(Notes):

        write-line 和 write-string 返回 string, 不是由 start 和 end 限定[bounded]的子字符串.

        (write-string string)
        ==  (dotimes (i (length string)
              (write-char (char string i)))

        (write-line string)
        ==  (prog1 (write-string string) (terpri))


### <span id="F-READ-SEQUENCE">函数 READ-SEQUENCE</span>

* 语法(Syntax):

        read-sequence sequence stream &key start end => position

* 参数和值(Arguments and Values):

        sequence---一个序列[sequence].
        stream---一个输入[input]流[stream].
        start, end---序列 sequence 的边界索引标识符[bounding index designator]. 对于 start 和 end 默认分别为 0 和 nil.
        position---一个大于等于零, 并且小于等于序列 sequence 长度[length]的整数[integer].

* 描述(Description):

        通过用读取自流 stream 的元素[element]来替换序列 sequence 中由 start 和 end 限定[bounded]的元素[element]来破坏性地修改序列 sequence.

        通过从流 stream 中拷贝连续元素[element]到序列 sequence 来破坏性地修改它. 如果在拷贝这个子序列的所有元素[element]之前到达这个流 stream 的文件末尾[end of file], 那么在序列 sequence 的末尾旁边的元素[element]不会被更新.

        position 是序列 sequence 中第一个没有被更新的元素[element]的索引, 由于到达文件的末尾[end of file]的话它可能小于 end.

* 示例(Examples):

    ```LISP
    (defvar *data* (make-array 15 :initial-element nil))
    (values (read-sequence *data* (make-string-input-stream "test string")) *data*)
    =>  11, #(#\t #\e #\s #\t #\Space #\s #\t #\r #\i #\n #\g NIL NIL NIL NIL)
    ```

* 副作用(Side Effects):

        修改流 stream 和 sequence.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果序列 sequence 不是一个正规序列[proper sequence], 就应该准备发出一个 type-error 类型[type]的错误. 如果 start 不是一个非负整数[integer], 就会发出一个 type-error 类型[type]的错误. 如果 end 不是一个非负整数[integer]或 nil, 就会发出一个 type-error 类型[type]的错误.

        如果读取自流 stream 的一个元素[element]不是 sequence 的一个元素类型[element type]的成员, 就会发出一个 type-error 类型[type]的错误.

* 也见(See Also):

        章节 3.2.1 (编译器术语), write-sequence, read-line

* 注意(Notes):

        read-sequence 和遍历指定的子序列并每次从流 stream 中读取一个元素[element]并将其存储到序列 sequence 中的效果是相同的, 但是可能比等价循环更有效率. 对于序列 sequence 是一个具有与 stream 相同的元素类型[element type]的向量[vector]的情况下, 更可能存在高效的实现. 


### <span id="F-WRITE-SEQUENCE">函数 WRITE-SEQUENCE</span>

* 语法(Syntax):

        write-sequence sequence stream &key start end => sequence

* 参数和值(Arguments and Values):

        sequence---一个序列[sequence].
        stream---一个输出[output]流[stream].
        start, end---序列 sequence 的边界索引标识符[bounding index designator]. 对于 start 和 end 默认分别为 0 和 nil.

* 描述(Description):

        write-sequence 把序列 sequence 中由 start 和 end 限定[bounded]的子序列的元素[element]写入到流 stream 中.

* 示例(Examples):

    ```LISP
    (write-sequence "bookworms" *standard-output* :end 4)
    >>  book
    =>  "bookworms"
    ```

* 副作用(Side Effects):

        修改流 stream.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果序列 sequence 不是一个正规序列[proper sequence], 就应该准备发出一个 type-error 类型[type]的错误. 如果 start 不是一个非负整数[integer], 就会发出一个 type-error 类型[type]的错误. 如果 end 不是一个非负整数[integer]或 nil, 就会发出一个 type-error 类型[type]的错误.

        如果限定[bounded sequence]的序列[sequence]的一个元素[element]不是流 stream 的流元素类型[stream element type]的一个成员, 可能会发出一个 type-error 类型[type]的错误.

* 也见(See Also):

        章节 3.2.1 (编译器), read-sequence, write-string, write-line

* 注意(Notes):

        write-sequence 和遍历指定的子序列并每次写入一个元素[element]到流 stream 中的效果是相同的, 但是可能比等价循环更有效率. 对于序列 sequence 是一个具有与 stream 相同的元素类型[element type]的向量[vector]的情况下, 更可能存在高效的实现.


### <span id="F-FILE-LENGTH">函数 FILE-LENGTH</span>

* 语法(Syntax):

        file-length stream => length

* 参数和值(Arguments and Values):

        stream---和一个文件关联的流[stream associated with a file].
        length---一个非负整数[integer]或 nil.

* 描述(Description):

        file-length 返回流 stream 的长度, 如果长度不能确定就返回 nil.

        对于一个二进制文件, 长度是以流 stream 的元素类型[element type]的单位来测量的.

* 示例(Examples):

    ```LISP
    (with-open-file (s "decimal-digits.text" 
                        :direction :output :if-exists :error)
      (princ "0123456789" s)
      (truename s))
    =>  #P"A:>Joe>decimal-digits.text.1"
    (with-open-file (s "decimal-digits.text")
      (file-length s))
    =>  10
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果流 stream 不是一个和文件关联的流[stream associated with a file]就会发出一个 type-error 类型[type]的错误.

* 也见(See Also):

        open

* 注意(Notes): None. 


### <span id="F-FILE-POSITION">函数 FILE-POSITION</span>

* 语法(Syntax):

        file-position stream => position

        file-position stream position-spec => success-p

* 参数和值(Arguments and Values):

        stream---一个流[stream].
        position-spec---一个文件位置标识符[file position designator].
        position---一个文件位置[file position]或 nil.
        success-p---一个广义 boolean [generalized boolean].

* 描述(Description):

        返回或改变一个流 stream 中的当前位置.

        当没有提供 position-spec 时, file-position 返回流 stream 中的当前文件位置[file position], 如果不能确定就返回 nil.

        当提供了 position-spec 时, 流 stream 中的文件位置[file position]会被设置为该文件位置[file position] (如果可能的话). 如果这个重定位执行成功, file-position 返回 true, 如果没有就返回 false.

        由单参数的 file-position 返回的整数[integer]用作同一个文件的 position-spec 应该是可接受的.

        对于一个字符文件, 执行一个单独的 read-char 或 write-char 操作可能造成这个文件位置递增超过 1, 因为字符集转换 (比如在 Common Lisp f#\Newline 字符和一外部的 ASCII 回车/换行序列之间的转换) 以及具体实现的其他方面. 对于一个二进制文件, 每个 read-byte 或 write-byte 操作递增文件位置 1.

* 示例(Examples):

    ```LISP
    (defun tester ()
      (let ((noticed '()) file-written)
        (flet ((notice (x) (push x noticed) x))
          (with-open-file (s "test.bin" 
                              :element-type '(unsigned-byte 8)
                              :direction :output
                              :if-exists :error)
              (notice (file-position s)) ;1
              (write-byte 5 s) 
              (write-byte 6 s)
              (let ((p (file-position s)))
                (notice p) ;2
                (notice (when p (file-position s (1- p))))) ;3
              (write-byte 7 s)
              (notice (file-position s)) ;4
              (setq file-written (truename s)))
            (with-open-file (s file-written
                              :element-type '(unsigned-byte 8)
                              :direction :input)
              (notice (file-position s)) ;5
              (let ((length (file-length s)))
                (notice length) ;6
                (when length
                  (dotimes (i length)
                    (notice (read-byte s)))))) ;7,...
            (nreverse noticed))))
    =>  tester
    (tester)
    =>  (0 2 T 2 0 2 5 7)
    OR=>  (0 2 NIL 3 0 3 5 6 7)
    OR=>  (NIL NIL NIL NIL NIL NIL)
    ```

* 副作用(Side Effects):

        当提供了这个 position-spec 参数时, 在这个 stream 中的文件位置[file position]可能被移动.

* 受此影响(Affected By):

        由 file-position 返回的值随着输入或输出操作的执行单调递增.

* 异常情况(Exceptional Situations):

        如果提供了 position-spec, 但是太大或者不合适, 就会发出一个错误.

* 也见(See Also):

        file-length, file-string-length, open

* 注意(Notes):

        将字符文件表示为一个有限大小的记录序列的具体实现可以选择将这个文件位置编码为, 比如, <<record-number>>*<<max-record-size>>+<<character-within-record>>. 这是一个有效的编码, 因为它随着每个字符被读取或写入单调递增, 尽管每次步进没有必要是 1. 作为给 file-position 的 position-spec, 如果在解码成记录数和字符数时, 结果表明所提供的记录对于指定的字符数来说太短了, 则可能认为一个整数[integer]是 "不合适的". 


### <span id="F-FILE-STRING-LENGTH">函数 FILE-STRING-LENGTH</span>

* 语法(Syntax):

        file-string-length stream object => length

* 参数和值(Arguments and Values):

        stream---一个输出[output]字符[character]文件流[file stream].
        object---一个字符串[string]或一个字符[character].
        length---一个非负整数[integer], 或 nil.

* 描述(Description):

        file-string-length 返回 (file-position stream) 的当前值和它在写入对象 object 之后的值的区别, 如果不能确定就是 nil.

        返回值对应这个调用时流 stream 的当前状态, 当这个流[stream]的状态改变时再一次调用的值可能是不同的.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 也见(See Also): None.

* 注意(Notes): None. 


### <span id="F-OPEN">函数 OPEN</span>

* 语法(Syntax):

        open filespec &key direction element-type if-exists if-does-not-exist external-format
        => stream

* 参数和值(Arguments and Values):

        filespec---一个路径名标识符[pathname designator].
        direction---:input, :output, :io, 或 :probe 其中之一. 默认是 :input.
        element-type---一个 character 的可识别子类型[recognizable subtype]的类型指定符[type specifier]; 或者一个 integer 的有限[finite]可识别子类型[recognizable subtype]; 或者符号[symbol] signed-byte, unsigned-byte, 或 :default 的其中一个. 默认是 character.
        if-exists---:error, :new-version, :rename, :rename-and-delete, :overwrite, :append, :supersede, 或 nil 其中之一. 如果 filespec 的版本成员是 :newest, 默认就是 :new-version, 否则就是 :error.
        if-does-not-exist---:error, :create, 或 nil 其中之一. 如果 direction 是 :input 或者 if-exists 是 :overwrite 或 :append, 默认就是 :error; 如果 direction 是 :output 或 :io, 并且 if-exists 既不是 :overwrite 也不是 :append, 那么就是 :create; 当 direction 是 :probe 时就是 nil.
        external-format---一个外部文件格式标识符[external file format designator]. 默认是 :default.
        stream---一个文件流[file stream]或 nil.

* 描述(Description):

        open 创建, 打开, 并返回一个连接到由 filespec 指定文件的文件流[file stream]. filespec 是这个要被打开的文件的名字. 如果这个 filespec 标识符[designator]是一个流[stream], 则该流[stream]不会首先关闭或以其他方式受到影响.

        给 open 的关键字参数指定了返回的那个文件流[file stream]的特质, 以及如何处理错误.

        如果 direction 是 :input 或 :probe, 或者如果 if-exists 不是 :new-version 而这个 filespec 的版本成员是 :newest, 那么这个打开的文件就是已经存在于那个文件系统中的文件, 该文件的版本比文件系统中其他路径名成员与 filespec 相同的任何其他文件都要大.

        一个具体实现需要去识别所有这些 open 关键字选项并且在这个主机操作系统的上下文中去做一些合理的事. 比如, 如果一个文件系统不支持不同的文件版本, 并且不区分删除(deletion)和除去(expunging)的概念, :new-version 可能被当作和 :rename 或 :supersede 一样, 而 :rename-and-delete 可能被当作和 :supersede 一样.

        :direction

            这些是 direction 的可能的值, 以及它们如何影响创建的流[stream]的性质:

            :input

                导致创建一个输入[input]文件流[file stream].

            :output

                导致创建一个输出[output]文件流[file stream].

            :io

                导致创建一个双向[bidirectional]文件流[file stream].

            :probe

                导致创建一个 "无方向(no-directional)" 文件流; 实际上, 这个文件流是在 open 返回之前创建并关闭的.

        :element-type

            这个 element-type 指定文件流[file stream]的事务单元. 如果它是 :default, 这个单元由文件系统[file system]决定, 可能基于这个文件[file].

        :if-exists

            if-exists 指定了如果 direction 是 :output 或 :io 而名为 filespec 的文件已经存在的话要采取的动作. 如果 direction 是 :input, 没有提供, 或 :probe, 那么 if-exists 会被忽略. 这些是经过 if-exists 修改的 open 的结果:

            :error

                发出一个 file-error 类型[type]的错误.

            :new-version

                用一个更大的版本数字创建一个新文件.

            :rename

                已存在的文件会重命名为某个其他的名字并且创建一个新文件.

            :rename-and-delete

                已存在的文件会重命名为某个其他的名字, 它会被删除(delete)但不会被除去(expunge), 然后创建一个新文件.

            :overwrite

                在这个流[stream]上的输出操作会破坏性地修改这个已存在的文件. 如果 direction 是 :io 那么这个文件会以同时允许读写的双向模式被打开. 这个文件指针的初始定位于这个文件的开始; 然而, 当文件打开时, 文件不会被截断为零.

            :append

                在这个流[stream]上的输出操作会破坏性地修改这个已存在的文件. 这个文件指针的初始定位于这个文件的末尾.

                如果 direction 是 :io, 那么这个文件会以同时允许读写的双向模式被打开.

            :supersede

                已存在的文件会被取代; 这就是说, 一个和旧的那个有着相同名字的新文件会被创建. 如果可能的话, 具体实现直到这个新的流关闭之前都不应该毁掉这个旧文件.

            nil

                没有文件或流[stream]会被创建; 反而, 返回 nil 来表示这个失败.

        :if-does-not-exist

            if-does-not-exist 指定了名为 filespec 的文件不存在的话要采取的动作. 这些是 open 被 if-does-not-exist 修改的结果:

            :error

                发出一个 file-error 类型[type]的错误.

            :create

                创建一个空文件. 处理继续进行, 就像文件已经存在一样, 但是没有执行 if-exists 所指示的处理.

            nil

                没有文件或流[stream]会被创建; 反而, 返回 nil 来表示这个失败.

        :external-format

            这个选项为文件[file]选择一个外部文件格式[external file format]: 这个选项的仅有标准化[standardized]值是 :default, 尽管具体实现[implementation]允许去定义额外的外部文件格式[external file format]并且 stream-external-format 返回的依赖于具体实现[implementation-dependent]的值也可以被符合规范的程序[conforming program]所使用.

            这个 external-format 对于所有元素类型[element type]为字符[character]的一个子类[subtype]的任何种类的文件流[file stream]都是有意义的. 对于对这个选项无意义的流[stream]会忽略这个选项; 然而, 具体实现[implementation]可能定义其他有意义的元素类型[element type]. 如果写入一个不能被给定外部文件格式[external file format]所表示的字符[character], 后果是未指定的.

        当一个文件被打开时, 文件流[file stream]被构造成文件系统到 Lisp 环境的代表; 文件流[file stream]上的操作反映在文件系统中的文件操作上.

        一个文件可以被 open 删除, 重命名, 或破坏性修改.

        关于打开相对路径名的信息, 见章节 19.2.3 (合并路径名).

* 示例(Examples):

    ```LISP
    (open filespec :direction :probe)  =>  #<Closed Probe File Stream...>
    (setq q (merge-pathnames (user-homedir-pathname) "test"))
    =>  #<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY directory-name
        :NAME "test" :TYPE NIL :VERSION :NEWEST>
    (open filespec :if-does-not-exist :create) =>  #<Input File Stream...>
    (setq s (open filespec :direction :probe)) =>  #<Closed Probe File Stream...>
    (truename s) =>  #<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY
        directory-name :NAME filespec :TYPE extension :VERSION 1>
    (open s :direction :output :if-exists nil) =>  NIL 
    ```

* 受此影响(Affected By):

        主机计算机文件系统[file system]的性质和状态.

* 异常情况(Exceptional Situations):

        如果 if-exists 是 :error, (受限于上面列出的 if-exists 含义的限制), 就会发出一个 file-error 类型[type]的错误.

        如果 if-does-not-exist 是 :error (受限于上面列出的 if-does-not-exist 含义的限制), 就会发出一个 file-error 类型[type]的错误.

        如果一个实现不可能以接近这里指定的方式处理某些选项, 就会发出一个 error 类型[type]的错误.

        如果 (wild-pathname-p filespec) 返回 true 就会发出一个 file-error 类型[type]的错误.

        如果 external-format 不被具体实现[implementation]所接受, 就会发出一个 error 类型[type]的错误.

        目前存在的各种文件系统[file system]具有广泛的不同功能, 并且文件系统[file system]的某些方面超出了这个规范定义的范围. 一个给定的实现[implementation]可能无法以完全相同的方式支持所有这些选项. 一个实现[implementation]需要去识别所有这些选项关键字, 并尝试在主机文件系统[file system]的上下文中执行一些"合理"的操作. 在必要的情况下, 为了适应文件系统[file system], 即便一个实现[implementation]稍微偏离了这里指定的语义, 也不被取消作为一个符合规范的实现[conforming implementation]的资格. 如果实现[implementation]以类似于此处指定的方式处理某些选项是完全不可能的, 那么它可能只是发出一个错误.

        关于 :element-type 选项, 如果一个请求的类型[type]不被文件系统[file system]所支持, 在提升[upgrade]中进行的类型替换是允许的. 作为一个最小的需求, 应该是这样的情况: 在给定的元素类型[element type]下打开一个输出[output]流[stream], 然后在相同的元素类型[element type]中打开同一个文件[file]的输入[input]流[stream]应该是兼容的.

* 也见(See Also):

        with-open-file, close, pathname, logical-pathname, 章节 19.2.3 (合并路径名), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes):

        当一个反常的退出发生时, open 不会自动关闭这个文件.

        当 element-type 是 character 的一个子类型[subtype]时, read-char 和/或 write-char 可以在产生的文件流[file stream]上被使用.

        当 element-type 是 integer 的一个子类型[subtype]时, read-byte 和/或 write-byte 可以在产生的文件流[file stream]上被使用.

        当 element-type 是 :default 时, 类型[type]可以通过使用 stream-element-type 来确定. 


### <span id="F-STREAM-EXTERNAL-FORMAT">函数 STREAM-EXTERNAL-FORMAT</span>

* 语法(Syntax):

        stream-external-format stream => format

* 参数和值(Arguments and Values):

        stream---一个文件流[file stream].
        format---一个外部文件格式[external file format].

* 描述(Description):

        返回流 stream 的一个外部文件格式标识符[external file format designator].

* 示例(Examples):

    ```LISP
    (with-open-file (stream "test" :direction :output)
      (stream-external-format stream))
    =>  :DEFAULT
    OR=>  :ISO8859/1-1987
    OR=>  (:ASCII :SAIL)
    OR=>  ACME::PROPRIETARY-FILE-FORMAT-17
    OR=>  #<FILE-FORMAT :ISO646-1983 2343673>
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 也见(See Also):

        给函数[function] open 和宏[macro] with-open-file 的 :external-format 参数[argument].

* 注意(Notes):

        这个返回的格式没有必要对于其他实现[implementation]是有意义的. 


### <span id="M-WITH-OPEN-FILE">宏 WITH-OPEN-FILE</span>

* 语法(Syntax):

        with-open-file (stream filespec options*) declaration* form*
        => results

* 参数和值(Arguments and Values):

        stream -- 一个变量.
        filespec---一个路径名标识符[pathname designator].
        options -- 一个表达式形式[form]; 求值的.
        declaration---一个 declare 表达式[expression]; 不求值.
        forms---一个隐式 progn [implicit progn].
        results---由表达式形式 forms 返回的值[value].

* 描述(Description):

        with-open-file 使用 open 来创建一个到名为 filespec 的文件[file]的文件流[file stream]. filespec 是要被打开的文件的名字. options 是用作给 open 的关键字参数.

        这个 stream 变量[variable]绑定[bound]的流[stream]对象[object]有着动态范围[dynamic extent]; 它的范围[extent]在表达式形式[form]退出时结束.

        with-open-file 作为一个隐式的 progn [implicit progn]求值表达式形式 forms, 其中流 stream 被绑定到 open 返回的值上.

        当控制离开主体时, 不管是正常的还是反常的 (比如通过使用 throw), 这个文件会被自动关闭. 如果一个新的输出文件要被写入, 而控制不正常地离开了, 这个文件会被终止并且文件系统被保留, 尽可能地保留, 就好像文件从来没有打开过一样.

        对于流 stream 使用 :if-exists nil 或 :if-does-not-exist nil 来绑定为 nil 是可能的. :if-does-not-exist nil 的使用者应该检查是否为一个有效的流[stream].

        如果尝试去对流变量[variable]赋值[assign], 后果是未定义的. 如果检测到这样的尝试, 编译器可能选择去发出一个警告.

* 示例(Examples):

    ```LISP
    (setq p (merge-pathnames "test"))
    =>  #<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY directory-name
        :NAME "test" :TYPE NIL :VERSION :NEWEST>
    (with-open-file (s p :direction :output :if-exists :supersede)
        (format s "Here are a couple~%of test data lines~%")) =>  NIL
    (with-open-file (s p)
        (do ((l (read-line s) (read-line s nil 'eof)))
            ((eq l 'eof) "Reached end of file.")
        (format t "~&*** ~A~%" l)))
    >>  *** Here are a couple
    >>  *** of test data lines
    =>  "Reached end of file."

    ;; Normally one would not do this intentionally because it is
    ;; not perspicuous, but beware when using :IF-DOES-NOT-EXIST NIL
    ;; that this doesn't happen to you accidentally...
    (with-open-file (foo "no-such-file" :if-does-not-exist nil)
      (read foo))
    >>  hello?
    =>  HELLO? ;This value was read from the terminal, not a file!

    ;; Here's another bug to avoid...
    (with-open-file (foo "no-such-file" :direction :output :if-does-not-exist nil)
      (format foo "Hello"))
    =>  "Hello" ;FORMAT got an argument of NIL!
    ```

* 副作用(Side Effects):

        创建一个名为 filename 的文件[file]的流[stream] (进入时), 并且关闭这个流[stream] (退出时). 在某些实现[implementation]中, 在这个文件[file]被打开时它可能被锁定. 如果这个流[stream]是一个输出[output]流[stream], 可能会创建一个文件[file].

* 受此影响(Affected By):

        主机计算机文件系统.

* 异常情况(Exceptional Situations):

        见函数[function] open.

* 也见(See Also):

        open, close, pathname, logical-pathname, 章节 19.1.2 (路径名作为文件名)

* 注意(Notes): None. 


### <span id="F-CLOSE">函数 CLOSE</span>

* 语法(Syntax):

        close stream &key abort => result

* 参数和值(Arguments and Values):

        stream---一个流[stream] (不管是打开的[open]还是关闭的[closed]).
        abort---一个广义 boolean [generalized boolean]. 默认是 false.
        result---如果这个流 stream 在它被接受作为参数时是打开的[open]就是 t, 否则就是依赖于具体实现的[implementation-dependent].

* 描述(Description):

        close 关闭流 stream. 关闭一个流[stream]意味着它可能不再被用于输入或输出操作了. 关闭一个文件流[file stream]的行为会结束这个流[stream]和它关联的文件[file]之间的关联; 与文件系统[file system]的事务会结束, 而输入/输出可能不再在这个流[stream]上执行.

        如果 abort 是 true, 会尝试去清理已经创建的流的任何副作用. 如果流 stream 对创建流[stream]时创建的文件执行输出, 这个文件会被删除并且任何之前存在的文件不会被取代.

        允许去关闭一个已经关闭的流[stream], 但是在这个情况中结果是依赖于具体实现的[implementation-dependent].

        在流 stream 被关闭后, 仍然可能在它上面执行一下查询操作: streamp, pathname, truename, merge-pathnames, pathname-host, pathname-device, pathname-directory,pathname-name, pathname-type, pathname-version, namestring, file-namestring, directory-namestring, host-namestring, enough-namestring, open, probe-file, 和 directory.

        在一个构造的流[constructed stream]上的 close 的效果只是去关闭这个参数 stream. 对复合流[composite stream]的组成部分[constituent]没有影响.

        对于一个用 make-string-output-stream 创建的流[stream], 在 close 后的 get-output-stream-string 结果是未指定的.

* 示例(Examples):

    ```LISP
    (setq s (make-broadcast-stream)) =>  #<BROADCAST-STREAM>
    (close s) =>  T
    (output-stream-p s) =>  true
    ```

* 副作用(Side Effects):

        流 stream 会被关闭[close] (如果必要的话). 如果 abort 是 true 并且这个流 stream 是一个输出[output]文件流[file stream], 它关联的文件[file]可能被删除.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 也见(See Also):

        open

* 注意(Notes): None. 


### <span id="M-WITH-OPEN-STREAM">宏 WITH-OPEN-STREAM</span>

* 语法(Syntax):

        with-open-stream (var stream) declaration* form*
        => result*

* 参数和值(Arguments and Values):

        var---一个变量[variable]名字[name].
        stream---一个表达式形式[form]; 求值来产生一个流[stream].
        declaration---一个 declare 表达式[expression]; 不求值.
        forms---一个隐式 progn [implicit progn].
        results---由这些表达式形式 forms 返回的那些值[value].

* 描述(Description):

        with-open-stream 在流 stream 上执行一系列操作, 并返回一个值, 然后关闭这个流 stream.

        var 被绑定为这个流 stream 的值, 然后这些表达式形式 forms 就像一个隐式的 progn [implicit progn]一样被求值. 流 stream 在从 with-open-stream 退出时会被自动关闭, 不管这个退出是正常的还是不正常的. 流 stream 有着动态范围[dynamic extent]; 它的范围[extent]在这个表达式形式[form]退出时结束.

        如果在这些表达式形式 forms 中尝试去对变量[variable] var 赋值[assign]后果是未定义的.

* 示例(Examples):

    ```LISP
    (with-open-stream (s (make-string-input-stream "1 2 3 4"))
        (+ (read s) (read s) (read s))) =>  6
    ```

* 副作用(Side Effects):

        这个流 stream 会被关闭 (退出时).

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 也见(See Also):

        close

* 注意(Notes): None. 


### <span id="F-LISTEN">函数 LISTEN</span>

* 语法(Syntax):

        listen &optional input-stream => generalized-boolean

* 参数和值(Arguments and Values):

        input-stream---一个输入[input]流标识符[stream designator]. 默认是标准输入[standard input].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果从输入流 input-stream 立即有一个字符可用就返回 true; 否则, 返回 false. 在一个非交互式输入流上, listen 返回 true, 除了到文件末尾[end of file[1]]时例外. 如果到达文件的末尾[end of file], listen 返回 false. 当输入流 input-stream 从一个交互式设备如键盘中获得字符时, 就可以使用 listen.

* 示例(Examples):

    ```LISP
    (progn (unread-char (read-char)) (list (listen) (read-char)))
    >>  1
    =>  (T #\1)
    (progn (clear-input) (listen))
    =>  NIL ;Unless you're a very fast typist!
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        *standard-input*

* 异常情况(Exceptional Situations): None.

* 也见(See Also):

        interactive-stream-p, read-char-no-hang

* 注意(Notes): None. 


### <span id="F-CLEAR-INPUT">函数 CLEAR-INPUT</span>

* 语法(Syntax):

        clear-input &optional input-stream => nil

* 参数和值(Arguments and Values):

        input-stream---一个输入[input]流标识符[stream designator]. 默认是标准输入[standard input].

* 描述(Description):

        从输入流 input-stream 中清除任何可用的输入.

        如果 clear-input 对输入流 input-stream 没有意义, 那么 clear-input 什么都不做.

* 示例(Examples):

    ```LISP
    ;; The exact I/O behavior of this example might vary from implementation
    ;; to implementation depending on the kind of interactive buffering that
    ;; occurs.  (The call to SLEEP here is intended to help even out the 
    ;; differences in implementations which do not do line-at-a-time buffering.)

    (defun read-sleepily (&optional (clear-p nil) (zzz 0))
      (list (progn (print '>) (read))
            ;; Note that input typed within the first ZZZ seconds 
            ;; will be discarded.
            (progn (print '>) 
                  (if zzz (sleep zzz))
                  (print '>>)
                  (if clear-p (clear-input))
                  (read))))

    (read-sleepily)
    >>  > 10
    >>  >
    >>  >> 20
    =>  (10 20)

    (read-sleepily t)
    >>  > 10
    >>  >
    >>  >> 20
    =>  (10 20)

    (read-sleepily t 10)
    >>  > 10
    >>  > 20  ; Some implementations won't echo typeahead here.
    >>  >> 30
    =>  (10 30)
    ```

* 副作用(Side Effects):

        输入流 input-stream 会被修改.

* 受此影响(Affected By):

        *standard-input*

* 异常情况(Exceptional Situations):

        如果 input-stream 不是一个流标识符[stream designator], 就应该发出一个 type-error 类型[type]的错误.

* 也见(See Also):

        clear-output

* 注意(Notes): None. 


### <span id="F-FINISH-AND-FORCE-AND-CLEAR-OUTPUT">函数 FINISH-OUTPUT, FORCE-OUTPUT, CLEAR-OUTPUT</span>

* 语法(Syntax):

        finish-output &optional output-stream => nil

        force-output &optional output-stream => nil

        clear-output &optional output-stream => nil

* 参数和值(Arguments and Values):

        output-stream---一个输出[output]流标识符[stream designator]. 默认是标准输出[standard output].

* 描述(Description):

        finish-output, force-output, 和 clear-output 可以控制缓冲流输出的内部处理.

        finish-output 尝试去确保任何发送到 output-stream 的缓冲输出已经到达目的地, 然后返回.

        force-output 开始内部缓冲区的清空, 但不等待完成或确认返回.

        clear-output 试图中止任何正在进行中的未完成的输出操作, 以便允许尽可能少的输出继续到目的地.

        如果这些操作的任何一个对于 output-stream 没有意义, 那么它什么都不做. 这些函数[function]的准确行为是依赖于具体实现的[implementation-dependent].

* 示例(Examples):

    ```LISP
    ;; Implementation A
    (progn (princ "am i seen?") (clear-output))
    =>  NIL

    ;; Implementation B
    (progn (princ "am i seen?") (clear-output))
    >>  am i seen?
    =>  NIL
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        *standard-output*

* 异常情况(Exceptional Situations):

        如果 output-stream 不是一个流标识符[stream designator], 就应该发出一个 type-error 类型[type]的错误.

* 也见(See Also):

        clear-input

* 注意(Notes): None. 


### <span id="F-Y-OR-N-P-YES-OR-NO-P">函数 Y-OR-N-P, YES-OR-NO-P</span>

* 语法(Syntax):

        y-or-n-p &optional control &rest arguments => generalized-boolean

        yes-or-no-p &optional control &rest arguments => generalized-boolean

* 参数和值(Arguments and Values):

        control---一个格式化控制[format control].
        arguments---control 的格式化参数[format argument].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        这些函数询问一个问题并且解析一个来自用户的响应. 如果回答是肯定的, 它们返回 true, 如果是否定的就是 false.

        y-or-n-p 被用于询问用户一个答案为 "yes" 或 "no" 的问题. 它的目的是要求用户用一个字符来回答一个 yes-or-no 的问题. yes-or-no-p 也被用于询问用户一个答案为 "yes" 或 "no" 的问题. 它的目的是要求用户采取更多的操作, 而不仅仅是一次击键, 比如输入完整的单词 "yes" 或 "no", 然后是换行符.

        y-or-n-p 输出一个信息 (如果提供的话), 以某种依赖于具体实现[implementation-dependent]的方式读取一个回答 (目的是为了简短和简单, 比如读取一个字符, 比如 Y 或 N). yes-or-no-p 输出一个信息 (如果提供的话), 吸引用户的注意力 (比如, 通过终端的响铃), 并且以某种依赖于具体实现[implementation-dependent]的方式读取一个回答 (目的是多字符, 比如 YES 或 NO).

        如果提供了 format-control 并且不是 nil, 那么会执行一个 fresh-line 操作; 然后打印一个信息, 就好像 format-control 和 arguments 给到 format 一样. 在任何情况下, 如果合适的话, yes-or-no-p 和 y-or-n-p 会提供一个提示, 比如 "(Y or N)" 或 "(Yes or No)".

        所有输入和输出执行都使用查询 I/O [query I/O].

* 示例(Examples):

    ```LISP
    (y-or-n-p "(t or nil) given by")
    >>  (t or nil) given by (Y or N) Y
    =>  true
    (yes-or-no-p "a ~S message" 'frightening) 
    >>  a FRIGHTENING message (Yes or No) no
    =>  false
    (y-or-n-p "Produce listing file?") 
    >>  Produce listing file?
    >>  Please respond with Y or N. n
    =>  false
    ```

* 副作用(Side Effects):

        会发生查询 I/O [query I/O]的输入或输出.

* 受此影响(Affected By):

        *query-io*.

* 异常情况(Exceptional Situations): None.

* 也见(See Also):

        format

* 注意(Notes):

        yes-or-no-p 和 yes-or-no-p 不会在提示字符串的末尾添加问号, 因此任何想要的问号或其他标点符号都应该显式地包含在文本查询中. 


### <span id="F-MAKE-SYNONYM-STREAM">函数 MAKE-SYNONYM-STREAM</span>

* 语法(Syntax):

        make-synonym-stream symbol => synonym-stream

* 参数和值(Arguments and Values):

        symbol---命名动态变量[dynamic variable]的一个符号[symbol].
        synonym-stream---一个同义流[synonym stream].

* 描述(Description):

        返回一个同义流符号[synonym stream symbol]是 symbol 的同义流[synonym stream].

* 示例(Examples):

    ```LISP
    (setq a-stream (make-string-input-stream "a-stream")
            b-stream (make-string-input-stream "b-stream"))
    =>  #<String Input Stream> 
    (setq s-stream (make-synonym-stream 'c-stream))
    =>  #<SYNONYM-STREAM for C-STREAM> 
    (setq c-stream a-stream)
    =>  #<String Input Stream> 
    (read s-stream) =>  A-STREAM
    (setq c-stream b-stream)
    =>  #<String Input Stream> 
    (read s-stream) =>  B-STREAM
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果它的参数不是一个符号[symbol]就应该发出 type-error.

* 也见(See Also):

        章节 21.1 (流的概念)

* 注意(Notes): None. 


### <span id="F-SYNONYM-STREAM-SYMBOL">函数 SYNONYM-STREAM-SYMBOL</span>

* 语法(Syntax):

        synonym-stream-symbol synonym-stream => symbol

* 参数和值(Arguments and Values):

        synonym-stream---一个同义流[synonym stream].
        symbol---一个符号[symbol].

* 描述(Description):

        返回 symbol-value 正在被这个同义流 synonym-stream 所使用的符号[symbol].

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 也见(See Also):

        make-synonym-stream

* 注意(Notes): None. 


### <span id="F-BROADCAST-STREAM-STREAMS">函数 BROADCAST-STREAM-STREAMS</span>

* 语法(Syntax):

        broadcast-stream-streams broadcast-stream => streams

* 参数和值(Arguments and Values):

        broadcast-stream---一个广播流[broadcast stream].
        streams---一个流[stream]列表[list].

* 描述(Description):

        返回由这个广播流 broadcast-stream 正在广播的所有流[stream]组成的一个输出流[stream]列表[list].

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 也见(See Also): None.

* 注意(Notes): None. 


### <span id="F-MAKE-BROADCAST-STREAM">函数 MAKE-BROADCAST-STREAM</span>

* 语法(Syntax):

        make-broadcast-stream &rest streams => broadcast-stream

* 参数和值(Arguments and Values):

        stream---一个输出[output]流[stream].
        broadcast-stream---一个广播流[broadcast stream].

* 描述(Description):

        返回一个广播流[broadcast stream].

* 示例(Examples):

    ```LISP
    (setq a-stream (make-string-output-stream)
            b-stream (make-string-output-stream)) =>  #<String Output Stream>
    (format (make-broadcast-stream a-stream b-stream)
              "this will go to both streams") =>  NIL
    (get-output-stream-string a-stream) =>  "this will go to both streams"
    (get-output-stream-string b-stream) =>  "this will go to both streams"
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果任何一个 stream 不是一个输出[output]流[stream]就会发出一个 type-error 类型[type]的错误.

* 也见(See Also):

        broadcast-stream-streams

* 注意(Notes): None. 


### <span id="F-MAKE-TWO-WAY-STREAM">函数 MAKE-TWO-WAY-STREAM</span>

* 语法(Syntax):

        make-two-way-stream input-stream output-stream => two-way-stream

* 参数和值(Arguments and Values):

        input-stream---一个流[stream].
        output-stream---一个流[stream].
        two-way-stream---一个双向流[two-way stream].

* 描述(Description):

        返回一个从 input-stream 得到输入并发送输出到 output-stream 的双向流[two-way stream].

* 示例(Examples):

    ```LISP
    (with-output-to-string (out)
        (with-input-from-string (in "input...")
          (let ((two (make-two-way-stream in out)))
            (format two "output...")
            (setq what-is-read (read two))))) =>  "output..."
    what-is-read =>  INPUT... 
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 input-stream 不是一个输入[input]流[stream]就应该发出一个 type-error 类型[type]的错误. 如果 output-stream 不是一个输出[output]流[stream]就应该发出一个 type-error 类型[type]的错误.

* 也见(See Also): None.

* 注意(Notes): None. 


### <span id="F-T-W-S-INPUT-AND-OUTPUT-STREAM">函数 TWO-WAY-STREAM-INPUT-STREAM, TWO-WAY-STREAM-OUTPUT-STREAM</span>

* 语法(Syntax):

        two-way-stream-input-stream two-way-stream => input-stream

        two-way-stream-output-stream two-way-stream => output-stream

* 参数和值(Arguments and Values):

        two-way-stream---一个 two-way-stream 双向流[two-way stream].
        input-stream---一个输入[input]流[stream].
        output-stream---一个输出[output]流[stream].

* 描述(Description):

        two-way-stream-input-stream 返回 two-way-stream 接收输入的那个流[stream].

        two-way-stream-output-stream 返回 two-way-stream 发送输出的那个流[stream].

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 也见(See Also): None.

* 注意(Notes): None. 


### <span id="F-ECHO-STREAM-INPUT-AND-OUTPUT-STREAM">函数 ECHO-STREAM-INPUT-STREAM, ECHO-STREAM-OUTPUT-STREAM</span>

* 语法(Syntax):

        echo-stream-input-stream echo-stream => input-stream

        echo-stream-output-stream echo-stream => output-stream

* 参数和值(Arguments and Values):

        echo-stream---一个回显流[echo stream].
        input-stream---一个输入[input]流[stream].
        output-stream---一个输出[output]流[stream].

* 描述(Description):

        echo-stream-input-stream 返回 echo-stream 接收输入的那个输入[input]流[stream].

        echo-stream-output-stream 分拣 echo-stream 发送输出的那个输出[output]流[stream].

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 也见(See Also): None.

* 注意(Notes): None. 


### <span id="F-MAKE-ECHO-STREAM">函数 MAKE-ECHO-STREAM</span>

* 语法(Syntax):

        make-echo-stream input-stream output-stream => echo-stream

* 参数和值(Arguments and Values):

        input-stream---一个输入[input]流[stream].
        output-stream---一个输出[output]流[stream].
        echo-stream---一个回显流[echo stream].

* 描述(Description):

        创建并返回一个从 input-stream 获取输入并发送输出到 output-stream 的回显流[echo stream].

* 示例(Examples):

    ```LISP
    (let ((out (make-string-output-stream)))
        (with-open-stream 
            (s (make-echo-stream
                (make-string-input-stream "this-is-read-and-echoed")
                out))
          (read s)
          (format s " * this-is-direct-output")
          (get-output-stream-string out)))
    =>  "this-is-read-and-echoed * this-is-direct-output"
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 也见(See Also):

        echo-stream-input-stream, echo-stream-output-stream, make-two-way-stream

* 注意(Notes): None. 


### <span id="F-CONCATENATED-STREAM-STREAMS">函数 CONCATENATED-STREAM-STREAMS</span>

* 语法(Syntax):

        concatenated-stream-streams concatenated-stream => streams

* 参数和值(Arguments and Values):

        concatenated-stream -- 一个连接流[concatenated stream].
        streams---一个输入[input]流[stream]列表[list].

* 描述(Description):

        返回组成连接流 concatenated-stream 仍然需要读取的有序流[stream]的集合 streams 的输入[input]流[stream]列表[list], 从当前读取的流开始. 如果没有更多的流[stream]被读取, 这个列表可能是空的.

        如果这些流 streams 的列表结构[list structure]被修改, 那么后果是未定义的.

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 也见(See Also): None.

* 注意(Notes): None.


### <span id="F-MAKE-CONCATENATED-STREAM">函数 MAKE-CONCATENATED-STREAM</span>

* 语法(Syntax):

        make-concatenated-stream &rest input-streams => concatenated-stream

* 参数和值(Arguments and Values):

        input-stream---一个输入[input]流[stream].
        concatenated-stream---一个连接流[concatenated stream].

* 描述(Description):

        返回一个连接流[concatenated stream], 它具有最初与之关联的那些输入流 input-streams.

* 示例(Examples):

    ```LISP
    (read (make-concatenated-stream
            (make-string-input-stream "1")
            (make-string-input-stream "2"))) =>  12
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果任何一个参数不是一个输入[input]流[stream]就应该发出 type-error.

* 也见(See Also):

        concatenated-stream-streams

* 注意(Notes): None. 


### <span id="F-GET-OUTPUT-STREAM-STRING">函数 GET-OUTPUT-STREAM-STRING</span>

* 语法(Syntax):

        get-output-stream-string string-output-stream => string

* 参数和值(Arguments and Values):

        string-output-stream---一个流[stream].
        string---一个字符串[string].

* 描述(Description):

        返回一个字符串[string], 其中按顺序包含已输出到 string-output-stream 的所有字符[character]. 这个操作清除 string-output-stream 上的任何字符[character], 所以这个字符串 string 只包含从上一次对 get-output-stream-string 的调用开始或者从 string-output-stream 创建以来输出的那些字符, 取最近发生的那种情况.

* 示例(Examples):

    ```LISP
    (setq a-stream (make-string-output-stream)
            a-string "abcdefghijklm") =>  "abcdefghijklm"
    (write-string a-string a-stream) =>  "abcdefghijklm"
    (get-output-stream-string a-stream) =>  "abcdefghijklm"
    (get-output-stream-string a-stream) =>  ""
    ```

* 副作用(Side Effects):

        这个 string-output-stream 会被清理.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 stream-output-string 是关闭的[closed], 那么后果是未定义的.

        如果 string-output-stream 是一个不是由 make-string-output-stream 产生的流[stream], 那么后果是未定义的. 如果 string-output-stream 是由 with-output-to-string 或 format 隐式创建的, 那么后果是未定义的.

* 也见(See Also):

        make-string-output-stream

* 注意(Notes): None. 


### <span id="F-MAKE-STRING-INPUT-STREAM">函数 MAKE-STRING-INPUT-STREAM</span>

* 语法(Syntax):

        make-string-input-stream string &optional start end => string-stream

* 参数和值(Arguments and Values):

        string---一个字符串[string].
        start, end---string 的边界索引标识符[bounding index designator]. 对于 start 和 end 默认分别为 0 和 nil.
        string-stream---一个输入[input]字符串流[string stream].

* 描述(Description):

        返回一个输入[input]字符串流[string stream]. 这个流[stream]会依次提供 string 中由 start 和 end 限定[bounded]的子字符串的字符[character]. 在最后一个字符[character]被提供之后, 这个字符串流会到达文件的末尾[end of file].

* 示例(Examples):

    ```LISP
    (let ((string-stream (make-string-input-stream "1 one ")))
      (list (read string-stream nil nil)
            (read string-stream nil nil)
            (read string-stream nil nil)))
    =>  (1 ONE NIL)

    (read (make-string-input-stream "prefixtargetsuffix" 6 12)) =>  TARGET
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 也见(See Also):

        with-input-from-string

* 注意(Notes): None. 


### <span id="F-MAKE-STRING-OUTPUT-STREAM">函数 MAKE-STRING-OUTPUT-STREAM</span>

* 语法(Syntax):

        make-string-output-stream &key element-type => string-stream

* 参数和值(Arguments and Values):

        element-type---一个类型指定符[type specifier]. 默认是 character.
        string-stream---一个输出[output]字符串流[string stream].

* 描述(Description):

        返回一个接收字符[character]的输出[output]字符串流[string stream], 并提供一个包含实际输出字符[character]的字符串[string] (通过 get-output-stream-string).

        这个元素类型 element-type 命名这个字符串[string]元素[element]的类型[type]; 一个字符串[string]由可以容纳 element-type 元素类型的最具体的类型[type]构成.

* 示例(Examples):

    ```LISP
    (let ((s (make-string-output-stream)))
      (write-string "testing... " s)
      (prin1 1234 s)
      (get-output-stream-string s))
    =>  "testing... 1234"
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 也见(See Also):

        get-output-stream-string, with-output-to-string

* 注意(Notes): None. 


### <span id="M-WITH-INPUT-FROM-STRING">宏 WITH-INPUT-FROM-STRING</span>

* 语法(Syntax):

        with-input-from-string (var string &key index start end) declaration* form*
        => result*

* 参数和值(Arguments and Values):

        var---一个变量[variable]名[name].
        string---一个表达式形式[form]; 求值来产生一个字符串[string].
        index---一个位置[place].
        start, end---string 的边界索引标识符[bounding index designator]. 对于 start 和 end 默认分别为 0 和 nil.
        declaration---一个 declare 表达式[expression]; 不求值.
        forms---一个隐式 progn [implicit progn].
        result---由这些表达式形式 forms 返回的那些[value].

* 描述(Description):

        创建一个输入[input]字符串流[string stream], 提供一个机会来执行在这个流[stream]上的操作 (返回零个或更多的值[value]), 然后关闭这个字符串流[string stream].

        string 首先被求值, 并且 var 被绑定为一个字符输入[input]字符串流[string stream], 它从由 start 和 end 限定[bounded]的字符串[string]的子序列中提供字符[character]. 主体部分作为一个隐式 progn [implicit progn]求值.

        在从 with-input-from-string 退出时这个输入[input]字符串流[string stream]会自动关闭, 不管这个退出是正常的还是反常的. 变量 var 绑定的输入[input]字符串流[string stream]有着动态范围[dynamic extent]; 它的范围[extent]在这个表达式形式[form]退出时结束.

        这个 index 是这个要被推进的字符串 string 中的一个指针. 如果 with-input-from-string 正常退出, 那么 index 的值[value]就是字符串 string 中表示第一个没有读取的字符的索引, 如果所有字符都使用了那么它就是 (length string). 由 index 指定的位置不会随着读取进度而更新, 但是只有在这个操作的结尾更新.

        start 和 index 可能都指向同一个变量, 它是要被推进的字符串 string 中的一个指针, 可能由一些包含循环重复地指定.

        如果尝试去对变量[variable] var 赋值[assign], 那么后果是未定义的.

* 示例(Examples):

    ```LISP
    (with-input-from-string (s "XXX1 2 3 4xxx"
                                :index ind
                                :start 3 :end 10)
        (+ (read s) (read s) (read s))) =>  6
    ind =>  9
    (with-input-from-string (s "Animal Crackers" :index j :start 6)
      (read s)) =>  CRACKERS
    ```

        变量 j 会被设置为 15.

* 副作用(Side Effects):

        由 index 命名的位置[place]如果存在的话, 值[value]会被修改.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 也见(See Also):

        make-string-input-stream, 章节 3.6 (遍历规则和副作用)

* 注意(Notes): None. 


### <span id="M-WITH-OUTPUT-TO-STRING">宏 WITH-OUTPUT-TO-STRING</span>

* 语法(Syntax):

        with-output-to-string (var &optional string-form &key element-type) declaration* form*
        => result*

* 参数和值(Arguments and Values):

        var---一个变量[variable]名字[name].
        string-form---一个表达式形式[form]或 nil; 如果是非 nil [non-nil], 求值产生字符串 string.
        string---一个有着填充指针[fill pointer]的字符串[string].
        element-type---一个类型指定符[type specifier]; 求值的. 默认是 character.
        declaration---一个 declare 表达式[expression]; 不求值.
        forms---一个隐式 progn [implicit progn].
        results---如果没有提供一个 string-form 或者是 nil, 就是一个字符串[string]; 否则, 就是这些表达式形式 forms 返回的值[value].

* 描述(Description):

        with-output-to-string 创建一个字符输出[output]流[stream], 执行可能发送结果到这个流[stream]的一系列操作, 然后关闭这个流[stream].

        这个元素类型 element-type 命名这个流[stream]的元素的类型[type]; 一个流[stream]由可以容纳给定类型[type]的元素的最具体的类型[type]构成.

        这个主体作为一个隐式的 progn [implicit progn]被执行, 其中 var 被绑定为一个输出[output]字符串流[string stream]. 所有到那个字符串流[string stream]的输出都会保存到一个字符串[string]中.

        如果提供了 string, 那么 element-type 会被忽略, 并且这个输出会被递增地追加给这个字符串 string, 就像是通过 vector-push-extend 一样.

        这个输出[output]流[stream]在从 with-output-from-string 退出时会自动关闭, 不管这个退出是正常的还是异常的. 这个绑定[bound]给变量[variable] var 的输出[output]字符串流[string stream]有着动态范围[dynamic extent]; 它的范围[extent]在退出这个表达式形式[form]时终止.

        如果没有提供 string, 那么 with-output-from-string 产生一个接收字符的流并返回一个指定的 element-type 元素类型的字符串[string]的流[stream]. 如果提供了 string, with-output-to-string 返回求值最后一个表达式形式 form 的结果.

        如果尝试去对变量[variable] var 赋值[assign], 那么后果是未定义的.

* 示例(Examples):

    ```LISP
    (setq fstr (make-array '(0) :element-type 'base-char
                                :fill-pointer 0 :adjustable t)) =>  ""
    (with-output-to-string (s fstr)
        (format s "here's some output")
        (input-stream-p s)) =>  false
    fstr =>  "here's some output"
    ```

* 副作用(Side Effects):

        这个 string 会被修改.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果在这个调用的动态范围[dynamic extent]内直接执行 string 上的破坏性修改, 那么后果是未定义的.

* 也见(See Also):

        make-string-output-stream, vector-push-extend, 章节 3.6 (遍历规则和副作用)

* 注意(Notes): None. 


### <span id="V-IO-ALL">变量 *DEBUG-IO*, *ERROR-OUTPUT*, *QUERY-IO*, *STANDARD-INPUT*, *STANDARD-OUTPUT*, *TRACE-OUTPUT*</span>

* 值类型(Value Type):

        *standard-input*: 一个输入[input]流[stream]

        *error-output*, *standard-output*, 和 *trace-output*: 一个输出[output]流[stream].

        *debug-io*, *query-io*: 一个双向[bidirectional]流[stream].

* 初始值(Initial Value):

        依赖于具体实现[implementation-dependent], 但是它必须是一个打开的[open]流[stream], 不是一个到 I/O 定制变量[I/O customization variable]的广义同义流[generalized synonym stream]但是可能是一个到某个 I/O 定制变量[I/O customization variable]的值的广义同义流[generalized synonym stream]. 这个初始值可能也是一个广义同义流[generalized synonym stream], 是符号[symbol] *terminal-io* 或者是作为它的值[value]的流[stream].

* 描述(Description):

        这些变量[variable]全体被称为标准化[standardized] I/O 定制变量[I/O customization variable]. 它们可以被绑定[bound]和赋值[assign], 来更改各种标准化[standardized]操作符[operator]和工具所使用的输入和/或输出的默认目的地.

        *debug-io* 的值[value], 称为调试 I/O [debug I/O], 是一个被用于交互式调试目的的流[stream].

        *error-output* 的值[value], 称为错误输出[error output], 是一个警告和非交互式错误信息应该被发送到的流[stream].

        *query-io* 的值[value], 称为查询 I/O [query I/O], 是一个在询问用户问题时使用的双向[bidirectional]流[stream]. 这个问题应该输出到这个流[stream]中, 并且答复也从这个流读取.

        *standard-input* 的值[value], 称为标准输入[standard input], 是许多操作符[operator]没有明确提供特定的输入[input]流[stream]时用作默认的输入源使用的一个流[stream].

        *standard-output* 的值[value], 称为标准输出[standard output], 是许多操作符[operator]没有明确提供特定的输出[output]流[stream]时用作默认的目的地使用的一个流[stream].

        *trace-output* 的值[value], 称为跟踪输出[trace output], 是一个流[stream], 跟踪函数(见 trace)和 time 宏[macro]打印它们的输出到这个流上.

* 示例(Examples):

    ```LISP
    (with-output-to-string (*error-output*)
      (warn "this string is sent to *error-output*"))
    =>  "Warning: this string is sent to *error-output*
    " ;The exact format of this string is implementation-dependent.

    (with-input-from-string (*standard-input* "1001")
        (+ 990 (read))) =>  1991                       

    (progn (setq out (with-output-to-string (*standard-output*)
                        (print "print and format t send things to")
                        (format t "*standard-output* now going to a string")))
            :done)
    =>  :DONE
    out
    =>  "
    \"print and format t send things to\" *standard-output* now going to a string"

    (defun fact (n) (if (< n 2) 1 (* n (fact (- n 1)))))
    =>  FACT
    (trace fact)
    =>  (FACT)
    ;; Of course, the format of traced output is implementation-dependent.
    (with-output-to-string (*trace-output*)
      (fact 3)) 
    =>  "
    1 Enter FACT 3
    | 2 Enter FACT 2
    |   3 Enter FACT 1
    |   3 Exit FACT 1
    | 2 Exit FACT 2
    1 Exit FACT 6"
    ```

* 也见(See Also):

        *terminal-io*, synonym-stream, time, trace, 章节 9 (状况), 章节 23 (读取器), 章节 22 (打印器)

* 注意(Notes):

        这些 I/O 定制变量[I/O customization variable]的初始值[value]上约束的意图是去确保绑定[bind]或赋值[assign]这样一个变量[variable]到另一个 I/O 定制变量[I/O customization variable]的值[value]总是安全的, 不过度限制具体实现[implementation]的灵活性.

        使 *debug-io* 和 *query-io* 的初始值[value]为同一个[same]流[stream]以及使 *error-output* 和 *standard-output* 的初始值[value]为同一个[same]流[stream]对于一个实现[implementation]来说是很常见的.

        函数 y-or-n-p 和 yes-or-no-p 使用查询 I/O [query I/O]作为它们的输入和输出.

        在正常的 Lisp read-eval-print 循环[Lisp read-eval-print loop]中, 输入是从标准输入[standard input]读取的. 很多输入函数, 包括 read 和 read-char, 接收一个默认为标准输入[standard input]的流[stream]参数.

        在正常的 Lisp read-eval-print 循环[Lisp read-eval-print loop]中, 输出被发送到标准输出[standard output]. 很多输出函数, 包括 print 和 write-char, 接受默认为标准输出[standard output]的流[stream]参数.

        例如, 一个程序想要将输出转移到文件中, 应该通过绑定[binding] *standard-output* 来实现; 发送到 *error-output* 的错误消息仍然可以通过 *terminal-io* 到达用户(如果 *error-output* 被绑定到 *terminal-io* 的话), 这通常是需要的. 


### <span id="V-TERMINAL-IO">变量 *TERMINAL-IO*</span>

* 值类型(Value Type):

        一个双向[bidirectional]流[stream].

* 初始值(Initial Value):

        依赖于具体实现[implementation-dependent], 但是它必须是一个打开的[open]流[stream], 不是一个到 I/O 定制变量[I/O customization variable]的广义同义流[generalized synonym stream]但是可能是一个到某个 I/O 定制变量[I/O customization variable]的值[value]的广义同义流[generalized synonym stream].

* 描述(Description):

        被称为终端 I/O [terminal I/O]的 *terminal-io* 的值[value]通常是一个连接到用户终端的双向[bidirectional]流[stream]. 通常, 写入到这个流[stream]会导致输出出现在一个显示的屏幕, 比如, 从这个流[stream]读取会从键盘接收一个输入. 它的目的是, 当与这个流[stream]一起使用时, 诸如 read 和 read-char 之类的标准输入函数, 会引起输入到流的输出端的回显. 实现这一点的方法是依赖于具体实现的[implementation-dependent].

        改变 *terminal-io* 的值[value]的效果, 不管是通过绑定[binding]还是赋值[assign], 都是具体实现定义的[implementation-defined].

* 示例(Examples):

    ```LISP
    (progn (prin1 'foo) (prin1 'bar *terminal-io*))
    >>  FOOBAR
    =>  BAR
    (with-output-to-string (*standard-output*)
      (prin1 'foo) 
      (prin1 'bar *terminal-io*))
    >>  BAR
    =>  "FOO"
    ```

* 受此影响(Affected By): None.

* 也见(See Also):

        *debug-io*, *error-output*, *query-io*, *standard-input*, *standard-output*, *trace-output*

* 注意(Notes): None. 


### <span id="CT-STREAM-ERROR">状况类型 STREAM-ERROR</span>

* 类优先级列表(Class Precedence List):

        stream-error, error, serious-condition, condition, t

* 描述(Description):

        类型[type] stream-error 由从一个流[stream]接收输入或发送输出到一个流[stream]相关的错误状况构成. 这个 "违规的流" 通过 make-condition 的 :streaminitialization 参数来初始化, 并且通过函数[function] stream-error-stream 来访问.

* 也见(See Also):

        stream-error-stream 


### <span id="F-STREAM-ERROR-STREAM">函数 STREAM-ERROR-STREAM</span>

* 语法(Syntax):

        stream-error-stream condition => stream

* 参数和值(Arguments and Values):

        condition---一个 stream-error 类型[type]的状况[condition].
        stream---一个流[stream].

* 描述(Description):

        返回一个 stream-error 类型[type]的状况[condition]的违规的流[stream].

* 示例(Examples):

    ```LISP
    (with-input-from-string (s "(FOO")
      (handler-case (read s)
        (end-of-file (c)
          (format nil "~&End of file on ~S." (stream-error-stream c)))))
    "End of file on #<String Stream>."
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 也见(See Also):

        stream-error, 章节 9 (状况)

* 注意(Notes): None. 


### <span id="CT-END-OF-FILE">状况类型 END-OF-FILE</span>

* 类优先级列表(Class Precedence List):

        end-of-file, stream-error, error, serious-condition, condition, t

* 描述(Description):

        类型[type] end-of-file 由在没有更多数据的流[stream]中执行读取操作相关的错误状况组成.

* 也见(See Also):

        stream-error-stream 


# 22. 打印器

> * 22.1 [Lisp 打印器](#TheLispPrinter)
> * 22.2 [Lisp 美观打印器](#TheLispPrettyPrinter)
> * 22.3 [格式化输出](#FormattedOutput)
> * 22.4 [打印器的字典](#ThePrinterDictionary)


## 22.1 <span id="TheLispPrinter">Lisp 打印器</span>

> * 22.1.1 [Lisp 打印器概览](#OverviewTheLispPrinter)
> * 22.1.2 [打印器分派](#PrinterDispatching)
> * 22.1.3 [默认 Print-Object 方法](#DefaultPrintObjectMethods)
> * 22.1.4 [打印器行为的示例](#ExamplesPrinterBehavior)

### 22.1.1 <span id="OverviewTheLispPrinter">Lisp 打印器概览</span>

Common Lisp 以打印文本的形式提供了大多数对象[object]的表示形式, 称为打印表示. 像 print 这样的函数接受一个对象[object]并且把它的打印表示的那些字符发送给一个流[stream]. 做这些的例程集合被称为 (Common Lisp) 打印器.

读取一个打印表示通常产生一个和原始打印对象[object] equal 的对象[object].

#### 22.1.1.1 多种可能的文本表示

大部分对象[object]有着超过一个可能的文本表示. 比如, 一个大小为 27 的正整数[integer]在文本上可以被表示为这些方式的任意一种:

    27    27.    #o33    #x1B    #b11011    #.(* 3 3 3)    81/3

一个包含两个符号 A 和 B 的列表也在文本上被表示为好几种方式:

    (A B)    (a b)    (  a  b )    (\A |B|) 
    (|\A|
      B
    )

通常情况下, 从 Lisp 读取器[Lisp reader]的视角看, 在一个文本表示允许空白字符[whitespace]的地方, 任意数量的空格[space]和换行[newline]可以出现在标准语法[standard syntax]中.

当一个比如 print 这样的函数产生一个打印表示时, 它必须从几个可能的文本表示中选择. 在大部分情况下, 它选择一个程序可读的表示, 但在某些情况下, 它可能使用更紧凑的符号, 而不是程序可读的.

提供了许多被称之为打印器控制变量[printer control variable]的选项变量来允许控制对象[object]的打印表示的各个方面. 下一段中展示了标准[standardized]打印器控制变量[printer control variable]; 这里也可能存在具体实现定义[implementation-defined]的打印器控制变量[printer control variable].

    *print-array*   *print-gensym*       *print-pprint-dispatch*  
    *print-base*    *print-length*       *print-pretty*           
    *print-case*    *print-level*        *print-radix*            
    *print-circle*  *print-lines*        *print-readably*         
    *print-escape*  *print-miser-width*  *print-right-margin*     

    Figure 22-1. 标准打印器控制变量

除了打印器控制变量[printer control variable]之外, 下面附加的已定义名称[defined name]与 Lisp 打印器[Lisp printer]的行为相关或影响着 Lisp 打印器[Lisp printer]的行为:

    *package*                    *read-eval*  readtable-case  
    *read-default-float-format*  *readtable*                  

    Figure 22-2. 对 Lisp 打印器的额外影响.

##### 22.1.1.1.1 打印器转义

变量[variable] \*print-escape* 控制 Lisp 打印器[Lisp printer]是否尝试去产生诸如转义字符和包前缀这类的标记.

当程序可读的输出特别重要时, 变量[variable] \*print-readably* 可以被用于重写由其他打印器控制变量[printer control variable]控制的各个方面.

使 \*print-readably* 的值[value]为 true 的诸多影响之一是 Lisp 打印器[Lisp printer]表现地就好像 \*print-escape* 也是 true 一样. 为了表示方便, 我们说如果 \*print-readably* 或 \*print-escape* 任意一个值是 true, 那么打印器转义[printer escaping]就是 "启用的"; 并且我们说如果 \*print-readably* 和 \*print-escape* 的值都是 false, 那么打印器转义[printer escaping]就是 "禁用的". 

### 22.1.2 <span id="PrinterDispatching">打印器分派</span>

Lisp 打印器[Lisp printer]决定如何打印一个对象[object], 如下所示:

如果 \*print-pretty* 的值[value]是 true, 打印由当前美观打印分派表[current pprint dispatch table]控制; 见章节 22.2.1.4 (美观打印分派表).

否则 (如果 \*print-pretty* 的值[value]是 false), 使用对象的 print-object 方法; 见章节 22.1.3 (默认 Print-Object 方法). 

### 22.1.3 <span id="DefaultPrintObjectMethods">默认 Print-Object 方法</span>

这一章节描述了 对于标准[standardized]类型[type]的 print-object 方法的默认行为.

> * 22.1.3.1 [打印数字](#PrintingNumbers)
> * 22.1.3.2 [打印字符](#PrintingCharacters)
> * 22.1.3.3 [打印符号](#PrintingSymbols)
> * 22.1.3.4 [打印字符串](#PrintingStrings)
> * 22.1.3.5 [打印列表和构造(cons)](#PrintingListsConses)
> * 22.1.3.6 [打印位向量](#PrintingBitVectors)
> * 22.1.3.7 [打印其他向量](#PrintingOtherVectors)
> * 22.1.3.8 [打印其他数组](#PrintingOtherArrays)
> * 22.1.3.9 [打印数组的示例](#ExamplesPrintingArrays)
> * 22.1.3.10 [打印随机状态](#PrintingRandomStates)
> * 22.1.3.11 [打印路径名](#PrintingPathnames)
> * 22.1.3.12 [打印结构体](#PrintingStructures)
> * 22.1.3.13 [打印其他对象](#PrintingOtherObjects)

#### 22.1.3.1 <span id="PrintingNumbers">打印数字</span>

> * 22.1.3.1.1 [打印整数](#PrintingIntegers)
> * 22.1.3.1.2 [打印比率](#PrintingRatios)
> * 22.1.3.1.3 [打印浮点数](#PrintingFloats)
> * 22.1.3.1.4 [打印复数](#PrintingComplexes)
> * 22.1.3.1.5 [关于打印数字的注意事项](#NotePrintingNumbers)

##### 22.1.3.1.1 <span id="PrintingIntegers">打印整数</span>

整数[integer]是用当前输出基数[current output base]在位置符号中所指定的基数来打印的, 最有效数字优先. 如果合适的话, 可以打印出一个基数说明符; 见 \*print-radix*. 如果一个整数[integer]是负的, 会打印一个负号和那个整数[integer]的绝对值. 整数[integer]零会被表示为单个数字 0 并且不会有符号. 一个小数点可能被打印出来, 取决于 \*print-radix* 的值[value].

关于一个整数[integer]的语法相关信息, 见章节 2.3.2.1.1 (一个整数的语法). 


##### 22.1.3.1.2 <span id="PrintingRatios">打印比率</span>

比率[ratio]按如下打印: 作为一个整数[integer]打印分子的绝对值; 然后是一个 /; 再是分母. 分子和分母都以当前输出基数[current output base]指定的基数打印; 它们就像是通过 numerator 和 denominator 获取到的, 所以比率[ration]以简化形式打印(最低项). 如果合适的话, 可以打印出一个基数说明符; 见 \*print-radix*. 如果这个比率是负的, 在分子前会打印一个负号.

关于一个比率[ratio]的语法相关信息, 见章节 2.3.2.1.2 (一个比率的语法). 


##### 22.1.3.1.3 <span id="PrintingFloats">打印浮点数</span>

如果这个浮点数的大小是零或在 10^-3 (包含的) 和 10^7 (不包含的) 之间, 它会被打印为这个数字的整数部分, 然后一个小数点, 再是这个数字的小数部分; 小数点的每一边都至少有一个数字. 如果这个数字的符号 (由 float-sign 确定) 是负的, 那么会在这个数字之前打印一个负号. 如果这个数字的格式和 \*read-default-float-format* 指定的格式不匹配, 那么也会打印出该格式的指数标记[exponent marker]和数字 0. 例如, 自然对数作为一个短浮点数[short float]可以被打印成 2.71828S0.

对于范围 10^-3 到 10^7 之外的非零大小, 一个浮点数[float]以计算机科学计数法打印的. 这个数字的表示被缩放到 1 (包含的) 和 10 (不包含的) 之间然后打印, 其中小数点前一位数, 小数点后至少有一个位. 接下来是打印这个格式的指数标记[exponent marker], 但是如果数字的格式与 \*read-default-float-format* 指定的格式相匹配, 那么就使用指数标记[exponent marker] E. 最后, 一个 10 的幂被打印成一个十进制整数, 这个小数和这个幂相乘的结果等于原始数字. 例如, 阿伏伽德罗数作为一个短浮点数[short float]会被打印为 6.02S23.

关于一个浮点数[float]的语法相关信息, 见章节 2.3.2.2 (浮点数的语法). 

##### 22.1.3.1.4 <span id="PrintingComplexes">打印复数</span>

一个复数[complex]被打印为一个 #C, 一个开圆括号, 它的实部的打印表示, 一个空格, 它的虚部的打印表示, 以及最后的闭圆括号.

关于一个复数[complex]语法的相关信息, 见章节 2.3.2.3 (复数的语法) 以及章节 2.4.8.11 (井号C(#C)). 


##### 22.1.3.1.5 <span id="NotePrintingNumbers">关于打印数字的注意事项</span>

一个数字的打印表示一定不能包含转义[escape]字符[character]; 见章节 2.3.1.1.1 (转义字符和潜在数字). 


#### 22.1.3.2 <span id="PrintingCharacters">打印字符</span>

当打印器转义[printer escaping]被禁用时, 一个字符[character]被打印为它的自身; 它被直接发送给输出流[stream]. 当打印器转义[printer escaping]被启用时, 那么使用 #\ 语法.

当打印器输出一个字符[character]的名字时, 它使用和 #\ 读取器宏[reader macro]相同的表; 因此输出的任何字符[character]作为输入都是可接受的 (在那个实现[implementation]中). 如果一个非图形化[non-graphic]字符[character]有着一个标准化[standardized]名字[name[5]], 对于使用 #\ 符号打印, 该名称[name]优于非标准名称. 对于图形化[graphics]标准字符[standard character], 这个字符[character]自身被用于 #\ 标记打印---即便这个字符[character]也有一个名字[name[5]].

关于 #\ 读取器宏[reader macro]的详细信息, 见章节 2.4.8.1 (井号反斜线(#\\)). 


#### 22.1.3.3 <span id="PrintingSymbols">打印符号</span>

当打印器转义[printer escaping]被禁用时, 只有那个符号[symbol]名字[name]的字符会被输出 (但是打印名字[name]中的字符的大小写由 \*print-case* 控制; 见章节 22.1.3.3.2 (Lisp 打印器上读取表大小写的影响)).

章节 22.1.3.3 的其余部分仅在启用打印器转义[printer escaping]时才适用.

当打印一个符号[symbol]时, 打印器插入足够的单转义[single escape] 和/或 多转义[multiple escape]字符 (反斜线[backslash] 和/或 竖线[vertical-bar]) 这样一来如果用相同的 \*readtable* 以及绑定为当前输出基数[current output base]的 \*read-base* 来调用 read, 它会返回相同的符号[symbol] (如果它没有被显式解除捕捉[apparently uninterned]的话) 或者一个带有相同打印名的未捕捉[uninterned symbol]符号[symbol] (否则的话).

比如, 当打印符号 face 时如果 \*print-base* 的值[value]是 16, 它可能会被打印为 \FACE 或 \Face 或 |FACE|, 因为如果 \*read-base* 的值[value]是 16 那么记号 face 会被读取为一个十六进制数字 (数字值 64206).

对于当前读取表[current readtable]中具有非标准语法类型[syntax type]字符的附加限制, 见变量[variable] \*print-readably*

关于 Lisp 读取器[Lisp reader]如何解析符号[symbol]的信息, 见章节 2.3.4 (符号标记) 和章节 2.4.8.5 (井号冒号(#:)).

当 \*print-pretty* 是 true 并且打印器转义[printer escaping]是启用时, nil 可能被打印为 () .

> * 22.1.3.3.1 [符号的包前缀](#PackagePrefixesSymbols)
> * 22.1.3.3.2 [Lisp 打印器上读取表大小写的影响](#EffectReadtableCase)

##### 22.1.3.3.1 <span id="PackagePrefixesSymbols">符号的包前缀</span>

如果必要的话, 包前缀[package prefix]会被打印. 包前缀[package prefix]的规则如下. 当这个符号[symbol]被打印时, 如果它在 KEYWORD 包, 那么它和一个前置的冒号[colon]一起被打印; 否则, 如果它在当前包[current package]中可访问[accessible], 它被打印为不带包前缀[package prefix]的; 否则, 它会被打印为带有一个包前缀[package prefix]的.

如果 \*print-gensym* 是 true 并且打印器转义[printer escaping]是启用的, 那么一个被显式解除绑定[apparently uninterned]的符号[symbol]会以 "#:" 前置的方式被打印; 如果 \*print-gensym* 是 false 或打印器转义[printer escaping]被禁用, 那么符号[symbol]会以不带前缀的方式打印, 就好像它是在当前包[current package]中的.

由于 #: 语法不会捕捉后面的符号, 如果 \*print-circle* 是 true 并且相同的未捕捉的符号在一个要被打印的表达式中出现多次, 有必要去使用循环列表的语法. 比如, 如果 \*print-circle*  是 false, 下面这个的结果

    (let ((x (make-symbol "FOO"))) (list x x))

会被打印为 (#:foo #:foo), 如果 \*print-circle* 是 true, 那么就是 (#1=#:foo #1#).

前面的包前缀规则的总结如下:

foo:bar

    当符号[symbol] bar 在它的 home 包[home package] foo 中是外部的并且在当前包[current package]中不是可访问[accessible]的时候, 打印 foo:bar.

foo::bar

    当 bar 在它的 home 包[home package] foo 中是内部的并且在当前包[current package]中不是可访问[accessible]时, 打印 foo::bar.

:bar

    当 bar 的 home 包是 KEYWORD 包时, 打印 :bar.

#:bar

    当 bar 被显式解除绑定[apparently uninterned]时都会打印为 #:bar, 即使在 bar 没有 home 包[home package]但在当前包[current package]中却是可访问[accessible]的病态情况下. 


##### 22.1.3.3.2 <span id="EffectReadtableCase">Lisp 打印器上读取表大小写的影响</span>

当打印器转义[printer escaping]被禁用, 或正在考虑的字符还没有被单转义[single escape]或多转义[multiple escape]语法引用时, 当前读取表[current readtable]的读取表大小写[readtable case]以以下方式影响 Lisp 打印器[Lisp printer]写入符号[symbol]的方式:

:upcase

    当读取表大小写[readtable case]是 :upcase 时, 大写[uppercase]字符[character]由 *print-case* 指定的大小写来打印, 而小写[lowercase]字符[character]按照它们自身的大小写打印.

:downcase

    当读取表大小写[readtable case]是 :downcase 时, 大写[uppercase]字符[character]按照它们自身的大小写打印, 而小写[lowercase]字符[character]由 *print-case* 指定的大小写来打印.

:preserve

    当读取表大小写[readtable case]是 :preserve 时, 所有字母[alphabetic]字符[character]都按照它们自身的大小写打印.

:invert

    当读取表大小写[readtable case]是 :invert 时, 单一大小写符号名中的所有字母[alphabetic]字符[character]的大小写会被转换. 混合大小写符号名会保留原样打印.

如果启用了打印器转义[printer escaping], 那么符号名中的转义字母[alphabetic]字符[character]的规则受 readtable-case 影响. 字母[alphabetic]字符[character]按如下转义:

:upcase

    当读取表大小写[readtable case]是 :upcase 时, 所有小写[lowercase]字符[character]必须被转义.

:downcase

    当读取表大小写[readtable case]是 :downcase 时, 所有大写[uppercase]字符[character]必须被转义.

:preserve

    当读取表大小写[readtable case]是 :preserve 时, 没有字母[alphabetic]字符[character]需要被转义.

:invert

    当读取表大小写[readtable case]是 :invert 时, 没有字母[alphabetic]字符[character]需要被转义.


###### 22.1.3.3.2.1 Lisp 打印器上读取表大小写影响的示例

    ```LISP
    (defun test-readtable-case-printing ()
      (let ((*readtable* (copy-readtable nil))
            (*print-case* *print-case*))
        (format t "READTABLE-CASE *PRINT-CASE*  Symbol-name  Output~
                  ~%--------------------------------------------------~
                  ~%")
        (dolist (readtable-case '(:upcase :downcase :preserve :invert))
          (setf (readtable-case *readtable*) readtable-case)
          (dolist (print-case '(:upcase :downcase :capitalize))
            (dolist (symbol '(|ZEBRA| |Zebra| |zebra|))
              (setq *print-case* print-case)
              (format t "~&:~A~15T:~A~29T~A~42T~A"
                      (string-upcase readtable-case)
                      (string-upcase print-case)
                      (symbol-name symbol)
                      (prin1-to-string symbol)))))))
    ```

来自 (test-readtable-case-printing) 的输出应该如下:

    READTABLE-CASE *PRINT-CASE*  Symbol-name  Output
    --------------------------------------------------
    :UPCASE        :UPCASE       ZEBRA        ZEBRA
    :UPCASE        :UPCASE       Zebra        |Zebra|
    :UPCASE        :UPCASE       zebra        |zebra|
    :UPCASE        :DOWNCASE     ZEBRA        zebra
    :UPCASE        :DOWNCASE     Zebra        |Zebra|
    :UPCASE        :DOWNCASE     zebra        |zebra|
    :UPCASE        :CAPITALIZE   ZEBRA        Zebra
    :UPCASE        :CAPITALIZE   Zebra        |Zebra|
    :UPCASE        :CAPITALIZE   zebra        |zebra|
    :DOWNCASE      :UPCASE       ZEBRA        |ZEBRA|
    :DOWNCASE      :UPCASE       Zebra        |Zebra|
    :DOWNCASE      :UPCASE       zebra        ZEBRA
    :DOWNCASE      :DOWNCASE     ZEBRA        |ZEBRA|
    :DOWNCASE      :DOWNCASE     Zebra        |Zebra|
    :DOWNCASE      :DOWNCASE     zebra        zebra
    :DOWNCASE      :CAPITALIZE   ZEBRA        |ZEBRA|
    :DOWNCASE      :CAPITALIZE   Zebra        |Zebra|
    :DOWNCASE      :CAPITALIZE   zebra        Zebra
    :PRESERVE      :UPCASE       ZEBRA        ZEBRA
    :PRESERVE      :UPCASE       Zebra        Zebra
    :PRESERVE      :UPCASE       zebra        zebra
    :PRESERVE      :DOWNCASE     ZEBRA        ZEBRA
    :PRESERVE      :DOWNCASE     Zebra        Zebra
    :PRESERVE      :DOWNCASE     zebra        zebra
    :PRESERVE      :CAPITALIZE   ZEBRA        ZEBRA
    :PRESERVE      :CAPITALIZE   Zebra        Zebra
    :PRESERVE      :CAPITALIZE   zebra        zebra
    :INVERT        :UPCASE       ZEBRA        zebra
    :INVERT        :UPCASE       Zebra        Zebra以以下方式影响
    :INVERT        :UPCASE       zebra        ZEBRA
    :INVERT        :DOWNCASE     ZEBRA        zebra
    :INVERT        :DOWNCASE     Zebra        Zebra
    :INVERT        :DOWNCASE     zebra        ZEBRA
    :INVERT        :CAPITALIZE   ZEBRA        zebra
    :INVERT        :CAPITALIZE   Zebra        Zebra
    :INVERT        :CAPITALIZE   zebra        ZEBRA


#### 22.1.3.4 <span id="PrintingStrings">打印字符串</span>

字符串[string]中的字符会被依次输出. 如果启用了打印器转义[printer escaping], 一个双引号[double-quote]会在之前或之后被输出, 并且所有的双引号[double-quote]和单转义[single escape]前面会有一个反斜线[backslash]. 字符串[string]的打印不受 \*print-array* 的影响. 只有字符串[string]中的有效[active]元素[element]会被打印.

关于 Lisp 读取器[Lisp reader]如何解析字符串[string]的信息, 见章节 2.4.5 (双引号). 

#### 22.1.3.5 <span id="PrintingListsConses">打印列表和构造(cons)</span>

只要有可能, 列表记号优先于点记号. 因此以下运算法则被用于打印一个 cons x:

1. 打印一个左圆括号[left-parenthesis].

2. 打印 x 的 car.

3. 如果 x 的 cdr 自身是一个 cons, 它会成为当前的 cons (换句话说, x 变为那个 cons), 打印一个空格[space], 然后再次进入步骤 2.

4. 如果 x 的 cdr 不为空[null], 打印一个空格[space], 一个点[dot], 一个空格[space], 以及 x 的 cdr.

5. 打印一个右圆括号[right-parenthesis].

事实上, 只有当 \*print-pretty* 是 false 时, 使用以上运算法则. 当 \*print-pretty* 是 true 时(或者当使用 pprint 时), 额外的空格[whitespace[1]]可能替换一个单空格[space]的使用, 并且使用一种更复杂的、具有类似的目标但具有更多的表示灵活性的算法; 见章节 22.1.2 (打印器分派).

虽然以下两个表达式是等价的, 并且读取器接收任意一个并打印相同的 cons, 但是打印器总是用第二种形式来打印这样一个 cons.

    (a . (b . ((c . (d . nil)) . (e . nil))))
    (a b (c d) e)

cons 的打印受 \*print-level*, \*print-length*, 和 \*print-circle* 的影响.

下面是列表的打印表示的示例:

    (a . b)     ;A dotted pair of a and b
    (a.b)       ;A list of one element, the symbol named a.b
    (a. b)      ;A list of two elements a. and b
    (a .b)      ;A list of two elements a and .b
    (a b . c)   ;A dotted list of a and b with c at the end; two conses
    .iot        ;The symbol whose name is .iot
    (. b)       ;Invalid -- an error is signaled if an attempt is made to read 
                ;this syntax.
    (a .)       ;Invalid -- an error is signaled.
    (a .. b)    ;Invalid -- an error is signaled.
    (a . . b)   ;Invalid -- an error is signaled.
    (a b c ...) ;Invalid -- an error is signaled.
    (a \. b)    ;A list of three elements a, ., and b
    (a |.| b)   ;A list of three elements a, ., and b
    (a \... b)  ;A list of three elements a, ..., and b
    (a |...| b) ;A list of three elements a, ..., and b

关于 Lisp 读取器[Lisp reader]如何解析列表[list]和 cons 的信息, 见章节 2.4.1 (左圆括号). 

#### 22.1.3.6 <span id="PrintingBitVectors">打印位向量</span>

一个位向量[bit vector]被打印为 #* 后面依次跟着位向量[bit vector]的各个位. 如果 \*print-array* 是 false, 那么这个位向量[bit vector]以一种简洁但是不可读取的格式 (使用 #<) 来打印. 只有位向量[bit vector]中的有效[active]元素[element]会被打印.

关于 Lisp 读取器[Lisp reader]如何解析位向量[bit vector]的信息, 见章节 2.4.8.4 (井号星号(#*)). 


#### 22.1.3.7 <span id="PrintingOtherVectors">打印其他向量</span>

如果 \*print-array* 是 true 并且 \*print-readably* 是 false, 除了字符串[string]和位向量[bit vector]以外的向量[vector]会用普通向量语法来打印; 这意味着关于特殊向量表示的信息不会出现. 零长度向量[vector]的打印表示是 #(). 非零长度的向量[vector]用 #( 开始打印. 在那个后面, 向量[vector]的第一个元素会被打印. 如果这里有任何其他元素, 它们会依次被打印, 如果 \*print-pretty* 是 false 那么每一个额外的元素前面会有一个空格[space], 如果 \*print-pretty* 是 true 那么就是空白[whitespace[1]]. 最后一个元素后的右圆括号[right-parenthesis]终止这个向量[vector]的打印表示. 向量[vector]的打印受 \*print-level* 和 \*print-length* 的影响. 如果这个向量[vector]有着填充指针[fill pointer], 那么只有那些在填充指针[fill pointer]下的元素会被打印.

如果 \*print-array* 和 \*print-readably* 都是 false, 向量[vector]不会按如上所述被打印, 而是以一种简洁但不可读的格式 (使用 #<) 来打印.

如果 \*print-readably* 是 true, 那么向量[vector]以一种具体实现定义[implementation-defined]的方式来打印; 见变量[variable] \*print-readably*.

关于 Lisp 读取器[Lisp reader]如何解析"其他变量[vector]"的信息, 见章节 2.4.8.3 (井号左括号(#()). 

#### 22.1.3.8 <span id="PrintingOtherArrays">打印其他数组</span>

如果 \*print-array* 是 true 并且 \*print-readably* 是 false, 除了向量[vector]以外的任何数组[array]都用 #nA 格式打印. 这里 n 为这个数组[array]的秩[rank]. 接着打印 #, 再是十进制整数 n, 然后是 A, 然后 n 个开括号. 接下来这些元素[element]按照行优先的顺序被扫描, 在每一个元素[element]上使用 write, 并且元素[element]之间用空格[whitespace[1]]分隔. 数组的维度从左到右被计为 0 到 n-1, 并以最右的索引变化最快的方式枚举. 每次维度 j 的索引递增, 就会采取以下动作:

* 如果 j < n-1, 那么打印一个闭圆括号.

* 如果递增维度 j 的索引导致它和维度 j 相等, 那个索引被重置为零并且维度 j-1 的索引会递增 (因此递归执行这三个步骤), 除非 j=0, 在这个情况下终止整个运算法则. 如果递增维度 j 的索引没有导致它等于维度 j, 那么打印一个空格.

* 如果 j < n-1, 打印一个开圆括号.

这个导致要被打印的内容以一种适合于给 make-array 的 :initial-contents 参数的格式来打印. 这个过程有效打印的列表可能会被 \*print-level* 和 \*print-length* 截断.

如果这个数组[array]是特定类型[type]的, 包含位或者字符, 那么由上述运算法则生成的最内部的列表可以用位向量或字符串的语法来打印, 假定这些最内部的列表不会被 \*print-length* 截断.

如果 \*print-array* 和 \*print-readably* 都是 false, 那么数组[array]以一种简洁但不可读的方式 (使用 #<) 打印.

如果 \*print-readably* 是 true, 这个数组[array]以一种具体实现定义[implementation-defined]的方式打印; 见变量[variable] \*print-readably*. 具体来说, 这对于 0 维数组来说是很重要的.

关于 Lisp 读取器[Lisp reader]如何解析这些"其他数组[array]"的信息, 见章节 2.4.8.12 (井号A(#A)).


#### 22.1.3.9 <span id="ExamplesPrintingArrays">打印数组的示例</span>

    ```LISP
    (let ((a (make-array '(3 3)))
          (*print-pretty* t)
          (*print-array* t))
      (dotimes (i 3) (dotimes (j 3) (setf (aref a i j) (format nil "<~D,~D>" i j))))
      (print a)
      (print (make-array 9 :displaced-to a)))
    >>  #2A(("<0,0>" "<0,1>" "<0,2>") 
    >>      ("<1,0>" "<1,1>" "<1,2>") 
    >>      ("<2,0>" "<2,1>" "<2,2>")) 
    >>  #("<0,0>" "<0,1>" "<0,2>" "<1,0>" "<1,1>" "<1,2>" "<2,0>" "<2,1>" "<2,2>") 
    =>  #<ARRAY 9 indirect 36363476>
    ```

#### 22.1.3.10 <span id="PrintingRandomStates">打印随机状态</span>

没有为打印 random-state 类型[type]的对象[object]指定具体的语法. 然而, 每个具体实现[implementation]必须以这样一种方式来安排打印随机状态[random state]对象[object], 在相同实现中, read 可以从这个打印表示来构造这个随机状态[random state]的一个拷贝, 就好像这个拷贝是通过 make-random-state 创建的一样.

如果这个随机状态[random state]类型实际上是通过 defstruct 来有效实现的, 那么常见的结构体语法可以被用于打印随机状态[random state]对象; 一种打印可能看上去像下面这样

    #S(RANDOM-STATE :DATA #(14 49 98436589 786345 8734658324 ... ))

其中的成员是依赖于具体实现的[implementation-dependent]. 


#### 22.1.3.11 <span id="PrintingPathnames">打印路径名</span>

当启用打印器转义[printer escaping]时, 语法 #P"..." 是路径名[pathname]如何被 write 和这里描述的函数打印的语法. 这个 "..." 这个路径名的名称字符串表示.

当禁用打印器转义[printer escaping]时, write 通过写入 (namestring P) 来写入一个路径名[pathname] P.

关于 Lisp 读取器[Lisp reader]如何解析路径名[pathname]的信息, 见章节 2.4.8.14 (井号P(#P)). 


#### 22.1.3.12 <span id="PrintingStructures">打印结构体</span>

默认情况下, 一个类型 S 的结构体[structure]使用 #S 语法打印. 这个行为可以通过给定义 S 的 defstruct 表达式形式[form]指定一个 :print-function 或 :print-object 选项, 或者通过写一个为 S 类型的对象[object]特化[specialized]的 print-object 方法来定制.

不同的结构体可能以不同的方式打印; 结构体的默认表示法是:

    #S(structure-name {slot-key slot-value}*)

其中 #S 表示结构体语法, structure-name 是一个结构体名字[structure name], 每一个 slot-key 是这个结构体[structure]中一个槽[slot]的初始化参数的名字[name], 而每一个对应的 slot-value 是那个槽[slot]中的对象[object]的一个表示.

关于 Lisp 读取器[Lisp reader]如何解析结构体[structure]的信息, 见章节 2.4.8.13 (井号S(#S)). 


#### 22.1.3.13 <span id="PrintingOtherObjects">打印其他对象</span>

其他对象[object]以一种依赖于具体实现[implementation-dependent]的方式被打印. 没有强制要求一个具体实现[implementation]以可读[readably]的方式打印那些对象[object].

比如, 哈系表[hash table], 读取表[readtable], 包[package], 流[stream], 和函数[function]可能不会以可读[readably]的方式打印.

在这个情况中使用的普遍表示是 #<...>. 由于 #< 不是通过 Lisp 读取器[Lisp reader]可读的, 它遵循的文本准确格式是不重要的, 但是要使用的一个普遍格式是由 print-unreadable-object 宏[macro]提供的.

关于 Lisp 读取器[Lisp reader]如何对待这种表示的信息, 见章节 2.4.8.20 (井号小于号(#<)). 关于如何表示不能被可读[readably]地打印的对象[object]的信息, 见章节 2.4.8.6 (井号点(#.)).

### 22.1.4 <span id="ExamplesPrinterBehavior">打印器行为的示例</span>

    ```LISP
    (let ((*print-escape* t)) (fresh-line) (write #\a))
    >>  #\a
    =>  #\a
    (let ((*print-escape* nil) (*print-readably* nil))
      (fresh-line)
      (write #\a))
    >>  a
    =>  #\a
    (progn (fresh-line) (prin1 #\a))
    >>  #\a
    =>  #\a
    (progn (fresh-line) (print #\a))
    >>  
    >>  #\a
    =>  #\a
    (progn (fresh-line) (princ #\a))
    >>  a
    =>  #\a

    (dolist (val '(t nil))
      (let ((*print-escape* val) (*print-readably* val))
        (print '#\a) 
        (prin1 #\a) (write-char #\Space)
        (princ #\a) (write-char #\Space)
        (write #\a)))
    >>  #\a #\a a #\a
    >>  #\a #\a a a
    =>  NIL

    (progn (fresh-line) (write '(let ((a 1) (b 2)) (+ a b))))
    >>  (LET ((A 1) (B 2)) (+ A B))
    =>  (LET ((A 1) (B 2)) (+ A B))

    (progn (fresh-line) (pprint '(let ((a 1) (b 2)) (+ a b))))
    >>  (LET ((A 1)
    >>        (B 2))               
    >>    (+ A B))
    =>  (LET ((A 1) (B 2)) (+ A B))

    (progn (fresh-line) 
            (write '(let ((a 1) (b 2)) (+ a b)) :pretty t))
    >>  (LET ((A 1)
    >>        (B 2))
    >>    (+ A B))                 
    =>  (LET ((A 1) (B 2)) (+ A B))

    (with-output-to-string (s)  
        (write 'write :stream s)
        (prin1 'prin1 s))
    =>  "WRITEPRIN1"
    ```

## 22.2 <span id="TheLispPrettyPrinter">Lisp 美观打印器</span>

> * 22.2.1 [美观打印器的概念](#PrettyPrinterConcepts)
> * 22.2.2 [使用美观打印器的示例](#ExamplesPrettyPrinter)
> * 22.2.3 [美观打印器背景的注意事项](#NotesPrettyPrinterBackground)

### 22.2.1 <span id="PrettyPrinterConcepts">美观打印器的概念</span>

美观打印器[pretty printer]提供的工具允许程序[program]重新定义代码[code]显示的方式, 并且允许美观打印的全部能力应用于复杂的数据结构组合.

任何给定的输出样式实际上是否是"美观"的, 本质上是一个主观的问题. 然而, 由于美观打印器[pretty printer]的效果可以由符合标准的程序[conforming program]进行定制, 所以为单个程序[program]提供了必要的灵活性以达到任意程度的审美控制.

通过直接访问美观打印器内的机制来对布局做出动态决策, 这些 pprint-logical-block, pprint-newline, 和 pprint-indent 宏和函数可以为任何产生输出的函数指定美观打印布局规则. 它们也使得环状和共享的检测以及要被函数支持的基于长度和嵌套深度的缩写变得简单.

美观打印器[pretty printer]完全是根据 \*print-pprint-dispatch* 的值[value]来驱动的. 函数[function] set-pprint-dispatch 使得符合规范的程序[conforming program]去关联美观打印函数和一个类型[type]成为可能.

> * 22.2.1.1 [输出排列的动态控制](#DynamicControlArrangeOutput)
> * 22.2.1.2 [格式化指令接口](#FormatDirectiveInterface)
> * 22.2.1.3 [编译格式化字符串](#CompilingFormatStrings)
> * 22.2.1.4 [美观打印分派表](#PrettyPrintDispatchTables)
> * 22.2.1.5 [美观打印器边距](#PrettyPrinterMargins)

#### 22.2.1.1 <span id="DynamicControlArrangeOutput">输出排列的动态控制</span>
<!--TODO 所有输出到, 但不包括 ??-->
当一个输出[pretty printer]太大而无法容纳到可用空间中时, 可以精确地控制美观打印器的操作. 三个概念是这些操作工作的基础---逻辑块[logical blocks], 条件换行[conditional newlines], 以及节段[sections]. 在继续之前, 定义这些术语是很重要的.

下一段中的第一行展示了输出的示意图片段. 输出的每个字符都用 "-" 表示. 条件换行的位置由数字表示. 这个逻辑块的开始和结束分别由 "<" 和 ">" 表示.

输出作为一个整体是一个逻辑块和最外层节段. 这节段由 Figure 1 的第二行中的 0 表示. 嵌套在这个输出中的逻辑块通过宏 pprint-logical-block 来指定. 条件换行的位置由 pprint-newline 调用来指定. 每个条件换行定义了两个节段 (一个在它之前, 一个在它之后) 并且和第三个关联 (直接包含它的那个节段).

一个条件换行后面的节段由这些组成: 所有输出直到, 但不包括: (a) 在同一个逻辑块中直接包含的下一个条件换行; 或者如果 (a) 是不可应用的, (b) 嵌套在逻辑块的更低级别的下一个换行; 或者如果 (b) 是不可应用的, (c) 输出的末尾.

一个条件换行前面的节段由这些组成: 所有的输出向后直到, 但不包括: (a) 被直接包含在相同逻辑块中的前面的条件换行; 或者如果 (a) 不可应用, (b) 直接包含逻辑块的开头. Figure 1 中的最后四行表示四个条件换行前后的节段.

直接包含一个条件换行的节段是包含这个条件换行节段中最短的那个. 在下一段中, 第一个条件换行被直接包含在 0 标记的节段中, 第二个和第三个条件换行被直接包含在第四个条件换行之前的节段中, 并且第四个条件换行被直接包含在第一个条件换行之后的节段中.

    <-1---<--<--2---3->--4-->->
    000000000000000000000000000
    11 111111111111111111111111
              22 222
                 333 3333
           44444444444444 44444

    Figure 22-3. 逻辑块, 条件换行, 和节段的示例

只要有可能, 美观打印器在一行中显示一个节段的完整内容. 然而, 如果该节段太长, 无法容纳在可用空间, 则在该节段内的条件换行位置插入换行符. 


#### 22.2.1.2 <span id="FormatDirectiveInterface">格式化指令接口</span>

动态确定输出排列的操作的主要接口是通过美观打印器的函数和宏提供的. 下一段展示了和美观打印相关的已定义的名字.

    *print-lines*            pprint-dispatch                pprint-pop           
    *print-miser-width*      pprint-exit-if-list-exhausted  pprint-tab           
    *print-pprint-dispatch*  pprint-fill                    pprint-tabular       
    *print-right-margin*     pprint-indent                  set-pprint-dispatch  
    copy-pprint-dispatch     pprint-linear                  write                
    format                   pprint-logical-block                                
    formatter                pprint-newline                                      

    Figure 22-4. 和美观打印相关的已定义的名字.

下一个段标识了一组格式化指令[format directive], 它们以更简洁的形式作为相同的美观打印操作的替代接口.

    ~I   ~W      ~<...~:>  
    ~:T  ~/.../  ~_        

    Figure 22-5. 和美观打印相关的格式化指令


#### 22.2.1.3 <span id="CompilingFormatStrings">编译格式化字符串</span>

格式化字符串[format string]本质上是一个用于执行打印的特殊目的语言的程序, 并且可以通过函数[function] format 来解释. formatter 宏[macro]提供了使用编译后的函数[compiled function]来完成相同的打印的效率, 但是不会丢失格式化字符串[format string]的文本紧凑性.

一个格式化控制[format control]是一个格式化字符串[format string]或一个由 formatter 宏[macro]返回的函数[function]. 


#### 22.2.1.4 <span id="PrettyPrintDispatchTables">美观打印分派表</span>

一个美观打印分派表[pprint dispatch table]是一个从键到值对的映射. 每一个键是一个类型指定符[type specifier]. 和一个键关联的值是一个 "函数" (具体的说, 一个函数标识符[function designator]或 nil) 和一个 "优先级数值" (具体的说, 一个 real). 基本的插入和检索是基于键来进行的, 键的等价性由 equal 测试.

当 \*print-pretty* 是 true 时, 当前美观打印分派表[current pprint dispatch table] (在 \*print-pprint-dispatch* 中) 控制对象[object]如何被打印. 这个表中的信息优先于指定如何打印对象[object]的所有其他机制. 特别是, 它的优先级超过用户定义的 print-object 方法[method], 因为优先考虑这个当前美观打印分派表[current pprint dispatch table].

通过在当前美观打印分派表[current pprint dispatch table]中查找和那个对象[object]匹配的类型指定符[type specifier]相关联的最高优先级的函数来选择这个函数; 如果这里有不止一个这样的函数, 哪一个被使用是依赖于具体实现的[implementation-dependent].

然而, 如果在这个表中没有关于如何美观打印[pretty print]一个特定种类对象[object]的信息, 就会调用一个使用 print-object 来打印这个对象[object]的函数[function]. 当这个函数被调用时, \*print-pretty* 的值始终为 true, 并且对于 print-object 的各个方法仍然可以选择根据 \*print-pretty* 的值[value]产生特殊格式的输出. 


#### 22.2.1.5 <span id="PrettyPrinterMargins">美观打印器边距</span>

美观打印的主要目标是将输出保持在两个边距之间. 输出开始的列取自左边距. 如果当前列不能在输出开始时确定, 这个左边距被假定为零. 右边距由 \*print-right-margin* 控制. 


### 22.2.2 <span id="ExamplesPrettyPrinter">使用美观打印器的示例</span>

作为逻辑块, 条件换行, 和缩进相互作用的一个例子, 细想下面这个函数 simple-pprint-defun. 这个函数用标准的方式打印 car 为 defun 的列表, 假定这些列表的长度都是 4.

```LISP
(defun simple-pprint-defun (*standard-output* list)
  (pprint-logical-block (*standard-output* list :prefix "(" :suffix ")")
    (write (first list))
    (write-char #\Space)
    (pprint-newline :miser)
    (pprint-indent :current 0)
    (write (second list))
    (write-char #\Space)
    (pprint-newline :fill)
    (write (third list))
    (pprint-indent :block 1)
    (write-char #\Space)
    (pprint-newline :linear)
    (write (fourth list))))
```

假设它按照如下求值:

```LISP
(simple-pprint-defun *standard-output* '(defun prod (x y) (* x y)))
```

如果可用的行宽大于等于 26, 那么所有输出会出现在一行中. 如果可用的行宽减少到 25, 在表达式[expression] (* x y) 之前的线性条件换行符处插入一个换行符, 生成如下所示的输出. 这个 (pprint-indent :block 1) 导致 (* x y) 以逻辑块中相对缩进 1 的位置打印.

```LISP
(DEFUN PROD (X Y) 
  (* X Y))
```

如果可用的行宽是 15, 在参数列表前的填充样式条件换行符处也插入换行符. 这个 (pprint-indent :current 0) 的调用导致参数列表排列在函数名字下.

```LISP
(DEFUN PROD
      (X Y)
  (* X Y))
```

如果 \*print-miser-width* 大于等于 14, 上面输出示例会是如下这样, 因为在最小执行常式(miser)模式下所有缩进的改变会被忽略并且换行符被插入到最小执行常式的条件换行中.

```LISP
(DEFUN
  PROD
  (X Y)
  (* X Y))
```

作为每行前缀的一个例子, 细想行宽为 20 并且 \*print-miser-width* 是 nil 的情况下求值下面这些产生的输出.

```LISP
(pprint-logical-block (*standard-output* nil :per-line-prefix ";;; ")
  (simple-pprint-defun *standard-output* '(defun prod (x y) (* x y))))

;;; (DEFUN PROD
;;;        (X Y)
;;;   (* X Y))
```

作为一个更加复杂 (并且真实) 示例, 细想下面的函数 pprint-let. 这个指定如何去用传统风格打印一个 let 表达式形式[form]. 它比上面的例子更复杂, 因为它不得不去处理嵌套的结构. 同样的, 不像上面的例子, 它包含去可读地打印任何以符号[symbol] let 开始的可能的列表的完整代码. 最外部的 pprint-logical-block 表达式形式[form]处理输入列表作为整体的打印并且指定应该在输出中打印的圆括号. 第二个 pprint-logical-block 表达式形式[form]处理绑定对的列表. 在列表中的每一对自身通过最内部的 pprint-logical-block 打印. (使用 loop 表达式形式[form], 而不是将这个对分解为两个对象[object], 这样一来不管这个对对应的列表有着一个元素, 两个元素, 或(难看的)不止两个元素都会产生可读的输出). 会在除了最后一个之外的每一个对后面放置一个空格和一个填充风格的条件换行. 在最顶层 pprint-logical-block 表达式形式[form]末尾的循环打印在这个 let 表达式形式[form]的主体中被空格和线性风格条件换行分隔的表达式形式. 

```LISP
(defun pprint-let (*standard-output* list)
  (pprint-logical-block (nil list :prefix "(" :suffix ")")
    (write (pprint-pop))
    (pprint-exit-if-list-exhausted)
    (write-char #\Space)
    (pprint-logical-block (nil (pprint-pop) :prefix "(" :suffix ")")
      (pprint-exit-if-list-exhausted)
      (loop (pprint-logical-block (nil (pprint-pop) :prefix "(" :suffix ")")
              (pprint-exit-if-list-exhausted)
              (loop (write (pprint-pop))
                    (pprint-exit-if-list-exhausted)
                    (write-char #\Space)
                    (pprint-newline :linear)))
            (pprint-exit-if-list-exhausted)
            (write-char #\Space)
            (pprint-newline :fill)))
    (pprint-indent :block 1)
    (loop (pprint-exit-if-list-exhausted)
          (write-char #\Space)
          (pprint-newline :linear)
          (write (pprint-pop)))))
```

细想在 \*print-level* 是 4, 并且 \*print-circle* 是 true 的情况下求值下面这个.

```LISP
(pprint-let *standard-output*
            '#1=(let (x (*print-length* (f (g 3))) 
                      (z . 2) (k (car y)))
                  (setq x (sqrt z)) #1#))
```

如果行宽大于等于 77, 所产生的输出出现在一行中. 然而, 如果行宽是 76, 换行符会被插入在分隔这些表达式形式的线性风格条件换行中并且产生下面这样的输出. 注意, 退化绑定对 x 即使不是一个列表也可以打印出来; 一个深度缩写标记会被打印来替换 (g 3); 绑定对 (z . 2) 即便不是一个正规列表[proper list]也可以打印出来; 并打印缩写的环状标记.

```LISP
#1=(LET (X (*PRINT-LENGTH* (F #)) (Z . 2) (K (CAR Y))) 
      (SETQ X (SQRT Z))
      #1#)
```

如果行宽被减少到 35, 一个换行符会被插入到这些分隔绑定对的填充风格条件换行中的一个.

```LISP
#1=(LET (X (*PRINT-PRETTY* (F #))
          (Z . 2) (K (CAR Y)))
      (SETQ X (SQRT Z))
      #1#)
```

假设这个行宽进一步减少到 22 并且 \*print-length* 被设置为 3. 在这个情况中, 换行符被插入到第一个和第二个绑定对后面. 另外, 第二个绑定对自身被断开为两行. 填充风格条件换行的描述中的子句 (b) (见函数[function] pprint-newline) 避免了绑定对 (z . 2) 被打印在第三行末尾. 注意, 长度缩写从视图上隐藏了环并且因此环标记的打印消失了.

```LISP
(LET (X
      (*PRINT-LENGTH*
        (F #))
      (Z . 2) ...)
  (SETQ X (SQRT Z))
  ...)
```

下面这个函数使用 "#(...)" 标识打印了一个向量.

```LISP
(defun pprint-vector (*standard-output* v)
  (pprint-logical-block (nil nil :prefix "#(" :suffix ")")
    (let ((end (length v)) (i 0))
      (when (plusp end)
        (loop (pprint-pop)
              (write (aref v i))
              (if (= (incf i) end) (return nil))
              (write-char #\Space)
              (pprint-newline :fill))))))
```

在行宽为 15 时求值下面这个的输出如下.

```LISP
(pprint-vector *standard-output* '#(12 34 567 8 9012 34 567 89 0 1 23))

#(12 34 567 8 
  9012 34 567 
  89 0 1 23)
```

作为用格式化字符串[format string]指定美观打印的示例, 细想上面被用作示例的函数 simple-pprint-defun 和 pprint-let 可以按如下简洁地定义. (函数 pprint-vector 不能使用 format 来定义, 因为遍历的数据结构不是一个列表.)

```LISP
(defun simple-pprint-defun (*standard-output* list)
  (format T "~:<~W ~@_~:I~W ~:_~W~1I ~_~W~:>" list))

(defun pprint-let (*standard-output* list)
  (format T "~:<~W~^~:<~@{~:<~@{~W~^~_~}~:>~^~:_~}~:>~1I~@{~^~_~W~}~:>" list)) 
```

在下面的示例中, 第一个表达式形式[form]把 \*print-pprint-dispatch* 复原为它的等价初始值. 后面两个表达式形式为美观打印比率设置了一种特殊的方式. 注意, 更具体的类型指定符[type specifier]会和更高的优先级关联.

```LISP
(setq *print-pprint-dispatch* (copy-pprint-dispatch nil))

(set-pprint-dispatch 'ratio
  #'(lambda (s obj)
      (format s "#.(/ ~W ~W)" 
                (numerator obj) (denominator obj))))

(set-pprint-dispatch '(and ratio (satisfies minusp))
  #'(lambda (s obj)
      (format s "#.(- (/ ~W ~W))" 
              (- (numerator obj)) (denominator obj)))
  5)

(pprint '(1/3 -2/3))
(#.(/ 1 3) #.(- (/ 2 3)))
```

下面两个表达式形式[form]阐述了关于代码[code]类型的美观打印函数的定义. 第一个表达式形式[form]阐述了如何为使用单引号[single-quote]引用的对象指定传统方法. 注意, 确保以 quote 开头的数据列表也可以被打印出来. 第二个表达式形式指定了当初始美观打印分派表[pprint dispatch table]生效时以符号 my-let 开始的列表应该和 let 开始的列表打印方式相同.

```LISP
 (set-pprint-dispatch '(cons (member quote)) () 
   #'(lambda (s list)
       (if (and (consp (cdr list)) (null (cddr list)))
          (funcall (formatter "'~W") s (cadr list))
          (pprint-fill s list))))
 
 (set-pprint-dispatch '(cons (member my-let)) 
                      (pprint-dispatch '(let) nil))
```

下一个示例指定一个默认方法, 用于打印与函数调用不对应的列表. 注意, 函数 pprint-linear, pprint-fill, 和 pprint-tabular 都用可选的 colon-p 和 at-sign-p 参数定义, 这样一来它们可以被用作美观打印分派函数(pprint dispatch function), 和 ~/.../ 函数一样.

    ```LISP
    (set-pprint-dispatch '(cons (not (and symbol (satisfies fboundp))))
                          #'pprint-fill -5)
    
    ;; Assume a line length of 9
    (pprint '(0 b c d e f g h i j k))
    (0 b c d
      e f g h
      i j k)
    ```

最后的示例展示了如何为用户定义的数据结构定义一个美观打印函数.

    ```LISP
    (defstruct family mom kids)
    
    (set-pprint-dispatch 'family
      #'(lambda (s f)
          (funcall (formatter "~@<#<~;~W and ~2I~_~/pprint-fill/~;>~:>")
                  s (family-mom f) (family-kids f))))
    ```

结构体 family 的美观打印函数指定了如何去调整输出的布局以至于它可以很好地适应各种行的宽度. 另外, 它遵循打印器控制变量 \*print-level*, \*print-length*, \*print-lines*, \*print-circle* 和 \*print-escape*, 并且可以容忍数据结构中几种不同的多样性. 下面的输出展示了在右边距为 25, \*print-pretty* 是 true, \*print-escape* 是 false 时, 一个多样的 kids 列表会被打印出什么.

    ```LISP
    (write (list 'principal-family
                  (make-family :mom "Lucy"
                              :kids '("Mark" "Bob" . "Dan")))
            :right-margin 25 :pretty T :escape nil :miser-width nil)
    (PRINCIPAL-FAMILY
      #<Lucy and
          Mark Bob . Dan>)
    ```

注意, 一个结构体的美观打印函数和结构体的 print-object 方法[method]是不同的. print-object 方法[method]永久地和一个结构体关联, 美观打印函数是被存储在美观打印分派表[pprint dispatch table]中并且可以迅速地改变来反映不同的打印需求. 如果在当前的美观打印分派表[pprint dispatch table]中没有一个结构体的美观打印函数, 就会使用它的 print-object 方法[method]. 

### 22.2.3 <span id="NotesPrettyPrinterBackground">美观打印器背景的注意事项</span>

有关本节中详细描述的抽象概念的背景引用, 见 XP: A Common Lisp Pretty Printing System. 这篇论文的细节对这份文件没有约束力, 但可能有助于建立理解这种资料的概念基础. 


## 22.3 <span id="">格式化输出</span>

format 对于产生格式化的字符串、产生美观的信息等等都非常有用. format 可以生成和返回一个字符串[string]或输出到目标 destination.

给 format 的控制字符串 control-string 参数是一个格式化控制[format control]. 这也就是说, 它可以是一个格式化字符串[format string]或一个函数[function], 比如由 formatter 宏[macro]返回的一个函数[function].

如果它是一个函数[function], 用合适的输出流作为它的第一个参数并且给 format 的数据参数作为它的剩余参数来调用这个函数[function]. 这个函数应该执行必要的输出, 并返回参数中未使用的尾部 (如果有的话).

由 formatter 执行的编译过程产生一个函数[function], 它可以像 format 解释器处理这些参数[argument]一样来处理这些参数[argument].

这个章节的剩余部分描述了如果 control-string 是一个格式化字符串[format string]会发生什么.

控制字符串 control-string 由简单文本 (字符[character]) 和内嵌指令组成.

format 按原样写入简单文本; 每一个内嵌的指令指定了进一步的文本输出, 这些输出将出现在简单文本中对应位置. 大部分指令使用参数 args 中的一个或多个来创建它们的输出.

一个指令由一个波浪符号[tilde], 由逗号分隔的可选前缀参数, 可选冒号[colon]和 at-sign 字符修饰语, 以及表示这个指令种类的单个字符组成. 这里没有要求 at-sign 字符和冒号[colon]修饰符之间的顺序. 忽略这个指令字符的大小写[case]. 前缀参数被表示为带符号的 (符号是可选的) 十进制数字, 或者一个单引号[single-quote]后面跟着一个字符. 比如, ~5,'0d 可以被用于在五列中以前导零打印一个十进制整数[integer], 或使用 ~5,'*d 来得到一个前导的星号.

将前缀参数替换为指令, 可以使用 V (或 v). 在这个情况中, format 从 args 中接受一个参数作为给指令的参数. 这个参数应该是一个整数[integer]或字符[character]. 如果这个被 V 参数使用的参数 arg 是 nil, 效果就好像这个参数被省略了一样. # 可以被用于替换一个前缀参数; 它表示剩下要被处理的参数 args 的数量. 当在一个递归的格式化中使用时, 在 ~? 或 ~{ 的上下文中, 这个 # 前缀参数表示在这个递归调用中剩余格式化参数[format argument]的数量.

格式化字符串[format string]的示例:

    "~S"        ;This is an S directive with no parameters or modifiers.  
    "~3,-4:@s"  ;This is an S directive with two parameters, 3 and -4,    
                ; and both the colon and at-sign flags.                   
    "~,+4S"     ;Here the first prefix parameter is omitted and takes     
                ; on its default value, while the second parameter is 4.  

    Figure 22-6. 格式化控制字符串的示例

format 发送这个输出到目标 destination. 如果 destination 是 nil, format 创建并返回一个包含来自 control-string 的输出的字符串[string]. 如果 destination 非 nil [non-nil], 它必须是一个带有填充指针[fill pointer]的字符串[string], 一个流[stream], 或者符号 t. 如果 destination 是一个带有填充指针[fill pointer]的字符串[string], 输出会被添加到这个字符串[string]的末尾. 如果 destination 是一个流[stream], 输出会被发送到这个流[stream]. 如果 destination 是 t, 输出会被发送到标准输出[standard output].

在对以下指令的描述中, 术语 arg 通常引用要被处理的 args 集合的下一个条目. 每个描述开头的词或短语是该指令的助记符. format 指令不会绑定任何一个打印器控制变量(\*print-...*), 除了在下面描述中指定的. 具体实现可能为每个格式化指令指定新的、具体实现专有的打印器控制变量的绑定, 但是它们既不能绑定 format 指令表述中未指定的任何标准打印器控制变量, 也不能绑定这个描述中指定的任何标准打印器控制变量.

> * 22.3.1 [FORMAT 基本输出](#FORMATBasicOutput)
> * 22.3.2 [FORMAT 基数控制](#FORMATRadixControl)
> * 22.3.3 [FORMAT 浮点数打印器](#FORMATFloatingPointPrinters)
> * 22.3.4 [FORMAT 打印器操作](#FORMATPrinterOperations)
> * 22.3.5 [FORMAT 美观打印器操作](#FORMATPrettyPrinterOperations)
> * 22.3.6 [FORMAT 布局控制](#FORMATLayoutControl)
> * 22.3.7 [FORMAT 控制流操作](#FORMATControlFlowOperation)
> * 22.3.8 [FORMAT 杂项操作](#FORMATMiscellaneousOperation)
> * 22.3.9 [FORMAT 杂项伪操作](#FORMATMiscellaneousPseudoOperation)
> * 22.3.10 [关于 FORMAT 的额外信息](#AddInfoFORMATOperations)
> * 22.3.11 [FORMAT 的示例](#ExamplesFORMAT)
> * 22.3.12 [FORMAT 的注意事项](#NotesFORMAT)


### 22.3.1 <span id="FORMATBasicOutput">FORMAT 基本输出</span>

> * 22.3.1.1 [波浪符号 C: 字符](#TildeCCharacter)
> * 22.3.1.2 [波浪符号百分比号 %: 换行](#TildePercentNewline)
> * 22.3.1.3 [波浪符号和号 &: 换行](#TildeAmpersandFreshLine)
> * 22.3.1.4 [波浪符号竖杠 |: 页](#TildeVerticalBarPage)
> * 22.3.1.5 [波浪符号波浪符号 ~: 波浪符号](#TildeTildeTilde)

#### 22.3.1.1 <span id="TildeCCharacter">波浪符号 C: 字符</span>

下一个参数 arg 应该是一个字符[character]; 它是根据修饰符的标志打印出来的.

如果这个字符[character]是一个简单[simple]字符[character], 那么 ~C 打印这个字符就像是通过使用 write-char 打印的一样. 不是简单[simple]的字符[character]没有必要打印地跟 write-char 一样, 但是以一种具体实现定义的[implementation-defined]简洁的格式显示. 比如,

    ```LISP
    (format nil "~C" #\A) =>  "A"
    (format nil "~C" #\Space) =>  " "
    ```

~:C 和 ~C 一样, 都用于打印[printing]字符[character], 但是其他字符[character]是 "拼写出来的". 其目的是, 打印字符的"美观"格式. 关于不打印[printing]的简单[simple]字符[character], 拼写出来的是字符[character]的名称[name] (见 char-name). 对于没有打印[printing]的非简单[simple]字符[character], 拼写出什么是具体实现定义的[implementation-defined]. 比如,

    ```LISP
    (format nil "~:C" #\A) =>  "A"
    (format nil "~:C" #\Space) =>  "Space"
    ;; This next example assumes an implementation-defined "Control" attribute.
    (format nil "~:C" #\Control-Space)
    =>  "Control-Space"
    OR=>  "c-Space"
    ```

~:@C 打印 ~:C 会打印的东西, 然后如果这个字符[character]需要键盘上的不寻常的 shift 键来输入, 这个事实就会被提到. 比如,

    ```LISP
    (format nil "~:@C" #\Control-Partial) =>  "Control-<PARTIAL> (Top-F)"  
    ```

这是一种格式, 用于告诉用户他希望在提示符中输入的键. 准确的输出可能不仅取决于实现, 还取决于所使用的特定 I/O 设备.

~@C 以一种 Lisp 读取器[Lisp reader]可以理解的方式打印这个字符[character], 使用 #\ 语法.

~@C 绑定 \*print-escape* 为 t. 

#### 22.3.1.2 <span id="TildePercentNewline">波浪符号百分比号 %: 换行</span>

这个输出一个 #\Newline 字符, 从而终止当前的输出行并开始一个新的输出行. ~n% 输出 n 个新行. 不使用参数 arg. 

#### 22.3.1.3 <span id="TildeAmpersandFreshLine">波浪符号和号 &: 换行</span>

除非它可以确定这个输出流已经在一行的开始, 否则这个就会输出一个新行. ~n& 调用 fresh-line 然后输出 n-1 个新行. ~0& 什么都不做.

#### 22.3.1.4 <span id="TildeVerticalBarPage">波浪符号竖杠 |: 页</span>

如果可能的话, 这个输出一个分页符号. ~n| 执行 n 次这个. 

#### 22.3.1.5 <span id="TildeTildeTilde">波浪符号波浪符号 ~: 波浪符号</span>

这个输出一个波浪符号[tilde]. ~n~ 输出 n 个波浪符号. 

### 22.3.2 <span id="FORMATRadixControl">FORMAT 基数控制</span>

> * 22.3.2.1 [波浪符号 R: 基数](#TildeRRadix)
> * 22.3.2.2 [波浪符号 D: 十进制](#TildeDDecimal)
> * 22.3.2.3 [波浪符号 B: 二进制](#TildeBBinary)
> * 22.3.2.4 [波浪符号 O: 八进制](#TildeOOctal)
> * 22.3.2.5 [波浪符号 X: 十六进制](#TildeXHexadecimal)

#### 22.3.2.1 <span id="TildeRRadix">波浪符号 R: 基数</span>

~nR 用基数 n 来打印参数 arg. 修饰符标识和任何剩余参数被用于 ~D 检测. ~D 和 ~10R 相同. 完整形式是 ~radix,mincol,padchar,commachar,comma-intervalR.

如果没有给 ~R 一个前缀参数, 那就会给定一个不同的解释. 这个参数应该是一个整数[integer]. 比如, 如果参数 arg 是 4:

* ~R 打印参数 arg 为一个基本的英语数字: four.

* ~:R 打印参数 arg 为一个英语序数: fourth.

* ~@R 打印参数 arg 作为一个罗马数字: IV.

* ~:@R 打印参数 arg 作为一个旧罗马数字: IIII.

比如:

    ```LISP
    (format nil "~,,' ,4:B" 13) =>  "1101"
    (format nil "~,,' ,4:B" 17) =>  "1 0001"
    (format nil "~19,0,' ,4:B" 3333) =>  "0000 1101 0000 0101"
    (format nil "~3,,,' ,2:R" 17) =>  "1 22"
    (format nil "~,,'|,2:D" #xFFFF) =>   "6|55|35"
    ```

当且仅当第一个参数 n 被提供时, ~R 绑定 \*print-escape* 为 false, \*print-radix* 为 false, \*print-base* 为 n, 以及 \*print-readably* 为 false.

当且仅当没有提供参数时, ~R 绑定 \*print-base* 为 10. 

#### 22.3.2.2 <span id="TildeDDecimal">波浪符号 D: 十进制</span>

一个应该为一个整数[integer]的参数 arg 用十进制基数来打印. ~D 不会在这个数字后面放一个小数点.

~mincolD 使用 mincol 的列宽度; 如果这个数的数字和符号需要小于 mincal 列, 空格 space 就会被插入到左边. 如果这个数字不适应 n 列, 则需要额外的列.

~mincol,padcharD 使用 padchar 作为填补字符而不是空格 space.

如果参数 arg 不是一个整数[integer], 它会用 ~A 格式和十进制基数来打印.

这个 @ 修饰符导致这个数字的符号总是被打印; 默认当且仅当这个数字是负的才打印. 这个 : 修饰符导致逗号被打印在数字组之间; commachar 可能被用于改变用作逗号的字符. comma-interval 一定是个整数[integer]并且默认为 3. 当这个 : 修饰符被给定为这些指令的任意一个时, 这个 commachar 被打印在 comma-interval 个数字组之间.

因此最广泛的 ~D 形式是 ~mincol,padchar,commachar,comma-intervalD.

~D 绑定 \*print-escape* 为 false, 绑定 \*print-radix* 为 false, 绑定 \*print-base* 为 10, 以及 绑定 \*print-readably* 为 false. 


#### 22.3.2.3 <span id="TildeBBinary">波浪符号 B: 二进制</span>

这个就像 ~D 但是用二进制基数 (基数 2) 而不是十进制来打印. 因此完整形式为 ~mincol,padchar,commachar,comma-intervalB.

~B 绑定 \*print-escape* 为 false, 绑定 \*print-radix* 为 false, 绑定 \*print-base* 为 2, 以及绑定 \*print-readably* 为 false. 


#### 22.3.2.4 <span id="TildeOOctal">波浪符号 O: 八进制</span>

这个就像 ~D 但是用八进制基数 (基数 8) 而不是十进制来打印. 因此完整形式为 ~mincol,padchar,commachar,comma-intervalO.

~O 绑定 \*print-escape* 为 false, 绑定 \*print-radix* 为 false, 绑定 \*print-base* 为 8, 以及绑定 \*print-readably* 为 false. 


#### 22.3.2.5 <span id="TildeXHexadecimal">波浪符号 X: 十六进制</span>

这个就像 ~D 但是用十六进制基数 (基数 16) 而不是十进制来打印. 因此完整形式为 ~mincol,padchar,commachar,comma-intervalX.

~X 绑定 \*print-escape* 为 false, 绑定 \*print-radix* 为 false, 绑定 \*print-base* 为 16, 以及绑定 \*print-readably* 为 false. 


### 22.3.3 <span id="FORMATFloatingPointPrinters">FORMAT 浮点数打印器</span>

> * 22.3.3.1 [波浪符号 F: 固定格式浮点数](#TildeFFixedFormat)
> * 22.3.3.2 [波浪符号 E: 指数浮点数](#TildeEExponential)
> * 22.3.3.3 [波浪符号 G: 一般浮点数](#TildeGGeneral)
> * 22.3.3.4 [波浪符号 美元符号: 货币浮点数](#TildeDollarsignMonetary)


#### 22.3.3.1 <span id="TildeFFixedFormat">波浪符号 F: 固定格式浮点数</span>

下一个参数 arg 被打印为一个浮点数[float].

完整形式是 ~w,d,k,overflowchar,padcharF. 参数 w 是要被打印的域宽度; d 是在小数点后面要被打印的数字的数量; k 是一个默认为零的伸缩因子.

恰好输出 w 个字符. 首先, 如果有必要, 打印出字符 padchar (默认为一个空格 space) 的前导拷贝, 来填充左边的域. 如果这个参数 arg 是负的, 那么会打印一个负号; 如果这个参数 arg 不是负的, 当且仅当提供了 @ 修饰符时会打印一个正号. 然后一个包含单个内嵌小数点的数字序列会被打印; 这个表示参数 arg 的值的大小乘以 10^k, 舍入到 d 小数数位. 当向上舍入和向下舍入可能产生和参数 arg 的伸缩值等距的打印值时, 那么具体实现可以自由地去选择任意一个. 比如, 使用格式 ~4,2F 打印参数 6.375 可能正确地产生 6.37 或 6.38. 前导零是不允许的, 除了当打印的值小于 1 时一个单个的数字零会被输出到小数点前, 如果 w=d+1 那么这个单个的数字零不会被输出.

如果用要求的格式在一个宽度为 w 的域中打印这个值是不可能的, 那么就会采取这两个动作中的一个. 如果提供了参数 overflowchar, 那么那个参数的 w 个拷贝会被打印而不是这个参数 arg 的伸缩值. 如果省略了这个 overflowchar 参数, 那么这个伸缩值会使用超过 w 个字符来打印, 和它需要的一样多.

如果省略了这个 w 参数, 那么这个域就是可变宽度的. 实际上, 会以这样一种方式为 w 选择一个值: 没有前导的填充字符需要被打印并且小数点后面准确地跟着 d 个字符. 比如, 指令 ~,2F 会准确打印小数点后两位数而小数点前根据必要尽可能多.

如果省略了参数 d, 那么在小数点后面的数字的数量上没有约束. 会以这样一种方式为 d 选择一个值: 尽可能多的数字可能被打印出来, 取决于参数 w 所施加的宽度限制以及在小数末尾中不出现 0 数字的约束条件, 除非如果这个要被打印的小数是 0, 如果这个宽度约束允许, 那么一个单独的零数字应该出现在小数点后面.

如果 w 和 d 都被省略了, 那么效果就是使用普通的自由格式输出来打印这个值; prin1 为任何大小为零或在 10^-3 (包括的) 和 10^7 (不包括的) 之间的数字使用这个格式.

如果省略了 w, 那么如果这个参数 arg 的大小太大 (或者, 如果 d 也被省略, 那么就是太小) 以致于超过 100 个数字不得不被打印, 那么一个实现可以自由地去使用指数符号来打印这个数字, 就像是通过指令 ~E (所有给 ~E 的参数都是默认的, 没有从 ~F 指令中接收任何值).

如果 arg 是一个有理数[rational], 那么它会被强制转换为一个单浮点数[single float]并且打印. 或者, 一个具体实现允许去用任何其他有着相同本质行为但是避免由于强制转换导致的精度丢失或溢出的方法来处理一个有理数[rational]. 如果没有提供 w 和 d 并且这个数字没有准确的十进制表示, 比如 1/3, 由于只能打印有限数量的数字, 所以具体实现必须选择一定的精度截断.

如果参数 arg 是一个复数[complex]或者某个非数值对象, 那么它会使用格式化指令 ~wD 来打印, 从而用十进制数字和 w 的最小域宽度来打印它.

~F 绑定 \*print-escape* 为 false 并绑定 \*print-readably* 为 false. 


#### 22.3.3.2 <span id="TildeEExponential">波浪符号 E: 指数浮点数</span>

下一个参数 arg 用指数表示来打印为一个浮点数[float].

完整形式是 ~w,d,e,k,overflowchar,padchar,exponentcharE. 参数 w 是这个要被打印的域宽度; d 是在小数点后面要被打印的数字的数量; 当打印一个指数时 e 是要被使用的数字数量; k 是一个默认为 1 的伸缩因子 (不是零).

恰好输出 w 个字符. 首先, 如果有必要, 打印出字符 padchar (默认为一个空格 space) 的前导拷贝, 来填充左边的域. 如果这个参数 arg 是负的, 那么会打印一个负号; 如果这个参数 arg 不是负的, 当且仅当提供了 @ 修饰符时会打印一个正号. 然后一个包含单独内嵌小数点的数字序列会被打印. 这个数字序列的形式取决于伸缩因子 k. 如果 k 是 0, 那么在小数点后面打印 d 个数字, 如果总的域宽度允许, 一个单独的数字 0 会出现在小数点前面. 如果 k 是正的, 那么它必须严格小于 d+2; 小数点前打印 k 个有效数字, 而小数点之后打印 d-k+1 个数字. 如果 k 是负的, 那么它必须是严格大于 -d; 如果总的域宽度允许, 一个单独的 0 会出现在小数点前, 而在小数点后先打印 -k 个 0 然后是 d+k 个有效数字. 打印的小数必须正确地四舍五入. 当向上舍入和向下舍入可能产生和参数 arg 的伸缩值等距的打印值时, 那么具体实现可以自由地去选择任意一个. 比如, 使用 ~8,2E 格式来打印 637.5 可能正确地产生 6.37E+2 或 6.38E+2.

在这个数字序列后, 打印这个指数. 首先打印字符参数 exponentchar; 如果这个参数省略了, 那么这个 prin1 使用的指数标记[exponenet marker]会被打印, 由这个浮点数[float]的类型和 \*read-default-float-format* 的当前值决定. 接着, 打印一个正号或负号, 后面跟着 e 位数表示十的幂, 打印的小数必须乘以这个值才能正确地表示参数 arg 的舍入值.

如果不可能以要求的格式在宽度为 w 的域中打印这个值, 可能是因为 k 太大或太小或者因为这个指数不能被打印在 e 个字符位置中, 那么会采取这两个动作中的一个. 如果提供了参数 overflowchar, 那么那个参数的 w 个宽度的拷贝会被打印而不是打印参数 arg 的伸缩值. 如果这个 overflowchar 参数被省略了, 那么使用超过 w 个字符打印伸缩值, 需要多少就打印多少; 如果这个问题是这个 d 对于提供的 k 来说太小, 或者 e 太小, 那么就会按照需要使用一个更大的 d 或 e 值.

如果省略了这个 w 参数, 那么这个域就是可变宽度的. 事实上, 以一种没有前导填充字符需要被打印的方式来选择一个 w 值.

如果省略了参数 d, 那么在数字的出现数量上没有约束. 以这样的方式为 d 选择一个值: 在根据参数 w 所施加的宽度限制, 这个伸缩因子 k 的约束, 以及没有数字零出现在小数的尾部中的约束可以打印尽可能多的数字, 除了如果要被打印的小数是 0 那么单独的数字零会出现在小数点后面.

如果参数 e 被省略, 则使用表示其值所需的最小位数打印这个指数.

如果 w, d, 和 e 都被省略, 那么这个效果是使用普通的自由格式的指数计数法来打印这个值; prin1 为任意小于 10^-3 或大于 10^7 的非零数字使用一个类似的格式. 仅有的区别是这个 ~E 指令总是在指数前打印一个正号或符号, 而如果这个指数是非负的 prin1 省略这个正号.

如果参数 arg 是一个有理数[rational], 那么它会被强制转换为一个单浮点数[single float]并且打印. 或者, 一个具体实现允许去用任何其他有着相同本质行为但是避免由于强制转换导致的精度丢失或溢出的方法来处理一个有理数[rational]. 如果 w 和 d 没有被提供并且这个数字没有准确的十进制表示, 比如 1/3, 由于只能打印有限数量的数字, 所以具体实现必须选择一定的精度截断.

如果 arg 是一个复数[complex]或某个非数值对象[object], 那么它会使用格式化指令 ~wD 来打印, 从而以十进制基数和最小域宽度 w 来打印它.

~E 绑定 \*print-escape* 为 false 并且绑定 \*print-readably* 为 false. 


#### 22.3.3.3 <span id="TildeGGeneral">波浪符号 G: 一般浮点数</span>

下一个参数 arg 以固定格式或指数表示法(视情况而定)打印为浮点数[float].

完整形式是 ~w,d,e,k,overflowchar,padchar,exponentcharG. 用来打印参数 arg 的格式取决于参数 arg 的大小 (绝对值). 让 n 为一个满足 10^n-1 <= |arg| < 10^n 的整数. 让 ee 等于 e+2, 或者如果 e 省略了就是 4. 让 ww 等于 w-ee, 如果 w 省略了就是 nil. 如果 d 省略了, 首先让 q 成为打印 arg 所需的数字的数量, 不丢失任何信息, 没有前导或尾随的零; 然后让 d 等于 (max q (min n 7)). 让 dd 等于 d-n.

如果 0 <= dd <= d, 那么 arg 就像是通过下面这个格式化指令被打印

    ~ww,dd,,overflowchar,padcharF~ee@T

注意, 伸缩因子 k 不会传递给那个 ~F 指令. 对于 dd 的所有其他值, arg 就像是通过下面这个格式化指令被打印

    ~w,d,e,k,overflowchar,padchar,exponentcharE

在任何一种情况下, 当且仅当向 ~G 指令提供了一个 @ 修饰符, 那么它将被提供给 ~F 或 ~E 指令.

~G 绑定 \*print-escape* 为 false 并且绑定 \*print-readably* 为 false. 


#### 22.3.3.4 <span id="TildeDollarsignMonetary">波浪符号 美元符号: 货币浮点数</span>

下一个参数 arg 用固定格式表示打印为一个浮点数[float].

完整形式为 ~d,n,w,padchar$. 参数 d 是小数点后要被打印的数字的数量 (默认值 2); n 是小数点前要打印数字的最小数量 (默认值 1); w 是要被打印的这个域的最小总宽度 (默认值 0).

首先输出填充和符号. 如果这个参数 arg 是负的, 那么会输出一个负号; 如果这个参数 arg 不是负的, 当且仅当提供一个 @ 修饰符时打印一个正号. 如果使用了这个 : 修饰符, 这个符号会出现在任何填充之前, 否则就是在填充之后. 如果提供了 w 并且其他要被输出的字符的数量小于 w, 那么 padchar (默认为一个空格 space) 的拷贝会被输出来使域的总宽度等于 w. 然后打印 n 个数字作为参数 arg 的整数部分, 如果必要的话, 带有前导的零; 然后打印一个小数点; 接着是小数的 d 个数字, 适当地舍入.

如果参数 arg 的大小太大以致于超过 m 个数字需要被打印, 其中 m 是 w 和 100 的较大者, 那么一个具体实现可以自由地自行决定使用指数表示来打印这个数字, 就像是通过指令 ~w,q,,,,padcharE, 其中 w 和 padchar 是存在的还是省略的得根据它们在这个 ~$ 指令中是存在的还是省略的来决定, 并且其中 q=d+n-1, 而 d 和 n 是提供给 ~$ 指令的值 (可能是默认的).

如果 arg 是一个有理数[rational], 那么它会被强制转换为一个单浮点数[single float]并且打印. 或者, 一个具体实现允许去用任何其他有着相同本质行为但是避免由于强制转换导致的精度丢失或溢出的方法来处理一个有理数.

如果 arg 是一个复数[complex]或者某个非数值对象[object], 那么它使用格式指令 ~wD 来打印, 从而以十进制基数和一个 w 的最小域宽度来打印它.

~$ 绑定 \*print-escape* 为 false 并且绑定 \*print-readably* 为 false. 


### 22.3.4 <span id="FORMATPrinterOperations">FORMAT 打印器操作</span>

#### 22.3.4.1 波浪符号 A: Aesthetic

一个可以是任何对象[object]的参数 arg 打印时没有转义字符 (就像是通过 princ). 如果 arg 是一个字符串[string], 它的字符[character]会逐字输出. 如果 arg 是 nil 它会被打印为 nil; 这个冒号修饰符 (~:A) 会导致一个 nil 的参数 arg 被打印为 (), 但是如果参数 arg 是一个复合结构, 例如一个列表[list]或向量[vector], 任何包含 nil 的出现仍然打印为 nil.

如果必要的话, ~mincolA 在右边插入空格来使这个宽度至少为 mincol 列. 这个 @ 修饰符导致空格被插入到左边而不是右边.

~mincol,colinc,minpad,padcharA 是 ~A 的完整形式, 它允许填充的控制. 这个字符串[string]会用至少 minpad 个 padchar 的拷贝来填充右边 (如果使用了 @ 修饰符就是左边); 填充字符会在一次插入 colinc 字符, 直到总宽度至少是 mincol. 对于 mincol 和 minpad 默认是 0, 对于 colinc 默认是 1, 并且对于 padchar 默认是空格字符.

~A 绑定 \*print-escape* 为 false, 并且绑定 \*print-readably* 为 false. 

#### 22.3.4.2 波浪符号 S: Standard

这个就像是 ~A, 但是参数 arg 用转义字符打印 (就像是通过 prin1 而不是 princ). 因此这个输出适合作为输入来 read. ~S 接受所有 ~A 接受的参数和修饰符.

~S 绑定 \*print-escape* 为 t. 

#### 22.3.4.3 波浪符号 W: Write

参数(任何对象[object])按照每个打印器控制变量进行打印 (像是通过 write). 另外, ~W 与深度缩写进行正确的交互, 不将深度计数器重置为 0. ~W 不接受参数. 如果给定了冒号[colon]修饰符, ~W 绑定 \*print-pretty* 为 true. 如果给定了 at-sign 修饰符, ~W 绑定 \*print-level* 和 \*print-length* 为 nil.

~W 为环状和共享的检测提供自动支持. 如果 \*print-circle* 的值[value]不是 nil 并且 ~W 应用到了一个是环状(或共享)引用的参数, 一个适当的 #n# 标记会被插入到输出中而不是打印这个参数. 

### 22.3.5 <span id="FORMATPrettyPrinterOperations">FORMAT 美观打印器操作</span>

以下构造提供了对美观打印器[pretty printer]的访问:

#### 22.3.5.1 波浪符号 下划线: 条件换行

没有任何修饰符时, ~_ 和 (pprint-newline :linear) 一样. ~@_ 和 (pprint-newline :miser) 一样. ~:_ 和 (pprint-newline :fill) 一样. ~:@_ 和 (pprint-newline :mandatory) 一样. 

#### 22.3.5.2 波浪符号 小于号: 逻辑块

~<...~:>

如果 ~:> 被用于终止 ~<...~>, 这个指令等价于一个对 pprint-logical-block 的调用. 对应于 ~<...~:> 指令的参数和 pprint-logical-block 的列表[list]参数相同方式处理, 因此为非列表[list]参数和环, 共享和深度缩写的检测提供了自动支持. 嵌套在 ~<...~:> 中的 control-string 部分指定了 :prefix (或 :per-line-prefix), :suffix, 和 pprint-logical-block 的主体.

~<...~:> 包含的这个 control-string 部分可以通过 ~; 指令被划分为片段 ~<prefix~;body~;suffix~:>. 如果第一部分由 ~@; 终止, 它指定一个行前缀而不是一个简单的前缀. 这个前缀和后缀不能包含格式化指令. 如果前缀或后缀不是一个不变的字符串或者如果这个包含的部分被拆分为不止三个片段, 那么就会发出一个错误.

如果这个包含的部分只被划分为两个片段, 后缀默认为空字符串. 如果这个包含的部分只由一个单独的片段组成, 那么前缀和后缀都默认为空字符串. 如果使用了这个冒号[colon]修饰符 (具体来说, 就是 ~:<...~:>), 前缀和后缀默认分别为 "(" 和 ")" 而不是空字符串.

这个主体片段可以是任意格式化字符串[format string]. 这个格式化字符串[format string]被应用于把 ~<...~:> 作为一个整体对应的数组元素. 使用 pprint-pop 从这个列表中提取元素, 因此为畸形列表以及环, 共享和长度缩写的检测提供自动支持. 在这个主体片段中, ~^ 表现得就像是 pprint-exit-if-list-exhausted.

~<...~:> 支持一个 pprint-logical-block 不支持的特性. 如果 ~:@> 被用于终止指令 (也就是, ~<...~:@>), 那么一个填充风格的条件换行会被自动插入到这个主体所包含的每一个空白组后 (除了一个 <Newline> 指令后面的空白以外). 这样就很容易实现与填充段落相同的效果.

如果这个 at-sign 修饰符和 ~<...~:> 一起使用, 那么这个完整的剩余参数列表会作为参数传递给这个指令. 所有这些剩余参数都由 ~@<...~:> 消耗, 即便它们没有全部被嵌套在这个指令中的格式化字符串[format string]使用. 除了在它的参数中的区别, ~@<...~:> 和 ~<...~:> 一样, 除了如果 ~@<...~:> 在一个格式化字符串[format string]中到达了顶层, 这个环的检测就不适用. 这个保证这个环的检测只会应用到数据列表, 不会应用到格式化参数[format argument]列表[list].

如果要将环或共享作为一个整体来表示, " . #n#" 将被打印出来.

在很大程度上, 指令 ~<...~> 的基本形式和通过 ~W, ~\_, ~<...~:>, ~I, 和 ~:T 的输出配置的动态控制不兼容. 因此, 如果这些指令中的任何一个嵌套在 ~<...~> 中就会发出一个错误. 除了那个以外, 如果这个 ~<...~> 的 ~<...~:;...~> 形式和 ~W, ~_, ~<...~:>, ~I, 或 ~:T 一起在同一个格式化字符串[format string]中使用也会发出一个错误.

也见章节 22.3.6.2 (波浪符号 小于号: 对齐). 


#### 22.3.5.3 波浪符号 I: 缩进

~nI 和 (pprint-indent :block n) 一样.

~n:I 和 (pprint-indent :current n) 一样. 在这两种情况中, 如果 n 被省略的话, 它默认为零. 

#### 22.3.5.4 波浪符号 斜杠: 调用函数

~/name/

可以在一个格式化字符串中通过使用 ~/name/ 指令来调用用户定义的函数. 这个冒号[colon]修饰符, at-sign 修饰符, 以及很多参数可以和 ~/name/ 指令一起被指定. name 可以是不包含 "/" 的任意字符串. 这个 name 中的所有字符都会像它们是大写的情况一样被对待. 如果 name 包含了一个单冒号[colon] (:) 或双冒号[colon] (::), 那么直到但不包括第一个 ":" 或 "::" 的所有字符被认为是命名一个包[package]的字符串[string]. 在第一个 ":" 或 "::" (如果有的话) 后面的所有字符都被认为是命名一个符号[symbol]的字符串[string]. 对应于一个 ~/name/ 指令的函数通过在指定的包[package]中查找具有指定名称的符号[symbol]来获取. 如果 name 不包含 ":" 或 "::", 那么在 COMMON-LISP-USER 包中查找整个 name 字符串.

当遇到一个 ~/name/ 指令时, 指定的函数用四个或更多的参数来调用. 前四个参数是: 输出流, 对应这个指令的格式化参数[format argument], 一个如果使用了冒号[colon]修饰符就是 true 的广义 boolean [generalized boolean], 以及一个如果使用了 at-sign 修饰符就是 true 的广义 boolean [generalized boolean]. 剩余参数由指令指定的任何参数组成. 函数应该适当地打印参数. 这个函数返回的值都会被忽略.

这三个函数[function] pprint-linear, pprint-fill, 和 pprint-tabular 是特别设计的以致于它们可以通过 ~/.../ 来调用 (换句话说, ~/pprint-linear/, ~/pprint-fill/, 和 ~/pprint-tabular/). 特别地, 它们接受冒号[colon]和 at-sign 参数. 


### 22.3.6 <span id="FORMATLayoutControl">FORMAT 布局控制</span>

#### 22.3.6.1 波浪符号 T: 制表符

将这个空格移到给定的列上. ~colnum,colincT 会输出足够的空格来使游标移动到列 colnum. 如果这个游标已经在或超过列 colnum, 它会输出空格来移动它到列 colnum+k*colinc, 其中 k 为可能的最小正整数, 除非 colinc 是零, 在这个情况下如果游标已经在或超过列 colnum 不会输出空格. colnum 和 colinc 默认为 1.

如果由于某个原因, 当前完整的列位置不能由直接查询来确定, format 可以通过注意某些指令将列位置重置为零(例如 ~%, 或 ~&, 或带有包含换行的字符串参数的 ~A), 并计算从该点开始发出的字符数, 从而推断出当前列的位置. 如果这样失败了, format 可以尝试对更危险的假设进行类似的推断, 即在调用 format 时, 目标位于列 0. 如果即便这个试探失败了, 或者在实现上不方便, 最坏情况下这个 ~T 操作符最多只会输出两个空格.

~@T 执行相对的制表. ~colrel,colinc@T 输出 colrel 个空格并且接着输出最小非负数量的必要的额外空格来使游标移动到是 colinc 的倍数的一个列. 比如, 指令 ~3,8@T 输出三个空格, 然后将光标移动到一个 "标准的八倍制表停止"(如果还没有达到1). 如果不能确定当前的输出列, 那么 colinc 就会被忽略, 而 colrel 个空格恰好是输出.

如果这个冒号[colon]修饰符和 ~T 指令一起使用, 这个制表的计算是相对于立即包含该指令的节开始的水平位置进行的, 而不是相对于水平位置零. 这两个数值参数都被解释为以 em 为单位并且默认为 1. ~n,m:T 和 (pprint-tab :section n m) 一样. ~n,m:@T 和 (pprint-tab :section-relative n m) 一样. 


#### 22.3.6.2 波浪符号 小于号: 对齐

~mincol,colinc,minpad,padchar<str~>

这个将至少 mincol 列宽度的域中处理 str 产生的文本对齐. str 可能使用 ~; 划分片段, 在这个情况中间隔在文本段之间平均分配.

没有修饰符时, 最左边的文本片段在这个域中被左对齐, 并且最右边的文本片段被右对齐. 如果这里只有一个文本元素, 作为一个特殊情况, 它被右对齐. 这个 : 修饰符导致在第一个文本片段之前要被引入的间距; 这个 @ 修饰符导致在最后要被添加的间距. 这个 minpad 参数 (默认 0) 是在每一个片段之间要被输出的填充字符的最小数量. 填充字符由 padchar 提供, 默认为空格字符. 如果需要去满足这些约束的总宽度大于 mincol, 那么使用的宽度是 mincol+k*colinc, 其中 k 是可能的最小非负整数值. colinc 默认为 1, 并且 mincol 默认为 0.

注意, str 可能包含 format 指令. 在 str 中的所有子句依次被处理; 它是经过调整的文本结果.

这个 ~^ 指令可以被用于过早地终止子句处理, 在这个情况下只有那些完整处理的子句会被对齐.

如果 ~< 的第一个子句由 ~:; 终止而不是 ~;, 那么以一种特殊的方式来使用它. 所有这些子句都被处理 (当然, 受限于 ~^), 但是第一个不会被用于执行间距和填充. 当那个填充的结果已经被确定时, 那么如果它符合输出的当前行, 它就被输出, 并且第一个子句的文本会被丢弃. 然而, 如果填充的文本不符合当前行, 那么第一个子句的文本片段会在这个填充文本之前被输出. 第一个子句应该包含一个换行 (例如一个 ~% 指令). 第一个子句总是被处理, 因此它引用的任何参数都会被使用; 决定是否使用产生的文本段, 而不是是否处理第一个子句. 如果这个 ~:; 有一个前缀参数 n, 填充文本必须与当前行匹配, 并保留 n 个字符位置, 以避免输出第一个子句的文本. 比如, 控制字符串

    "~%;; ~{ ~<~%;; ~1:; ~S~>~^ ,~} .~%"

可以用来打印一个由逗号分隔的条目列表, 而不需要在行边界上破坏条目, 其中每一行用 ;; 开始. 如果这个对齐条目不是列表中的最后一个元素, 那么在 ~1:; 中的前缀参数 1 说明了该条目后面的逗号宽度, 如果是最后一个元素的话就是句号的宽度. 如果 ~:; 有一个第二个前缀参数, 那么它被用作这个行的宽度, 因此覆盖了这个输出流的自然行宽度. 为了使前面的例子使用 50 的行宽, 一种方式可以写作

    "~%;; ~{ ~<~%;; ~1,50:; ~S~>~^ ,~}  .~%"

如果没有提供第二个参数, 那么 format 使用 destination 输出流的行宽. 如果不能确定这个 (比如, 当产生一个字符串[string]结果时), 那么 format 使用 72 作为行长度.

也见章节 22.3.5.2 (波浪符号 小于号: 逻辑块). 

#### 22.3.6.3 波浪符号 大于号: 终止对齐

~> 终止一个 ~<. 在其他地方使用它的后果是未定义的. 


#### 22.3.7 <span id="FORMATControlFlowOperation">FORMAT 控制流操作</span>

> * 22.3.7.1 [波浪符号 星号: Go-To](#TildeAsteriskGoTo)
> * 22.3.7.2 [波浪符号 左中括号: 条件表达式](#TildeLeftBracketCondExpr)
> * 22.3.7.3 [波浪符号 右中括号: 条件表达式的结束](#TildeRightBracketEndCondExpr)
> * 22.3.7.4 [波浪符号 左大括号: 循环](#TildeLeftBraceIteration)
> * 22.3.7.5 [波浪符号 右大括号: 循环的结束](#TildeRightBraceEndIteration)
> * 22.3.7.6 [波浪符号 问号: 递归处理](#TildeQuestionMarkRecursiveProc)

#### 22.3.7.1 <span id="TildeAsteriskGoTo">波浪符号 星号: Go-To</span>

下一个参数 arg 会被忽略. ~n* 忽略接下来的 n 个参数.

~:* 在参数列表中倒退, 这样一来最后处理的参数会被再一次处理. ~n:* 倒退 n 个参数.

当在一个 ~{ 构造 (见下方) 中时, 这个忽略 (不管在哪个方向) 是相对于要被这个循环处理的参数列表.

~n@* 转到第 n 个参数 arg, 这里 0 表示第一个; n 默认为 0, 因此 ~@* 转移回第一个参数 arg. 在一个 ~n@* 后的指令会接收一个序列中的参数, 这个序列以那个转移到的参数开始. 当在一个 ~{ 构造中时, 这个 "goto" 是相对于要被这个循环处理的参数列表 . 

#### 22.3.7.2 <span id="TildeLeftBracketCondExpr">波浪符号 左中括号: 条件表达式</span>

~[str0~;str1~;...~;strn~]

这个是一个控制字符串的集合, 称为子句, 它们的其中一个会被选择并使用. 这些子句由 ~; 分隔并且这个构造由 ~] 终止. 比如,

    "~[Siamese~;Manx~;Persian~] Cat"

第 arg 个子句会被选择, 其中第一个子句是数字 0. 如果给定了一个前缀参数 (例如 ~n[), 那么该前缀参数会被使用而不是一个实参. 如果这个参数 arg 在范围之外那么没有子句会被选择并且不会发出错误. 在这个选择的方案被处理后, 这个控制字符串在 ~] 后继续下去.

~[str0~;str1~;...~;strn~:;default~] 有一个默认情况. 如果最后的 ~; 用于分隔子句是 ~:;, 那么最后那个子句是一个 else 子句, 没有其他子句被选择时被执行. 比如:

    "~[Siamese~;Manx~;Persian~:;Alley~] Cat"

如果参数 arg 是 false, 那么 ~:[alternative~;consequent~] 选择 alternative 控制字符串, 否则选择 consequent 控制字符串.

~@[consequent~] 检验这个参数. 如果它是 true, 则 ~[ 命令不会使用该参数, 而是保留作为下一个要处理的参数, 而子句 consequent 被处理了. 如果参数 arg 是 false, 则使用该参数, 并且该子句不会被处理. 因此这个子句正常应该仅使用一个参数, 并且可能期望它为非 nil [non-nil]. 比如:

```LISP
(setq *print-level* nil *print-length* 5)
(format nil
        "~@[ print level = ~D~]~@[ print length = ~D~]"
        *print-level* *print-length*)
=>   " print length = 5"
```

注意

```LISP
(format stream "...~@[str~]..." ...)
==  (format stream "...~:[~;~:*str~]..." ...)
```

这个 ~[ 和 # 的组合是很有用的, 比如, 用于处理打印列表的英语规约:

```LISP
(setq foo "Items:~#[ none~; ~S~; ~S and ~S~
          ~:;~@{~#[~; and~] ~S~^ ,~}~].")
(format nil foo) =>   "Items: none."
(format nil foo 'foo) =>   "Items: FOO."
(format nil foo 'foo 'bar) =>   "Items: FOO and BAR."
(format nil foo 'foo 'bar 'baz) =>   "Items: FOO, BAR, and BAZ."
(format nil foo 'foo 'bar 'baz 'quux) =>   "Items: FOO, BAR, BAZ, and QUUX."
```

#### 22.3.7.3 <span id="TildeRightBracketEndCondExpr">波浪符号 右中括号: 条件表达式的结束</span>

~] 终止一个 ~[. 在其他地方使用它的后果是未定义的. 

#### 22.3.7.4 <span id="TildeLeftBraceIteration">波浪符号 左大括号: 循环</span>

~{str~}

这是一个循环构造. 参数应该是一个列表[list], 它被用作一个参数集合, 就像是用于 format 的一个递归调用. 字符串[string] str 被重复用作控制字符串. 每个循环都可以吸收列表[list]中它所期望的数量的元素作为参数; 如果 str 本身使用了两个参数, 那么列表[list]将在每次循环时消耗两个元素. 如果在任何循环步骤之前这个列表[list]就是空的, 那么这个循环会被终止. 同样地, 如果给定了一个前缀参数 n, 那么这里会有至少 n 个 str 处理的重复. 最后, 这个 ~^ 指令可以被用于提前终止这个循环.

比如:

```LISP
(format nil "The winners are:~{ ~S~}." 
        '(fred harry jill)) 
=>  "The winners are: FRED HARRY JILL."                           
(format nil "Pairs:~{ <~S,~S>~}." 
        '(a 1 b 2 c 3))
=>  "Pairs: <A,1> <B,2> <C,3>."
```

~:{str~} 是类似的, 但是参数应该是一个子表的列表[list]. 在每一个重复步骤, 一个子表被用作处理 str 的参数集合; 下一次重复时, 使用一个新的子表, 不管最后的子表是否已经被处理. 例如:

```LISP
(format nil "Pairs:~:{ <~S,~S>~} ." 
                '((a 1) (b 2) (c 3)))
=>  "Pairs: <A,1> <B,2> <C,3>."
```

~@{str~} 类似于 ~{str~}, 但不是使用一个参数列表, 而是使用所有剩余参数作为这个循环的参数列表. 例如:

```LISP
(format nil "Pairs:~@{ <~S,~S>~} ." 'a 1 'b 2 'c 3)
=>  "Pairs: <A,1> <B,2> <C,3>."
```

如果在所有剩余参数被消耗之前循环终止, 那么任何没有被这个循环处理的参数保留给这个循环构造后面的指令来处理.

~:@{str~} 组合 ~:{str~} and ~@{str~} 的特性. 所有这些剩余参数都会被使用, 并且每一个一定是一个列表[list]. 在每一个循环中, 下一个参数被用作给 str 的参数列表[list]. 例如:

```LISP
(format nil "Pairs:~:@{ <~S,~S>~} ." 
            '(a 1) '(b 2) '(c 3)) 
=>  "Pairs: <A,1> <B,2> <C,3>."
```

用 ~:} 而不是 ~} 终止这个重复构造会强制对 str 处理至少一次, 即便参数的初始列表是空的. 然而, 这个不会覆盖一个显式的前缀参数零.

如果 str 是空的, 那么一个参数被用作 str. 它必须是一个格式化控制[format control]并且先于要被这个循环处理的任何参数之前. 举个例子, 下面这个是等价的:

```LISP
    (apply #'format stream string arguments)
 ==  (format stream "~1{~:}" string arguments)
```

这个会将 string 用作一个格式化字符串. 这个 ~1{ 说明它最多只会被处理一次, 而这个 ~:} 说明它会被处理至少一次. 因此它只处理一次, 使用 arguments 作为参数. 这个情况可能被 ~? 指令更清晰地处理, 但是这个 ~{ 的一般特性比 ~? 更强大. 


#### 22.3.7.5 <span id="TildeRightBraceEndIteration">波浪符号 右大括号: 循环的结束</span>

~} 终止一个 ~{. 在其他地方使用它的后果是未定义的. 

#### 22.3.7.6 <span id="TildeQuestionMarkRecursiveProc">波浪符号 问号: 递归处理</span>

下一个参数 arg 必须是一个格式化控制[format control], 并且在它后面的是一个列表[list]; 这两个都被 ~? 指令消耗. 这两个被作为一个控制字符串 control-string 处理, 使用这个列表[list]的元素作为参数. 一旦这个递归处理已经完成, 这个包含 ~? 指令的控制字符串的处理就会恢复. 例如:

```LISP
(format nil "~? ~D" "<~A ~D>" '("Foo" 5) 7) =>  "<Foo 5> 7"
(format nil "~? ~D" "<~A ~D>" '("Foo" 5 14) 7) =>  "<Foo 5> 7"
```

注意, 在第二个例子中三个参数被提供给格式化字符串[format string] "<~A ~D>", 但是只有两个被处理并且第三个被忽略.

带有这个 @ 修饰符时, 只有一个参数 arg 被直接消费. 这个参数 arg 必须是一个字符串[string]; 它作为控制字符串的一部分处理, 就好像它代替了 ~@? 构造一样, 并且这个递归处理的字符串中的任何指令可能消费这个包含 ~@? 指令的控制字符串的参数. 例如:

```LISP
(format nil "~@? ~D" "<~A ~D>" "Foo" 5 7) =>  "<Foo 5> 7"
(format nil "~@? ~D" "<~A ~D>" "Foo" 5 14 7) =>  "<Foo 5> 14"
```


### 22.3.8 <span id="FORMATMiscellaneousOperation">FORMAT 杂项操作</span>

#### 22.3.8.1 波浪符号 左圆括号: 大小写转换

~(str~)

包含的控制字符串 str 被处理, 并且产生的结果受限于大小写转换.

在没有标志的情况下, 每一个大写[uppercase]字符[character]会被转换为对应小写[lowercase]字符[case].

~:( 就像是通过 string-capitalize 一样将所有单词大写.

~@( 只是用大写字母写第一个单词并且强制剩余的为小写.

~:@( 转换每一个小写字符为对应大写字符.

在这个例子中 ~@( 被用于使 ~@R 产生的第一个单词大写:

```LISP
(format nil "~@R ~(~@R~)" 14 14) 
=>  "XIV xiv"
(defun f (n) (format nil "~@(~R~) error~:P detected." n)) =>  F
(f 0) =>  "Zero errors detected."
(f 1) =>  "One error detected."
(f 23) =>  "Twenty-three errors detected."
```

当大小写转换嵌套出现时, 则由外部的转换来主导, 就像下面这个例子中说明的:

```LISP
(format nil "~@(how is ~:(BOB SMITH~)?~)")
=>  "How is bob smith?"
NOT=>  "How is Bob Smith?"
```

#### 22.3.8.2 波浪符号 右圆括号: 大小写转换的终止

~) 终止一个 ~(. 在其他地方使用它的后果是未定义的. 

#### 22.3.8.3 波浪符号 P: Plural

如果 arg 不是和整数 1 是 eql 的, 打印一个小写的 s; 如果参数 arg 和 1 是 eql 的, 什么都不打印. 如果 arg 是一个浮点数 1.0, 那么打印 s.

~:P 做相同的事, 在执行一个 ~:* 后倒退一个参数; 这也就是说, 如果前面的参数不是 1, 那么它打印一个小写的 s.

如果参数是 1, ~@P 打印 y, 如果不是就是 ies. ~:@P 做相同的事, 但是先后退.

```LISP
(format nil "~D tr~:@P/~D win~:P" 7 1) =>  "7 tries/1 win"
(format nil "~D tr~:@P/~D win~:P" 1 0) =>  "1 try/0 wins"
(format nil "~D tr~:@P/~D win~:P" 1 3) =>  "1 try/3 wins"
```


### 22.3.9 <span id="FORMATMiscellaneousPseudoOperation">FORMAT 杂项伪操作</span>

#### 22.3.9.1 波浪符号 分号: 子句分隔符

这个分隔 ~[ 和 ~< 构造中的子句. 在其他地方是用它的后果是未定义的. 


#### 22.3.9.2 波浪符号 抑扬符: 向上逸出

~^

这是一个逸出构造. 如果这里没有更多要被处理的参数剩余, 那么直接包含的 ~{ 或 ~< 构造会被终止. 如果这里没有这样包含的构造, 那么整个格式化操作会被终止. 在 ~< 的情况中, 这个格式化会被执行, 但是在执行这个调整之前没有更多的片段会被处理. ~^ 可能出现在一个 ~{ 构造中的任何地方.

```LISP
(setq donestr "Done.~^ ~D warning~:P.~^ ~D error~:P.")
=>  "Done.~^ ~D warning~:P.~^ ~D error~:P."
(format nil donestr) =>  "Done."
(format nil donestr 3) =>  "Done. 3 warnings."
(format nil donestr 1 5) =>  "Done. 1 warning. 5 errors."
```

如果给定了一个前缀参数, 如果这个参数是零则发生终止. (因此 ~^ 等价于 ~#^.) 如果给定了两个参数, 如果它们是相等的则发生终止. 如果给定了三个参数, 如果第一个小于等于第二个并且第二个小于等于第三个, 那么就会发生终止. 当然, 如果所有这些前置参数都是常量, 那么就是没有用的; 它们中至少一个应该是 # 或一个 V 参数.

如果 ~^ 在一个 ~:{ 构造中被使用, 那么它终止当前的循环步骤, 因为在标准情况下它只测试当前步骤的剩余参数; 下一个循环步骤立即开始. ~:^ 被用于终止这个循环过程. ~:^ 可能只有当它会终止的命令是 ~:{ 或 ~:@{ 时才使用. 当且仅当这个为当前循环步骤提供参数的子列表是 ~:{ 中的最后一个子列表时, 或者是 ~:@{ 中的最后一个 format 参数时, 整个循环过程终止. ~:^ 不等价于 ~#:^; 当且仅当当前循环步骤没有参数剩余时, 后者会终止整个循环步骤. 比如:

```LISP
(format nil "~:{ ~@?~:^ ...~} " '(("a") ("b"))) =>  "a...b"
```

如果 ~^ 出现在一个 ~? 指令控制下要被处理的控制字符串中, 但是没有在那个字符串的任何 ~{ 或 ~< 构造中, 那么这个要被处理的字符串会被终止, 因此结束这个 ~? 指令的处理. 然后从包含这个 ~? 指令的字符串中的这个指令后面的位置继续处理.

如果 ~^ 出现在一个 ~[ 或 ~( 构造中, 那么所有直到 ~^ 的命令会被正确选择或转换大小写, 这个 ~[ 或 ~( 处理终止, 继续向外搜索要被终止的 ~{ 或 ~< 构造. 例如:

```LISP
(setq tellstr "~@(~@[~R~]~^ ~A!~)")
=>  "~@(~@[~R~]~^ ~A!~)"
(format nil tellstr 23) =>  "Twenty-three!"
(format nil tellstr nil "losers") =>  " Losers!"
(format nil tellstr 23 "losers") =>  "Twenty-three losers!"
```

下面是在一个 ~< 构造中使用 ~^ 的示例.

```LISP
(format nil "~15<~S~;~^~S~;~^~S~>" 'foo)
=>   "            FOO"
(format nil "~15<~S~;~^~S~;~^~S~>" 'foo 'bar)
=>   "FOO         BAR"
(format nil "~15<~S~;~^~S~;~^~S~>" 'foo 'bar 'baz)
=>   "FOO   BAR   BAZ"
```

#### 22.3.9.3 波浪符号 换行符: 忽略换行

波浪符号[tilde]后面立即跟着一个换行符[newline]会忽略换行[newline]以及后面的非换行空白[whitespace[1]]字符. 带有一个 : 的话, 换行符[newline]会被忽略, 但是任何后面的空白[whitespace[1]]字符会留在原处. 带有一个 @ 的话, 换行符[newline]会留在原处, 但是任何后面的空白[whitespace[1]]字符会被忽略. 例如:

```LISP
(defun type-clash-error (fn nargs argnum right-type wrong-type)
  (format *error-output*
          "~&~S requires its ~:[~:R~;~*~]~ 
          argument to be of type ~S,~%but it was called ~
          with an argument of type ~S.~%"
          fn (eql nargs 1) argnum right-type wrong-type))
(type-clash-error 'aref nil 2 'integer 'vector)  prints:
AREF requires its second argument to be of type INTEGER,
but it was called with an argument of type VECTOR.
NIL
(type-clash-error 'car 1 1 'list 'short-float)  prints:
CAR requires its argument to be of type LIST,
but it was called with an argument of type SHORT-FLOAT.
NIL
```

注意, 在这个例子中换行符只出现在由 ~& 和 ~% 指令指定的输出中; 在这个控制字符串中的这些实际换行符被抑制, 因为每一个前面都有一个波浪符号. 

### 22.3.10 <span id="AddInfoFORMATOperations">关于 FORMAT 的额外信息</span>

#### 22.3.10.1 FORMAT 操作的嵌套

大小写转换, 条件, 循环, 以及对齐构造可以通过把其他格式化构造括在一起来包含它们. 这些构造必须和其他每一个正确地嵌套. 例如, 在条件的每个分支中放置一个大小写转换构造的开始而在条件之外放置大小写转换结构的结束是不合法的:

```LISP
(format nil "~:[abc~:@(def~;ghi~
:@(jkl~]mno~)" x) ;Invalid!
```

这个表示是非法的因为 ~[...~;...~] 和 ~(...~) 构造是不正确地嵌套.

由 ~? 指令引起的间接处理也是一种嵌套, 其目的是实现正确的嵌套规则. 不允许在 ~? 指令控制下处理的字符串中启动括号构造, 并在包含该构造的字符串中的 ~? 构造之后的某个点结束该构造, 反之亦然. 例如, 这个情况是非法的:

```LISP
(format nil "~@?ghi~)" "abc~@(def") ;Invalid!
```

这个表示是非法的因为 ~? 和 ~(...~) 构造是不正确地嵌套. 

#### 22.3.10.2 缺失的以及额外的 FORMAT 参数

如果对于一个需要一个参数的指令没有剩余的参数, 那么后果是未定义的. 然而, 允许一个或多个剩余的参数没有被一个指令处理; 这样的参数 args 会被忽略. 

#### 22.3.10.3 额外的 FORMAT 参数

如果一个格式化指令给定了比它在这里描述的可接受参数更多的参数, 那么后果是未定义的. 

#### 22.3.10.4 未定义的 FORMAT 修饰符组合

如果冒号[colon]或 at-sign 修饰符以这里没有明确描述为有意义的组合形式提供给指令, 那么后果是未定义的. 

### 22.3.11 <span id="">FORMAT 的示例</span>

```LISP
(format nil "foo") =>  "foo"
(setq x 5) =>  5
(format nil "The answer is ~D." x) =>  "The answer is 5."
(format nil "The answer is ~3D." x) =>  "The answer is   5."
(format nil "The answer is ~3,'0D." x) =>  "The answer is 005."
(format nil "The answer is ~:D." (expt 47 x))
=>  "The answer is 229,345,007."
(setq y "elephant") =>  "elephant"
(format nil "Look at the ~A!" y) =>  "Look at the elephant!"
(setq n 3) =>  3
(format nil "~D item~:P found." n) =>  "3 items found."
(format nil "~R dog~:[s are~; is~] here." n (= n 1))
=>  "three dogs are here."
(format nil "~R dog~:*~[s are~; is~:;s are~] here." n)
=>  "three dogs are here."
(format nil "Here ~[are~;is~:;are~] ~:*~R pupp~:@P." n)
=>  "Here are three puppies."

(defun foo (x)
  (format nil "~6,2F|~6,2,1,'*F|~6,2,,'?F|~6F|~,2F|~F"
          x x x x x x)) =>  FOO
(foo 3.14159)  =>  "  3.14| 31.42|  3.14|3.1416|3.14|3.14159"
(foo -3.14159) =>  " -3.14|-31.42| -3.14|-3.142|-3.14|-3.14159"
(foo 100.0)    =>  "100.00|******|100.00| 100.0|100.00|100.0"
(foo 1234.0)   =>  "1234.00|******|??????|1234.0|1234.00|1234.0"
(foo 0.006)    =>  "  0.01|  0.06|  0.01| 0.006|0.01|0.006"

(defun foo (x)  
  (format nil
          "~9,2,1,,'*E|~10,3,2,2,'?,,'$E|~
          ~9,3,2,-2,'%@E|~9,2E"
          x x x x))
(foo 3.14159)  =>  "  3.14E+0| 31.42$-01|+.003E+03|  3.14E+0"
(foo -3.14159) =>  " -3.14E+0|-31.42$-01|-.003E+03| -3.14E+0"
(foo 1100.0)   =>  "  1.10E+3| 11.00$+02|+.001E+06|  1.10E+3"
(foo 1100.0L0) =>  "  1.10L+3| 11.00$+02|+.001L+06|  1.10L+3"
(foo 1.1E13)   =>  "*********| 11.00$+12|+.001E+16| 1.10E+13"
(foo 1.1L120)  =>  "*********|??????????|%%%%%%%%%|1.10L+120"
(foo 1.1L1200) =>  "*********|??????????|%%%%%%%%%|1.10L+1200"
```

作为一个可变伸缩因子影响的例子, 代码

```LISP
(dotimes (k 13)
  (format t "~%Scale factor ~2D: |~13,6,2,VE|"
          (- k 5) (- k 5) 3.14159))
```

产生以下输出:

    Scale factor -5: | 0.000003E+06|
    Scale factor -4: | 0.000031E+05|
    Scale factor -3: | 0.000314E+04|
    Scale factor -2: | 0.003142E+03|
    Scale factor -1: | 0.031416E+02|
    Scale factor  0: | 0.314159E+01|
    Scale factor  1: | 3.141590E+00|
    Scale factor  2: | 31.41590E-01|
    Scale factor  3: | 314.1590E-02|
    Scale factor  4: | 3141.590E-03|
    Scale factor  5: | 31415.90E-04|
    Scale factor  6: | 314159.0E-05|
    Scale factor  7: | 3141590.E-06|

```LISP
(defun foo (x)
  (format nil "~9,2,1,,'*G|~9,3,2,3,'?,,'$G|~9,3,2,0,'%G|~9,2G"
          x x x x))                                     
(foo 0.0314159) =>  "  3.14E-2|314.2$-04|0.314E-01|  3.14E-2"
(foo 0.314159)  =>  "  0.31   |0.314    |0.314    | 0.31    "
(foo 3.14159)   =>  "   3.1   | 3.14    | 3.14    |  3.1    "
(foo 31.4159)   =>  "   31.   | 31.4    | 31.4    |  31.    "
(foo 314.159)   =>  "  3.14E+2| 314.    | 314.    |  3.14E+2"
(foo 3141.59)   =>  "  3.14E+3|314.2$+01|0.314E+04|  3.14E+3"
(foo 3141.59L0) =>  "  3.14L+3|314.2$+01|0.314L+04|  3.14L+3"
(foo 3.14E12)   =>  "*********|314.0$+10|0.314E+13| 3.14E+12"
(foo 3.14L120)  =>  "*********|?????????|%%%%%%%%%|3.14L+120"
(foo 3.14L1200) =>  "*********|?????????|%%%%%%%%%|3.14L+1200"

(format nil "~10<foo~;bar~>")   =>  "foo    bar"
(format nil "~10:<foo~;bar~>")  =>  "  foo  bar"
(format nil "~10<foobar~>")     =>  "    foobar"
(format nil "~10:<foobar~>")    =>  "    foobar"
(format nil "~10:@<foo~;bar~>") =>  "  foo bar "
(format nil "~10@<foobar~>")    =>  "foobar    "
(format nil "~10:@<foobar~>")   =>  "  foobar  "

  (FORMAT NIL "Written to ~A." #P"foo.bin")
  =>  "Written to foo.bin."
```

### 22.3.12 <span id="NotesFORMAT">FORMAT 的注意事项</span>

格式化输出不仅可以通过 format 来执行, 还可以由接受 format 方式的格式化控制[format control]的某些其他函数执行. 例如, 像 cerror 这样的发送错误的函数接收格式化控制[format control].

注意, 给 format 作为目标的 nil 和 t 的意义和那些作为流标识符[stream designator]的 nil 和 t 不同.

这个 ~^ 应该只出现在一个 ~< 子句的开始, 因为它终止这个它出现的完整子句 (所有后面的子句也一样). 


## 22.4 <span id="ThePrinterDictionary">打印器的字典</span>

> * [函数 COPY-PPRINT-DISPATCH](#F-COPY-PPRINT-DISPATCH)
> * [宏 FORMATTER](#M-FORMATTER)
> * [函数 PPRINT-DISPATCH](#F-PPRINT-DISPATCH)
> * [局部宏 PPRINT-EXIT-IF-LIST-EXHAUSTED](#LM-PPRINT-EXIT-IF-LIST-EXHAUSTED)
> * [函数 PPRINT-FILL, PPRINT-LINEAR, PPRINT-TABULAR](#F-PPRINT-FILL-LINEAR-TABULAR)
> * [函数 PPRINT-INDENT](#F-PPRINT-INDENT)
> * [宏 PPRINT-LOGICAL-BLOCK](#M-PPRINT-LOGICAL-BLOCK)
> * [函数 PPRINT-NEWLINE](#F-PPRINT-NEWLINE)
> * [局部宏 PPRINT-POP](#LM-PPRINT-POP)
> * [函数 PPRINT-TAB](#F-PPRINT-TAB)
> * [标准广义函数 PRINT-OBJECT](#SGF-PRINT-OBJECT)
> * [宏 PRINT-UNREADABLE-OBJECT](#M-PRINT-UNREADABLE-OBJECT)
> * [函数 SET-PPRINT-DISPATCH](#F-SET-PPRINT-DISPATCH)
> * [函数 WRITE, PRIN1, PRINT, PPRINT, PRINC](#F-WRITE-PRIN1-PRINT-PPRINT-PRINC)
> * [函数 WRITE-TO-STRING, PRIN1-TO-STRING, PRINC-TO-STRING](#F-WRITE-PRIN1-PRINC-TO-STRING)
> * [变量 *PRINT-ARRAY*](#V-PRINT-ARRAY)
> * [变量 *PRINT-BASE*, *PRINT-RADIX*](#V-PRINT-BASE-RADIX)
> * [变量 *PRINT-CASE*](#V-PRINT-CASE)
> * [变量 *PRINT-CIRCLE*](#V-PRINT-CIRCLE)
> * [变量 *PRINT-ESCAPE*](#V-PRINT-ESCAPE)
> * [变量 *PRINT-GENSYM*](#V-PRINT-GENSYM)
> * [变量 *PRINT-LEVEL*, *PRINT-LENGTH*](#V-PRINT-LEVEL-LENGTH)
> * [变量 *PRINT-LINES*](#V-PRINT-LINES)
> * [变量 *PRINT-MISER-WIDTH*](#V-PRINT-MISER-WIDTH)
> * [变量 *PRINT-PPRINT-DISPATCH*](#V-PRINT-PPRINT-DISPATCH)
> * [变量 *PRINT-PRETTY*](#V-PRINT-PRETTY)
> * [变量 *PRINT-READABLY*](#V-PRINT-READABLY)
> * [变量 *PRINT-RIGHT-MARGIN*](#V-PRINT-RIGHT-MARGIN)
> * [状况类型 PRINT-NOT-READABLE](#CT-PRINT-NOT-READABLE)
> * [函数 PRINT-NOT-READABLE-OBJECT](#F-PRINT-NOT-READABLE-OBJECT)
> * [函数 FORMAT](#F-FORMAT)

### <span id="F-COPY-PPRINT-DISPATCH">函数 COPY-PPRINT-DISPATCH</span>

* 语法(Syntax):

        copy-pprint-dispatch &optional table => new-table

* 参数和值(Arguments and Values):

        table---一个美观打印分派表[pprint dispatch table], 或 nil.
        new-table---一个新的[fresh]美观打印分派表[pprint dispatch table].

* 描述(Description):

        创建并返回指定的表 table 的一个拷贝, 如果没有指定表 table 那么就是 *print-pprint-dispatch* 的值[value]的拷贝, 如果指定了 nil 那么就是 *print-pprint-dispatch* 初始值[value]的拷贝.

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 table 不是一个美观打印分派表[pprint dispatch table]那么应该发出一个 type-error 类型[type]的错误.

* 也见(See Also): None.

* 注意(Notes): None. 


### <span id="M-FORMATTER">宏 FORMATTER</span>

* 语法(Syntax):

        formatter control-string => function

* 参数和值(Arguments and Values):

        control-string---一个格式化字符串[format string]; 不求值.
        function---一个函数[function].

* 描述(Description):

        返回一个行为等价于下面这个的函数[function]:

            #'(lambda (*standard-output* &rest arguments)
                (apply #'format t control-string arguments)
                arguments-tail)

        如果在 control-string 中有更多格式化指令, 其中 arguments-tail 是参数 arguments 的末尾, 它将下一个要被处理的参数作为它的 car, 如果最近处理的参数后没有更多 arguments 那么就是 nil.

* 示例(Examples):

    ```LISP
    (funcall (formatter "~&~A~A") *standard-output* 'a 'b 'c)
    >>  AB
    =>  (C)

    (format t (formatter "~&~A~A") 'a 'b 'c)
    >>  AB
    =>  NIL
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果这个参数不是一个有效的格式化字符串[format string], 那么可能会发出一个错误(在宏展开时或运行时).

* 也见(See Also):

        format

* 注意(Notes): None. 


### <span id="F-PPRINT-DISPATCH">函数 PPRINT-DISPATCH</span>

* 语法(Syntax):

        pprint-dispatch object &optional table => function, found-p

* 参数和值(Arguments and Values):

        object---一个对象[object].
        table---一个美观打印分派表[pprint dispatch table], 或者 nil. 默认是 *print-pprint-dispatch* 的值[value].
        function---一个函数标识符[function designator].
        found-p---一个广义 boolean [generalized boolean].

* 描述(Description):

        在表 table 中检索和 object 匹配的类型指定符[type specifier]相关联的最高优先级函数. 通过在表 table 中查找所有和对象 object 匹配的类型指定符[type specifier]并且挑选和这些类型指定符[type specifier]中的任意一个关联的最高优先级函数来选择这个函数. 如果这里有超过一个最高优先级函数, 会执行任意的选择. 如果没有匹配 object 的类型指定符[type specifier], 会返回一个使用 print-object 来打印对象 object 的函数.

        第二个值[secondary value], found-p, 如果在表 table 中找到匹配的类型指定符[type specifier]那么就是 true, 否则就是 false.

        如果 table 是 nil, 检索在初始美观打印分派表[initial pprint dispatch table]上进行.

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        这个表 table 的状态.

* 异常情况(Exceptional Situations):

        如果 table 既不是美观打印分派表[pprint dispatch table]也不是 nil 那么就会发出一个 type-error 类型[type]的错误.

* 也见(See Also): None.

* 注意(Notes):

        (let ((*print-pretty* t))
          (write object :stream s))
        ==  (funcall (pprint-dispatch object) s object)


### <span id="LM-PPRINT-EXIT-IF-LIST-EXHAUSTED">局部宏 PPRINT-EXIT-IF-LIST-EXHAUSTED</span>

* 语法(Syntax):

        pprint-exit-if-list-exhausted <no arguments> => nil

* 参数和值(Arguments and Values): None.

* 描述(Description):

        检验传递给词法上当前逻辑块(lexically current logical block)的列表是否已经被耗尽; 见章节 22.2.1.1 (输出排列的动态控制). 如果这个列表已经被归约为 nil, pprint-exit-if-list-exhausted 终止这个词法上当前逻辑块(lexically current logical block)的执行, 除了这个后缀的打印. 否则 pprint-exit-if-list-exhausted 返回 nil.

        pprint-exit-if-list-exhausted 在全局环境[global environment]中是否为 fbound 的是依赖于具体实现的[implementation-dependent]; 然而, 在这个 pprint-exit-if-list-exhausted 上的重定义和遮蔽的限制和那些在 COMMON-LISP 包中在全局环境[global environment]中是 fbound 的符号[symbol]是一样的. 尝试在 pprint-logical-block 外部去使用 pprint-exit-if-list-exhausted 的后果是未定义的.

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果在一个不是词法上处于 pprint-logical-block 调用中的任何地方使用 pprint-exit-if-list-exhausted 就会发出一个错误 (在宏展开时或运行时). 同样, 在 pprint-logical-block 的动态范围之外但是词法上包含时执行 pprint-if-list-exhausted 的后果是未定义的.

* 也见(See Also):

        pprint-logical-block, pprint-pop.

* 注意(Notes): None. 


### <span id="F-PPRINT-FILL-LINEAR-TABULAR">函数 PPRINT-FILL, PPRINT-LINEAR, PPRINT-TABULAR</span>

* 语法(Syntax):

        pprint-fill stream object &optional colon-p at-sign-p => nil

        pprint-linear stream object &optional colon-p at-sign-p => nil

        pprint-tabular stream object &optional colon-p at-sign-p tabsize => nil

* 参数和值(Arguments and Values):

        stream---一个输出[output]流标识符[stream designator].
        object---一个对象[object].
        colon-p---一个广义 boolean [generalized boolean]. 默认是 true.
        at-sign-p---一个广义 boolean [generalized boolean]. 默认是依赖于具体实现的[implementation-dependent].
        tabsize---一个非负整数[integer]. 默认是 16.

* 描述(Description):

        函数 pprint-fill, pprint-linear, 和 pprint-tabular 指定美观打印一个列表[list]到流 stream 的特定方式. 当且仅当 colon-p 为 true 时, 每个函数在输出周围打印括号. 每个函数忽略它的 at-sign-p 参数. (这两个参数都包含在内, 即使只需要一个参数, 以便这些功能可以通过 ~/.../ 来使用并作为 set-pprint-dispatch 函数, 也可以直接使用.) 每个函数正确地处理缩写以及循环和共享的检测, 并且当它不是一个列表[non-list]时使用 write 来打印对象 object.

        如果对象 object 是一个列表[list]并且 *print-pretty* 的值[value]是 false, 这些函数中的每一个都用最少的空格[whitespace]来打印对象, 就像章节 22.1.3.5 (打印列表和构造(cons)) 中描述的. 否则 (如果对象 object 是一个列表[list]并且 *print-pretty* 的值[value]是 true):

            函数[function] pprint-linear 把一个列表[list]的所有元素打印在一行中, 或者每个元素[element]在一个分隔的行上.

            函数[function] pprint-fill 把一个列表[list]尽可能多的元素[element]打印到一行上.

            函数[function] pprint-tabular 和 pprint-fill 一样除了它打印的这些元素[element]按列对齐. 这个 tabsize 以 em 单位指定了列间隔, 也就是从一列的前缘到下一列的前缘的总间距.

* 示例(Examples):

        在行长为 25 的情况下求值下面这个产生的输出如下.

    ```LISP
    (progn (princ "Roads ") 
          (pprint-tabular *standard-output* '(elm main maple center) nil nil 8))
    Roads ELM     MAIN
          MAPLE   CENTER
    ```

* 副作用(Side Effects):

        执行输出到指定的流[stream].

* 受此影响(Affected By):

        指定的流[stream]上的游标位置, 如果它可以被确定的话.

* 异常情况(Exceptional Situations): None.

* 也见(See Also): None.

* 注意(Notes):

        函数[function] pprint-tabular 可以按如下定义:

    ``LISP
    (defun pprint-tabular (s list &optional (colon-p t) at-sign-p (tabsize nil))
      (declare (ignore at-sign-p))
      (when (null tabsize) (setq tabsize 16))
      (pprint-logical-block (s list :prefix (if colon-p "(" "")
                                    :suffix (if colon-p ")" ""))
        (pprint-exit-if-list-exhausted)
        (loop (write (pprint-pop) :stream s)
              (pprint-exit-if-list-exhausted)
              (write-char #\Space s)
              (pprint-tab :section-relative 0 tabsize s)
              (pprint-newline :fill s))))
    ```

        请注意, 使用 format 指定这个函数会很不方便, 因为需要将 tabsize 参数传递给一个嵌套在列表迭代中的 ~:T 格式指令. 


### <span id="F-PPRINT-INDENT">函数 PPRINT-INDENT</span>

* 语法(Syntax):

        pprint-indent relative-to n &optional stream => nil

* 参数和值(Arguments and Values):

        relative-to---:block 或 :current.
        n---一个实数[real].
        stream---一个输出[output]流标识符[stream designator]. 默认是标准输出[standard output].

* 描述(Description):

        pprint-indent 指定要在流[stream]上的逻辑块中使用的缩进. 如果流 stream 是一个美观打印流[pretty printing stream]并且 *print-pretty* 的值[value]为 true, pprint-indent 设置最内部的动态闭合逻辑块中的缩进; 否则, pprint-indent 没有效果.

        n 用 em 单位指定了缩进. 如果 relative-to 是 :block, 这个缩进会被设置为在这个动态当前逻辑块中第一个字符的水平位置加上 n 个 em 单位. 如果 relative-to 是 :current, 这个缩进被设置为当前输出位置加上 n 个 em 单位. (为了面对可变宽度字体时的健壮性, 可能的情况下建议使用 :current 以及零作为 n.)

        n 可以是负的; 然而, 总的缩进不能移动到这行开始的左边或者最右边的每行前缀的末尾的左边---超越这些限制的尝试被视为试图达到该限制. 由 pprint-indent 导致的缩进的改变不会生效, 直到下一个换行符之后. 另外, 在最小执行常式模式中所有对 pprint-indent 的调用都被忽略, 从而迫使与逻辑块对应的行对齐到块中的第一个字符之下.

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 relative-to 是 :block 或 :current 以外的任何对象[object], 就会发出一个错误.

* 也见(See Also):

        章节 22.3.5.3 (波浪符号 I: 缩进)

* 注意(Notes): None. 


### <span id="M-PPRINT-LOGICAL-BLOCK">宏 PPRINT-LOGICAL-BLOCK</span>

* 语法(Syntax):

        pprint-logical-block (stream-symbol object &key prefix per-line-prefix suffix) declaration* form*
        => nil

* 参数和值(Arguments and Values):

        stream-symbol---一个流变量标识符[stream variable designator].
        object---一个对象[object]; 求值的.
        :prefix---一个字符串[string]; 求值的. 复杂的默认行为; 见下方.
        :per-line-prefix---一个字符串[string]; 求值的. 复杂的默认行为; 见下方.
        :suffix---一个字符串[string]; 求值的. 默认是空[null]字符串[string].
        declaration---一个 declare 表达式[expression]; 不求值的.
        forms---一个隐式 progn [implicit progn];

* 描述(Description):

        使打印被分组到一个逻辑块中.

        这个逻辑块被打印到一个流[stream], 它是由 stream-symbol 表示的变量[variable]的值[value]. 在这些表达式形式[form]的执行期间, 那个变量[variable]被绑定[bound]为一个美观打印流[pretty printing stream], 它支持关于输出排列的决策, 然后将输出转发到目标流. 所有标准打印函数 (例如, write, princ, 和 terpri) 都可以被用于打印输出到这个美观打印流[pretty printing stream]. 所有且只有输出到这个美观打印流[pretty printing stream]的输出被视为在逻辑块中.

        这个前缀 prefix 指定了在这个逻辑块开始前要被打印的前缀. 这个行前缀 per-line-prefix 指定了在这个逻辑块以及逻辑块中的每一个新行开始之前要打印的前缀. 这个 :prefix 和 :pre-line-prefix 参数[argument]是互斥的. 如果 :prefix 和 :per-line-prefix 都没有指定, 会采取一个空[null]字符串[string]前缀.

        这个后缀 suffix 指定了在这个逻辑块后面打印的后缀.

        这个 object 通常是一个主体表达式形式 forms 负责打印的列表[list]. 如果 object 不是一个列表[list], 它使用 write 打印. (这使得编写在面对格式不正确的参数时仍然健壮的打印函数变得更加容易). 如果 *print-circle* 是非 nil [non-nil]并且 object 是对一个 cons 的环状 (或者共享的) 引用, 那么就会打印一个适当的 "#n#" 标记. (这使得编写完全支持环状和共享缩写的打印函数变得很容易.) 如果 *print-level* 不是 nil 并且这个逻辑块在这些逻辑块中大于 *print-level* 的动态嵌套深度中, "#" 会被打印. (这使得编写支持深度缩写的打印函数变得很容易.)

        如果以上三个情况的任意一个发生了, 指定的输出打印在 stream-symbol 上并且在打印 :prefix 和 :suffix 时, 跳过主体表达式形式 forms. (如果主体表达式形式 forms 不负责打印一个列表, 那么上述前两个检验可以通过为 object 参数提供 nil 来关闭.)

        除了 pprint-logical-block 的 object 参数之外, 标准打印函数的参数 (例如 write, print, prin1, 和 pprint, 例如 ~A, ~S, 和 ~W 这样的标准格式化指令[format directive]的参数也一样) 都会检测环状和共享 (当有必要的时候). 然而, 这样的检测不会应用到函数 write-line, write-string, 和 write-char 的参数上, 也不会应用到由 format 输出的字面文本上. 这样做的结果是, 如果您想要在输出中打印一些字面文本, 而这些文本不支持环状或共享检测, 那么您必须使用后者的一个函数.

       一个 pprint-logical-block 表达式形式[form]的主体表达式形式 forms 一定不能对周围环境产生副作用; 比如, 没有在它的作用域中被绑定[bound]的变量[variable]不能被赋值.

        不管 *print-pretty* 的值[value]是什么, 这个 pprint-logical-block 宏[macro]都可能被使用.

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        *print-circle*, *print-level*.

* 异常情况(Exceptional Situations):

        如果提供的 :suffix, :prefix, 或 :per-line-prefix 的任何一个但是没有被求值为一个字符串[string], 那么就会发出一个 type-error 类型[type]的错误.

        如果 :prefix 和 :pre-line-prefix 都使用了就会发出一个错误.

        pprint-logical-block 和它创建的美观打印流[pretty printing stream]有着动态范围[dynamic extent]. 如果在这个作用域之外尝试去输出到它创建的这个美观打印流[pretty printing stream], 那么后果是未定义的.

        如果在这个范围内直接发送任何输出到底层的目标流, 会发生什么也是不确定的.

* 也见(See Also):

        pprint-pop, pprint-exit-if-list-exhausted, 章节 22.3.5.2 (波浪符号 小于号: 逻辑块)

* 注意(Notes):

        当 *print-pretty* 的值[value]为 nil 时使用 pprint-logical-block 宏[macro]的一个原因是允许它对点列表[dotted list]执行检查, (和 pprint-pop 配合) 检查 *print-level* 或 *print-length* 溢出也一样.

        美观打印器[pretty printer]支持环状和共享的检测, 本质上是执行两次请求的输出. 第一次通过时, 循环和共享被检测而实际输出的字符串被抑制. 在第二次通过时, 适当的 "#n=" 和 "#n#" 标记会被插入并且字符会被输出. 就就是为什么副作用上的约束是必要的. 当遍历一个要被 pprint-logical-block 表达式形式[form]的主体表达式形式 forms 打印的列表时, 使用 pprint-pop 来实现这一限制, 而不是普通的 pop.


### <span id="F-PPRINT-NEWLINE">函数 PPRINT-NEWLINE</span>

* 语法(Syntax):

        pprint-newline kind &optional stream => nil

* 参数和值(Arguments and Values):

        kind---:linear, :fill, :miser, 或 :mandatory 的其中之一.
        stream---一个流标识符[stream designator]. 默认是标准输出[standard output].

* 描述(Description):

        如果流 stream 是一个美观打印流[pretty printing stream]并且 *print-pretty* 的值[value]是 true, 当满足以下适当条件时, 一个换行符会被插入到输出中; 否则, pprint-newline 没有效果.

        kind 指定了条件换行的样式. 这个参数[parameter]按如下对待:

        :linear

            这个指定了一个 "线性风格(linear-style)" 条件换行[conditional newline]. 当且仅当这个直接包含的片段[section]不能被打印在一行中时会插入一个换行符. 这个的效果是换行符被插入到一个逻辑块的每一个线性风格的条件换行中或者一个也不插入.

        :miser

            这个指定了一个 "最小执行常式风格(miser-style)" 条件换行[conditional newline]. 当且仅当这个直接包含的片段[section]不能被打印在一行中并且在这个直接包含的逻辑块中这个风格生效时会插入一个换行符. 这个效果是 miser-style 条件换行表现得像线性风格条件换行一样, 但是只有当这个风格生效的情况下. 当且仅当一个逻辑块的起始位置距离右边距小于或等于 *print-miser-width* 个 em 单位时, 这个逻辑块的最小执行常式风格是生效的.

        :fill

            这个指定一个 "填充风格(fill-style)" 条件换行[conditional newline]. 当且仅当以下情况满足任意一条时, 会插入一个断行: (a) 后面的片段[section]不能被打印在当前行的结尾, (b) 前面的片段[section]没有被打印在单独的一行, 或 (c) 直接包含的片段[section]不能被打印在一行上并且最小执行常式风格在这个直接包含的逻辑块中是生效的. 如果一个逻辑块被填充风格的条件换行分解成一些子片段, 其基本效果是在每一行上以尽可能多的子片段打印逻辑块. 但是, 如果最小执行常式风格是生效的, fill-style 条件换行表现得像线性风格条件换行一样.

        :mandatory

            这个指定一个 "强制风格(mandatory-style)" 条件换行[conditional newline]. 一个断行总是会被插入. 这个意味着这些包含的片段[section]中没有一个可以被打印在单独的一行并且因此会触发在这些片段[section]中的线性风格条件换行中的换行符的插入.

        当一个换行符通过任何类型的条件换行被插入时, 任何直接位于条件换行之前的空白会从这个输出中被省略并且在下一行的开始引入缩进. 默认情况下, 这个缩进导致下面这行从和直接包含的逻辑块的第一个字符相同的水平位置开始. (缩进可以通过 pprint-indent 来改变.)

        这里有一些把非条件换行引入到输出的方法 (换句话说, 通过 terpri 或通过打印一个包含一个换行字符的字符串). 与强制条件换行一样, 这可以防止任何包含[section]的片段被打印在一行上. 通常情况下, 当遇到一个非条件换行时, 它是在没有抑制前面的空格并且后面没有跟着任何缩进的情况下打印出来. 然而, 如果指定一个行前缀 (见 pprint-logical-block), 这个前缀总是被打印, 不管一个新行是如何开始的.

* 示例(Examples):

        见章节 22.2.2 (使用美观打印器的示例).

* 副作用(Side Effects):

        输出到流 stream.

* 受此影响(Affected By):

        *print-pretty*, *print-miser*. 包含的逻辑块的出现. 换行符和条件换行符的位置.

* 异常情况(Exceptional Situations):

        如果 kind 表示 :linear, :fill, :miser, 或 :mandatory 的其中之一, 就会发出一个 type-error 类型[type]的错误.

* 也见(See Also):

        章节 22.3.5.1 (波浪符号 下划线: 条件换行), 章节 22.2.2 (使用美观打印器的示例)

* 注意(Notes): None. 


### <span id="LM-PPRINT-POP">局部宏 PPRINT-POP</span>

* 语法(Syntax):

        pprint-pop <no arguments> => object

* 参数和值(Arguments and Values):

        object---在词法上的当前逻辑块中要被打印的列表[list]的一个元素[element], 或者 nil.

* 描述(Description):

        从在词法上的当前逻辑块中要被打印的列表[list]中弹出一个元素[element], 遵循如下所述的 *print-length* 和 *print-circle*.

        每次 pprint-pop 被调用, 它把传递给词法上的当前逻辑块的列表[list]的下一个值弹出并返回. 但是, 在做这个之前, 它执行三个检验:

            如果剩余的 'list' 不是一个列表[list], ". " 被打印并后面跟着剩余的 'list'. (这个使得编写一个面对难看的参数是强健的打印函数变得更容易.)

            如果 *print-length* 非 nil [non-nil], 并且 pprint-pop 在直接包含的逻辑块中已经被调用 *print-length* 次, 则打印 "...". (这使得编写一个适当处理 *print-length* 的函数变得容易.)

            如果 *print-circle* 非 nil [non-nil], 并且剩余列表是一个环状 (或者共享) 引用, 那么打印 ". " 并在后面跟着一个适当的 "#n#" 标记. (这个捕捉列表中环状和共享的 cdr 实例.)

        如果发生了上面的三个状况中的任意一个, 那么表示的输出会被打印在由直接包含的 pprint-logical-block 创建的美观打印流[pretty printing stream]上并且直接包含的 pprint-logical-block 会终止, 除了后缀的打印.

        如果给 pprint-logical-block 一个 nil 的 'list' 参数---因为它没有处理一个列表---pprint-pop 仍然可以被用来获取对 *print-length* 的支持. 在这个情况中, 上面的第一个和第三个测试会被禁用并且 pprint-pop 总是返回 nil. 见章节 22.2.2 (使用美观打印器的示例)---具体来说, 那个 pprint-vector 示例.

        pprint-pop 在全局环境[global environment]中是否是 fbound 的是依赖于具体实现的[implementation-dependent]; 但是, 在 pprint-pop 的重定义和遮蔽上的约束和 COMMON-LISP 包中在全局环境[global environment]中被 fbound 的符号[symbol]相同. 在 pprint-logical-block 外部尝试去使用 pprint-pop 的后果是 未定义的.

* 示例(Examples): None.

* 副作用(Side Effects):

        可能导致输出到和当前词法逻辑块相关联的美观打印流[pretty printing stream].

* 受此影响(Affected By):

        *print-length*, *print-circle*.

* 异常情况(Exceptional Situations):

        如果一个 pprint-pop 的使用没有出现在词法上包含在 pprint-logical-block 表达式形式[form]的地方, 那么就会发出一个错误 (不管是宏展开时或是运行时).

        如果 pprint-pop 在这个 pprint-logical-block 的动态范围[dynamic extent]外被执行, 那么后果是未定义的.

* 也见(See Also):

        pprint-exit-if-list-exhausted, pprint-logical-block.

* 注意(Notes):

        在调用 pprint-pop 之前调用 pprint-exit-if-list-exhausted 通常是一个好办法. 


### <span id="F-PPRINT-TAB">函数 PPRINT-TAB</span>

* 语法(Syntax):

        pprint-tab kind colnum colinc &optional stream => nil

* 参数和值(Arguments and Values):

        kind--- :line, :section, :line-relative, 或 :section-relative 其中之一.
        colnum---一个非负整数[integer].
        colinc---一个非负整数[integer].
        stream---一个输出[output]流标识符[stream designator].

* 描述(Description):

        就像是通过标准 ~T 格式化指令执行的一样对流 stream 指定制表. 如果流 stream 是一个美观打印流[pretty printing stream]并且 *print-pretty* 的值[value]是 true, 那么就会执行制表; 否则, pprint-tab 没有效果.

        参数 colnum 和 colinc 对应于给 ~T 的两个参数并且按照 em 单位. 这个 kind 参数指定了制表的样式. 它必须是 :line (就如 ~T 一样制表), :section (就如 ~:T 一样制表, 但是相对于这个动态闭合部分的开始处来水平测量), :line-relative (就如 ~@T 一样制表), 或 :section-relative (就如 ~:@T 一样制表, 但是相对于这个动态闭合部分的开始处来水平测量) 其中之一.

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 kind 不是 :line, :section, :line-relative, 或 :section-relative 其中之一, 那么就会发出一个错误.

* 也见(See Also):

        pprint-logical-block

* 注意(Notes): None. 


### <span id="SGF-PRINT-OBJECT">标准广义函数 PRINT-OBJECT</span>

* 语法(Syntax):

        print-object object stream => object

* 方法签名(Method Signatures):

        print-object (object standard-object) stream

        print-object (object structure-object) stream

* 参数和值(Arguments and Values):

        object---一个对象[object].
        stream---一个流[string].

* 描述(Description):

        广义函数[generic function] print-object 把对象 object 的打印表示写入到流 stream. 函数[function] print-object 是通过 Lisp 打印器[Lisp reader]调用的; 它不应该被用户调用.

        每个具体实现都需要在类[class] standard-object 和类[class] structure-object 上提供一个方法[method]. 另外, 每一个实现[implementation]必须在足够的其他类[class]上提供方法[method]来确保这里总是有一个可应用的方法[method]. 具体实现[implementation]可以自由地去给其他类[class]添加方法[method]. 用户如果不希望去继承一个依赖于具体实现[implementation-dependent]的方法[method], 可以为它们自己的类[class]编写 print-object 方法[method].

        类[class] structure-object 上的方法[method]以默认的 #S 表示打印这个对象; 见章节 22.1.3.12 (打印结构体).

        print-object 上的方法[method]有责任去实现它们的这些打印器控制变量[printer control variable]的语义部分, 如下:

        *print-readably*

            所有 print-object 的方法[method]必须遵循 *print-readably*. 这个包括用户定义的方法和具体实现定义的[implementation-defined]方法. 结构体[structure]和标准对象[standard object]的可读打印由它们的 print-object 方法控制, 不是由它们的 make-load-form 方法. 这些对象[object]的相似性[similarity]是依赖于应用的, 因此它被定义为这些方法所做的任何事情; 见章节 3.2.4.2 (字面化对象的相似性).

        *print-escape*

            每个方法[method]必须实现 *print-escape*.

        *print-pretty*

            这个方法可能希望基于 *print-pretty* 的值来执行某个特殊的断行或其他输出条件句. 关于进一步的信息, 见 (例如) 宏[macro] pprint-fill. 也见章节 22.2.1.4 (美观打印分派表) 和章节 22.2.2 (使用美观打印器的示例).

        *print-length*

            产生无限长度输出的方法[method]必须遵循 *print-length*. 关于进一步的信息, 见 (例如) 宏 pprint-logical-block 和 pprint-pop. 也见章节 22.2.1.4 (美观打印分派表) 和章节 22.2.2 (使用美观打印器的示例).

        *print-level*

            打印器自动关注 *print-level*, 假设每个方法[method]处理结构体的一个层级而如果这里有更多的结构体层级就递归调用 write (或者一个等价的函数[function]). 打印器对于一个对象[object]是否有着成员的决策是依赖于具体实现的[implementation-dependent] (并且因此当打印深度不小于 *print-level* 时不应该被打印). 在某些实现中它的 print-object 方法[method]不会被调用; 在其他实现中这个方法[method]会被调用, 并且这个对象[object]有着成员的决策是基于它尝试把什么写入到这个流 stream 中.

        *print-circle*

            当 *print-circle* 的值[value]是 true 时, 一个用户定义的 print-object 方法[method]可以使用 write, prin1, princ, 或 format 打印对象[object]到提供的流[stream], 并且期望环状会被检测到并使用 #n# 语法打印. 如果一个用户定义的 print-object 方法[method]打印到提供的流 stream 之外的流[stream], 那么对于这个流[stream]的环状检测重新开始. 见 *print-circle*.

        *print-base*, *print-radix*, *print-case*, *print-gensym*, and *print-array*

            这些打印器控制变量[printer control variable]应用于特定类型的对象[object]并且由这些对象[object]的方法[method]来处理.

        如果这些规则没有被遵守, 结果就是没有定义的.

        通常情况下, 打印器和 print-object 方法不应该随着它们在结构中递归操作重新绑定这些打印器控制变量, 但是这个是依赖于具体实现的[implementation-dependent].

        在某些实现中传递给一个 print-object 方法[method]的这个 stream 参数不是原始的流[stream], 而是一个实现了这个打印器部分的中间流[method]. 因此方法[method]不应该依赖于这个流[stream]的标识.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 也见(See Also):

        pprint-fill, pprint-logical-block, pprint-pop, write, *print-readably*, *print-escape*, *print-pretty*, *print-length*, 章节 22.1.3 (默认 Print-Object 方法), 章节 22.1.3.12 (打印结构体), 章节 22.2.1.4 (美观打印分派表), 章节 22.2.2 (使用美观打印器的示例)

* 注意(Notes): None. 


### <span id="M-PRINT-UNREADABLE-OBJECT">宏 PRINT-UNREADABLE-OBJECT</span>

* 语法(Syntax):

        print-unreadable-object (object stream &key type identity) form* => nil

* 参数和值(Arguments and Values):

        object---一个对象[object]; 求值的.
        stream---一个流标识符[stream designator]; 求值的.
        type---一个广义 boolean [generalized boolean]; 求值的.
        identity---一个广义 boolean [generalized boolean]; 求值的.
        forms---一个隐式 progn [implicit progn];

* 描述(Description):

        在流 stream 上输出对象 object 的打印表示, 用 "#<" 开始并且用 ">" 结束. 通过主体表达式形式 forms 输出到流 stream 的所有东西被闭合在一个尖括号中. 如果 type 是 true, 来自表达式形式 forms 的输出前有着这个对象 object 类型[type]的简要描述和一个空白字符. 如果 identity 是 true, 那么这个来自表达式形式 forms 的输出后跟着一个空白字符和一个和这个对象标识的表示, 通常是一个存储地址.

        如果 type 或 identity 没有被提供, 它的值就是 false. 省略主体表达式形式 forms 是有效的. 如果 type 和 identity 都是 true 并且这里没有主体表达式形式 forms, 只有一个空白字符来分隔着类型和身份.

* 示例(Examples):

    ```LISP
    ;; Note that in this example, the precise form of the output ;; is implementation-dependent.

    (defmethod print-object ((obj airplane) stream)
      (print-unreadable-object (obj stream :type t :identity t)
        (princ (tail-number obj) stream)))

    (prin1-to-string my-airplane)
    =>  "#<Airplane NW0773 36000123135>"
    OR=>  "#<FAA:AIRPLANE NW0773 17>"
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 *print-readably* 是 true, print-unreadable-object 在不打印任何东西的情况下发出一个 print-not-readable 类型[type]的错误.

* 也见(See Also): None.

* 注意(Notes): None. 


### <span id="F-SET-PPRINT-DISPATCH">函数 SET-PPRINT-DISPATCH</span>

* 语法(Syntax):

        set-pprint-dispatch type-specifier function &optional priority table => nil

* 参数和值(Arguments and Values):

        type-specifier---一个类型指定符[type specifier].
        function---一个函数[function], 一个函数名[function name], 或 nil.
        priority---一个实数[real]. 默认是 0.
        table---一个美观打印分派表[pprint dispatch table]. 默认是 *print-pprint-dispatch* 的值[value].

* 描述(Description):

        安装一个条目到美观打印分派表[pprint dispatch table] table.

        type-specifier 是这个条目的键[key]. set-pprint-dispatch 的第一个动作是移除之前存在的和 type-specifier 任何关联条目. 这个保证在一个美观打印分派表[pprint dispatch table]中不会存在和同一个类型指定符[type specifier]关联的两个条目. 类型指定符[type specifier]的等价性由 equal 确定.

        在一个美观打印分派表[pprint dispatch table]中每一个类型指定符[type specifier]和两个值关联: 一个函数 function 和一个优先级 priority. 这个函数 function 必须接受两个参数: 要输出到的流[stream]以及要被打印的对象[object]. 那个函数 function 应该把对象[object]美观打印[pretty print]到那个流 stream. 这个函数 function 可以假定那个对象 object 满足由 type-specifier 给定的类型[type]. 函数 function 必须遵循 *print-readably*. 任何由那个函数 function 返回的值会被忽略.

        当一个对象匹配不止一个条目时, 优先级 priority 是用于解决冲突的优先级.

        允许函数 function 为 nil. 在这个情况中, 在 set-pprint-dispatch 返回后表 table 中将没有 type-specifier 条目.

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 priority 不是一个实数[real], 就会发出一个错误.

* 也见(See Also): None.

* 注意(Notes):

        因为美观打印分派表[pprint dispatch table]经常被用于控制 Lisp 代码的美观打印, type-specifier 通常为下面这个形式的一个表达式[expression]

    ```LISP
    (cons car-type cdr-type)
    ```

        这个表示这个对应对象必须是一个 cons 存储格, 它的 car 匹配类型指定符[type specifier] car-type 以及它的 cdr 匹配类型指定符[type specifier] cdr-type. 这个 cdr-type 可以被省略, 这个情况下它默认为 t. 


### <span id="F-WRITE-PRIN1-PRINT-PPRINT-PRINC">函数 WRITE, PRIN1, PRINT, PPRINT, PRINC</span>

* 语法(Syntax):

        write object &key array base case circle escape gensym length level lines miser-width pprint-dispatch pretty radix readably right-margin stream
        => object

        prin1 object &optional output-stream => object

        princ object &optional output-stream => object

        print object &optional output-stream => object

        pprint object &optional output-stream => <no values>

* 参数和值(Arguments and Values):

        object---一个对象[object].
        output-stream---一个输出[output]流标识符[stream designator]. 默认是标准输出[standard output].
        array---一个广义 boolean [generalized boolean].
        base---一个基数[radix].
        case---一个 (member :upcase :downcase :capitalize) 类型[type]的符号[symbol].
        circle---一个广义 boolean [generalized boolean].
        escape---一个广义 boolean [generalized boolean].
        gensym---一个广义 boolean [generalized boolean].
        length---一个非负整数[integer], 或 nil.
        level---一个非负整数[integer], 或 nil.
        lines---一个非负整数[integer], 或 nil.
        miser-width---一个非负整数[integer], 或 nil.
        pprint-dispatch---一个美观打印分派表[pprint dispatch table].
        pretty---一个广义 boolean [generalized boolean].
        radix---一个广义 boolean [generalized boolean].
        readably---一个广义 boolean [generalized boolean].
        right-margin---一个非负整数[integer], 或 nil.
        stream---一个输出[output]流标识符[stream designator]. 默认是标准输出[standard output].

* 描述(Description):

        write, prin1, princ, print, 和 pprint 把对象 object 的打印表示写入到输出流 output-stream 中.

        write 是到 Lisp 打印器[Lisp printer]的一般入口点. 对于显式提供的下一段中命名的每个关键字参数[keyword parameter], 对应的打印器控制变量[printer control variable]在打印进行时会被动态地绑定为它的值[value]; 对于下一段中没有显式提供的每个关键字参数[keyword parameter], 对应打印器控制变量[printer control variable]的值和 write 被调用时一样. 一旦建立合适的绑定[binding], 这个对象[object]会被 Lisp 打印器[Lisp printer]输出.

            参数              对应的动态变量  
            array            *print-array*                   
            base             *print-base*                    
            case             *print-case*                    
            circle           *print-circle*                  
            escape           *print-escape*                  
            gensym           *print-gensym*                  
            length           *print-length*                  
            level            *print-level*                   
            lines            *print-lines*                   
            miser-width      *print-miser-width*             
            pprint-dispatch  *print-pprint-dispatch*         
            pretty           *print-pretty*                  
            radix            *print-radix*                   
            readably         *print-readably*                
            right-margin     *print-right-margin*            

            Figure 22-7. 对于 WRITE 函数的参数对应关系.

        prin1, princ, print, 和 pprint 隐式绑定[bind]某些打印参数为特定的值. 这些剩余参数值取自 *print-array*, *print-base*, *print-case*, *print-circle*, *print-escape*, *print-gensym*, *print-length*, *print-level*, *print-lines*, *print-miser-width*, *print-pprint-dispatch*, *print-pretty*, *print-radix*, 和 *print-right-margin*.

        prin1 产生适合于 read 的输入的输出. 它绑定 *print-escape* 为 true.

        princ 就像是 prin1, 除了输出没有转义[escape]字符[character]. 它绑定 *print-escape* 为 false 并且绑定 *print-readably* 为 false. 普遍规则是, 来自 princ 的输出意图在于让人更好地查看, 而来自 prin1 的输出意图在于对于 read 是可接受的.

        print 就像是 prin1, 除了对象 object 的打印表示前面有一个换行并且后面有空格.

        pprint 就像是 print 除了省略尾部的空格并且对象 object 使用非 nil [non-nil]的 *print-pretty* 标志来打印, 进而产生美观的输出.

        output-stream 指定输出要被发送到的流[stream].

* 受此影响(Affected By):

        *standard-output*, *terminal-io*, *print-escape*, *print-radix*, *print-base*, *print-circle*, *print-pretty*, *print-level*, *print-length*, *print-case*, *print-gensym*, *print-array*, *read-default-float-format*.

* 异常情况(Exceptional Situations): None.

* 也见(See Also):

        readtable-case, 章节 22.3.4 (FORMAT 打印器操作)

* 注意(Notes):

        函数[function] prin1 和 print 不会绑定 *print-readably*.

        (prin1 object output-stream)
        ==  (write object :stream output-stream :escape t)

        (princ object output-stream)
        ==  (write object stream output-stream :escape nil :readably nil)

        (print object output-stream)
        ==  (progn (terpri output-stream)
                  (write object :stream output-stream
                                :escape t)
                  (write-char #\space output-stream))

        (pprint object output-stream)
        ==  (write object :stream output-stream :escape t :pretty t)


### <span id="F-WRITE-PRIN1-PRINC-TO-STRING">函数 WRITE-TO-STRING, PRIN1-TO-STRING, PRINC-TO-STRING</span>

* 语法(Syntax):

        write-to-string object &key array base case circle escape gensym length level lines miser-width pprint-dispatch pretty radix readably right-margin
        => string

        prin1-to-string object => string

        princ-to-string object => string

* 参数和值(Arguments and Values):

        object---一个对象[object].
        array---一个广义 boolean [generalized boolean].
        base---一个基数[radix].
        case---一个类型[type] (member :upcase :downcase :capitalize) 的符号[symbol].
        circle---一个广义 boolean [generalized boolean].
        escape---一个广义 boolean [generalized boolean].
        gensym---一个广义 boolean [generalized boolean].
        length---一个非负整数[integer], 或 nil.
        level---一个非负整数[integer], 或 nil.
        lines---一个非负整数[integer], 或 nil.
        miser-width---一个非负整数[integer], 或 nil.
        pprint-dispatch---一个美观打印分派表[pprint dispatch table].
        pretty---一个广义 boolean [generalized boolean].
        radix---一个广义 boolean [generalized boolean].
        readably---一个广义 boolean [generalized boolean].
        right-margin---一个非负整数[integer], 或 nil.
        string---一个字符串[string].

* 描述(Description):

        write-to-string, prin1-to-string, 和 princ-to-string 被用于创建一个由对象 object 的打印表示组成的字符串[string]. 对象 object 被有效地打印, 就像分别是通过 write, prin1, 或 princ 打印一样, 并且输出的字符[character]构成一个字符串[string].

        write-to-string 是一个一般的输出函数. 它能够指定所有适用于打印对象 object 的参数.

        prin1-to-string 表现地就像是 :escape 为 t 时的 write-to-string, 这也就是说, 转义[escape]字符[character]会写入到合适的地方.

        princ-to-string 表现地就像是 :escape 为 nil 并且 :readably 为 nil 时的 write-to-string. 因此没有转义[escape]字符[character]会被写入.

        当 prin1-to-string 或 princ-to-string 被调用时, 所有会被指定给 write-to-string 的其他关键字都是默认值.

        给 write-to-string 的关键字参数的意义和默认值与 write 的相同.

* 示例(Examples):

    ```LISP
    (prin1-to-string "abc") =>  "\"abc\""
    (princ-to-string "abc") =>  "abc"
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        *print-escape*, *print-radix*, *print-base*, *print-circle*, *print-pretty*, *print-level*, *print-length*, *print-case*, *print-gensym*, *print-array*, *read-default-float-format*.

* 异常情况(Exceptional Situations): None.

* 也见(See Also):

        write

* 注意(Notes):

        (write-to-string object {key argument}*)
        ==  (with-output-to-string (#1=#:string-stream) 
            (write object :stream #1# {key argument}*))

        (princ-to-string object)
        ==  (with-output-to-string (string-stream)
            (princ object string-stream))

        (prin1-to-string object)
        ==  (with-output-to-string (string-stream)
            (prin1 object string-stream))


### <span id="V-PRINT-ARRAY">变量 *PRINT-ARRAY*</span>

* 值类型(Value Type):

        一个广义 boolean [generalized boolean].

* 初始值(Initial Value):

        依赖于具体实现的[implementation-dependent].

* 描述(Description):

        控制数组[array]被打印的格式. 如果它是 false, 除了字符串[string]以外的数组[array]内容不会被打印. 取而代之, 数组[array]以一个使用 #< 的简洁形式来打印, 这个形式为用户提供了足够的信息来辨别这个数组[array], 但是不会包含整个数组[array]内容. 如果它是 true, 非字符串[string]数组[array]使用 #(...), #*, 或 #nA 语法打印.

* 示例(Examples): None.

* 受此影响(Affected By):

        具体实现[implementation].

* 也见(See Also):

        章节 2.4.8.3 (井号左括号(#()), 章节 2.4.8.20 (井号小于号(#<))

* 注意(Notes): None. 


### <span id="V-PRINT-BASE-RADIX">变量 *PRINT-BASE*, *PRINT-RADIX*</span>

* 值类型(Value Type):

        *print-base*---a radix. *print-radix*---一个广义 boolean [generalized boolean].

* 初始值(Initial Value):

        这个 *print-base* 的初始值[value]是 10. 这个 *print-radix* 的初始值[value]是 false.

* 描述(Description):

        *print-base* 和 *print-radix* 控制有理数[rational]的打印. 这个 *print-base* 的值[value]称为当前输出基数[current output base].

        这个 *print-base* 的值[value]是打印器打印有理数[rational]所用的基数[radix]. 对于 10 以上的基数, 字母表中的字母被用于表示 9 以上的数字.

        如果 *print-radix* 的值[value是 true, 那么打印器会打印一个基数指定符来表示它打印有理数[rational]所用的基数[radix]. 这个基数指定符总是用小写字母来打印. 如果 *print-base* 是 2, 8, 或 16, 那么使用的基数指定负分别是 #b, #o, 或 #x. 对于整数[integer], 基数 10 是用一个尾部的小数点来表示而不是一个前导的基数指定符; 对于比率[ratio], 使用 #10r.

* 示例(Examples):

    ```LISP
    (let ((*print-base* 24.) (*print-radix* t))
      (print 23.))
    >>  #24rN
    =>  23
    (setq *print-base* 10) =>  10
    (setq *print-radix* nil) =>  NIL
    (dotimes (i 35)
        (let ((*print-base* (+ i 2)))           ;print the decimal number 40 
          (write 40)                            ;in each base from 2 to 36
          (if (zerop (mod i 10)) (terpri) (format t " "))))
    >>  101000
    >>  1111 220 130 104 55 50 44 40 37 34
    >>  31 2C 2A 28 26 24 22 20 1J 1I
    >>  1H 1G 1F 1E 1D 1C 1B 1A 19 18
    >>  17 16 15 14
    =>  NIL
    (dolist (pb '(2 3 8 10 16))
        (let ((*print-radix* t)                 ;print the integer 10 and
              (*print-base* pb))                ;the ratio 1/10 in bases 2,
        (format t "~&~S  ~S~%" 10 1/10)))        ;3, 8, 10, 16
    >>  #b1010  #b1/1010
    >>  #3r101  #3r1/101
    >>  #o12  #o1/12
    >>  10.  #10r1/10
    >>  #xA  #x1/A
    =>  NIL
    ```

* 受此影响(Affected By):

        可能被 format, 和 write, write-to-string 绑定[bound].

* 也见(See Also):

        format, write, write-to-string

* 注意(Notes): None.


### <span id="V-PRINT-CASE">变量 *PRINT-CASE*</span>

* 值类型(Value Type):

        符号[symbol] :upcase, :downcase, 或 :capitalize 其中之一.

* 初始值(Initial Value):

        符号[symbol] :upcase.

* 描述(Description):

        这个 *print-case* 的值[value]控制当没有使用竖杠语法时符号[symbol]名字中的任何大写字符要被打印的大小写 (大写, 小写, 或混合的).

        当 *print-escape* 的值[value]是 false 时, *print-case* 在所有时间都有效. 当 *print-escape* 的值[value]是 true 时 *print-case* 也有效, 除非在一个转义上下文中 (换句话说, 除非在竖杠[vertical-bar]之间或一个斜杠[slash]之后).

* 示例(Examples):

    ```LISP
    (defun test-print-case ()
      (dolist (*print-case* '(:upcase :downcase :capitalize))
        (format t "~&~S ~S~%" 'this-and-that '|And-something-elSE|)))
    =>  TEST-PC
    ;; Although the choice of which characters to escape is specified by
    ;; *PRINT-CASE*, the choice of how to escape those characters 
    ;; (i.e., whether single escapes or multiple escapes are used)
    ;; is implementation-dependent.  The examples here show two of the
    ;; many valid ways in which escaping might appear.
    (test-print-case) ;Implementation A
    >>  THIS-AND-THAT |And-something-elSE|
    >>  this-and-that a\n\d-\s\o\m\e\t\h\i\n\g-\e\lse
    >>  This-And-That A\n\d-\s\o\m\e\t\h\i\n\g-\e\lse
    =>  NIL
    (test-print-case) ;Implementation B
    >>  THIS-AND-THAT |And-something-elSE|
    >>  this-and-that a|nd-something-el|se
    >>  This-And-That A|nd-something-el|se
    =>  NIL
    ```

* 受此影响(Affected By): None.

* 也见(See Also):

        write

* 注意(Notes):

        read 通常将出现在符号[symbol]中的小写字符转换为大写字符, 这样一来内部打印名字通常只包含大写字符.

        如果 *print-escape* 是 true, 一个符号[symbol]名字[name]中的小写字符总是用小写打印, 并且前面有单转义字符或被多转义字符围绕; 一个符号[symbol]名字[name]中的大写字符可能会用大写, 小写或混合的方式来打印, 以便根据 *print-case* 的值使单词首字母大写. 关于构成一个 "单词(word)" 的规约和 string-capitalize 一样. 


### <span id="V-PRINT-CIRCLE">变量 *PRINT-CIRCLE*</span>

* 值类型(Value Type):

        一个广义 boolean [generalized boolean].

* 初始值(Initial Value):

        false.

* 描述(Description):

        控制检测一个要被打印的对象[object]中环状和共享的尝试.

        如果是 false, 打印过程仅仅是通过递归的下降来进行, 而不需要检测环状和共享.

        如果是 true, 打印器将努力检测出要被打印的结构中的环和共享, 并且使用 #n= 和 #n# 语法来表示环或共享成员.

        如果是 true, 一个用户定义的 print-object 方法[method]可以使用 write, prin1, princ, 或 format 打印对象[object]到提供的流[stream]中并且期望检测环和共享并使用 #n# 语法打印. 如果一个用户定义的 print-object 方法[method]打印到提供的流[stream]之外的流, 那么对该流[stream]重新进行环状检测.

        注意, 当 Lisp 读取器[Lisp reader]会自动确保没有它的共享时, 具体实现不应该使用 #n# 标记 (例如, 就像被捕获[interned]的符号[symbol]一样).

* 示例(Examples):

    ```LISP
    (let ((a (list 1 2 3)))
      (setf (cdddr a) a)
      (let ((*print-circle* t))
        (write a)
        :done))
    >>  #1=(1 2 3 . #1#)
    =>  :DONE
    ```

* 受此影响(Affected By): None.

* 也见(See Also):

        write

* 注意(Notes):

        在 *print-circle* 设置为 nil 的情况下尝试去打印一个环状结构可能导致循环行为并且不能终止. 


### <span id="V-PRINT-ESCAPE">变量 *PRINT-ESCAPE*</span>

* 值类型(Value Type):

        一个广义 boolean [generalized boolean].

* 初始值(Initial Value):

        true.

* 描述(Description):

        如果是 false, 在打印一个表达式时, 转义字符和包前缀[package prefix]不会被输出.

        如果是 true, 尝试以一种它可以被再次读取以产生一个 equal 的表达式[expression]的方式来打印一个表达式[expression]. (这只是一个指导纲要; 不是必须的. 见 *print-readably*.)

        关于 *print-escape* 的值[value]如何影响特定类型[type]的打印的更具体信息, 见章节 22.1.3 (默认 Print-Object 方法).

* 示例(Examples):

    ```LISP
    (let ((*print-escape* t)) (write #\a))
    >>  #\a
    =>  #\a
    (let ((*print-escape* nil)) (write #\a))
    >>  a
    =>  #\a
    ```

* 受此影响(Affected By):

        princ, prin1, format

* 也见(See Also):

        write, readtable-case

* 注意(Notes):

        princ 实际上绑定 *print-escape* 为 false. prin1 实际上绑定 *print-escape* 为 true. 


### <span id="V-PRINT-GENSYM">变量 *PRINT-GENSYM*</span>

* 值类型(Value Type):

        一个广义 boolean [generalized boolean].

* 初始值(Initial Value):

        true.

* 描述(Description):

        控制在明显未捕捉的[apparently uninterned]符号[symbol]前面是否打印前缀 "#:". 当且仅当这个 *print-gensym* 的值[value]是 true 时, 在这样一个符号[symbol]之前打印这个前缀.

* 示例(Examples):

    ```LISP
    (let ((*print-gensym* nil))
      (print (gensym)))
    >>  G6040
    =>  #:G6040
    ```

* 受此影响(Affected By): None.

* 也见(See Also):

        write, *print-escape*

* 注意(Notes): None.


### <span id="V-PRINT-LEVEL-LENGTH">变量 *PRINT-LEVEL*, *PRINT-LENGTH*</span>

* 值类型(Value Type):

        一个非负整数[integer], 或 nil.

* 初始值(Initial Value):

        nil.

* 描述(Description):

        *print-level* 控制一个嵌套对象[object]打印多少层级深度. 如果它是 false, 那么不会执行控制. 否则, 它就是一个表示要被打印的最大层级的整数[integer]. 一个要被打印的对象[object]处于 0 层级; 它的成员 (就像是在一个列表[list]或向量[vector]中) 处于 1 层级; 以此类推. 如果一个要被递归打印的对象[object]有着大于等于 *print-level* 值[value]的层级, 那么这个对象[object]被打印为 "#".

        *print-length* 控制在一个给定的层级下打印多少个元素. 如果它是 false, 那么就没有打印成员数量上的限制. 否则, 它就是一个表示要被打印的对象[object]的最大元素[element]数的整数[integer]. 如果超过了, 这个打印器会打印 "..." 来替换其他元素[element]. 在点对列表[dotted list]的情况下, 如果这个列表[list]包含了和 *print-length* 的值[value]一样多的元素[element], 终止的基元[atom]会被打印而不是打印 "..."

        *print-level* 和 *print-length* 影响用类列表语法打印的任何对象[object]的打印. 它们不会影响符号[symbol], 字符串[string], 和位向量[bit vector]的打印.

* 示例(Examples):

    ```LISP
    (setq a '(1 (2 (3 (4 (5 (6))))))) =>  (1 (2 (3 (4 (5 (6))))))
    (dotimes (i 8)
      (let ((*print-level* i))
        (format t "~&~D -- ~S~%" i a)))
    >>  0 -- #
    >>  1 -- (1 #)
    >>  2 -- (1 (2 #))
    >>  3 -- (1 (2 (3 #)))
    >>  4 -- (1 (2 (3 (4 #))))
    >>  5 -- (1 (2 (3 (4 (5 #)))))
    >>  6 -- (1 (2 (3 (4 (5 (6))))))
    >>  7 -- (1 (2 (3 (4 (5 (6))))))
    =>  NIL

    (setq a '(1 2 3 4 5 6)) =>  (1 2 3 4 5 6)
    (dotimes (i 7)
      (let ((*print-length* i))
        (format t "~&~D -- ~S~%" i a)))
    >>  0 -- (...)
    >>  1 -- (1 ...)
    >>  2 -- (1 2 ...)
    >>  3 -- (1 2 3 ...)
    >>  4 -- (1 2 3 4 ...)
    >>  5 -- (1 2 3 4 5 6)
    >>  6 -- (1 2 3 4 5 6)
    =>  NIL

    (dolist (level-length '((0 1) (1 1) (1 2) (1 3) (1 4)
                          (2 1) (2 2) (2 3) (3 2) (3 3) (3 4)))
    (let ((*print-level*  (first  level-length))
          (*print-length* (second level-length)))
      (format t "~&~D ~D -- ~S~%"
              *print-level* *print-length*
              '(if (member x y) (+ (car x) 3) '(foo . #(a b c d "Baz"))))))
    >>  0 1 -- #
    >>  1 1 -- (IF ...)
    >>  1 2 -- (IF # ...)
    >>  1 3 -- (IF # # ...)
    >>  1 4 -- (IF # # #)
    >>  2 1 -- (IF ...)
    >>  2 2 -- (IF (MEMBER X ...) ...)
    >>  2 3 -- (IF (MEMBER X Y) (+ # 3) ...)
    >>  3 2 -- (IF (MEMBER X ...) ...)
    >>  3 3 -- (IF (MEMBER X Y) (+ (CAR X) 3) ...)
    >>  3 4 -- (IF (MEMBER X Y) (+ (CAR X) 3) '(FOO . #(A B C D ...)))
    =>  NIL
    ```

* 受此影响(Affected By): None.

* 也见(See Also):

        write

* 注意(Notes): None.


### <span id="V-PRINT-LINES">变量 *PRINT-LINES*</span>

* 值类型(Value Type):

        一个非负整数[integer], 或 nil.

* 初始值(Initial Value):

        nil.

* 描述(Description):

        当这个 *print-lines* 的值[value]是除了 nil 以外的值时, 当某个东西要被美观打印时, 它是产生的输出行数的限制. 如果尝试去超出那么多行, ".." 会被打印在最后一行末尾, 后面跟着所有待打印的后缀 (结束分隔符).

* 示例(Examples):

    ```LISP
    (let ((*print-right-margin* 25) (*print-lines* 3))
      (pprint '(progn (setq a 1 b 2 c 3 d 4))))
    >>  (PROGN (SETQ A 1
    >>               B 2
    >>               C 3 ..))
    =>  <no values>
    ```

* 也见(See Also): None.

* 注意(Notes):

        这个 ".." 标记是有意和用于级别缩写的 "..." 标记不同的, 这样一来这两个不同的情况可以被可见地区分.

        这个标记用于增加 Lisp 读取器[Lisp reader]在稍后尝试读取缩略输出时发出错误的可能性. 但是注意这个截断如果发生在一个字符串[string]中, 比如在 "This string has been trunc.." 中, 以后不会检测到问题情况, 也不会出现此类错误. 


### <span id="V-PRINT-MISER-WIDTH">变量 *PRINT-MISER-WIDTH*</span>

* 值类型(Value Type):

        一个非负整数[integer], 或 nil.

* 初始值(Initial Value):

        依赖于具体实现的[implementation-dependent]

* 描述(Description):

        如果它不是 nil, 那么当打印子结构的可用宽度小于或等于这么多个 em 单位时, 这个美观打印器[pretty printer]切换到输出的紧凑风格(称为最小执行常式(miser)风格).

* 示例(Examples): None.

* 也见(See Also): None.

* 注意(Notes): None.


### <span id="V-PRINT-PPRINT-DISPATCH">变量 *PRINT-PPRINT-DISPATCH*</span>

* 值类型(Value Type):

        一个美观打印分派表[pprint dispatch table].

* 初始值(Initial Value):

        依赖于具体实现的[implementation-dependent], 但是这些初始条目都使用了一个特殊的优先级, 其属性是它们比所有使用 set-pprint-dispatch 指定的优先级都小, 这样一来任何条目的初始内容可以被重写.

* 描述(Description):

        这个美观打印分派表[pprint dispatch table]控制当前美观打印器[pretty printer].

* 示例(Examples): None.

* 也见(See Also):

        *print-pretty*, 章节 22.2.1.4 (美观打印分派表)

* 注意(Notes):

        其目的是, 该变量[variable]的初始值[value]应该导致代码[code]的"传统"美观打印. 然而, 通常你可以在 *print-pprint-dispatch* 放置一个值来使美观打印输出看起来像是非美观打印输出. 设置 *print-pretty* 为 true 只会导致当前美观打印分派表[current pprint dispatch table]中的这些函数有着超过普通 print-object 方法的优先级; 没有神奇的方法来强制这些函数实际上产生了美观的输出. 关于详细信息, 见章节 22.2.1.4 (美观打印分派表). 


### <span id="V-PRINT-PRETTY">变量 *PRINT-PRETTY*</span>

* 值类型(Value Type):

        一个广义 boolean [generalized boolean].

* 初始值(Initial Value):

        依赖于具体实现的[implementation-dependent].

* 描述(Description):

        控制 Lisp 打印器[Lisp printer]是否调用美观打印器[pretty printer].

        如果它是 false, 美观打印器[pretty printer]不会被使用并且当打印一个表达式时会输出最小数量的空格[whitespace[1]].

        如果它是 true, 美观打印器[pretty printer]会被使用, 并且 Lisp 打印器[Lisp printer]会尽可能的在可以使表达式[expression]变得更加可读的地方去插入额外的空格[whitespace[1]].

        即便当 *print-escape* 的值[value]是 false 时, *print-pretty* 也是有效的.

* 示例(Examples):

    ```LISP
    (setq *print-pretty* 'nil) =>  NIL
    (progn (write '(let ((a 1) (b 2) (c 3)) (+ a b c))) nil)
    >>  (LET ((A 1) (B 2) (C 3)) (+ A B C))
    =>  NIL
    (let ((*print-pretty* t))
      (progn (write '(let ((a 1) (b 2) (c 3)) (+ a b c))) nil))
    >>  (LET ((A 1)
    >>        (B 2)
    >>        (C 3))
    >>    (+ A B C))
    =>  NIL
    ;; Note that the first two expressions printed by this next form
    ;; differ from the second two only in whether escape characters are printed.
    ;; In all four cases, extra whitespace is inserted by the pretty printer.
    (flet ((test (x)
              (let ((*print-pretty* t))
                (print x)
                (format t "~%~S " x)
                (terpri) (princ x) (princ " ")
                (format t "~%~A " x))))
      (test '#'(lambda () (list "a" #'c #'d))))
    >>  #'(LAMBDA ()
    >>      (LIST "a" #'C #'D))
    >>  #'(LAMBDA ()
    >>      (LIST "a" #'C #'D))
    >>  #'(LAMBDA ()
    >>      (LIST a b 'C #'D))
    >>  #'(LAMBDA ()
    >>      (LIST a b 'C #'D))
    =>  NIL
    ```

* 受此影响(Affected By): None.

* 也见(See Also):

        write

* 注意(Notes): None. 


### <span id="V-PRINT-READABLY">变量 *PRINT-READABLY*</span>

* 值类型(Value Type):

        一个广义 boolean [generalized boolean].

* 初始值(Initial Value):

        false.

* 描述(Description):

        如果 *print-readably* 是 true, 打印对象[object]的一些特殊规则生效. 具体来说, 打印任何对象[object] O1 会产生一个打印表示, 当 Lisp 读取器[Lisp reader]在标准读取表[standard readtable]生效见到这个打印表示时, 会产生一个和 O1 相似[similar]的对象[object] O2. 产生的打印表示可能和 *print-readably* 是 false 时产生的打印表示一样, 也可能不一样. 如果不能打印一个可读[readably]对象[object], 就会发出一个 print-not-readable 类型[type]的错误而不是使用一个对于相同实现[implementation]不可读的语法 (比如, "#<" 语法). 如果某个其他打印器控制变量[printer control variable]的值[value]是这样的, 那么这些需求就会被违背, 那么这个其他变量[variable]的值[value]就会被忽略.

        具体的说, 如果 *print-readably* 是 true, 打印过程就像 *print-escape*, *print-array*, 和 *print-gensym* 也是 true 并且 *print-length*, *print-level*, 和 *print-lines* 是 false 一样.

        如果 *print-readably* 是 false, 正常的打印规则和其他打印器控制变量[printer control variable]的正常解释规则生效.

        单独的 print-object 方法[method], 包括用户定义的方法[method], 有责任去实现这些需要.

        如果 *read-eval* 是 false 并且 *print-readably* 是 true, 任何会输出对 "#." 读取器宏[reader macro]的引用的方法, 要么输出其他的东西, 要么会发出错误的信号 (就像上面描述的).

* 示例(Examples):

    ```LISP
    (let ((x (list "a" '\a (gensym) '((a (b (c))) d e f g)))
          (*print-escape* nil)
          (*print-gensym* nil)
          (*print-level* 3)
          (*print-length* 3))
      (write x)
      (let ((*print-readably* t))
        (terpri)
        (write x)
        :done))
    >>  (a a G4581 ((A #) D E ...))
    >>  ("a" |a| #:G4581 ((A (B (C))) D E F G))
    =>  :DONE

    ;; This is setup code is shared between the examples
    ;; of three hypothetical implementations which follow.
    (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32005763> 
    (setf (gethash table 1) 'one) =>  ONE
    (setf (gethash table 2) 'two) =>  TWO

    ;; Implementation A
    (let ((*print-readably* t)) (print table))
    Error: Can't print #<HASH-TABLE EQL 0/120 32005763> readably.

    ;; Implementation B
    ;; No standardized #S notation for hash tables is defined, 
    ;; but there might be an implementation-defined notation.
    (let ((*print-readably* t)) (print table))
    >>  #S(HASH-TABLE :TEST EQL :SIZE 120 :CONTENTS (1 ONE 2 TWO))
    =>  #<HASH-TABLE EQL 0/120 32005763>

    ;; Implementation C
    ;; Note that #. notation can only be used if *READ-EVAL* is true.
    ;; If *READ-EVAL* were false, this same implementation might have to
    ;; signal an error unless it had yet another printing strategy to fall
    ;; back on.
    (let ((*print-readably* t)) (print table))
    >>  #.(LET ((HASH-TABLE (MAKE-HASH-TABLE)))
    >>      (SETF (GETHASH 1 HASH-TABLE) ONE)
    >>      (SETF (GETHASH 2 HASH-TABLE) TWO)
    >>      HASH-TABLE)
    =>  #<HASH-TABLE EQL 0/120 32005763>
    ```

* 受此影响(Affected By): None.

* 也见(See Also):

        write, print-unreadable-object

* 注意(Notes):

        "相似性[similarity]" 规则意味着 #A 或 #( 语法不能被用于除了 t 以外的元素类型[element type]的数组[array]. 一个实现将不得不使用另一种语法或者发出一个 print-not-readable 类型[type]的错误. 


### <span id="V-PRINT-RIGHT-MARGIN">变量 *PRINT-RIGHT-MARGIN*</span>

* 值类型(Value Type):

        一个非负整数[integer], 或 nil.

* 初始值(Initial Value):

        nil.

* 描述(Description):

        如果它非 nil [non-nil], 当美观打印器[pretty printer]要做布局决定时, 它指定了要使用的右边距 (em 单位的整数[integer]).

        如果它是 nil, 右边距被认为是输出可以显示而不需要包绕或截断的最大行长度. 如果这个没有被确定, 使用一个依赖于具体实现的[implementation-dependent]值.

* 示例(Examples): None.

* 也见(See Also): None.

* 注意(Notes):

        这个度量是用 em 单位, 为了与具体实现定义的[implementation-defined]可变宽度字体兼容, 同时不要求语言提供对字体的支持. 


### <span id="CT-PRINT-NOT-READABLE">状况类型 PRINT-NOT-READABLE</span>

* 类优先级列表(Class Precedence List):

        print-not-readable, error, serious-condition, condition, t

* 描述(Description):

        当 *print-readably* 为 true 时, 类型[type] print-not-readable 由输出期间发生的错误状况组成, 是尝试去用 Lisp 打印器[Lisp printer]写入一个不能被 Lisp 读取器[Lisp reader]读回的打印表示的结果. 这个不能被打印的对象通过给 make-condition 的 :object 初始化参数来初始化, 并且可以通过函数[function] print-not-readable-object 访问.

* 也见(See Also):

        print-not-readable-object 


### <span id="F-PRINT-NOT-READABLE-OBJECT">函数 PRINT-NOT-READABLE-OBJECT</span>

* 语法(Syntax):

        print-not-readable-object condition => object

* 参数和值(Arguments and Values):

        condition---一个 print-not-readable 类型[type]的状况.
        object---一个对象[object].

* 描述(Description):

        返回在状况 condition 所表示的情况中不能被可读地打印的对象[object].

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 也见(See Also):

        print-not-readable, 章节 9 (状况)

* 注意(Notes): None. 


### <span id="F-FORMAT">函数 FORMAT</span>

* 语法(Syntax):

        format destination control-string &rest args => result

* 参数和值(Arguments and Values):

        destination---nil, t, 一个流[stream], 或者一个带有填充指针[fill pointer]的字符串[string].
        control-string---一个格式化控制[format control].
        args--- control-string 的格式化参数[format argument].
        result---如果 destination 非 nil [non-nil], 那么就是 nil; 否则, 就是一个字符串[string].

* 描述(Description):

        format 通过输出 control-string 的字符并观察到一个波浪字符[tilde]引入了一个指令来生成格式化的输出. 波浪符号后面的字符, 可能前面有前缀参数和和修饰符, 指定了想要的格式化种类. 大部分指令使用 args 中的一个或多个元素来创建它们的输出.

        如果 destination 是一个字符串[string], 一个流[stream], 或 t, 那么结果 result 是 nil. 否则, 结果 result 是一个包含 '输出' 的字符串[string].

        format 用于产生良好格式化的文本, 产生美观的信息是很有用的, 等等. format 可以生成并返回一个字符串[string]或者输出到 destination 中.

        关于 control-string 任何被解释的详细信息, 见章节 22.3 (格式化输出).
如果这个没有被确定
* 示例(Examples): None.

* 受此影响(Affected By):

        *standard-output*, *print-escape*, *print-radix*, *print-base*, *print-circle*, *print-pretty*, *print-level*, *print-length*, *print-case*, *print-gensym*, *print-array*.

* 异常情况(Exceptional Situations):

        如果 destination 是一个带有填充指针[fill pointer]的字符串[string], 如果在这个调用的动态范围[dynamic extent]内直接在这个字符串[string]上执行破坏性的修改, 那么后果是未定义的.

* 也见(See Also):

        write, 章节 13.1.10 (具体实现定义的文字的文档)

* 注意(Notes): None.


# 23. 读取器

> * 23.1 [读取器的概念](#ReaderConcepts)
> * 23.2 [读取器的字典](#TheReaderDictionary)

## 23.1 <span id="ReaderConcepts">读取器的概念</span>

> * 23.1.1 [Lisp 读取器的动态控制](#DynamicControlLispReader)
> * 23.1.2 [Lisp 读取器上的读取表大小写的影响](#EffectReadtableLispReader)
> * 23.1.3 [一些读取器函数的参数转换](#ArgConventSomeReaderFun)


### 23.1.1 <span id="DynamicControlLispReader">Lisp 读取器的动态控制</span>

Lisp 读取器[Lisp reader]的各个方面可以被动态控制. 见章节 2.1.1 (读取表) 和章节 2.1.2 (影响 Lisp 读取器的变量). 

### 23.1.2 <span id="EffectReadtableLispReader">Lisp 读取器上的读取表大小写的影响</span>

当前读取表[current readtable]的读取表大小写[readtable case]以以下方式影响 Lisp 读取器[Lisp reader]:

:upcase

    当读取表大小写[readtable case]是 :upcase 时, 未转义的成分字符[character]会被转换为大写[uppercase], 如章节 2.2 (读取器算法) 中所指定的那样.

:downcase

    当读取表大小写[readtable case]是 :downcase 时, 未转义的成分字符[character]会被转换为小写[lowercase].

:preserve

    当读取表大小写[readtable case]是 :preserve 时, 所有字符[character]的大小写保持不变.

:invert

    当读取表大小写[readtable case]是 :invert 时, 那么如果所有这些未转义字母在扩展 token 中是相同大小写[case], 这些 (未转义的) 字母会被转换为相反的大小写[case].

#### 23.1.2.1 Lisp 读取器上的读取表大小写的影响的示例

```LISP
(defun test-readtable-case-reading ()
  (let ((*readtable* (copy-readtable nil)))
    (format t "READTABLE-CASE  Input   Symbol-name~
              ~%-----------------------------------~
              ~%")
    (dolist (readtable-case '(:upcase :downcase :preserve :invert))
      (setf (readtable-case *readtable*) readtable-case)
      (dolist (input '("ZEBRA" "Zebra" "zebra"))
        (format t "~&:~A~16T~A~24T~A"
                (string-upcase readtable-case)
                input
                (symbol-name (read-from-string input)))))))
```

来自 (test-readtable-case-reading) 的输出 应该如下:

| READTABLE-CASE  |   Input | Symbol-name |
| --              |--       |--           |
|  :UPCASE        | ZEBRA   | ZEBRA       |
|  :UPCASE        | Zebra   | ZEBRA       |
|  :UPCASE        | zebra   | ZEBRA       |
|  :DOWNCASE      | ZEBRA   | zebra       |
|  :DOWNCASE      | Zebra   | zebra       |
|  :DOWNCASE      | zebra   | zebra       |
|  :PRESERVE      | ZEBRA   | ZEBRA       |
|  :PRESERVE      | Zebra   | Zebra       |
|  :PRESERVE      | zebra   | zebra       |
|  :INVERT        | ZEBRA   | zebra       |
|  :INVERT        | Zebra   | Zebra       |
|  :INVERT        | zebra   | ZEBRA       |


### 23.1.3 <span id="ArgConventSomeReaderFun">一些读取器函数的参数转换</span>

#### 23.1.3.1 EOF-ERROR-P 参数

在输入函数调用中的 eof-error-p 控制如果输入来自于一个文件(或者任何其他有着有限结尾的输入源)并且到达了文件的末尾会发生什么. 如果 eof-error-p 是 true (默认的), 就会在文件的结尾发出一个 end-of-file 类型[type]的错误. 如果它是 false, 那么没有错误会发生, 并且这个函数返回 eof-value.

像 read 这样读取一个对象[object]的打印表示而不是单个字符的函数, 如果文件结束在一个对象打印表示的中间, 不管 eof-error-p 的值是什么, 都会发出一个错误. 比如, 如果一个文件确实不包含足够的右括号来平衡它里面的左括号, read 就会发出一个错误. 如果一个文件以一个符号[symbol]或一个数字[number]后面直接跟着 end-of-file 终止, read 成功读取这个符号[symbol]或数字[number]并且再一次调用时根据 end-of-file 来表现. 类似地, 函数[function] read-line 成功地读取一个文件的最后一行, 即便那行用 end-of-file 终止而不是用一个换行字符. 可忽略的文本, 例如只包含空格[whitespace[2]]或注释, 不会被当作开始一个对象[object]; 如果 read 开始去读取一个表达式[expression]但是只看到这样的可忽略文本, 它不会认为这个文件终止在一个对象[object]的中间. 因此一个 eof-error-p 参数控制当文件在对象[object]之间结束时会发生什么. 

#### 23.1.3.2 RECURSIVE-P 参数

如果提供了 recursive-p 并且不是 nil, 它指明这个函数调用不是一个对 read 的最外部的调用而是一个内嵌的调用, 通常来自于一个读取器宏函数[reader macro function]. 区分这样的递归调用是很重要的, 原因有三.

1. 一个最外部的调用建立了限定 #n= 和 #n# 语法作用域的上下文. 细想, 例如, 表达式

    ```LISP
    (cons '#3=(p q r) '(x y . #3#))
    ```

    如果这个单引号[single-quote]读取器宏[reader macro]用这种方式定义:

    ```LISP
    (set-macro-character #\'       ;incorrect
      #'(lambda (stream char)
            (declare (ignore char))
            (list 'quote (read stream))))
    ```

    那么每一个对这个单引号[single-quote]读取器宏函数[reader macro function]的调用会为 read 信息的作用域建立一个独立的上下文, 包括在像 "#3=" 和 "#3#" 等标记之间的标识作用域. 但是, 对于这个表达式, 这个作用域显然是由更外面的一组括号来决定的, 所以这样一个定义是不正确的. 正确的方式去定义这个单引号[single-quote]读取器宏[reader macro]是使用 recursive-p:

    ```LISP
    (set-macro-character #\'       ;correct
      #'(lambda (stream char)
            (declare (ignore char))
            (list 'quote (read stream t nil t))))
    ```

2. 一个递归调用不会改变这个读取过程是否保留空格[whitespace[2]] (由最外面的调用为 read 还是 read-preserving-whitespace 决定). 再一次假设这个单引号[single-quote]被定义为上面不正确的定义所展示的那样. 然后一个读取表达式 'foo<Space> 的 read-preserving-whitespace 调用会无法保留符号 foo 后的空白字符, 因为这个单引号[single-quote]读取器宏函数[reader macro function]调用 read 而不是 read-preserving-whitespace 去读取后面的表达式 (在这个情况 foo). 传递给 read 的 recursive-p 值为 true 的正确定义允许最外部的调用去决定是否保留空格[whitespace[2]].

3. 当遇到 end-of-file 并且 eof-error-p 参数不是 nil 时, 发送的错误的种类可能取决于 recursive-p 的值. 如果 recursive-p 是 true, 那么这个 end-of-file 被认为已经出现在一个打印表示的中间; 如果 recursive-p 是 false, 那么这个 end-of-file 可能被认为已经出现在对象[object]之间而不是在一个的中间. 

## 23.2 <span id="TheReaderDictionary">读取器的字典</span>

> * [系统类 READTABLE](#SC-READTABLE)
> * [函数 COPY-READTABLE](#F-COPY-READTABLE)
> * [函数 MAKE-DISPATCH-MACRO-CHARACTER](#F-MDMC)
> * [函数 READ, READ-PRESERVING-WHITESPACE](#F-READ-AND-RPW)
> * [函数 READ-DELIMITED-LIST](#F-READ-DELIMITED-LIST)
> * [函数 READ-FROM-STRING](#F-READ-FROM-STRING)
> * [访问器 READTABLE-CASE](#A-READTABLE-CASE)
> * [函数 READTABLEP](#F-READTABLEP)
> * [函数 SET-DISPATCH-MACRO-CHARACTER, GET-DISPATCH-MACRO-CHARACTER](#F-SET-AND-GET-DMC)
> * [函数 SET-MACRO-CHARACTER, GET-MACRO-CHARACTER](#F-SET-AND-GET-MC)
> * [函数 SET-SYNTAX-FROM-CHAR](#F-SET-SYNTAX-FROM-CHAR)
> * [宏 WITH-STANDARD-IO-SYNTAX](#M-WITH-STANDARD-IO-SYNTAX)
> * [变量 *READ-BASE*](#V-READ-BASE)
> * [变量 *READ-DEFAULT-FLOAT-FORMAT*](#V-READ-DEFAULT-FLOAT-FORMAT)
> * [变量 *READ-EVAL*](#V-READ-EVAL)
> * [变量 *READ-SUPPRESS*](#V-READ-SUPPRESS)
> * [变量 *READTABLE*](#V-READTABLE)
> * [状况类型 READER-ERROR](#CT-READER-ERROR)


### <span id="SC-READTABLE">系统类 READTABLE</span>

* 类优先级列表(Class Precedence List):

        readtable, t

* 描述(Description):

        一个读取表[readtable]映射字符[character]到 Lisp 读取器[Lisp reader]的语法类型[syntax type]; 见章节 2 (语法). 一个读取表[readtable]也包含宏字符[macro character]和它们的读取器宏函数[reader macro function]之间的关联, 并且记录 Lisp 读取器[Lisp reader]解析符号[symbol]时使用的大小写转换规则的相关信息.

        在这个读取表[readtable]中的每一个简单[simple]字符[character]必须是可以表示的. 非简单[non-simple]字符[character]在读取表[readtable]中是否可以有语法描述是具体实现定义的[implementation-defined].

* 参见(See Also):

        章节 2.1.1 (读取表), 章节 22.1.3.13 (打印其他对象) 


### <span id="F-COPY-READTABLE">函数 COPY-READTABLE</span>

* 语法(Syntax):

        copy-readtable &optional from-readtable to-readtable => readtable

* 参数和值(Arguments and Values):

        from-readtable---一个读取表标识符[readtable designator]. 默认是当前读取表[current readtable].
        to-readtable---一个读取表[readtable]或 nil. 默认是 nil.
        readtable---如果 to-readtable 非 nil [non-nil]那么就是 to-readtable, 否则就是一个新的[refresh]读取表[readtable].

* 描述(Description):

        copy-readtable 复制 from-readtable.

        如果 to-readtable 是 nil, 一个新的读取表[readtable]会被创建并返回. 否则由 to-readtable 指定的读取表[readtable]会被修改并返回.

        copy-readtable 复制 readtable-case 的设置.

* 示例(Examples):

    ```LISP
    (setq zvar 123) =>  123
    (set-syntax-from-char #\z #\' (setq table2 (copy-readtable))) =>  T
    zvar =>  123
    (copy-readtable table2 *readtable*) =>  #<READTABLE 614000277>
    zvar =>  VAR
    (setq *readtable* (copy-readtable)) =>  #<READTABLE 46210223>
    zvar =>  VAR
    (setq *readtable* (copy-readtable nil)) =>  #<READTABLE 46302670>
    zvar =>  123
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        readtable, *readtable*

* 注意(Notes):

        (setq *readtable* (copy-readtable nil))

        恢复输入语法为标准 Common Lisp 语法, 即便那个初始的读取表[initial readtable]已经被重写 (假定它没有被恶劣的重写以至于你不能输入上述表达式).

        另一方面,

        (setq *readtable* (copy-readtable))

        用当前表[readtable]自身的一个拷贝替换当前表. 如果你想去保存一个读取表的拷贝用于后面的使用, 同时又不需要修改, 那么这是非常有用的. 如果你想局部绑定这个读取表为它自身的一个拷贝, 这也是很有用的, 像下面这样:

        (let ((*readtable* (copy-readtable))) ...)


### <span id="F-MDMC">函数 MAKE-DISPATCH-MACRO-CHARACTER</span>

* 语法(Syntax):

        make-dispatch-macro-character char &optional non-terminating-p readtable => t

* 参数和值(Arguments and Values):

        char---一个字符[character].
        non-terminating-p---一个广义 boolean [generalized boolean]. 默认是 false.
        readtable---一个读取表[readtable]. 默认是当前读取表[current readtable].

* 描述(Description):

        make-dispatch-macro-character 使 char 成为表 readtable 中的一个分派宏字符[dispatching macro character].

        首先, 在这个分派表中和 char 关联的每一个字符[character]有一个发出 reader-error 类型[type]的错误的关联函数.

        如果 non-terminating-p 是 true, 这个分派宏字符[dispatching macro character]会是一个非终止[non-terminating]宏字符[macro character]; 如果 non-terminating-p 是 false, 这个分派宏字符[dispatching macro character]会是一个终止[terminating]宏字符[macro character].

* 示例(Examples):

    ```LISP
    (get-macro-character #\{) =>  NIL, false
    (make-dispatch-macro-character #\{) =>  T
    (not (get-macro-character #\{)) =>  false
    ```

* 副作用(Side Effects): None.

        这个读取表 readtable 会被修改.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        *readtable*, set-dispatch-macro-character

* 注意(Notes): None. 


### <span id="F-READ-AND-RPW">函数 READ, READ-PRESERVING-WHITESPACE</span>

* 语法(Syntax):

        read &optional input-stream eof-error-p eof-value recursive-p => object

        read-preserving-whitespace &optional input-stream eof-error-p eof-value recursive-p
        => object

* 参数和值(Arguments and Values):

        input-stream---一个输入[input]流标识符[designator].
        eof-error-p---一个广义 boolean [generalized boolean]. 默认是 true.
        eof-value---一个对象[object]. 默认是 nil.
        recursive-p---一个广义 boolean [generalized boolean]. 默认是 false.
        object---一个对象[object] (由 Lisp 读取器[Lisp reader]解析的) 或者 eof-value.

* 描述(Description):

        read 从输入流 input-stream 解析一个对象[object]的打印表示并且构建这样一个对象[object].

        read-preserving-whitespace 类似于 read 但是保留任何分隔这个对象[object]的打印表示的空格[whitespace[2]]字符[character]. 当给 read-preserving-whitespace 的 recursive-p 参数[argument]是 true 时 read-preserving-whitespace 就像 read 一样.

        当 *read-suppress* 是 false 时, 如果分隔字符是空白[whitespace[2]]字符[character], read 会丢弃某些打印表示所需要的分隔字符; 但是如果它是语法上有意义的, 那么 read 会保留这个字符 (使用 unread-char), 因为它可以是下一个表达式的开始.

        如果一个文件终止于一个符号[symbol]或一个数字[number]后直接跟着文件的末尾[end of file[1]], read 成功地读取这个符号[symbol]或数字[number]; 当再一次调用时, 它见到文件的末尾[end of file[1]]并且只能根据 eof-error-p 来表现. 如果一个文件在末尾包含了可忽略的文本, 例如空白行和注释, read 不会把这个当作终止于一个对象[object]的中间.

        如果 recursive-p 是 true, 这个对 read 的调用应该是由某个函数内部生成的, 而这个函数本身是由 read 或类似的输入函数调用的, 而不是从顶层调用的.

        两个函数都返回从 input-stream 中读取到的对象[object]. 如果 eof-error-p 是 false 并且在开始一个对象[object]前到达了文件的末尾, 那么返回 eof-value.

* 示例(Examples):

    ```LISP
    (read)
    >>  'a
    =>  (QUOTE A)
    (with-input-from-string (is " ") (read is nil 'the-end)) =>  THE-END
    (defun skip-then-read-char (s c n)
        (if (char= c #\{) (read s t nil t) (read-preserving-whitespace s))
        (read-char-no-hang s)) =>  SKIP-THEN-READ-CHAR
    (let ((*readtable* (copy-readtable nil)))
        (set-dispatch-macro-character #\# #\{ #'skip-then-read-char)
        (set-dispatch-macro-character #\# #\} #'skip-then-read-char)
        (with-input-from-string (is "#{123 x #}123 y")
          (format t "~S ~S" (read is) (read is)))) =>  #\x, #\Space, NIL
    ```

        作为一个示例, 思考这个读取器宏[reader macro]定义:

    ```LISP
    (defun slash-reader (stream char)
      (declare (ignore char))
      `(path . ,(loop for dir = (read-preserving-whitespace stream t nil t)
                      then (progn (read-char stream t nil t)
                                  (read-preserving-whitespace stream t nil t))
                      collect dir
                      while (eql (peek-char nil stream nil nil t) #\/))))
    (set-macro-character #\/ #'slash-reader)
    ```

        思考现在在这个表达式上调用 read:

    ```LISP
    (zyedh /usr/games/zork /usr/games/boggle)
    ```

        这个 / 宏读取由多个 / 字符分隔的对象; 因此 /usr/games/zork 应该被读取为 (path usr games zork). 这整个示例表达式应该因此被读取为

    ```LISP
    (zyedh (path usr games zork) (path usr games boggle))
    ```

        然而, 如果已经使用了 read 而不是 read-preserving-whitespace, 那么在符号 zork 的读取后, 后面的空格会被丢弃; 下一个对 peek-char 的调用会见到后面的 /, 并且这个循环会继续, 产生这个解释:

    ```LISP
    (zyedh (path usr games zork usr games boggle))
    ```

        有时候空格[whitespace[2]]应该被丢弃. 如果一个命令解释器接受单字符命令, 但是偶尔读取一个对象[object], 那么如果一个符号[symbol]后的空格[whitespace[2]]没有被丢弃, 它有时可能在读取这个符号[symbol]后被解释为一个命令.

* 受此影响(Affected By):

        *standard-input*, *terminal-io*, *readtable*, *read-default-float-format*, *read-base*, *read-suppress*, *package*, *read-eval*.

* 异常情况(Exceptional Situations):

        如果文件终止于一个对象[object]表示的中间, 那么不管 eof-error-p 的值[value], read 发出一个 end-of-file 类型[type]的错误. 例如, 如果一个文件没有包含足够的右括号来平衡它里面的左括号, read 就会发出一个错误. 当 read 或 read-preserving-whitespace 被调用时 recursive-p 和 eof-error-p 非 nil [non-nil], 并且在一个对象[object]开始前到达了文件的末尾, 这个会被检测到.

        如果 eof-error-p 是 true, 在文件的末尾发出一个 end-of-file 类型[type]的错误.

* 参见(See Also):

        peek-char, read-char, unread-char, read-from-string, read-delimited-list, parse-integer, 章节 2 (语法), 章节 23.1 (读取起概念)

* 注意(Notes): None. 


### <span id="F-READ-DELIMITED-LIST">函数 READ-DELIMITED-LIST</span>

* 语法(Syntax):

        read-delimited-list char &optional input-stream recursive-p => list

* 参数和值(Arguments and Values):

        char---一个字符[character].
        input-stream---一个输入[input]流标识符[stream designator]. 默认是标准输入[standard input].
        recursive-p---一个广义 boolean [generalized boolean]. 默认是 false.
        list---一个读取到的对象[object]列表[list].

* 描述(Description):

        read-delimited-list 从 input-stream 中读取对象[object]直到在一个对象[object]表示后面的下一个字符(忽略空格[whitespace[2]]字符和注释)是 char.

        read-delimited-list 向前查看每一步, 以查找下一个非空格[whitespace[2]]字符[character], 并以 peek-char 的方式观察它. 如果它是 char, 那么这个字符[character]被消耗并且返回对象[object]列表[list]. 如果它是一个标记成分[constituent]或转义[escape]字符[character], 那么 read 被用于读取一个对象[object], 它会被添加到这个列表[list]的末尾. 如果它是一个宏字符[macro character], 那么就会调用它的读取器宏函数[reader macro function]; 如果这个函数返回一个值[value], 那么这个值[value]会被添加给列表[list]. 然后重复向前窥视的过程.

        如果 recursive-p 是 true, 这个调用预计被嵌入在一个更高层次的对 read 或一个相似函数的调用中.

        在 read-delimited-list 操作期间到达文件末尾是一个错误.

        如果 char 有一个当前读取表[current readtable]中的空格[whitespace[2]]的语法类型[syntax type], 那么后果是未定义的.

* 示例(Examples):

    ```LISP
    (read-delimited-list #\]) 1 2 3 4 5 6 ]
    =>  (1 2 3 4 5 6)
    ```

        假设你希望 #{a b c ... z} 被读取为元素 a, b, c, ..., z 的所有序对的列表, 例如.

            #{p q z a}  读取为  ((p q) (p z) (p a) (q z) (q a) (z a))

        这个可以通过为 #{ 指定一个宏字符定义来完成, 这个宏字符定义完成两件事: 读入直到 } 为止的所有项, 并且构造这些序对. read-delimited-list 执行第一个任务.

    ```LISP
    (defun |#{-reader| (stream char arg)
      (declare (ignore char arg))
      (mapcon #'(lambda (x)
                  (mapcar #'(lambda (y) (list (car x) y)) (cdr x)))
              (read-delimited-list #\} stream t))) =>  |#{-reader|

    (set-dispatch-macro-character #\# #\{ #'|#{-reader|) =>  T 
    (set-macro-character #\} (get-macro-character #\) nil))
    ```

        注意提供给 recursive-p 参数的 true.

        这里有必要对字符 } 给出一个定义, 并防止其成为一个标记成分. 如果上面显示的这行

    ```LISP
    (set-macro-character #\} (get-macro-character #\) nil))
    ```

        没有包括在内, 那么在

    ```LISP
    #{ p q z a}
    ```

        中的 } 会被认为是一个标记成分字符, 名为 a} 的符号的一部分. 这个可以通过在 } 之前放置一个空格来纠正, 但是去调用 set-macro-character 更好.

        给 } 和字符 ) 的标准定义相同的定义有着双重好处: 使它和 read-delimited-list 一起使用时终止标记并且也使它在其他上下文中使用是无效的. 尝试去读取一个离散的 } 会发出一个错误.

* 受此影响(Affected By):

        *standard-input*, *readtable*, *terminal-io*.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        read, peek-char, read-char, unread-char.

* 注意(Notes):

        read-delimited-list 旨在于被用来实现读取器宏[reader macro]. 通常, char 应该是一个终止的[terminating]宏字符[macro character], 以便可以使用它来分隔记号; 但是, read-delimited-list 不会尝试去修改有当前读取器表指定的 char 的语法. 调用者必须显式地对读取表语法做出必要改变. 


### <span id="F-READ-FROM-STRING">函数 READ-FROM-STRING</span>

* 语法(Syntax):

        read-from-string string &optional eof-error-p eof-value &key start end preserve-whitespace
        => object, position

* 参数和值(Arguments and Values):

        string---一个字符串[string].
        eof-error-p---一个广义 boolean [generalized boolean]. 默认是 true.
        eof-value---一个对象[object]. 默认是 nil.
        start, end---字符串 string 的边界索引标识符[bounding index designator]. 对于 start 和 end 默认分别为 0 和 nil.
        preserve-whitespace---一个广义 boolean [generalized boolean]. 默认是 false.
        object---一个对象[object] (由 Lisp 读取器[Lisp reader]解析的) 或者 eof-value
        position---一个大于等于零并且小于等于字符串 string 的长度[length]减一的整数[integer].

* 描述(Description):

        从字符串 string 中由 string 和 end 限定[bound]的子序列中解析一个对象[object]的打印表示, 就好像 read 在一个包含相同的这些字符[character]的输入[input]流[stream]上被调用一样.

        如果 preserve-whitespace 是 true, 这个操作会保留空格[whitespace[2]], 就好像 read-preserving-whitespace 做的一样.

        如果一个对象[object]被成功解析, 这个主值[primary value] object 就是那个解析的对象[object]. 如果 eof-error-p 是 false 并且到达了这个子字符串 substring 的末尾, 就会返回 eof-value.

        第二个值[secondary value] position 是限定[bounded]的字符串 string 中第一个没有被读取的字符[character]的索引. 这个 position 可能依赖 preserve-whitespace 的值. 如果这个完整的字符串 string 被读取, 这个返回的 position 是这个字符串 string 的长度或者比这个字符串 string 长度大一的数.

* 示例(Examples):

    ```LISP
    (read-from-string " 1 3 5" t nil :start 2) =>  3, 5
    (read-from-string "(a b c)") =>  (A B C), 7
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果在一个对象[object]可以被读取之前到达这个提供的子字符串的末尾, 如果 eof-error-p 是 true 就会发出一个错误. 如果这个子字符串的末尾出现在一个未完成的对象[object]中间, 那么就会发出一个错误.

* 参见(See Also):

        read, read-preserving-whitespace

* 注意(Notes):

        允许这个 position 超过这个字符串 string 的长度的原因是为了允许(但不是要求)具体实现[implementation]去通过模拟这些限定[bounded]字符串 string 末尾的一个尾部分隔符的效果来工作. 当 preserve-whitespace 是 true 时, 这个 position 可能统计了模拟分隔符. 


### <span id="A-READTABLE-CASE">访问器 READTABLE-CASE</span>

* 语法(Syntax):

        readtable-case readtable => mode

        (setf (readtable-case readtable) mode)

* 参数和值(Arguments and Values):

        readtable---一个读取表[readtable].
        mode---一个大小写敏感模式[case sensitivity mode].

* 描述(Description):

        访问[access] readtable 的读取表大小写[readtable case], 它影响 Lisp 读取器[Lisp Reader]读取符号[read symbol]的方式以及 Lisp 打印器[Lisp Printer]写入符号[symbol]的方式[symbol].

* 示例(Examples):

        见示例 23.1.2.1 (Lisp 读取器上的读取表大小写的影响的示例) 以及章节 22.1.3.3.2.1 (Lisp 打印器上读取表大小写影响的示例).

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 readtable 不是一个读取表[readtable], 那么应该发出一个 type-error 类型[type]的错误. 如果 mode 不是一个大小写敏感模式[case sensitivity mode], 那么应该发出一个 type-error 类型[type]的错误.

* 参见(See Also):

        *readtable*, *print-escape*, 章节 2.2 (Reader Algorithm), 章节 23.1.2 (Lisp 读取器上的读取表大小写的影响), 章节 22.1.3.3.2 (Lisp 打印器上读取表大小写的影响)

* 注意(Notes):

        copy-readtable 拷贝这个 readtable 的读取表大小写[readtable case]. 


### <span id="F-READTABLEP">函数 READTABLEP</span>

* 语法(Syntax):

        readtablep object => generalized-boolean

* 参数和值(Arguments and Values):

        object---一个对象[object].
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        如果对象 object 是 readtable 类型[type]就返回 true; 否则, 返回 false.

* 示例(Examples):

    ```LISP
    (readtablep *readtable*) =>  true
    (readtablep (copy-readtable)) =>  true
    (readtablep '*readtable*) =>  false
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes):

        (readtablep object) ==  (typep object 'readtable) 


### <span id="F-SET-AND-GET-DMC">函数 SET-DISPATCH-MACRO-CHARACTER, GET-DISPATCH-MACRO-CHARACTER</span>

* 语法(Syntax):

        get-dispatch-macro-character disp-char sub-char &optional readtable => function

        set-dispatch-macro-character disp-char sub-char new-function &optional readtable => t

* 参数和值(Arguments and Values):

        disp-char---一个字符[character].
        sub-char---一个字符[character].
        readtable---一个读取表标识符[readtable designator]. 默认是当前读取表[current readtable].
        function---一个函数标识符[function designator]或 nil.
        new-function---一个函数标识符[function designator].

* 描述(Description):

        set-dispatch-macro-character 导致在读取到 disp-char 后面跟着 sub-char 时调用 new-function. 如果 sub-char 是一个小写字母, 它会被转换为它的大写等价. 如果 sub-char 是一个十进制数字中的一个, 那么就是一个错误.

        set-dispatch-macro-character 安装一个 new-function, 当一个特定分派宏字符[dispatching macro character]对被读取到时 new-function 会被调用. new-function 作为分派函数被安装, 当这个 readtable 正在被使用并且 disp-char 后跟着 sub-char 时调用这个分派函数.

        关于这个 new-function 被调用的更多信息, 见章节 2.1.4.4 (宏字符).

        get-dispatch-macro-character 检索表 readtable 中和 disp-char 以及 sub-char 关联的分派函数.

        get-dispatch-macro-character 返回这个 sub-char 从属 disp-char 的宏字符函数, 如果这里没有和 sub-char 关联的函数那么就是 nil. 如果 sub-char 是一个十进制数字, get-dispatch-macro-character 返回 nil.

* 示例(Examples):

    ```LISP
    (get-dispatch-macro-character #\# #\{) =>  NIL
    (set-dispatch-macro-character #\# #\{        ;dispatch on #{
        #'(lambda(s c n)
            (let ((list (read s nil (values) t)))  ;list is object after #n{
              (when (consp list)                   ;return nth element of list
                (unless (and n (< 0 n (length list))) (setq n 0))
                (setq list (nth n list)))
            list))) =>  T
    #{(1 2 3 4) =>  1
    #3{(0 1 2 3) =>  3
    #{123 =>  123
    ```

        如果期望 #$foo : 就像 (dollars foo) 一样的话.

    ```LISP
    (defun |#$-reader| (stream subchar arg)
      (declare (ignore subchar arg))
      (list 'dollars (read stream t nil t))) =>  |#$-reader|
    (set-dispatch-macro-character #\# #\$ #'|#$-reader|) =>  T
    ```

* 参见(See Also):

        章节 2.1.4.4 (宏字符)

* 副作用(Side Effects):

        这个读取表 readtable 会被修改.

* 受此影响(Affected By):

        *readtable*.

* 异常情况(Exceptional Situations):

        对于任何一个函数, 如果 disp-char 不是一个 readtable 中的分派宏字符[dispatching macro character], 就会发出一个错误.

* 参见(See Also):

        *readtable*

* 注意(Notes):

        有必要在指定这个分派字符的子字符之前使用 make-dispatch-macro-character 去设置这个分派字符. 


### <span id="F-SET-AND-GET-MC">函数 SET-MACRO-CHARACTER, GET-MACRO-CHARACTER</span>

* 语法(Syntax):

        get-macro-character char &optional readtable => function, non-terminating-p

        set-macro-character char new-function &optional non-terminating-p readtable => t

* 参数和值(Arguments and Values):

        char---一个字符[character].
        non-terminating-p---一个广义 boolean [generalized boolean]. 默认是 false.
        readtable---一个读取表标识符[readtable]. 默认是当前读取表[current readtable].
        function---nil, 或者一个两参数[argument]函数[designator]的标识符[designator].
        new-function---一个函数标识符[function designator].

* 描述(Description):

        get-macro-character 返回这个在读取表 readtable 中和 char 相关联的读取器宏函数[reader macro function] function 作为它的主值[primary value] (如果有的话), 或者如果 char 不是一个读取表 readtable 中的一个宏字符[macro character], 那么就是 nil. 如果 char 是一个非终止[non-terminating]宏字符[macro character], 则第二个值[secondary value] non-terminating-p 就是 true; 否则, 它就是 false.

        set-macro-character 导致 char 成为读取表 readtable 中和读取器宏函数[reader macro function] new-function (或者 new-function 的标识符[designator]) 相关联的宏字符[macro character]. 如果 non-terminating-p 是 true, char 成为非终止[non-terminating]宏字符[macro character]; 否则它成为一个终止[terminating]宏字符[macro character].

* 示例(Examples):

    ```LISP
    (get-macro-character #\{) =>  NIL, false
    (not (get-macro-character #\;)) =>  false
    ```

        以下是标准语法[standard syntax]中的单引号[single-quote]读取器宏[reader macro]的一个可能的定义:

    ```LISP
    (defun single-quote-reader (stream char)
      (declare (ignore char))
      (list 'quote (read stream t nil t))) =>  SINGLE-QUOTE-READER
    (set-macro-character #\' #'single-quote-reader) =>  T
    ```

        这里 single-quote-reader 读取一个跟在单引号[single-quote]后面的对象[object]并且返回一个 quote 和那个对象[object]的列表[list]. 这个 char 参数被忽略.

        下面是标准语法[standard syntax]中的分号[semicolon]读取器宏[reader macro]的一个可能的定义:

    ```LISP
    (defun semicolon-reader (stream char)
      (declare (ignore char))
      ;; First swallow the rest of the current input line.
      ;; End-of-file is acceptable for terminating the comment.
      (do () ((char= (read-char stream nil #\Newline t) #\Newline)))
      ;; Return zero values.
      (values)) =>  SEMICOLON-READER
    (set-macro-character #\; #'semicolon-reader) =>  T
    ```

* 副作用(Side Effects):

        这个读取表 readtable 被修改.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        *readtable*

* 注意(Notes): None. 


### <span id="F-SET-SYNTAX-FROM-CHAR">函数 SET-SYNTAX-FROM-CHAR</span>

* 语法(Syntax):

        set-syntax-from-char to-char from-char &optional to-readtable from-readtable => t

* 参数和值(Arguments and Values):

        to-char---一个字符[character].
        from-char---一个字符[character].
        to-readtable---一个读取表[readtable]. 默认是当前读取表[current readtable].
        from-readtable---一个读取表标识符[readtable designator]. 默认是标准读取表[standard readtable].

* 描述(Description):

        set-syntax-from-char 使得 to-readtable 中的 to-char 语法和 from-readtable 中的 from-char 一样.

        set-syntax-from-char 拷贝 from-char 的语法类型[syntax type]. 如果 from-char 是一个宏字符[macro character], 它的读取器宏函数[reader macro function]也被拷贝. 如果这个字符是一个分派宏字符[dispatching macro character], 它的整个读取器宏函数[reader macro function]的分派表被拷贝. 这个 from-char 的标记成分特质[constituent trait]不会被拷贝.

        一个来自一个字符的宏定义可以被拷贝到另一个字符, 例如 "; 这个 " 的标准定义查找另一个和调用它的字符相同的字符. 另一方面, 这个 ( 的定义不能被有意义地拷贝到 {. 结果是列表[list]为 {a b c) 形式, 而不是 {a b c}, 因为这个定义总是查找一个闭合的圆括号, 不是一个闭合的大括号.

* 示例(Examples):

    ```LISP
    (set-syntax-from-char #\7 #\;) =>  T
    123579 =>  1235
    ```
    
* 副作用(Side Effects):

        这个 to-readtable 被修改.

* 受此影响(Affected By):

        在 from-readtable 中已存在的值.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        set-macro-character, make-dispatch-macro-character, 章节 2.1.4 (字符语法类型)

* 注意(Notes):

        一个字符[character]的标记成分特质[constituent trait]被 "硬连接(hard wired)" 到扩展标记[token]的解析器中. 例如, 如果 S 的定义被拷贝到 *, 那么 * 会成为一个字母[alphabetic[2]]的标记成分[constituent]但是不能被用作一个短浮点[short float]指数标记[exponent marker]. 关于进一步信息, 见章节 2.1.4.2 (标记成分特质). 


### <span id="M-WITH-STANDARD-IO-SYNTAX">宏 WITH-STANDARD-IO-SYNTAX</span>

* 语法(Syntax):

        with-standard-io-syntax form* => result*

* 参数和值(Arguments and Values):

        forms---一个隐式 progn [implicit progn].
        results---由这些表达式形式[form]返回的值[value].

* 描述(Description):

        在这些表达式形式 forms 主体的动态范围内, 所有读取器/打印器控制变量, 包括任何这个标准没有指定但是具体实现定义的[implementation-defined]那些, 被绑定为产生标准读取/打印行为的值. 这个标准指定的变量的值列在下一段中.

        变量                          值                               
        *package*                    CL-USER 包                 
        *print-array*                t                                   
        *print-base*                 10                                  
        *print-case*                 :upcase                             
        *print-circle*               nil                                 
        *print-escape*               t                                   
        *print-gensym*               t                                   
        *print-length*               nil                                 
        *print-level*                nil                                 
        *print-lines*                nil                                 
        *print-miser-width*          nil                                 
        *print-pprint-dispatch*      标准美观打印分派表[standard pprint dispatch table] 
        *print-pretty*               nil                                 
        *print-radix*                nil                                 
        *print-readably*             t                                   
        *print-right-margin*         nil                                 
        *read-base*                  10                                  
        *read-default-float-format*  single-float                        
        *read-eval*                  t                                   
        *read-suppress*              nil                                 
        *readtable*                  标准读取表[standard readtable]              

        Figure 23-1. 标准控制变量的值

* 示例(Examples):

    ```LISP
    (with-open-file (file pathname :direction :output)
      (with-standard-io-syntax
        (print data file)))

    ;;; ... Later, in another Lisp:

    (with-open-file (file pathname :direction :input)
      (with-standard-io-syntax
        (setq data (read file))))
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes): None. 


### <span id="M-WITH-STANDARD-IO-SYNTAX">变量 *READ-BASE*</span>

* 值类型(Value Type):

        一个基数[radix].

* 初始值(Initial Value):

        10.

* 描述(Description):

        控制被读取为整数[integer]或比数[ratio]的标记的解释.

        这个 *read-base* 的值[value], 称为当前的输入基数[current input base], 是整数[integer]和比数[ratio]要被 Lisp 读取器[Lisp reader]读取的基数. 其他数值类型[type] (例如, 浮点数[float])的解析不被这个选项所影响.

        *read-base* 在任何特定的有理数[rational]的读取上的效果可以通过显式使用 #O, #X, #B, 或 #nR 语法或通过一个尾部的小数点覆盖.

* 示例(Examples):

    ```LISP
    (dotimes (i 6)
      (let ((*read-base* (+ 10. i)))
        (let ((object (read-from-string "(\\DAD DAD |BEE| BEE 123. 123)")))
          (print (list *read-base* object)))))
    >>  (10 (DAD DAD BEE BEE 123 123))
    >>  (11 (DAD DAD BEE BEE 123 146))
    >>  (12 (DAD DAD BEE BEE 123 171))
    >>  (13 (DAD DAD BEE BEE 123 198))
    >>  (14 (DAD 2701 BEE BEE 123 227))
    >>  (15 (DAD 3088 BEE 2699 123 258))
    =>  NIL
    ```

* 受此影响(Affected By): None.

* 参见(See Also): None.

* 注意(Notes):

        在读取特殊格式的数据文件时, 修改输入基数是很有用的.


### <span id="V-READ-DEFAULT-FLOAT-FORMAT">变量 *READ-DEFAULT-FLOAT-FORMAT*</span>

* 值类型(Value Type):

        原子类型指定符[atomic type specifier] short-float, single-float, double-float, 或 long-float 的其中之一, 或者某个具体实现[implementation]定义的其他类型指定符[type specifier]也是可接受的.

* 初始值(Initial Value):

       符号[symbol] single-float.

* 描述(Description):

        读取一个没有指数标记[exponent marker]或者有着 e 或 E 的指数标记[exponent marker]的浮点数时控制要被使用的浮点格式. 其他指数标记[exponent marker]显式规定了要被使用的浮点数格式.

        当打印一个浮点数时, 打印器使用 *read-default-float-format* 来引导指数标记[exponent marker]的选择.

* 示例(Examples):

    ```LISP
    (let ((*read-default-float-format* 'double-float))
      (read-from-string "(1.0 1.0e0 1.0s0 1.0f0 1.0d0 1.0L0)"))
    =>  (1.0   1.0   1.0   1.0 1.0   1.0)   ;Implementation has float format F.
    =>  (1.0   1.0   1.0s0 1.0 1.0   1.0)   ;Implementation has float formats S and F.
    =>  (1.0d0 1.0d0 1.0   1.0 1.0d0 1.0d0) ;Implementation has float formats F and D.
    =>  (1.0d0 1.0d0 1.0s0 1.0 1.0d0 1.0d0) ;Implementation has float formats S, F, D.
    =>  (1.0d0 1.0d0 1.0   1.0 1.0d0 1.0L0) ;Implementation has float formats F, D, L.
    =>  (1.0d0 1.0d0 1.0s0 1.0 1.0d0 1.0L0) ;Implementation has formats S, F, D, L.
    ```

* 受此影响(Affected By): None.

* 参见(See Also): None.

* 注意(Notes): None.


### <span id="V-READ-EVAL">变量 *READ-EVAL*</span>

* 值类型(Value Type):

        一个广义 boolean [generalized boolean].

* 初始值(Initial Value):

        true.

* 描述(Description):

        如果它是 true, 那么这个 #. 读取器宏[reader macro]有着正常效果. 否则, 这个读取器宏[reader macro]发出一个 reader-error 类型[type]的错误.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 参见(See Also):

        *print-readably*

* 注意(Notes):

        如果 *read-eval* 是 false 并且 *print-readably* 是 true, 那么任何会输出一个对 #. 读取器宏[reader macro]的引用的 print-object 方法[method]会输出一个不同的东西或者发出一个 print-not-readable 类型[type]的错误.


### <span id="V-READ-SUPPRESS">变量 *READ-SUPPRESS*</span>

* 值类型(Value Type):

        一个广义 boolean [generalized boolean].

* 初始值(Initial Value):

        false.

* 描述(Description):

        这个变量主要用于支持读取时的条件标记 #+ 和 #- 的操作. 对于实现这些标记的读取器宏[reader macro]来说, 能够跳过表达式[expression]的打印表示形式是非常重要的, 尽管跳过的表达式[expression]的语法可能对当前实现不是完全有效, 因为 #+ 和 #- 的存在为了允许同一程序在多个 Lisp 语言实现 (包括除了 Common Lisp 以外的方言) 之间共享, 尽管语法上存在一些不兼容.

        如果它是 false, 那么这个 Lisp 读取器[Lisp reader]正常操作.

        如果这个 *read-suppress* 的值是 true, 那么 read, read-preserving-whitespace, read-delimited-list, 和 read-from-string 都在它们成功完成时返回一个 nil 的主值[primary value]; 但是, 它们继续用正常的方式去解析一个对象[object]的打印表示, 来跳过这个对象[object], 并且继续用正常方式去表示文件的末尾[end of file]. 除了下面记录的, 任何定义去读取[read[2]]一个后面对象[object]或标记[token]的标准[standardized]读取器宏[reader macro[2]]都会这样做, 但是如果这个读取到的对象[object]不是一个合适的类型或语法, 则不会发出一个错误. 这个标准语法[standard syntax]和它关联的读取器宏[reader macro]不会构造任何新对象[object] (比如, 当读取一个符号[symbol]的打印表示时, 没有符号[symbol]会被构造或捕捉).

        扩展标记

            所有扩展标记都完全不解释. 由于检测到无效的潜在数字[potential number], 包标记[package marker]的无效模式和点[dot]字符的无效使用, 这些错误可能会被抑制.

        分派宏字符 (包括井号[sharpsign])

            分派宏字符[dispatching macro character]继续去解析一个中缀数值参数, 并且调用分派函数. 标准[standardized]井号[sharpsign]读取器宏[reader macro]不会在这个数值参数的存在性和值上实施任何约束.

        #=

            这个 #= 标记被整个忽略. 它不会读取一个后面的对象[object]. 它不产生对象[object], 但是会被当作空格[whitespace[2]]一样对待.

        ##

            这个 ## 标记总是产生 nil.

        不管 *read-suppress* 的值[value]是什么, 圆括号仍然继续去分隔和构造列表[list]; 这个 #( 标记继续去分隔向量; 并且注释, 字符串[string], 以及单引号[single-quote]和反引号[back quote]继续去被正常解释. 像 '), #<, #), 和 #<Space> 这样的情况继续去发出错误.

* 示例(Examples):

    ```LISP
    (let ((*read-suppress* t))
      (mapcar #'read-from-string
              '("#(foo bar baz)" "#P(:type :lisp)" "#c1.2"
                "#.(PRINT 'FOO)" "#3AHELLO" "#S(INTEGER)"
                "#*ABC" "#\GARBAGE" "#RALPHA" "#3R444")))
    =>  (NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)
    ```

* 受此影响(Affected By): None.

* 参见(See Also):

        read, 章节 2 (语法)

* 注意(Notes):

        强烈鼓励定义额外宏字符[macro character]的程序员[programmer]和具体实现[implementation]去使它们遵守 *read-suppress*, 就像标准化[standardized]宏字符[macro character]那样. 这也就是说, 当 *read-suppress* 的值是 true 时, 它们应该在读取一个后续的对象[object]时忽略类型错误, 并且实现分派宏字符[dispatching macro character]的函数[function]应该接受 nil 作为它们的中缀参数[parameter]值, 即便通常要求为一个数值.


### <span id="V-READTABLE">变量 *READTABLE*</span>

* 值类型(Value Type):

        一个读取表[readtable].

* 初始值(Initial Value):

        一个符合章节 2 (语法) Common Lisp 语法描述的读取表[readtable].

* 描述(Description):

        *readtable* 的值[value]被称为当前的读取表[current readtable]. 它控制 Lisp 读取器[Lisp reader]的解析行为, 并且也可以影响 Lisp 打印器[Lisp printer] (比如, 见函数 readtable-case).

* 示例(Examples):

    ```LISP
    (readtablep *readtable*) =>  true
    (setq zvar 123) =>  123
    (set-syntax-from-char #\z #\' (setq table2 (copy-readtable))) =>  T
    zvar =>  123
    (setq *readtable* table2) =>  #<READTABLE>
    zvar =>  VAR
    (setq *readtable* (copy-readtable nil)) =>  #<READTABLE>
    zvar =>  123
    ```

* 受此影响(Affected By):

        compile-file, load

* 参见(See Also):

        compile-file, load, readtable, 章节 2.1.1.1 (当前的读取表)

* 注意(Notes): None. 


### <span id="CT-READER-ERROR">状况类型 READER-ERROR</span>

* 类优先级列表(Class Precedence List):

        reader-error, parse-error, stream-error, error, serious-condition, condition, t

* 描述(Description):

        类型[type] reader-error 由 Lisp 读取器[Lisp reader]执行的标记化和解析的错误状况组成.

* 参见(See Also):

        read, stream-error-stream, 章节 23.1 (读取器概念) 


# 24. 系统构造

> * 24.1 [系统构造的概念](#SystemConstructionConcepts)
> * 24.2 [系统构造的字典](#SystemConstructionDictionary)

## 24.1 <span id="SystemConstructionConcepts">系统构造的概念</span>

> * 24.1.1 [加载](#Loading)
> * 24.1.2 [特性](#Features)

### 24.1.1 <span id="Loading">加载</span>

去加载(load)一个文件[file]就是去把它的内容当作代码[code]并且执行[execute]那个代码[code]. 这个文件[file]可能包含源代码[source code]或编译后的代码[compiled code].

一个包含源代码[source code]的文件[file]称为源码文件[source file]. 加载一个源码文件[source file]通过顺序读取[read[2]]这个文件中的表达式形式[forms], 在读取[read]后立即求值其中的每一个来完成的.

一个包含编译后代码[compiled code]的文件[file]被称为一个编译后的文件[compiled file]. 加载一个编译后的文件[compiled file]类似于加载一个源码文件[source file], 除了这个文件[file]不会包含文本而是一种由编译器[compiler]创建的预处理表达式[expression]的依赖于具体实现[implementation-dependent]的表示. 通常, 一个编译后的文件[compiled file]可以比一个源码文件[source file]更快地加载. 见章节 3.2 (编译).

区分源码文件[source file]和编译后文件[compiled file]的方式是依赖于具体实现的[implementation-dependent].

### 24.1.2 <span id="Features">特性</span>

一个特性[feature]是 Common Lisp、具体实现[implementation]或者环境[environment]的方面或属性. 一个特性[feature]由一个符号[symbol]来标识.

当且仅当一个命名特性[feature]的符号[symbol]是变量[variable] \*features* 持有的列表[list]的一个元素[element]时, 就说这个特性[feature]出现[present]在一个 Lisp 镜像[Lisp image]中, 这个列表被称为特性列表[features list].

#### 24.1.2.1 特性表达式

称为特性表达式[feature expression]的特性[feature]的 boolean 组合被 #+ 和 #- 读取器宏[reader macro]用来指导表达式[expression]被 Lisp 读取器[Lisp reader]选择性读取.

解释一个特性表达式[feature expression]的规则如下:

特性[feature]

    如果命名一个特性[feature]的符号[symbol]被用作一个特性表达式[feature expression], 如果那个特性[feature]存在[present], 那么这个特性表达式[feature]成功; 否则就是失败.

(not feature-conditional)

    如果一个 not 特性表达式[feature expression]的参数 feature-conditional 失败了, 那么这个 not 特性表达式成功; 否则, 它失败.

(and feature-conditional*)

    如果一个 and 特性表达式[feature expression]的所有参数都成功, 那么这个 and 特性表达式成功; 否则, 它就失败.

(or feature-conditional*)

    如果一个 or 特性表达式[feature expression]的任意参数成功, 那么这个 or 特性表达式成功; 负责, 它失败.


##### 24.1.2.1.1 特性表达式的示例

比如, 假设在实现[implementation] A 中, 存在[present]特性[feature] spice 和 perq, 但是特性[feature] lispm 不存在[present]; 在实现[implementation] B 中, 存在[present]特性[feature] lispm, 但是不存在[present]特性[feature] spice 和 perq; 并且在实现[implementation] C 中, 特性[feature] spice, lispm, 或 perq 都不存在[present]. 下一段展示了一些简单表达式[expression], 以及它们在这些实现[implementation]中如何会被读取[read[2]].

    (cons #+spice "Spice" #-spice "Lispm" x)                             
                                                          
    in implementation A ...  (CONS "Spice" X)             
    in implementation B ...  (CONS "Lispm" X)             
    in implementation C ...  (CONS "Lispm" X)             
                                                          
    (cons #+spice "Spice" #+LispM "Lispm" x)                             
                                                          
    in implementation A ...  (CONS "Spice" X)             
    in implementation B ...  (CONS "Lispm" X)             
    in implementation C ...  (CONS X)                     
                                                          
    (setq a '(1 2 #+perq 43 #+(not perq) 27))                             
                                                          
    in implementation A ...  (SETQ A '(1 2 43))           
    in implementation B ...  (SETQ A '(1 2 27))           
    in implementation C ...  (SETQ A '(1 2 27))           
                                                          
    (let ((a 3) #+(or spice lispm) (b 3)) (foo a))                             
                                                          
    in implementation A ...  (LET ((A 3) (B 3)) (FOO A))  
    in implementation B ...  (LET ((A 3) (B 3)) (FOO A))  
    in implementation C ...  (LET ((A 3)) (FOO A))        
                                                          
    (cons #+Lispm "#+Spice" #+Spice "foo" #-(or Lispm Spice) 7 x)                             
                                                          
    in implementation A ...  (CONS "foo" X)               
    in implementation B ...  (CONS "#+Spice" X)           
    in implementation C ...  (CONS 7 X)                   

    Figure 24-1. 特性示例

## 24.2 <span id="SystemConstructionDictionary">系统构造的字典</span>

> * [函数 COMPILE-FILE](#F-COMPILE-FILE)
> * [函数 COMPILE-FILE-PATHNAME](#F-COMPILE-FILE-PATHNAME)
> * [函数 LOAD](#F-LOAD)
> * [宏 WITH-COMPILATION-UNIT](#M-WITH-COMPILATION-UNIT)
> * [变量 *FEATURES*](#V-FEATURES)
> * [变量 *COMPILE-FILE-PATHNAME*, *COMPILE-FILE-TRUENAME*](#V-CF-TRUENAME-PATHNAME)
> * [变量 *LOAD-PATHNAME*, *LOAD-TRUENAME*](#V-LOAD-PATHNAME-TRUENAME)
> * [变量 *COMPILE-PRINT*, *COMPILE-VERBOSE*](#V-COMPILE-PRINT-VERBOSE)
> * [变量 *LOAD-PRINT*, *LOAD-VERBOSE*](#V-LOAD-PRINT-VERBOSE)
> * [变量 *MODULES*](#V-MODULES)
> * [函数 PROVIDE, REQUIRE](#F-PROVIDE-REQUIRE)

### <span id="F-COMPILE-FILE">函数 COMPILE-FILE</span>

* 语法(Syntax):

        compile-file input-file &key output-file verbose print external-format
        => output-truename, warnings-p, failure-p

* 参数和值(Arguments and Values):

        input-file---一个路径名标识符[pathname designator]. (未指定的成员的默认填充是取自 *default-pathname-defaults*.)
        output-file---一个路径名标识符[pathname designator]. 默认值是具体实现定义的[implementation-defined].
        verbose---一个广义 boolean [generalized boolean]. 默认是 *compile-verbose* 的值[value].
        print---一个广义 boolean [generalized boolean]. 默认是 *compile-print* 的值[value].
        external-format---一个外部文件格式标识符[external file format designator]. 默认是 :default.
        output-truename---一个路径名[pathname] (输出文件[file]的真实名字 truename), 或 nil.
        warnings-p---一个广义 boolean [generalized boolean].
        failure-p---一个广义 boolean [generalized boolean].

* 描述(Description):

        compile-file 把由 input-file 指定的文件的内容转化为依赖于具体实现的[implementation-dependent]二进制数据, 放置在由 output-file 指定的文件中.

        这个 input-file 引用的文件[file]应该是一个源码文件[source file]. output-file 可以被用于指定一个输出路径名[pathname]; 编译后的代码[compiled code]要被输出到的编译后文件[compiled file]的实际路径名[pathname]就像是通过调用 compile-file-pathname 计算的一样.

        如果 input-file 或 output-file 是一个逻辑路径名[logical pathname], 那么它会像调用 translate-logical-pathname 一样被转化为一个物理路径名[physical pathname].

        如果 verbose 是 true, compile-file 用一个注释的形式打印一条信息 (换句话说, 用一个前导分号[semicolon]) 到标准输出[standard output]来表示什么文件[file]要被编译以及其他有用的信息. 如果 verbose 是 false, compile-file 不打印这个信息.

        如果 print 是 true, 关于这个要被编译的文件中的顶层表达式形式[top level form]的信息会被打印到标准输出[standard output]. 确切地说, 打印的内容依赖于具体实现[implementation-dependent], 但是仍然会打印一些信息. 如果 print 是 nil, 没有信息要被打印.

        这个 external-format 指定了当打开这个文件时要被使用的外部文件格式[external file format]; 见函数 open. compile-file 以及 load 必须以这样一种方式互操作: 产生的编译后文件[compiled file]可以不重新指定一个外部文件格式[external file format]来加载; 见函数[function] load.

        compile-file 将 *readtable* 和 *package* 绑定为它们在处理这个文件之前的值.

        *compile-file-truename* 被 compile-file 绑定来持有这个要被编译的文件路径名[pathname]的真实名字[truename].

        *compile-file-pathname* 被 compile-file 绑定来持有传递给 compile-file 的第一个参数所表示的路径名[pathname], 这个路径名和默认的合并; 这也就是说, (pathname (merge-pathnames input-file)).

        这个编译后文件[compiled file]包含的编译后的函数[function]在这个编译后文件[compiled file]被加载入 Lisp 中时是可用的. 任何由编译器处理的函数定义, 包括 #'(lambda ...) 表达式形式和由 flet, labels 创建的局部函数定义以及 defun 表达式形式, 产生一个 compiled-function 类型[type]的对象[object].

        由 compile-file 返回的主值[primary value] output-truename 是那个输出文件的真实名字[truename], 或者如果这个文件没有被创建那么就是 nil.

        如果编译器没有检测到 error 或 warning 类型[type]的状况[condition], 第二个值[secondary value] warnings-p 就是 false, 否则就是 true.

        如果编译器没有检测到 error 或 warning 类型的状况 (除了 style-warning), 第三个值[tertiary value] failure-p 就是 false, 否则就是 true.

        关于这个文件编译器[file compiler]如何处理文件[file]的一般信息, 见章节 3.2.3 (文件编译).

        要被文件编译器编译[file compiler]的程序[program]必须只包含可外部化对象[externalizable object]; 关于这样的对象[object]的详细信息, 见章节 3.2.4 (编译后文件中的字面化对象). 关于如何去扩展可外部化对象[externalizable object]集合的信息, 见函数[function] make-load-form 和章节 3.2.4.4 (外部化对象的附加约束).

* 示例(Examples): None.

* 受此影响(Affected By):

        *error-output*, *standard-output*, *compile-verbose*, *compile-print*

        计算机的文件系统.

* 异常情况(Exceptional Situations):

        关于编译处理期间的错误检测的信息, 见章节 3.2.5 (编译器中的异常情况).

        如果 (wild-pathname-p input-file) 返回 true, 那么可能会发出一个 file-error 类型[type]的错误.

        如果尝试去打开一个用于输入的源码文件[source file]或者尝试去打开一个用于输出的编译后文件[compiled file]失败了, 那么就会发出一个 file-error 类型[type]的错误.

* 参见(See Also):

        compile, declare, eval-when, pathname, logical-pathname, 章节 20.1 (文件系统概念), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes): None.


### <span id="F-COMPILE-FILE-PATHNAME">函数 COMPILE-FILE-PATHNAME</span>

* 语法(Syntax):

        compile-file-pathname input-file &key output-file &allow-other-keys => pathname

* 参数和值(Arguments and Values):

        input-file---一个路径名标识符[pathname designator]. (对于未指定成员的填充取自于 *default-pathname-defaults*.)
        output-file---一个路径名标识符[pathname designator]. 默认是具体实现定义的[implementation-defined].
        pathname---一个路径名[pathname].

* 描述(Description):

        如果给定相同参数的话, 这个函数返回 compile-file 会写入的路径名[pathname].

        这个 output-file 的默认值取自于合并 input-file 和 *default-pathname-defaults* 的值[value]所产生的路径名[pathname], 除了那个 type 成员应该是适当的具体实现定义的[implementation-defined]用于编译后文件[compiled file]的默认类型.

        如果 input-file 是一个逻辑路径名[logical pathname]并且 output-file 没有被提供, 那么结果也是一个逻辑路径名[logical pathname]. 如果 input-file 是一个逻辑路径名[logical pathname], 它会像调用 translate-logical-pathname 一样转化为一个物理路径名. 如果 input-file 是一个流[stream], 那个流[stream]可以是打开的或关闭的. compile-file-pathname 在一个文件被关闭后返回和那个文件开始时返回的相同的路径名[pathname]. 如果 input-file 是一个用 make-two-way-stream, make-echo-stream, make-broadcast-stream, make-concatenated-stream, make-string-input-stream, make-string-output-stream 创建的流[stream], 那么就是一个错误.

        如果一个具体实现支持给 compile-file 的额外参数, 那么 compile-file-pathname 必须接受相同的参数.

* 示例(Examples):

        见 logical-pathname-translations.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果 input-file 或 output-file 是通配符[wild], 那么就会发出一个 file-error 类型[type]的错误.

* 参见(See Also):

        compile-file, pathname, logical-pathname, 章节 20.1 (文件系统概念), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes): None.


### <span id="F-LOAD">函数 LOAD</span>

* 语法(Syntax):

        load filespec &key verbose print if-does-not-exist external-format
        => generalized-boolean

* 参数和值(Arguments and Values):

        filespec---一个流[stream], 或者一个路径名标识符[pathname designator]. 默认值取自于 *default-pathname-defaults*.
        verbose---一个广义 boolean [generalized boolean]. 默认是 *load-verbose* 的值[value].
        print---一个广义 boolean [generalized boolean]. 默认是 *load-print* 的值[value].
        if-does-not-exist---一个广义 boolean. 默认是 true.
        external-format---一个外部文件格式标识符[external file format designator]. 默认是 :default.
        generalized-boolean---一个广义 boolean [generalized boolean].

* 描述(Description):

        load 加载[load]由 filespec 命名的文件[name]到这个 Lisp 环境中.

        一个源码文件[source file]和一个编译后文件[compiled file]的区分方式是依赖于具体实现的[implementation-dependent]. 如果这个文件说明是不完整的并且匹配的源码文件[source file]和编译后文件[compiled file]都存在, 那么这些文件中的哪一个被 load 选择是依赖于具体实现的[implementation-dependent].

        如果 filespec 是一个流[stream], load 确定流[stream]的种类并且直接从那个流[stream]中加载. 如果 filespec 是一个逻辑路径名[logical pathname], 它会像调用 translate-logical-pathname 一样被转化为一个物理路径名[physical pathname].

        load 顺序依次执行在这个由 filespec 命名的文件[file]中它遇到的每一个表达式形式[form]. 如果这个文件[file]是一个源码文件[source file]并且这个具体实现[implementation]选择去执行隐式编译[implicit compilation], load 必须按章节 3.2.3.1 (顶层表达式形式的处理) 中描述的那样识别顶层表达式形式[top level form]并且安排每一个顶层表达式形式[top level form]在开始下一个隐式编译前被执行. (然而, 注意由 load 处理的 eval-when 表达式形式是由 :execute 情况控制的.)

        如果 verbose 是 true, compile-file 用一个注释的形式打印一个信息 (换句话说, 用一个前导分号[semicolon]) 到标准输出[standard output]来表示什么文件要被编译以及其他有用的信息. 如果 verbose 是 false, compile-file 不打印这个信息.

        如果 print 是 true, load 递增地打印信息到标准输出[standard output]来展示这个加载的进度. 对于一个源码文件[source file], 这个信息可能意味着这个文件[file]中的每一个表达式形式[form]产生的值[value]在这些值[value]返回时被打印. 对于一个编译后文件[compiled file], 打印到东西可能不会准确反映这个源码文件[source file]的内容, 但有些信息通常是打印出来的. 如果 print 是 false, load 不会打印这个信息.

        如果这个由 filespec 命名的文件被成功加载, load 返回 true.

        如果这个文件不存在, 采取依赖于 if-does-not-exist 的特定动作: 如果它是 nil, load 返回 nil; 否则, load 发出一个错误.

        这个 external-format 指定了当打开这个文件[file]时要被使用的外部文件格式[external file format] (见函数[file] open), 除了当 filespec 命名的文件[file]是一个编译后文件[complied file]时, 这个 external-format 会被忽略. compile-file 和 load 以一种依赖于具体实现的[implementation-dependent]方式互操作, 来确保这个源码文件[source file]被文件编译器[file compiler]以给定外部文件格式[external file format]处理时, 在这个源码文件[source file]中引用的字符[character]的相似性[similarity]的保留, 不管这个 external-format 的值在编译后文件[compiled file]被加载时是什么.

        load 将 *readtable* 和 *package* 绑定为它们在处理这个文件之前的值.

        *load-truename* 被 load 绑定[bound]来持有那个要被加载的文件路径名[pathname]的真实名字[truename].

        *load-pathname* 被 load 绑定[bound]来持有一个路径名[name], 这个路径名表示 filespec 和默认值合并的结果. 这也就是说, (pathname (merge-pathnames filespec)).

* 示例(Examples):

    ```LISP
    ;Establish a data file...
    (with-open-file (str "data.in" :direction :output :if-exists :error)
      (print 1 str) (print '(setq a 888) str) t)
    =>  T
    (load "data.in") =>  true
    a =>  888
    (load (setq p (merge-pathnames "data.in")) :verbose t)
    ; Loading contents of file /fred/data.in
    ; Finished loading /fred/data.in
    =>  true
    (load p :print t) 
    ; Loading contents of file /fred/data.in
    ;  1
    ;  888
    ; Finished loading /fred/data.in
    =>  true

    ;----[Begin file SETUP]----
    (in-package "MY-STUFF")
    (defmacro compile-truename () `',*compile-file-truename*)
    (defvar *my-compile-truename* (compile-truename) "Just for debugging.")
    (defvar *my-load-pathname* *load-pathname*)
    (defun load-my-system ()
      (dolist (module-name '("FOO" "BAR" "BAZ"))
        (load (merge-pathnames module-name *my-load-pathname*))))
    ;----[End of file SETUP]----

    (load "SETUP")
    (load-my-system)
    ```

* 受此影响(Affected By):

        具体实现, 以及主机计算机的文件系统.

* 异常情况(Exceptional Situations):

        如果 :if-does-not-exist 被提供并且是 true, 或者没有被提供, 那么如果这个由 filespec 命名的文件不存在或者文件系统[file system]不能处理这个请求的操作, 那么就会发出一个 file-error 类型[type]的错误.

        如果 (wild-pathname-p filespec) 返回 true, 那么就可能发出一个 file-error 类型[type]的错误.

* 参见(See Also):

        error, merge-pathnames, *load-verbose*, *default-pathname-defaults*, pathname, logical-pathname, 章节 20.1 (文件系统概念), 章节 19.1.2 (路径名作为文件名)

* 注意(Notes): None.


### <span id="M-WITH-COMPILATION-UNIT">宏 WITH-COMPILATION-UNIT</span>

* 语法(Syntax):

        with-compilation-unit ([[option]]) form* => result*

        option::= :override override

* 参数和值(Arguments and Values):

        override---一个广义 boolean [generalized boolean]; 求值的. 默认是 nil.
        forms---一个隐式 progn [implicit progn].
        results---由这些表达式形式[form]返回的值[value].

* 描述(Description):

        从左到右执行表达式形式 forms. 在这个 with-compilation-unit 的动态环境[dynamic environment]中, 被编译器推迟到这个编译结束的动作会被推迟到这个对 with-compilation-unit 的最外部调用的结束.

        具体实现可以扩展允许的 options 选项集合, 但是仅有的标准[standardized]关键字是 :override.

        如果是动态嵌套, 那么只有那个更外部的对 with-compilation-unit 的调用有效, 除非和 :override 关联的值是 true, 在这个情况下警告只会被推迟到 override 为 true 的最内部调用的结束.

        函数 compile-file 提供了

        (with-compilation-unit (:override nil) ...)

        围绕在它的代码[code]周围的效果.

        任何依赖于具体实现[implementation-dependent]的扩展只能通过使用依赖于具体实现[implementation-dependent]的关键字作为程序员显式请求的结果提供. 具体实现[implementation]禁止去为没有涉及关键字或只有关键字 :override 的这个宏的使用添加额外的意义.

* 示例(Examples):

        如果一个具体实现[implementation]会正常地推迟特定种类的警告(例如关于未定义函数的警告)到这个编译单元的结束 (例如一个文件[file]), 那么下面这个示例展示了如何将这些警告推迟到几个文件的编译结束.

    ```LISP
    (defun compile-files (&rest files)
      (with-compilation-unit ()
        (mapcar #'(lambda (file) (compile-file file)) files)))

    (compile-files "A" "B" "C")
    ```

        但是注意, 如果具体实现没有正常地推迟任何警告, 使用 with-compilation-unit 可能没有任何效果.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        compile, compile-file

* 注意(Notes): None.


### <span id="V-FEATURES">变量 *FEATURES*</span>

* 值类型(Value Type):

        一个正规列表[proper list].

* 初始值(Initial Value):

        依赖于具体实现的[implementation-dependent].

* 描述(Description):

        这个 *features* 的值[value]被称为特性列表[feature list]. 它是一个被称为特性[feature]的符号[symbol]列表[list], 这些符号对应于具体实现[implementation]或环境[environment]的某个方面.

        大部分特性[feature]有着依赖于具体实现[implementation-dependent]的意义; 特性名称被赋予以下含义:

        :cltl1

            如果出现, 表示这个 LISP 包声称符合[purports to conform] 1984 Common Lisp : The Language 规范. 对于一个符合规范的实现[conforming implementation], 可能但不是必须有这个特性, 因为这个规范指定它的符号[symbol]在 COMMON-LISP 包中, 而不是 LISP 包.

        :cltl2

            如果出现, 表示这个实现声称符合[purports to conform] Common Lisp: The Language, Second Edition. 这个特性一定不会出现在任何符合规范的实现[conforming implementation]中, 因为那个文档的规范性和这个说明的规范性不兼容. 但是, 这个说明保留了这个名称, 以便帮助程序区分符合该文档的实现和符合该这个说明的实现.

        :ieee-floating-point

            如果出现, 表示这个具体实现声称符合[purports to conform] IEEE Standard for Binary Floating-Point Arithmetic 的要求.

        :x3j13

            如果出现, 表示这个实现符合此规范的某些特定工作草案, 或者符合某些特性子集, 这些特性近似于对该规范可能包含的内容的理念. 一个符合规范的实现可能或可能不会包含这样的特性. (这个特性主要是作为一种权宜之计, 以便在标准草案可用之前为实现者提供一些可用的东西, 来阻止他们过早地引入 :draft-ansi-cl 和 :ansi-cl 特性.)

        :draft-ansi-cl

            如果出现, 表示这个实现[implementation]声称符合[purports to conform]这个规范的第一个完整草案, 它在 1992 年被公开复审. 一个有着 :draft-ansi-cl-2 或 :ansi-cl 特性的符合规范的实现[conforming implementation]不允许去保留这个 :draft-ansi-cl 特性[feature], 因为在第一个草案之后进行了不兼容的修改.

        :draft-ansi-cl-2

            如果出现, 表示这个规范的第二个完整草案已经公开复审, 并且这个实现[implementation]声称符合[purports to conform]这个规范. (如果产生另外的公开复审草案, 这个关键字会继续与引用第二个草案, 而额外的关键字会被添加来标识后面的这些草案的规范性. 同样地, 这个关键字的意义可以被认为不随时间改变). 如果最终被认可的标准和这个标准草案不兼容, 一个有着 :ansi-cl 特性[feature]的符合规范的实现[conforming implementation]只允许去保留 :draft-ansi-cl 特性[feature].

        :ansi-cl

            如果出现, 表示这个规范已经被 ANSI 采用作为官方标准, 并且这个实现[implementation]声称符合[purports to conform]了.

        :common-lisp

            这个特性必须出现在任何有着 :x3j13, :draft-ansi-cl, 或 :ansi-cl 中的一个或多个特性的实现的 *features* 中. 它还应该出现在具有 :cltl1 或 :cltl2 特性的实现中, 但是这个规范不能强制这样的行为. 其目的是, 该特性应该识别名为 "Common Lisp" 的语言家族, 而不是该家族中的某些特定方言.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 参见(See Also):

        章节 1.5.2.1.1 (读取时条件的使用), 章节 2.4 (标准宏字符)

* 注意(Notes):

        这个 *features* 的值[value]被 #+ 和 #- 读取器语法所使用.

        特性列表[feature list]中的符号[symbol]可能在任何包[package]中, 但是实际上它们通常在 KEYWORD 包中. 这是因为 KEYWORD 是在 #+ 和 #- 读取器宏[reader macro]中读取[read[2]]特性表达式[feature expression]默认使用的包[package]. 需要在一个包[pacakge] P 中 (除了 KEYWORD 以外) 命名一个特性[feature[2]]的代码[code]可以通过显式使用 P 的包前缀[package prefix]来完成, 但是注意这样的代码必须确保这个包[package] P 存在, 以便读取[read[2]]特性表达式[feature expression]---即使在特性表达式[feature expression]预期失败的情况下也是如此.

        通常认为, 具体实现[implementation]包含一个或多个标识特定实现[implementation]的特性[feature]是明智的, 这样就可以写出条件表达式来区分一个实现[implementation]的特质和另一个实现的那些特质. 由于特性通常是 KEYWORD 包中的符号[symbol], 在那里名字冲突可能很容易发生, 并且由于没有设计独特已定义的机制去决定谁有权使用哪些符号[symbol]出于什么原因, 一个保守的策略是更喜欢使用来源于自己的公司或产品名称的名字, 因为那些名字通常是商标, 因此不太可能无意中被另一个实现[implementation]使用.


### <span id="V-CF-TRUENAME-PATHNAME">变量 *COMPILE-FILE-PATHNAME*, *COMPILE-FILE-TRUENAME*</span>

* 值类型(Value Type):

        这个 *compile-file-pathname* 的值[value]总是为一个路径名[pathname]或 nil. 这个 *compile-file-truename* 的值[value]总是为一个物理路径名[physical pathname]或 nil.

* 初始值(Initial Value):

        nil.

* 描述(Description):

        在对 compile-file 的调用期间, *compile-file-pathname* 被绑定[bound]为 compile-file 的第一个参数所表示的路径名[pathname]和默认值合并的路径名[pathname]; 就是说, 它被绑定[bound]为 (pathname (merge-pathnames input-file)). 在相同的时间间隔期间, *compile-file-truename* 被绑定[bound]为这个要被编译的文件[file]的真实名字[truename].

        在其他时间, 这些变量的值[value]都是 nil.

        如果在 compile-file 正在进行时进入一个中断循环[break loop], 那么这些变量[variable]是否保留在进入中断循环[break loop]之前的值[value]还是被绑定[bound]为 nil, 都依赖于具体实现[implementation-dependent].

        如果尝试去对这些变量的任意一个赋值[assign]或绑定[bind], 后果是未定义的.

* 示例(Examples): None.

* 受此影响(Affected By):

        文件系统[file system].

* 参见(See Also):

        compile-file

* 注意(Notes): None.


### <span id="V-LOAD-PATHNAME-TRUENAME">变量 *LOAD-PATHNAME*, *LOAD-TRUENAME*</span>

* 值类型(Value Type):

        这个 *load-pathname* 的值[value]总是为一个路径名[pathname]或 nil. 这个 *load-truename* 的值[pathname]总是为一个物理路径名[physical pathname]或 nil.

* 初始值(Initial Value):

        nil.

* 描述(Description):

        在一个对 load 调用期间, *load-pathname* 被绑定[bound]为 load 的第一个参数所表示的路径名[pathname]和默认值合并的路径名[pathname]; 这也就是说, 它被绑定[bound]为 (pathname (merge-pathnames filespec)). 在相同的时间间隔期间, *load-truename* 被绑定[bound]为这个要被加载的文件[file]的真实名字[truename].

        在其他时间, 这些变量[variable]的值[value]都是 nil.

        如果在 load 正在进行时进入一个中断循环[break loop], 那么这些变量[variable]是否保留在进入中断循环[break loop]之前的值[value]还是被绑定[bound]为 nil, 都依赖于具体实现[implementation-dependent].

        如果尝试去对这些变量的任意一个赋值[assign]或绑定[bind], 后果是未定义的.

* 示例(Examples): None.

* 受此影响(Affected By):

        文件系统[file system].

* 参见(See Also):

        load

* 注意(Notes): None.


### <span id="V-COMPILE-PRINT-VERBOSE">变量 *COMPILE-PRINT*, *COMPILE-VERBOSE*</span>

* 值类型(Value Type):

        一个广义 boolean [generalized boolean].

* 初始值(Initial Value):

        依赖于具体实现[implementation-dependent].

* 描述(Description):

        这个 *compile-print* 的值[value]是给 compile-file 的 :print 参数[argument]的默认值. 这个 *compile-verbose* 的值[value]是给 compile-file 的 :verbose 参数[argument]的默认值.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 参见(See Also):

        compile-file

* 注意(Notes): None.


### <span id="V-LOAD-PRINT-VERBOSE">变量 *LOAD-PRINT*, *LOAD-VERBOSE*</span>

* 值类型(Value Type):

        一个广义 boolean [generalized boolean].

* 初始值(Initial Value):

        这个 *load-print* 的初始值[value]是 false. 这个 *load-verbose* 的初始值[value]是依赖于具体实现的[implementation-dependent].

* 描述(Description):

        这个 *load-print* 的值[value]是给 load 的 :print 参数[argument]的默认值. 这个 *load-verbose* 的值[value]是给 load 的 :verbose 参数[argument]的默认值.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 参见(See Also):

        load

* 注意(Notes): None.


### <span id="V-MODULES">变量 *MODULES*</span>

* 值类型(Value Type):

        一个字符串[string]列表[list].

* 初始值(Initial Value):

        依赖于具体实现[implementation-dependent].

* 描述(Description):

        这个 *modules* 的值[value]是一个已经被加载到当前 Lisp 镜像[Lisp image]中的模块名称列表.

* 示例(Examples): None.

* 受此影响(Affected By):

        provide

* 参见(See Also):

        provide, require

* 注意(Notes):

        这个 *modules* 变量已经被废弃.


### <span id="F-PROVIDE-REQUIRE">函数 PROVIDE, REQUIRE</span>

* 语法(Syntax):

        provide module-name => 依赖于具体实现[implementation-dependent]

        require module-name &optional pathname-list => 依赖于具体实现[implementation-dependent]

* 参数和值(Arguments and Values):

        module-name---一个字符串标识符[string designator].
        pathname-list---nil, 或者一个非空[non-empty]路径名标识符[pathname designator]列表[list]的标识符[designator]. 默认是 nil.

* 描述(Description):

        如果 module-name 还没有出现在由 *modules* 持有的列表[list]中, 那么 provide 添加这个 module-name 到该列表[list]中.

        require 检验 module-name 在 *modules* 所持有的列表[list]中的存在性. 如果它存在, require 立即返回. 否则, 按照下面所述尝试去加载一个文件[file]的适当集合: 这个 pathname-list 参数, 如果非 nil [non-nil], 就指定一个要被从左到右依次加载的路径名[pathname]列表. 如果这个 pathname-list 是 nil, 一个依赖于具体实现[implementation-dependent]的机制会被调用来加载名为 module-name 的模块; 如果没有这样的模块可以被加载, 会发出一个 error 类型[type]的错误.

        两个函数都使用 string= 来检测一个 module-name 的存在性.

* 示例(Examples):

    ```LISP
    ;;; This illustrates a nonportable use of REQUIRE, because it
    ;;; depends on the implementation-dependent file-loading mechanism.

    (require "CALCULUS")

    ;;; This use of REQUIRE is nonportable because of the literal 
    ;;; physical pathname.  

    (require "CALCULUS" "/usr/lib/lisp/calculus")

    ;;; One form of portable usage involves supplying a logical pathname,
    ;;; with appropriate translations defined elsewhere.

    (require "CALCULUS" "lib:calculus")

    ;;; Another form of portable usage involves using a variable or
    ;;; table lookup function to determine the pathname, which again
    ;;; must be initialized elsewhere.

    (require "CALCULUS" *calculus-module-pathname*)
    ```

* 副作用(Side Effects):

        provide 修改 *modules*.

* 受此影响(Affected By):

        由 require 采取的特定动作受 provide 调用影响 (或者, 一般而言, 任何对 *modules* 的值[value]的改变).

* 异常情况(Exceptional Situations):

        如果 module-name 不是一个字符串标识符[string designator], 那么就应该发出一个 type-error 类型[type]的错误.

        如果 require 由于一个和文件系统[file system]交互时的问题而未完成那个请求的操作, 那么就会发出一个 file-error 类型[type]的错误.

        如果在 pathname-list 中的任意路径名[pathname]是一个通配符[wild]路径名[pathname]的标识符[designator], 那么就会发出一个 file-error 类型[type]的错误.

* 参见(See Also):

        *modules*, 章节 19.1.2 (路径名作为文件名)

* 注意(Notes):

        函数 provide 和 require 已经被废弃.

        如果一个模块由单独的包[package]组成, 照惯例这个包和模块名是相同的.


# 25. 环境

> * 25.1 [外部环境](#TheExternalEnvironment)
> * 25.2 [环境字典](#TheEnvironmentDictionary)

## 25.1 <span id="TheExternalEnvironment">外部环境</span>

> * 25.1.1 [顶层循环](#TopLevelLoop)
> * 25.1.2 [调试工具](#DebuggingUtilities)
> * 25.1.3 [环境查询](#EnvironmentInquiry)
> * 25.1.4 [时间](#Time)

### 25.1.1 <span id="TopLevelLoop">顶层循环</span>

顶层循环是用户用来和 Common Lisp 系统正常交互的 Common Lisp 机制. 这个循环有时被称为 Lisp read-eval-print 循环[Lisp read-eval-print loop], 因为它通常由一个读取一个表达式、对它求值然后打印结果这样的无止尽的循环组成.

这个顶层循环没有被完全指定; 因此用户接口是具体实现定义的[implementation-defined]. 这个顶层循环打印所有来自于求值一个表达式形式[form]的值. 下一段中列出了由 Lisp read-eval-print 循环[Lisp read-eval-print loop]来维护的变量.

    *    +    /    -  
    **   ++   //
    ***  +++  ///

    Figure 25-1. 由 Read-Eval-Print 循环来保存的变量

### 25.1.2 <span id="DebuggingUtilities">调试工具</span>

下一段展示了和调试相关的已定义的名字[defined name].

    *debugger-hook*  documentation    step
    apropos          dribble          time
    apropos-list     ed               trace
    break            inspect          untrace  
    describe         invoke-debugger

    Figure 25-2. 和调试相关的已定义的名字

### 25.1.3 <span id="EnvironmentInquiry">环境查询</span>

环境查询的已定义名字[defined name]提供了关于硬件和软件配置的信息, 一个 Common Lisp 程序基于这些信息执行.

下一段展示了和环境查询相关的已定义名字[defined name].

    *features*                   machine-instance  short-site-name
    lisp-implementation-type     machine-type      software-type
    lisp-implementation-version  machine-version   software-version  
    long-site-name               room

    Figure 25-3. 和环境查询相关的已定义名字.

### 25.1.4 <span id="Time">时间</span>

时间在 Common Lisp 中用四种不同的方式被表示: 解码时间[decoded time], 通用时间[universal time], 内部时间[internal time]和秒. 解码时间[decoded time]和通用时间[universal time]主要被用于表示日历时间, 并且只精确到秒. 内部时间[internal time]主要被用于表示计算机时间的度量 (例如运行时间) 并且精确到某个依赖于具体实现[implementation-dependent]的秒的碎片, 称之为内部时间单元[internal time unit], 由 internal-time-units-per-second 指定. 一个内部时间[internal time]可以被用于绝对[absolute]和相对[relative]的时间[time]度量. 一个通用时间[universal time]和一个解码时间[decoded time]都只能被用于绝对[absolute]时间[time]度量. 在一个 sleep 函数的情况中, 时间间隔被表示为一个秒的非负实数[real].

下一段展示了和时间[time]相关的已定义名字[defined name].

    decode-universal-time   get-internal-run-time
    encode-universal-time   get-universal-time
    get-decoded-time        internal-time-units-per-second  
    get-internal-real-time  sleep

    Figure 25-4. 时间相关的已定义名字.

> * 25.1.4.1 [解码时间](#DecodedTime)
> * 25.1.4.2 [通用时间](#UniversalTime)
> * 25.1.4.3 [内部时间](#InternalTime)
> * 25.1.4.4 [秒](#Seconds)

#### 25.1.4.1 <span id="DecodedTime">解码时间</span>

一个解码时间[decoded time]是一个 9 个值的有序序列, 加在一起表示日历时间中的一个点 (忽略闰秒[leap seconds]):

    Second

        一个 0 和 59 之间的整数[integer], 是包含的.

    Minute

        一个 0 和 59 之间的整数[integer], 是包含的.

    Hour

        一个 0 和 23 之间的整数[integer], 是包含的.

    Date

        一个 1 和 31 之间的整数[integer], 是包含的 (当然这个上限实际上依赖于月份和年).

    Month

        一个 1 和 12 之间的整数[integer], 是包含的; 1 意味着 January, 2 意味着 February, 以此类推; 12 意味着 December.

    Year

        一个表示公元年的整数[integer]. 然而, 如果这个整数[integer]在 0 和 99 之间, 使用 "清楚的(obvious)" 的年; 更确切地说, 假设那一年等于整数[integer]模100, 并且在本年度的 50 年内 (向后包含但是向前不包含). 因此, 在 1978 年, 年 28 是 1928 但是年 27 是 2027. (以这种格式返回时间的函数总是返回全年数字.)

    Day of week

        一个 0 和 6 之间的整数[integer], 是包含的; 0 意味着周一(Monday), 1 意味着周二(Tuesday), 以此类推; 6 意味着周日(Sunday).

    Daylight saving time flag

        一个广义 boolean [generalized boolean], 如果为 true, 表示夏令时生效.

    Time zone

        一个时区[time zone].

下一段展示了和解码时间[decoded time]相关的已定义名字[defined name].

    decode-universal-time  get-decoded-time  

    Figure 25-5. 解码时间中涉及时间的已定义名字.


#### 25.1.4.2 <span id="UniversalTime">通用时间</span>

通用时间[universal time]是一个表示为一个单独的非负整数[integer]的绝对[absolute]时间[time]---这个整数[integer]是从 January 1, 1900 GMT (忽略闰秒[leap seconds]) 半夜开始的秒数. 因此时间 1 就是 00:00:01 (也就是说, 12:00:01 a.m.) January 1, 1900 GMT. 类似地, 时间 2398291201 对应于时间 00:00:01 January 1, 1976 GMT. 回想一下, 1900 年不是闰年; 出于 Common Lisp 的用途, 当且仅当一个年的数字可以被 4 整除, 那么这年是一个闰年, 除了可以被 100 整除的年不是闰年, 可以被 400 整除的年是闰年. 因此 2000 年会是一个闰年. 因为通用时间[universal time]必须是一个非负整数[integer], 在 January 1, 1900 GMT 半夜之前的时间不能被 Common Lisp 处理.

    decode-universal-time  get-universal-time  
    encode-universal-time

    Figure 25-6. 在通用时间中涉及时间的已定义名称.


#### 25.1.4.3 <span id="InternalTime">内部时间</span>

内部时间[internal time]把时间表示为一个单独的整数[integer], 根据一个称之为内部时间单位[internal time unit]的依赖于具体实现[implementation-dependent]的单位. 相对时间用这些单位的数量来衡量. 绝对时间是相对于任意的时间基数的.

下一段展示了和内部时间[internal time]相关的已定义名字[defined name].

    get-internal-real-time  internal-time-units-per-second  
    get-internal-run-time

    Figure 25-7. 在内部时间中涉及时间的已定义名称.


#### 25.1.4.4 <span id="Seconds">秒</span>

一个函数, sleep, 它的参数是一个秒的非负实数[real]. 非正式地, 把这看作一个相对的[relative]通用时间[universal time]可能是有用的, 但它在一个重要的方面是不同的: 通用时间[universal time]总是非负整数[integer], 而 sleep 的参数可以是任何非负实数[real], 以便考虑到分数秒的可能性.

    sleep

    Figure 25-8. 在秒中涉及时间的已定义名称.


## 25.2 <span id="TheEnvironmentDictionary">环境字典</span>

> * [函数 DECODE-UNIVERSAL-TIME](#F-DECODE-UNIVERSAL-TIME)
> * [函数 ENCODE-UNIVERSAL-TIME](#F-ENCODE-UNIVERSAL-TIME)
> * [函数 GET-UNIVERSAL-TIME, GET-DECODED-TIME](#F-GET-TIME-ALL)
> * [函数 SLEEP](#F-SLEEP)
> * [函数 APROPOS, APROPOS-LIST](#F-APROPOS-ALL)
> * [函数 DESCRIBE](#F-DESCRIBE)
> * [标准广义函数 DESCRIBE-OBJECT](#SGF-DESCRIBE-OBJECT)
> * [宏 TRACE, UNTRACE](#M-TRACE-UNTRACE)
> * [宏 STEP](#M-STEP)
> * [宏 TIME](#M-TIME)
> * [常量 INTERNAL-TIME-UNITS-PER-SECOND](#CV-INTERNAL-TIME-UNITS-PER-SECOND)
> * [函数 GET-INTERNAL-REAL-TIME](#F-GET-INTERNAL-REAL-TIME)
> * [函数 GET-INTERNAL-RUN-TIME](#F-GET-INTERNAL-RUN-TIME)
> * [函数 DISASSEMBLE](#F-DISASSEMBLE)
> * [标准广义函数 DOCUMENTATION, (SETF DOCUMENTATION)](#SGF-DOCUMENTATION-ALL)
> * [函数 ROOM](#F-ROOM)
> * [函数 ED](#F-ED)
> * [函数 INSPECT](#F-INSPECT)
> * [函数 DRIBBLE](#F-DRIBBLE)
> * [常量 -](#V-MINUS)
> * [常量 +, ++, +++](#V-ADD-ALL)
> * [常量 *, **, ***](#V-ASTERISK)
> * [常量 /, //, ///](#V-SLASH)
> * [函数 LISP-IMPLEMENTATION-TYPE, LISP-IMPLEMENTATION-VERSION](#F-LISP-IMPLEMENTATION-ALL)
> * [函数 SHORT-SITE-NAME, LONG-SITE-NAME](#F-SITE-NAME-ALL)
> * [函数 MACHINE-INSTANCE](#F-MACHINE-INSTANCE)
> * [函数 MACHINE-TYPE](#F-MACHINE-TYPE)
> * [函数 MACHINE-VERSION](#F-MACHINE-VERSION)
> * [函数 SOFTWARE-TYPE, SOFTWARE-VERSION](#F-SOFTWARE-ALL)
> * [函数 USER-HOMEDIR-PATHNAME](#F-USER-HOMEDIR-PATHNAME)

### <span id="F-DECODE-UNIVERSAL-TIME">函数 DECODE-UNIVERSAL-TIME</span>

* 语法(Syntax):

        decode-universal-time universal-time &optional time-zone
        => second, minute, hour, date, month, year, day, daylight-p, zone

* 参数和值(Arguments and Values):

        universal-time---一个通用时间[universal time].
        time-zone---一个时区[time zone].
        second, minute, hour, date, month, year, day, daylight-p, zone---一个解码时间[decoded time].

* 描述(Description):

        返回给定的通用时间[universal time]表示的解码时间[decoded time].

        如果没有提供 time-zone, 它默认为当前时区, 调整为夏令时. 如果提供了 time-zone, 忽略夏令时信息. 如果提供了 time-zone 那么夏令时标志就是 nil.

* 示例(Examples):

    ```LISP
    (decode-universal-time 0 0) =>  0, 0, 0, 1, 1, 1900, 0, false, 0

    ;; The next two examples assume Eastern Daylight Time.
    (decode-universal-time 2414296800 5) =>  0, 0, 1, 4, 7, 1976, 6, false, 5
    (decode-universal-time 2414293200) =>  0, 0, 1, 4, 7, 1976, 6, true, 5

    ;; This example assumes that the time zone is Eastern Daylight Time
    ;; (and that the time zone is constant throughout the example).
    (let* ((here (nth 8 (multiple-value-list (get-decoded-time)))) ;Time zone
            (recently (get-universal-time))
            (a (nthcdr 7 (multiple-value-list (decode-universal-time recently))))
            (b (nthcdr 7 (multiple-value-list (decode-universal-time recently here)))))
      (list a b (equal a b))) =>  ((T 5) (NIL 5) NIL)
    ```

* 受此影响(Affected By):

        用于计算任何给定会话的夏令时何时生效或是否生效的依赖于具体实现的[implementation-dependent]的机制.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        encode-universal-time, get-universal-time, 章节 25.1.4 (时间)

* 注意(Notes): None.


### <span id="F-ENCODE-UNIVERSAL-TIME">函数 ENCODE-UNIVERSAL-TIME</span>

* 语法(Syntax):

        encode-universal-time second minute hour date month year &optional time-zone
        => universal-time

* 参数和值(Arguments and Values):

        second, minute, hour, date, month, year, time-zone---一个解码时间[decoded time]的对应部分. (注意, 在一个完整的解码时间[decoded time]中, 9 个值中的一些是冗余的, 因此不用作此函数的输入.)
        universal-time---一个通用时间[universal time].

* 描述(Description):

        encode-universal-time 把一个解码时间格式的时间转换为一个通用时间[universal time].

        如果提供了 time-zone, 不会执行夏令时的调整.

* 示例(Examples):

    ```LISP
    (encode-universal-time 0 0 0 1 1 1900 0) =>  0
    (encode-universal-time 0 0 1 4 7 1976 5) =>  2414296800
    ;; The next example assumes Eastern Daylight Time.
    (encode-universal-time 0 0 1 4 7 1976) =>  2414293200
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        decode-universal-time, get-decoded-time

* 注意(Notes): None.


### <span id="F-GET-TIME-ALL">函数 GET-UNIVERSAL-TIME, GET-DECODED-TIME</span>

* 语法(Syntax):

        get-universal-time <no arguments> => universal-time

        get-decoded-time <no arguments>
        => second, minute, hour, date, month, year, day, daylight-p, zone

* 参数和值(Arguments and Values):

        universal-time---一个通用时间[universal time].
        second, minute, hour, date, month, year, day, daylight-p, zone---一个解码时间[decoded time].

* 描述(Description):

        get-universal-time 返回当前时间, 表示为一个通用时间[universal time].

        get-decoded-time 返回当前时间, 表示为一个解码时间[decoded time].

* 示例(Examples):

    ```LISP
    ;; At noon on July 4, 1976 in Eastern Daylight Time.
    (get-decoded-time) =>  0, 0, 12, 4, 7, 1976, 6, true, 5
    ;; At exactly the same instant.
    (get-universal-time) =>  2414332800
    ;; Exactly five minutes later.
    (get-universal-time) =>  2414333100
    ;; The difference is 300 seconds (five minutes)
    (- * **) =>  300
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        一天的时间 (换句话说, 流逝的时间), 系统时钟保持精确时间的能力, 以及系统时钟初始设置的准确性.

* 异常情况(Exceptional Situations):

        如果当前时间不能确定, 那么就会发出一个 error 类型[type]的错误.

* 参见(See Also):

        decode-universal-time, encode-universal-time, 章节 25.1.4 (时间)

* 注意(Notes):

        (get-decoded-time) ==  (decode-universal-time (get-universal-time))

        没有要求具体实现[implementation]有着一种方式去核实返回的时间是正确的. 然而, 如果一个具体实现[implementation]提供正确性检测 (例如, 未能正确初始化系统时钟可以可靠地检测到) 并且那个正确性检测没通过, 强烈鼓励 (但不是必须) 具体实现[implementation]去发出一个 error 类型[type]的错误 (而不是, 例如, 返回一个已知是错误的值), 它是可纠正的[correctable], 允许用户去交互式地设置正确的时间.


### <span id="F-SLEEP">函数 SLEEP</span>

* 语法(Syntax):

        sleep seconds => nil

* 参数和值(Arguments and Values):

        seconds---一个非负实数[real].

* 描述(Description):

        停止执行并进入休眠状态, 大约 seconds 表示的实时秒数, 然后恢复执行.

* 示例(Examples):

    ```LISP
    (sleep 1) =>  NIL

    ;; Actually, since SLEEP is permitted to use approximate timing,
    ;; this might not always yield true, but it will often enough that
    ;; we felt it to be a productive example of the intent.
    (let ((then (get-universal-time))
          (now  (progn (sleep 10) (get-universal-time))))
      (>= (- now then) 10))
    =>  true
    ```

* 副作用(Side Effects):

        导致执行终止.

* 受此影响(Affected By):

        调度程序的粒度.

* 异常情况(Exceptional Situations):

        如果 seconds 不是一个非负实数[real], 就会发出一个 type-error 类型[type]的错误.

* 参见(See Also): None.

* 注意(Notes): None.


### <span id="F-APROPOS-ALL">函数 APROPOS, APROPOS-LIST</span>

* 语法(Syntax):

        apropos string &optional package => <no values>

        apropos-list string &optional package => symbols

* 参数和值(Arguments and Values):

        string---一个字符串标识符[string designator].
        package---一个包标识符[package designator]或 nil. 默认是 nil.
        symbols---一个符号[symbol]列表[list].

* 描述(Description):

        这些函数搜索名字[name]中包含子字符串 string 的已捕捉的[interned]符号[symbol].

        对于 apropos, 作为每一个被找到的符号[symbol], 它的名字被打印在标准输出[standard output]. 另外, 如果这样的一个符号[symbol]被定义为一个函数[function]或动态变量[dynamic variable], 关于这些定义的信息也会被打印.

        对于 apropos-list, 随着这个搜索的进行不会产生输出; 而是当搜索完成时返回匹配的符号[symbol]的列表.

        如果 package 非 nil [non-nil], 只有包 pacakge 中可访问的[accessible]符号[symbol]会被搜索; 否则任何包[package]中的所有可访问的[accessible]符号[symbol]都会被搜索.

        由于一个符号[symbol]可能通过多个继承路径可用, apropos 可能打印相同[same]符号[symbol]的信息不止一次, 或者 apropos-list 可能返回一个包含重复符号[symbol]的列表[list].

        这个搜索是否是大小写敏感的是具体实现定义的[implementation-defined].

* 示例(Examples): None.

* 受此影响(Affected By):

        在任何要被搜索的包[package]中当前被捕捉的[interned]符号[symbol]的集合.

        apropos 也受 *standard-output* 影响.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes): None.


### <span id="F-DESCRIBE">函数 DESCRIBE</span>

* 语法(Syntax):

        describe object &optional stream => <no values>

* 参数和值(Arguments and Values):

        object---一个符号[symbol].
        stream---一个输出[output]流标识符[stream designator]. 默认是标准输出[standard output].

* 描述(Description):

        describe 显示关于对象 object 的信息到流 stream.

        比如, 一个符号[symbol]的描述 describe 可能展示这个符号[symbol]的值, 它的定义, 已经它的每一个属性. 一个浮点数[float]的描述可能以一种有助于跟踪舍入错误的方式显示数字的内部表示. 在所有情况中, 然而, 这个描述输出的性质和格式是依赖于具体实现的[implementation-dependent].

        describe 可以描述它在这个对象 object 中找到的东西; 在这样的情况中, 通常使用诸如增加缩进或在表中定位等符号图案, 以便从视觉上区分这种递归描述和参数 object 的描述.

        描述这个对象的实际行为是由 describe-object 实现的. describe 存在作为一个管理缺省参数的接口 (包括参数 t 和 nil 到流[stream]对象[object]的转换) 以及去抑制来自 describe-object 的任何返回值.

        describe 不打算作为一个交互式的函数. 在一个复合规范的实现[conforming implementation]中, 默认情况下, describe 一定不能为用户输入提示. 用户定义的 describe-objec 方法同样受限.

* 示例(Examples): None.

* 副作用(Side Effects):

        输出到标准输出[standard output]或终端 I/O [terminal I/O].

* 受此影响(Affected By):

        *standard-output* 和 *terminal-io*, 用户定义的类[class]的对象[object]上的 describe-object 和 print-object 方法.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        inspect, describe-object

* 注意(Notes): None.


### <span id="SGF-DESCRIBE-OBJECT">标准广义函数 DESCRIBE-OBJECT</span>

* 语法(Syntax):

        describe-object object stream => implementation-dependent

* 方法签名(Method Signatures):

        describe-object (object standard-object) stream

* 参数和值(Arguments and Values):

        object---一个符号[symbol].
        stream---一个流[stream].

* 描述(Description):

        广义函数 describe-object 打印对象 object 的描述到流 stream. describe-object 被 describe 调用; 它一定不能被用户调用.

        每一个具体实现需要去提供一个类[class] standard-object 上的方法[method]以及足够的其他类上的方法[method]来确保这里总是有一个可应用的方法[method]. 具体实现可以自由地去为其他类[class]添加方法[method]. 如果用户不想去继承一个具体实现提供的方法[method], 那么用户可以为他们自己的类[class]编写 describe-object 方法[method].

        在 describe-object 上的方法[method]可以递归调用 describe. 缩进, 深度限制, 还有环状检测都是自动处理的, 如果这里有更多结构层级, 那么假设每一个方法[method]处理结构的一层并且递归调用 describe. 如果没有遵守这个规则的后果是未定义的.

        在一些具体实现中, 传递给一个 describe-object 方法的这个 stream 流参数不是那个原始的流 stream, 而是一个实现了 describe 部分的中间流. 因此方法[method]不应该依赖于这个流[stream]的标识.

* 示例(Examples):

    ```LISP
    (defclass spaceship ()
      ((captain :initarg :captain :accessor spaceship-captain)
        (serial# :initarg :serial-number :accessor spaceship-serial-number)))

    (defclass federation-starship (spaceship) ())

    (defmethod describe-object ((s spaceship) stream)
      (with-slots (captain serial#) s
        (format stream "~&~S is a spaceship of type ~S,~
                        ~%with ~A at the helm ~
                          and with serial number ~D.~%"
                s (type-of s) captain serial#)))

    (make-instance 'federation-starship
                    :captain "Rachel Garrett"
                    :serial-number "NCC-1701-C")
    =>  #<FEDERATION-STARSHIP 26312465>

    (describe *)
    >>  #<FEDERATION-STARSHIP 26312465> is a spaceship of type FEDERATION-STARSHIP,
    >>  with Rachel Garrett at the helm and with serial number NCC-1701-C.
    =>  <no values>
    ```

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        describe

* 注意(Notes):

        和应用于 print-object 相同的实现机制被应用于 describe-object.

        使这个 describe-object 的返回值是未指定的原因是去避免强制用户在所有方法[method]中去包含显示的 (values). 由 describe 负责这个.


### <span id="M-TRACE-UNTRACE">宏 TRACE, UNTRACE</span>

* 语法(Syntax):

        trace function-name* => trace-result

        untrace function-name* => untrace-result

* 参数和值(Arguments and Values):

        function-name---一个函数名字[function name].
        trace-result---依赖于具体实现的[implementation-dependent], 除非没有提供 function-names, 在这个情况中 trace-result 是一个函数名字[function name]的列表[list].
        untrace-result---依赖于具体实现的[implementation-dependent].

* 描述(Description):

        trace 和 untrace 控制那个跟踪工具的调用.

        用一个或多个函数名 function-names 来调用 trace 导致表示的函数[function]被 "追踪". 无论何时一个被追踪的函数[function]被调用, 关于这个调用, 关于这些参数传递, 以及关于最后返回值的信息会被打印到跟踪输出[trace output]. 如果 trace 没有和函数名 function-names 一起使用, 不会执行跟踪的动作; 反而, 一个当前正在被跟踪的函数[function]列表会被返回.

        用一个或多个函数名调用 untrace 导致那些函数被 "解除追踪(untraced)" (换句话说, 不再被追踪). 如果 untrace 没有和函数名 function-names 一起使用, 所有当前正在被追踪的函数都会被解除追踪.

        如果一个要被追踪的函数[function]已经是 open-coded 的(例如, 由于它被申明为 inline), 一个对该函数的调用可能不会产生跟踪输出.

* 示例(Examples):

    ```LISP
    (defun fact (n) (if (zerop n) 1 (* n (fact (- n 1)))))
    =>  FACT
    (trace fact)
    =>  (FACT)
    ;; Of course, the format of traced output is implementation-dependent.
    (fact 3)
    >>  1 Enter FACT 3
    >>  | 2 Enter FACT 2
    >>  |   3 Enter FACT 1
    >>  |   | 4 Enter FACT 0
    >>  |   | 4 Exit FACT 1
    >>  |   3 Exit FACT 1
    >>  | 2 Exit FACT 2
    >>  1 Exit FACT 6
    =>  6
    ```

* 副作用(Side Effects):

        可能改变由 function-names 命名的那些函数[function]的定义.

* 受此影响(Affected By):

        受这些已命名的函数是否被定义或者是否已经被跟踪所影响.

* 异常情况(Exceptional Situations):

        跟踪一个已经被跟踪的函数, 或者解除一个当前没有被跟踪的函数的跟踪, 都不应该产生有害的效果, 但是可能发出一个警告.

* 参见(See Also):

        *trace-output*, step

* 注意(Notes):

        trace 和 untrace 可能也接受具体实现定义的[implementation-dependent]额外的参数格式. 这个跟踪输出的格式是依赖于具体实现的[implementation-dependent].

        虽然 trace 可以被扩展来允许非标准选项, 不过还是鼓励(但不是必须)具体实现[implementation]去警告既没有被这个标准指定也没有被这个实现[implementation]添加为一个扩展的语法或选项的使用, 因为它们可以是印刷错误或依赖一些其他实现[implementation]支持而当前实现[implementation]不支持的特性的症状.


### <span id="M-STEP">宏 STEP</span>

* 语法(Syntax):

        step form => result*

* 参数和值(Arguments and Values):

        form---一个表达式形式[form]; 按以下描述求值.
        results---由表达式形式 form 返回的那些值[value].

* 描述(Description):

        step 实现了一个调试模式, 在其中程序员允许去单步[step]调试一个表达式形式[form]的求值[evaluation]. 这个交互的具体性质, 包括使用哪个 I/O 流并且这个步进是否有着词法或动态的作用域, 是具体实现定义的[implementation-defined].

        step 在当前环境[envirnonment]中求值表达式形式 form. 一个对 step 的调用可以被编译, 但是对于一个实现来说, 只交互遍历被解释的计算部分是可以接受的.

        对于一个符合规范的实现[conforming implementation]除了正常求值表达式形式 form 以外不采取动作是技术上允许的. 在这样一个情况中, (step form) 等价于, 例如, (let () form). 在这种情况下的实现中, 相关文档应该提到这个事实.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        trace

* 注意(Notes):

        鼓励具体实现[implementation]去提供包含一个命令列表的帮助来回应 ? 的输入或一个 "help key" 的按下.


### <span id="M-TIME">宏 TIME</span>

* 语法(Syntax):

        time form => result*

* 参数和值(Arguments and Values):

        form---一个表达式形式[form]; 按如下所述求值.
        results---由这个表达式形式 form 返回的那些值[value].

* 描述(Description):

        time 在当前环境[environment]中 (词法和动态的) 求值表达式形式 form. 一个对 time 的调用可以被编译.

        time 把各种时间数据和其他信息打印到跟踪输出[trace output]. 这个打印信息的性质和格式是具体实现定义的[implementation-defined]. 鼓励具体实现去提供诸如经过的实际时间, 机器运行时间, 以及存储管理统计等信息.

* 示例(Examples): None.

* 受此影响(Affected By):

        结果的准确性除其他外, 还取决于底层操作系统提供的相应功能的准确性.

        结果的大小可能取决于硬件, 操作系统, lisp 具体实现和全局环境的状态. 一些经常影响结果具体问题是硬件速度, 调度器(如果有的话)的性质, 进程竞争过程(如果有的话), 系统分页, 这个调用是否被解释或编译, 这个被调用的函数是否被编译, 涉及的垃圾收集器的种类以及它是否运行, 内部数据结构(例如, 哈希表)是否隐式地重组, 等等.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        get-internal-real-time, get-internal-run-time

* 注意(Notes):

        通常情况下, 这些时间并不能保证足够可靠来进行市场比较. 它们的值主要是启发式的, 用于调优.

        有关解释计时结果所涉及的复杂问题的有用背景资料, 见 Performance and Evaluation of Lisp Programs.


### <span id="CV-INTERNAL-TIME-UNITS-PER-SECOND">常量 INTERNAL-TIME-UNITS-PER-SECOND</span>

* 常量值(Constant Value):

        一个正整数[integer], 它的大小是依赖于具体实现的[implementation-dependent].

* 描述(Description):

        一秒钟内的内部时间单位[internal time unit]的数量.

* 示例(Examples): None.

* 参见(See Also):

        get-internal-run-time, get-internal-real-time

* 注意(Notes):

        这些单元构成了内部时间格式表示的基础.


### <span id="F-GET-INTERNAL-REAL-TIME">函数 GET-INTERNAL-REAL-TIME</span>

* 语法(Syntax):

        get-internal-real-time <no arguments> => internal-time

* 参数和值(Arguments and Values):

        internal-time---一个非负整数[integer].

* 描述(Description):

        get-internal-real-time 以整数[integer]形式返回内部时间单元[internal time unit]中的当前时间, 相对于任意的时间基数. 两次调用这个函数的值的区别就是这两次调用之间逝去的实际时间总和 (换句话说, 时钟时间).

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        一天的时间 (换句话说, 时间的流逝). 时间基数影响结果的大小.

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        internal-time-units-per-second

* 注意(Notes): None.


### <span id="F-GET-INTERNAL-RUN-TIME">函数 GET-INTERNAL-RUN-TIME</span>

* 语法(Syntax):

        get-internal-run-time <no arguments> => internal-time

* 参数和值(Arguments and Values):

        internal-time---一个非负整数[integer].

* 描述(Description):

        以整数[integer]形式返回内部时间单元[internal time unit]中的当前运行时间. 这个量的确切含义是由具体实现定义的[implementation-defined]; 它可能测量实际时间, 运行时间, CPU 周期, 或者某个其他量. 目的是这个函数的两个调用的值之间的差值是两个调用之间的时间总量, 在此期间, 代表执行程序花费了计算工作量.

* 示例(Examples): None.

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        具体实现[implementation], 一天的时间 (换句话说, 时间的流逝).

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        internal-time-units-per-second

* 注意(Notes):

        依赖于具体实现[implementation], 换页时间和垃圾收集时间可能被包含在这个测量中. 同样的, 在多任务环境中, 或许不可能去展示这个运行过程的时间, 因此在一些实现[implementation]中, 其他进程在这期间所用掉的时间也可能被包含在这个测量中.


### <span id="F-DISASSEMBLE">函数 DISASSEMBLE</span>

* 语法(Syntax):

        disassemble fn => nil

* 参数和值(Arguments and Values):

        fn---一个扩展函数标识符[extended function designator]或一个 lambda 表达式[lambda expression].

* 描述(Description):

        函数[function] disassemble 是一个调试工具, 它用某种依赖于具体实现[implementation-dependent]的语言组成符号指令或表达式, 这些符号指令或表达式表示用于生成函数[function]的代码, 该函数是 fn 或者由参数 fn 命名. 结果以一种依赖于具体实现[implementation-dependent]的格式显示到标准输出[standard output].

        如果 fn 是一个 lambda 表达式[lambda expression]或一个被解释的函数[interpreted function], 它首先会被编译然后结果被解体.

        如果这个 fn 标识符[designator]是一个函数名字[function name], 那么它命名[name]的函数[function]会被解体. (如果那个函数[function]是一个被解释的函数[interpreted function], 它首先被编译但是这个隐式编译的结果不会被安装.)

* 示例(Examples):

    ```LISP
    (defun f (a) (1+ a)) =>  F
    (eq (symbol-function 'f)
        (progn (disassemble 'f)
                (symbol-function 'f))) =>  true
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        *standard-output*.

* 异常情况(Exceptional Situations):

        如果 fn 不是一个扩展函数标识符[extended function designator]或一个 lambda 表达式[lambda expression], 那么就应该发出一个 type-error 类型[type]的错误.

* 参见(See Also): None.

* 注意(Notes): None.


### <span id="SGF-DOCUMENTATION-ALL">标准广义函数 DOCUMENTATION, (SETF DOCUMENTATION)</span>

* 语法(Syntax):

        documentation x doc-type => documentation

        (setf documentation) new-value x doc-type => new-value

* 参数优先级顺序(Argument Precedence Order):

        doc-type, object

* 方法签名(Method Signatures):

    函数, 宏, 和特殊表达式:

        documentation (x function) (doc-type (eql 't))
        documentation (x function) (doc-type (eql 'function))
        documentation (x list) (doc-type (eql 'function))
        documentation (x list) (doc-type (eql 'compiler-macro))
        documentation (x symbol) (doc-type (eql 'function))
        documentation (x symbol) (doc-type (eql 'compiler-macro))
        documentation (x symbol) (doc-type (eql 'setf))

        (setf documentation) new-value (x function) (doc-type (eql 't))
        (setf documentation) new-value (x function) (doc-type (eql 'function))
        (setf documentation) new-value (x list) (doc-type (eql 'function))
        (setf documentation) new-value (x list) (doc-type (eql 'compiler-macro))
        (setf documentation) new-value (x symbol) (doc-type (eql 'function))
        (setf documentation) new-value (x symbol) (doc-type (eql 'compiler-macro))
        (setf documentation) new-value (x symbol) (doc-type (eql 'setf))

    方法组合:

        documentation (x method-combination) (doc-type (eql 't))
        documentation (x method-combination) (doc-type (eql 'method-combination))
        documentation (x symbol) (doc-type (eql 'method-combination))

        (setf documentation) new-value (x method-combination) (doc-type (eql 't))
        (setf documentation) new-value (x method-combination) (doc-type (eql 'method-combination))
        (setf documentation) new-value (x symbol) (doc-type (eql 'method-combination))

    方法:

        documentation (x standard-method) (doc-type (eql 't))

        (setf documentation) new-value (x standard-method) (doc-type (eql 't))

    包:

        documentation (x package) (doc-type (eql 't))

        (setf documentation) new-value (x package) (doc-type (eql 't))

    类型, 类, 以及结构体名字:

        documentation (x standard-class) (doc-type (eql 't))
        documentation (x standard-class) (doc-type (eql 'type))
        documentation (x structure-class) (doc-type (eql 't))
        documentation (x structure-class) (doc-type (eql 'type))
        documentation (x symbol) (doc-type (eql 'type))
        documentation (x symbol) (doc-type (eql 'structure))

        (setf documentation) new-value (x standard-class) (doc-type (eql 't))
        (setf documentation) new-value (x standard-class) (doc-type (eql 'type))
        (setf documentation) new-value (x structure-class) (doc-type (eql 't))
        (setf documentation) new-value (x structure-class) (doc-type (eql 'type))
        (setf documentation) new-value (x symbol) (doc-type (eql 'type))
        (setf documentation) new-value (x symbol) (doc-type (eql 'structure))

    变量:

        documentation (x symbol) (doc-type (eql 'variable))

        (setf documentation) new-value (x symbol) (doc-type (eql 'variable))

* 参数和值(Arguments and Values):

        x---一个符号[symbol].
        doc-type---一个符号[symbol].
        documentation---一个字符串[string]或 nil.
        new-value---一个字符串[string].

* 描述(Description):

        如果可用的话, 广义函数[generic function] documentation 返回和给定的对象[object]相关联的文档字符串[documentation string]; 否则它返回 nil.

        广义函数[generic function] (setf documentation) 更新和 x 相关联的文档字符串[documentation string]为 new-value. 如果 x 是一个列表[list], 它必须是 (setf symbol) 形式.

        文档字符串[documentation string]可用于调试目的. 符合规范的程序[conforming program]允许在文档字符串[documentation string]存在时去使用它们, 但是不应该将它们的正确行为依赖于这些文档字符串[documentation string]的存在性. 允许一个具体实现[implementation]出于具体实现定义的[implementation-defined]原因在任何时间丢弃文档字符串[documentation string].

        返回的文档字符串[documentation string]的性质依赖于 doc-type, 如下:

        compiler-macro

            返回这个名字[name]为函数名[function] x 的编译器宏[compiler macro]的文档字符串[documentation string].

        function

            如果 x 是一个函数名[function name], 返回名字[name]为 x 的函数[function], 宏[macro], 或特殊操作符[special operator]的文档字符串[documentation string].

            如果 x 是一个函数[function], 返回和 x 关联的文档字符串[documentation string].

        method-combination

            如果 x 是一个符号[symbol], 返回名为 x 的方法组合[method combination]的文档字符串[documentation string].

            如果 x 是一个方法组合[method combination], 返回和 x 关联的文档字符串[documentation string].

        setf

            返回名字[name]为符号[symbol] x 的 setf 展开器[setf expander]的文档字符串[documentation string].

        structure

            返回和结构体名[structure name] x 相关联的文档字符串[documentation string].

        t

            返回参数 x 自身的类[class]上特化的文档字符串[documentation string]. 比如, 如果 x 是一个函数[function], 返回和那个函数[function] x 关联的文档字符串[documentation string].

        type

            如果 x 是一个符号[symbol], 那么如果这里有这样一个类[class], 就返回名字[name]为符号[symbol] x 的类[class]的文档字符串[documentation string]. 否则, 返回类型指定符[type specifier]符号[symbol] x 的类型[type]的文档字符串[documentation string].

            如果 x 是一个结构体类[structure class]或者标准类[standard class], 那么返回和类[class] x 关联的文档字符串[documentation string].

        variable

            返回名字[name]为 x 的动态变量[dynamic variable]或常变量[constant variable]的文档字符串[documentation string].

        一个符合规范的实现[conforming implementation]或一个符合规范的程序[conforming program]可能扩展这个可接受作为 doc-type 的符号[symbol]集合.

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes):

        这个标准没有规定检索 defclass 表达式形式中指定的各个槽的文档字符串[documentation string]的方法, 但是具体实现[implementation]仍然可以提供调试工具 和/或 编程语言扩展来操纵这个信息. 我们鼓励希望提供这种支持的实现者查阅元对象协议[Metaobject Protocol], 以获得关于如何做到这一点的建议.


### <span id="F-ROOM">函数 ROOM</span>

* 语法(Syntax):

        room &optional x => 依赖于具体实现[implementation-dependent]

* 参数和值(Arguments and Values):

        x---t, nil, 或 :default 其中之一.

* 描述(Description):

        room 打印关于内部存储的状态信息以及它的管理到标准输出[standard output]. 这可能包括内存使用量和内存压缩程度的描述, 如果合适的话, 可能会按内部数据类型分解. 打印信息的性质和格式是依赖于具体实现[implementation-dependent]的. 目的是提供程序员[programmer]可能用于为特定实现[implementation]优化程序[program]的信息.

        (room nil) 打印出最少量的信息. (room t) 打印出最多量的信息. (room) 或 (room :default) 打印出可能有用的中间量的信息.

* 示例(Examples): None.

* 副作用(Side Effects):

        输出到标准输出[standard output].

* 受此影响(Affected By):

        *standard-output*.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes): None.


### <span id="F-ED">函数 ED</span>

* 语法(Syntax):

        ed &optional x => 依赖于具体实现[implementation-dependent]

* 参数和值(Arguments and Values):

        x---nil, 一个路径名[pathname], 一个字符串[string], 或一个函数名[function name]. 默认是 nil.

* 描述(Description):

        如果这个实现[implementation]提供一个常驻的编辑器, 那么 ed 就调用那个编辑器.

        如果 x 是 nil, 就进入那个编辑器. 如果之前已经进入那个编辑器, 那么如果可能的话, 恢复它的之前状态.

        如果 x 是一个路径名[pathname]或字符串[string], 它会被用作一个要被编辑的文件[file]的路径名标识符[pathname designator].

        如果 x 是一个函数名[function name], 则编辑它的定义的文本. 获取那个函数文本的方式是具体实现定义的[implementation-defined].

* 示例(Examples): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations):

        如果这个实现[implementation]没有提供一个常驻的编辑器, 那么后果是未定义的.

        如果提供了它的参数但是不是一个符号[symbol], 一个路径名[pathname], 或 nil, 那么可能发出一个 type-error 类型的错误.

        如果尝试编辑一个文件[file]期间在执行某个文件系统[file system]上的操作时发生一个故障, 那么会发出一个 file-error 类型[type]的错误.

        如果 x 是一个通配符[wild]路径名[pathname]的标识符[designator], 那么就可能会发出 file-error 类型[type]的错误.

        也可能被发出依赖于具体实现[implementation-dependent]的额外状况.

* 参见(See Also):

        pathname, logical-pathname, compile-file, load, 章节 19.1.2 (路径名作为文件名)

* 注意(Notes): None.


### <span id="F-INSPECT">函数 INSPECT</span>

* 语法(Syntax):

        inspect object => 依赖于具体实现[implementation-dependent]

* 参数和值(Arguments and Values):

        object---一个符号[symbol].

* 描述(Description):

        inspect 是 describe 的一个交互式版本. 这个交互的性质是依赖于具体实现[implementation-dependent], 但是这个 inspect 的目的是使浏览数据结构, 检验并修改它的各个部分变得容易.

* 示例(Examples): None.

* 副作用(Side Effects):

        依赖于具体实现[implementation-dependent].

* 受此影响(Affected By):

        依赖于具体实现[implementation-dependent].

* 异常情况(Exceptional Situations):

        依赖于具体实现[implementation-dependent].

* 参见(See Also):

        describe

* 注意(Notes):

        鼓励具体实现通过提供包含命令列表的帮助去回应 ? 的输入或一个 "help key" 的按下.


### <span id="F-DRIBBLE">函数 DRIBBLE</span>

* 语法(Syntax):

        dribble &optional pathname => 依赖于具体实现[implementation-dependent]

* 参数和值(Arguments and Values):

        pathname---一个路径名标识符[pathname designator].

* 描述(Description):

        绑定[bind] *standard-input* 和 *standard-output* 或采取其他适当的操作, 以便将输入/输出交互的记录发送到 pathname 命名的文件. dribble 旨在创建交互式会话的可读记录.

        如果 pathname 是一个逻辑路径名[logical pathname], 它会像是调用 translate-logical-pathname 一样被转换为一个物理路径名.

        (dribble) 终止输入和输出的记录并且关闭这个 dribble 文件.

        如果 dribble 被调用, 但是来自上次对 dribble 调用的到 "dribble file" 的流[stream]仍然打开的情况下, 效果是具体实现定义的[implementation-defined]. 比如, 这个已经打开[open]的流[stream]可能被关闭[closed], 或者 dribbling 可能对于旧的流[stream]和新的流[stream]同时发生, 或者那个旧的流[stream]可能保持打开但是不接受进一步的输出, 或者这个新的请求会被忽略, 或者采取某个其他动作.

* 示例(Examples): None.

* 受此影响(Affected By):

        具体实现[implementation].

* 异常情况(Exceptional Situations):

        如果创建这个 dribble 文件期间在执行某个文件系统[file system]上的操作时出现一个失败, 那么一个 file-error 类型[type]的错误会被发出.

        如果 pathname 是一个通配符[wild]路径名[pathname]的标识符[designator], 那么就可能会发出 file-error 类型[type]的错误.

* 参见(See Also):

        章节 19.1.2 (路径名作为文件名)

* 注意(Notes):

        dribble 可以在后续的表达式形式[form]执行之前返回. 它也可以进入到一个递归的交互式循环中, 只有当 (dribble) 完成时返回.

        dribble 主要用于交互式调试; 在一个程序中使用它时, 不能依赖它的效果.


### <span id="V-MINUS">常量 -</span>

* 值类型(Value Type):

        一个表达式形式[form].

* 初始值(Initial Value):

        依赖于具体实现[implementation-dependent].

* 描述(Description):

        这个 - 的值[value]是当前被 Lisp read-eval-print 循环[Lisp read-eval-print loop]求值的表达式形式[form].

* 示例(Examples):

    ```LISP
    (format t "~&Evaluating ~S~%" -)
    >>  Evaluating (FORMAT T "~&Evaluating ~S~%" -)
    =>  NIL
    ```

* 受此影响(Affected By):

        Lisp read-eval-print 循环[Lisp read-eval-print loop].

* 参见(See Also):

        + (变量), * (变量), / (变量), 章节 25.1.1 (顶层循环)

* 注意(Notes): None.


### <span id="V-ADD-ALL">常量 +, ++, +++</span>

* 值类型(Value Type):

        一个对象[object].

* 初始值(Initial Value):

        依赖于具体实现[implementation-dependent].

* 描述(Description):

        这些 +, ++, 和 +++ 变量[variable]由 Lisp read-eval-print 循环[Lisp read-eval-print loop]维护, 来保存最近求值的表达式形式[form].

        这个 + 的值[value]是最后求值的表达式形式[form], 这个 ++ 的值[value]是 + 的前一个值, 而 +++ 的值[value]是 ++ 的前一个值.

* 示例(Examples):

    ```LISP
    (+ 0 1) =>  1
    (- 4 2) =>  2
    (/ 9 3) =>  3
    (list + ++ +++) =>  ((/ 9 3) (- 4 2) (+ 0 1))
    (setq a 1 b 2 c 3 d (list a b c)) =>  (1 2 3)
    (setq a 4 b 5 c 6 d (list a b c)) =>  (4 5 6)
    (list a b c) =>  (4 5 6)
    (eval +++) =>  (1 2 3)
    #.`(,@++ d) =>  (1 2 3 (1 2 3))
    ```

* 受此影响(Affected By):

        Lisp read-eval-print 循环[Lisp read-eval-print loop].

* 参见(See Also):

        - (variable), * (variable), / (variable), 章节 25.1.1 (顶层循环)

* 注意(Notes): None.


### <span id="V-ASTERISK">常量 *, **, ***</span>

* 值类型(Value Type):

        一个对象[object].

* 初始值(Initial Value):

        依赖于具体实现[implementation-dependent].

* 描述(Description):

        这些 *, **, 和 *** 变量[variable]由 Lisp read-eval-print 循环[Lisp read-eval-print loop]维护, 来保存每一次通过这个循环打印的结果值.

        这个 * 是最近被打印的主要值[primary value], 这个 ** 的值[value]是 * 的前一个值, 而 *** 的值[value]是 ** 的前一个值.

        如果产生多个值, * 只包含第一个值; 如果没有值产生, 那么 * 包含 nil.

        *, **, 和 *** 的这些值[value]被 Lisp read-eval-print 循环[Lisp read-eval-print loop]在打印顶层表达式形式[form]的返回值[return value]之前被更新. 如果这样一个表达式形式[form]的求值在它正常返回之前被中止, 那么 *, **, 和 *** 的值都不会被更新.

* 示例(Examples):

    ```LISP
    (values 'a1 'a2) =>  A1, A2
    'b =>  B
    (values 'c1 'c2 'c3) =>  C1, C2, C3
    (list * ** ***) =>  (C1 B A1)

    (defun cube-root (x) (expt x 1/3)) =>  CUBE-ROOT
    (compile *) =>  CUBE-ROOT
    (setq a (cube-root 27.0)) =>  3.0
    (* * 9.0) =>  27.0
    ```

* 受此影响(Affected By):

        Lisp read-eval-print 循环[Lisp read-eval-print loop].

* 参见(See Also):

        - (变量), + (变量), / (变量), 章节 25.1.1 (顶层循环)

* 注意(Notes):

        *   ==  (car /)
        **  ==  (car //)
        *** ==  (car ///)


### <span id="V-SLASH">常量 /, //, ///</span>

* 值类型(Value Type):

        一个属性列表[proper list].

* 初始值(Initial Value):

        依赖于具体实现[implementation-dependent].

* 描述(Description):

        这些 /, //, 和 /// 变量[value]由 Lisp read-eval-print 循环[Lisp read-eval-print loop]维护, 来保存这个循环最后被打印的结果的值.

        这个 / 的值[value]是最近被打印的值[value]的列表[list], 这个 // 的值[value]是 / 的前一个值, 而这个 /// 的值[value]是 // 的前一个值.

        /, //, 和 /// 的值被 Lisp read-eval-print 循环[Lisp read-eval-print loop]在打印顶层表达式形式[form]的返回值[return value]之前被更新. 如果这样一个表达式形式[form]的求值在它正常返回之前被中止, 那么 /, //, 和 /// 的这些值都不会被更新.

* 示例(Examples):

    ```LISP
    (floor 22 7) =>  3, 1
    (+ (* (car /) 7) (cadr /)) =>  22
    ```

* 受此影响(Affected By):

        Lisp read-eval-print 循环[Lisp read-eval-print loop].

* 参见(See Also):

        - (变量), + (变量), * (变量), 章节 25.1.1 (顶层循环)

* 注意(Notes): None.


### <span id="F-LISP-IMPLEMENTATION-ALL">函数 LISP-IMPLEMENTATION-TYPE, LISP-IMPLEMENTATION-VERSION</span>

* 语法(Syntax):

        lisp-implementation-type <no arguments> => description

        lisp-implementation-version <no arguments> => description

* 参数和值(Arguments and Values):

description---a string or nil.

* 描述(Description):

        lisp-implementation-type 和 lisp-implementation-version 标识当前的 Common Lisp 实现.

        lisp-implementation-type 返回一个标识这个特定 Common Lisp 实现的通用名称的字符串[string].

        lisp-implementation-version 返回一个标识这个特定 Common Lisp 实现的版本的字符串[string].

        如果不能产生适当的和相关的结果, 会返回 nil 而不是一个字符串[string].

* 示例(Examples):

    ```LISP
    (lisp-implementation-type)
    =>  "ACME Lisp"
    OR=>  "Joe's Common Lisp"
    (lisp-implementation-version)
    =>  "1.3a"
    =>  "V2"
    OR=>  "Release 17.3, ECO #6"
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By): None.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes): None.


### <span id="F-SITE-NAME-ALL">函数 SHORT-SITE-NAME, LONG-SITE-NAME</span>

* 语法(Syntax):

        short-site-name <no arguments> => description

        long-site-name <no arguments> => description

* 参数和值(Arguments and Values):

        description---一个字符串[string]或 nil.

* 描述(Description):

        short-site-name 和 long-site-name 返回一个标识这个计算机硬件的物理部署信息的字符串[string], 如果不能产生适当的描述, 就返回 nil.

* 示例(Examples):

    ```LISP
    (short-site-name)
    =>  "MIT AI Lab"
    OR=>  "CMU-CSD"
    (long-site-name)
    =>  "MIT Artificial Intelligence Laboratory"
    OR=>  "CMU Computer Science Department"
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        具体实现, 计算机硬件的物理部署信息, 以及安装/配置过程.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes): None.


### <span id="F-MACHINE-INSTANCE">函数 MACHINE-INSTANCE</span>

* 语法(Syntax):

        machine-instance <no arguments> => description

* 参数和值(Arguments and Values):

        description---一个字符串[string]或 nil.

* 描述(Description):

        返回一个标识 Common Lisp 正在运行的这个计算机硬件的特定实例的字符串[string], 如果没有这样的字符串[string]可以被计算就返回 nil.

* 示例(Examples):

    ```LISP
    (machine-instance)
    =>  "ACME.COM"
    OR=>  "S/N 123231"
    OR=>  "18.26.0.179"
    OR=>  "AA-00-04-00-A7-A4"
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        机器实例, 以及具体实现[implementation].

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        machine-type, machine-version

* 注意(Notes): None.


### <span id="F-MACHINE-TYPE">函数 MACHINE-TYPE</span>

* 语法(Syntax):

        machine-type <no arguments> => description

* 参数和值(Arguments and Values):

        description---一个字符串[string]或 nil.

* 描述(Description):

        返回一个标识这个 Common Lisp 正在运行的计算机硬件的通用名称的字符串[string].

* 示例(Examples):

    ```LISP
    (machine-type)
    =>  "DEC PDP-10"
    OR=>  "Symbolics LM-2"
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        这个机器类型. 具体实现[implementation].

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        machine-version

* 注意(Notes): None.


### <span id="F-MACHINE-VERSION">函数 MACHINE-VERSION</span>

* 语法(Syntax):

        machine-version <no arguments> => description

* 参数和值(Arguments and Values):

        description---一个字符串[string]或 nil.

* 描述(Description):

        返回一个标识这个 Common Lisp 正在运行的计算机硬件的版本的字符串[string], 如果不能计算出这样的值就返回 nil.

* 示例(Examples):

    ```LISP
    (machine-version) =>  "KL-10, microcode 9"
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        机器的版本, 和具体实现[implementation].

* 异常情况(Exceptional Situations): None.

* 参见(See Also):

        machine-type, machine-instance

* 注意(Notes): None.


### <span id="F-SOFTWARE-ALL">函数 SOFTWARE-TYPE, SOFTWARE-VERSION</span>

* 语法(Syntax):

        software-type <no arguments> => description

        software-version <no arguments> => description

* 参数和值(Arguments and Values):

        description---一个字符串[string]或 nil.

* 描述(Description):

        software-type 返回一个标识任何相关支持软件的通用名字的字符串[string], 如果不能产生适当的或相关的值就返回 nil.

        software-version 返回一个标识任何相关支持软件的版本的字符串[string], 如果不能产生适当的或相关的值就返回 nil.

* 示例(Examples):

    ```LISP
    (software-type) =>  "Multics"
    (software-version) =>  "1.3x"
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        操作系统环境.

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes):

        这些信息应该对具体实现[implementation]的维护者有用.


### <span id="F-USER-HOMEDIR-PATHNAME">函数 USER-HOMEDIR-PATHNAME</span>

* 语法(Syntax):

        user-homedir-pathname &optional host => pathname

* 参数和值(Arguments and Values):

        host---一个字符串[string], 一个字符串[string]列表[list], 或 :unspecific.
        pathname---一个路径名[pathname]或 nil.

* 描述(Description):

        user-homedir-pathname 确定在主机 host 上对应用户家目录的路径名[pathname]. 如果没有提供 host, 它的值依赖于具体实现[implementation-dependent]. 对于一个 :unspecific 的描述, 见章节 19.2.1 (路径名成员).

        家目录的定义是依赖于具体实现的[implementation-dependent], 但是在 Common Lisp 中的定义意味着用户保存例如初始化文件和邮件之类的个人文件的目录.

        user-homedir-pathname 为主机 host 上的用户家目录返回一个不带任何名称, 类型, 或版本成员的路径名[pathname] (这些成员都是 nil).

        如果不能去确定主机 host 上的用户家目录, 就么就会返回 nil. 如果没有提供 host, 那么 user-homedir-pathname 从不返回 nil.

* 示例(Examples):

    ```LISP
    (pathnamep (user-homedir-pathname)) =>  true
    ```

* 副作用(Side Effects): None.

* 受此影响(Affected By):

        主机计算机文件系统, 以及具体实现[implementation].

* 异常情况(Exceptional Situations): None.

* 参见(See Also): None.

* 注意(Notes): None.


# 26. 术语

## 26.1 术语

### 术语表示

这个术语表中的每个条目都有以下部分:

* 要定义的术语, 用粗线表示.

* 可选的发音, 用方括号括起来并且用黑体字表示, 就像后面的例子中那样: ['a,list]. 这个发音的调遵循 Third New International Dictionary the English Language, Unabridged, 除了这个 "uh" 被用于表示非中央元音 (颠倒的 "e") 字符, "ee" 被用于表示一个 hard "e" (一个带有上划线的 "e"), "oh" 被用于表示一个 hard "o" (一个带有上划线的 "o"), 并且 "ay" 被用于表示一个 hard "a" (一个带有上划线的 "a")..
<!--TODO hard ？？-->
* 词类的部分或多个部分, 用斜体表示. 如果一个术语可以被用作多个词类部分, 那么每一部分的词类都有一个单独的定义.

* 不止一个定义的话, 按如下组织:

    如果这里有多个定义, 就会出现一个可选的数字. 小写字母也可以用于需要编号定义的子定义的情况.

    一个可选的词类部分, 用斜体表示, 如果这个术语是词类的多个部分之一就会出现.

    如果术语有重复的标准定义, 就会出现一个用斜体表示的可选的学科. 比如, "*Math*".

    如果这个定义只有在可选的上下文中有意义就会出现一个可选的上下文. 例如, "一个符号(of a symbol)".

    这个术语的定义.

    一个可选的示例句子. 比如, "This is an example of an example."

    可选的交叉引用.

另外, 一些术语在 Common Lisp 社区有着惯用的用法, 但是不被其他社区所共享, 或者不是学术上正确的. 标记了 "*习语*(*Idiom*)." 的定义表示这样的本地用法; 有时这些定义后面跟着一个注释.

这个字体的单词是这个术语表中有条目的单词. 示例句子中的单词不遵循这个约定.

当出现歧义时, 最长匹配的子字符串具有优先级. 例如, "复浮点数[complex float]" 引用单独术语条目 "复浮点数[complex float]" 而不是术语 "复数[complex]" 和 "浮点数[float]" 的组合意义.

下标符号 , 就像在 "something[n]" 中的意味着打算用 "something" 的第 n 个定义. 这种表示法只在上下文可能不足以消除歧义的情况下使用.

以下是术语表中使用的缩写:

    缩写          意义                                     
    adj.          形容词                                   
    adv.          副词                                      
    ANSI          兼容一个或多个 ANSI 标准  
    Comp.         计算机                                   
    Idiom.        习语                                   
    IEEE          兼容一个或多个 IEEE 标准  
    ISO           兼容一个或多个 ISO 标准   
    Math.         数学                                 
    Trad.         传统                                 
    n.            名词                                        
    v.            动词                                        
    v.t.          及物动词                             


### 非字母的

**()** ['nil], n. 编写符号 nil 的一个替代表示, 用于强调 nil 作为空列表[empty list]的使用. 

### A

**absolute** adj. 1. (指时间[time]) 表示一个特定的时间点. 2. (指路径名[pathname]) 表示目录层次结构中的特定位置. 见相对[relative].

**access** n., v.t. 1. v.t. (一个位置[place], 或数组[array]) 去读取[read[1]]或写入[write[1]]这个[place]的值[value]或这个数组[array]的元素[element]. 2. n. (指位置[place]) 尝试去访问[access[1]]这个位置[place]的值[valuea].

**accessibility** n. 可访问[accessible]的状态.

**accessible** adj. 1. (指对象[object]) 能够被引用. 2. (指一个类[class]的实例[instance]中共享槽[shared slot]或局部槽[local slot]) 已经被这个实例[instance]的类[class]定义或从这个类[class]的超类[superclass]中继承. 3. (指一个包[package]中的一个符号[symbol]) 能够在那个包[package]是当前包时不使用包前缀[package prefix]引用, 不管那个符号[symbol]出现[present]在那个包[package]中或是继承的.

**accessor** n. 执行一个访问[access]的一个操作符[operator]. 见读取函数[reader]和写入函数[writer].

**active** adj. 1. (指处理者[handler], 重启动[restart], 或捕获标记[catch tag]) 已经被建立但是还没有狼狈废除. 2. (指一个数组[array]的元素[element]) 有着大于等于零, 但是小于填充指针[fill pointer] (如果有的话) 的索引. 对于一个没有填充指针[fill pointer]的数组[array], 所有元素[element]都被认为是活跃的[active].

**actual adjustability** n. (指数组[array]) 和这个数组[array]关联的一个广义 boolean [generalized boolean], 表示这个数组[array]实际上可调整的[actually adjustable]. 参见明确可调整性[expressed adjustability]和 adjustable-array-p.

**actual argument** n. Trad. 一个实参[argument].

**actual array element type** n. (指数组[array]) 这个数组[array]实际特化的类型[type], 它是这个数组[array]的表达数组元素类型[expressed array element type]的提升数组元素类型[upgraded array element type]. 见函数[function] array-element-type.

**actual complex part type** n. (指复数[complex]) 实际用来表示这个复数[complex]的实部和虚部的类型[type], 它是这个复数[complex]的表达复数部分类型[expressed complex part type]的提升复数部分类型[upgraded complex part type].

**actual parameter** n. Trad. 一个实参[argument].

**actually adjustable** adj. (指数组[array]) 这样的 adjust-array 可以通过直接修改来直接调整它的性质. 只有在已知该数组[array]是明确可调整的[expressly adjustable], 或者该数组[array]已经被 adjustable-array-p 显式地测试过的情况下, 一个符合规范的程序[conforming program]可以认为这个数组[array]实际上可调整的[actually adjustable].

**adjustability** n. (指数组[array]) 1. 明确可调整性[expressed adjustability]. 2. 实际可调整性[actual adjustability].

**adjustable** adj. (指数组[array]) 1. 明确可调整的[expressly adjustable]. 2. 实际可调整的[actually adjustable].

**after method** n. 一个有着 :after 限定符[qualifier]的方法[method].

**alist** ['ay,list], n. 一个关联列表[association list].

**alphabetic** n., adj. 1. adj. (一个字符[character]的) 是标准字符[standard character] A 到 Z 或 a 到 z 的一个, 或者是任何具体实现定义的[implementation-defined]有着大小写[case]的字符, 或者是某个其他的由具体实现[implementation]定义为字母的[alphabetic[1]]的图形[graphic]字符[character]. 2. a. n. 一个字符的几种标记成分特质[constituent trait]中的一个. 关于详情, 见章节 2.1.4.1 (标记成分字符) 和章节 2.2 (读取器算法). b. adj. (一个字符[character]的) 是一个在当前读取表中有着标记成分[constituent]语法类型[syntax type]并且有着标记成分特质[constituent trait]字母[alphabetic[2a]]的字符. 见 Figure 2-8.

**alphanumeric** adj. (一个字符[character]的) 是一个字母[alphabetic[1]]字符[character]或一个数值[numeric]字符.

**ampersand** n. 被称为 "ampersand" (&) 的标准字符[standard character]. 见 Figure 2-5.

**anonymous** adj. 1. (指一个类[class]或函数[function]) 没有名字[name] 2. (指重启动[restart]) 有一个为 nil 的名字[name].

**apparently uninterned** adj. 有着一个为 nil 的 home 包[home package]. (一个明确解除捕捉[apparently uninterned]的符号[symbol]可能是也可能不是一个未捕捉的[uninterned]符号[symbol]. 未捕捉的[uninterned]符号[symbol]有着一个为 nil 的 home 包[home package], 但是那些已经从 home 包[home package]中被解除捕捉[uninterned]的符号[symbol]也有着一个为 nil 的 home 包[home package], 即便它们可能仍然被捕获[interned]在某个其他包[package]中.)

**applicable** adj. 1. (指处理者[handler]) 是一个可应用处理者[applicable handler]. 2. (指方法[method]) 是一个可应用[applicable method]. 3. (指重启动[restart]) 是一个可应用[applicable restart].

**applicable handler** n. (指一个要被发送的状况[condition]) 一个关联类型包含这个状况[condition]的活跃[active]处理者[handler].

**applicable method** n. (指使用实参[argument]调用的广义函数[generic function]) 该广义函数[generic function]的一个方法[method], 其中这些参数[argument]满足这个方法[method]的参数特化符[parameter specializer]. 见章节 7.6.6.1.1 (选择可应用的方法).

**applicable restart** n. 1. (指状态[condition]) 当给定这个状况[condition]作为参数时, 关联的测试条件返回 true 的一个活跃[active]处理者[handler]. 2. (指非特定状况[condition]) 当给定 nil 作为参数时, 关联的测试条件返回 true 的一个活跃[active]处理者[handler].

**apply** v.t. (一个函数[function]到一个[list]) 使用这个列表[list]的元素[element]作为参数来调用这个函数[function]. "应用函数 + 到整数列表会返回这个列表的元素的总和(Applying the function + to a list of integers returns the sum of the elements of that list)".

**argument** n. 1. (一个函数[function]的) 当这个函数[function]被调用时, 作为数据提供给它的对象[object]. 2. (一个格式化控制[format control]的) 一个格式化参数[format argument].

**argument evaluation order** n. 一个函数调用中实参[argument]的求值顺序. "Common Lisp 的参数求值顺序是从左到右的". 见章节 3.1 (求值).

**argument precedence order** n. 将可应用方法[applicable method]按照优先级顺序排序时, 考虑给广义函数[generic function]的参数[argument]的顺序.

**around method** n. 有着 :around 限定符[qualifier]的方法[method].

**array** n. 一个 array 类型[type]的对象[object], 作为被安排在一个笛卡儿坐标系统(Cartesian coordinate system)的其他对象[object]的容器.

**array element type** n. (指数组[array]) 1. 一个和数组[array]关联的类型[type], 并且这个数组[array]的所有元素[element]都被约束为它的一个成员. 2. 这个数组的实际数组元素类型[actual array element type]. 3. 这个数组[array]的表达数组元素类型[expressed array element type].

**array total size** n. 一个数组[array]中的元素[element]的总数量, 由这个数组[array]的维数[dimension]的乘积计算得来. (因此一个零维数组[array]的大小为一.)

**assign** v.t. (一个变量[variable]) 去改变一个已经被建立的绑定[binding]的变量[variable]的值[value]. 见特殊操作符[special operator] setq.

**association list** n. 一个表示键[key]和值[value]关联的 cons 的列表[list], 其中每一个 cons 的car 为键[key]而 cdr 为那个键[key]关联的值[value].

**asterisk** n. 标准字符[standard character], 可被称为 "asterisk" 或 "star" (*). 见 Figure 2-5.

**at-sign** n. 标准字符[standard character], 可被称为 "commercial at" 或 "at sign" (@). 见 Figure 2-5.

**atom** n. 任何不是一个 cons 的对象[object]. "一个向量是一个原子(A vector is an atom)".

**atomic** adj. 是一个原子[atom]. "数字 3, 符号 foo, 还有 nil 都是原子的(The number 3, the symbol foo, and nil are atomic)".

**atomic type specifier** n. 一个原子的[atomic]类型指定符[type specifier]. 对于每一个原子类型指定符[atomic type specifier], x, 这里有一个没有提供参数的等价符合类型指定符[compound type specifier], (x).

**attribute** n. (指字符[character]) 这个字符[character]的程序可见的方面. 一个字符[character]的仅有标准化[standardized]属性[attribute]是它的码值[code[2]], 但是允许具体实现[implementation]去持有额外的具体实现定义的[implementation-defined]属性[attribute]. 见章节 13.1.3 (字符属性). "支持字体的实现可能使字体信息成为字符的属性, 而其他实现可能分别表示字体信息和字符".

**aux variable** n. 出现在 lambda 列表[lambda list]中由 &aux 引入的部分的一个变量[variable]. 不想 lambda-list 引入的所有其他变量[variable], 辅助变量[aux variable]不是参数[parameter].

**auxiliary method** n. 两组方法[method] (主方法[primary method]集合是另一组)中的一组方法[method]的成员, 它们在方法[method]的广义函数[generic function]上形成方法[method]集合的穷举分区. 如何确定这些集合取决于方法组合[method combination]类型; 见章节 7.6.2 (方法的介绍). 

### B

**backquote** n. 标准字符[standard character], 被称为 "抑音符" 或 "反引号" (`). 见 Figure 2-5.

**backslash** n. 标准字符[standard character], 被称为 "反斜线" 或 "反斜杠" (\\). See Figure 2-5.

**base character** n. 一个 base-char 类型[type]的字符[character].

**base string** n. 一个 base-string 类型[type]的字符串[string].

**before method** n. 一个修饰符[qualifier]为 :before 的方法.

**bidirectional** adj. (指流[stream]) 同时为一个输入[input]流[stream]和一个输出[output]流[stream].

binary adj. 1. (指流[stream]) 元素类型[element type]为 integer 类型[type]的子类型[subtype]的一个流[stream]. 在一个二进制[binary]输入[input]流[stream]上最基本的操作是 read-byte 而在一个二进制[binary]输出[output]流[stream]上最基本的操作是 write-byte. 见字符[character]. 2. (指文件[file]) 已经通过打开一个二进制[binary]流[stream]来创建. (这是否为一个文件[file]的可见测方面, 或者任何给定的字符[character]文件[file]是否被当作一个二进制[binary]文件[file]处理是依赖于具体实现的[implementation-dependent].)

**bind** v.t. (一个变量[variable]) 去建立这个变量[variable]的一个绑定[binding].

**binding** n. 一个名字[name]和那个名字[name]所表示的之间的一个关联. "一个词法绑定是一个名字和它的值之间的一个词法关联". 当这个术语绑定[binding]被一个命名空间[namespace]的名字限定时, 例如 "变量(variable)" 或 "函数(function)", 它约束这个绑定[binding]到指定的命名空间[namespace], 就像在: "let 建立变量绑定." 或 "let 建立多个变量的绑定" 中

**bit** n. 一个 bit 类型[type]的对象[object]; 也就是说, 是整数[integer] 0 或者整数[integer] 1.

**bit array** n. 一个 (array bit) 类型[type]的特化数组[array], 并且它的元素是 bit 类型[type].

**bit vector** n. 一个 bit-vector 类型[type]的特化向量[vector], 并且它的元素是 bit 类型[type].

**bit-wise logical operation specifier** n. 一个命名了可以被 boole 函数执行的十六个可能的位逻辑操作符之一的对象[object], 并且它是常变量[constant variable] boole-clr, boole-set, boole-1, boole-2, boole-c1, boole-c2, boole-and, boole-ior, boole-xor, boole-eqv, boole-nand, boole-nor, boole-andc1, boole-andc2, boole-orc1, 或 boole-orc2 之一的值[value].

**block** n. 一个已命名的词法退出点[exit point], 由 block 显式建立或者由 loop, do 和 prog 之类的操作符隐式建立, 通过使用带有这个语句块[block]的名字的 return-from 表达式形式, 可以将控制和值转移到该退出点.

**block tag** n. 在一个 block 表达式形式[form]内命名由这个 block 表达式形式[form]建立的语句块[block]的符号[symbol]. 见 return 或 return-from.

**boa lambda list** n. 一个语法上像普通 lambda 列表[ordinary lambda list]但是是"按参数顺序"处理的风格的 lambda 列表[lambda list]. 见章节 3.4.6 (Boa Lambda 列表).

**body parameter** n. 特定 lambda 列表[lambda list]中的一个可用的形参[parameter], 从符合规范的程序[conforming program]的视角看, 各种方面它就像是剩余参数[rest parameter], 除了它是由 &body 引入而不是 &rest 引入. (允许具体实现[implementation]提供区分主体参数[body parameter]和剩余参数[rest parameter]的扩展---比如, 使用主体参数[body parameter]定义的操作符[operator]的表达式形式[form]打印出来可能和使用剩余参数[rest parameter]定义的操作符[operator]的表达式形式[form]稍有不同.)

**boolean** n. 一个 boolean 类型[type]的对象[object]; 这也就是说, 下面这些对象[object]之一: 符号 t (表示 true), 或者符号 nil (表示 false). 见广义 boolean [generalized boolean].

**boolean equivalent** n. (指对象[object] O1) 当 O1 和 O2 都被视为广义 boolean [generalized boolean]时, 与 O1 有相同真实值的任何对象[object] O2.

**bound** adj., v.t. 1. adj. 在一个绑定[binding]中有一个关联的表示. "这些由一个 let 命名的变量在它的主体中是被绑定的(The variables named by a let are bound within its body)". 见未绑定的[unbound]. 2. adj. 有着一个遮蔽[shadows[2]]另一个的局部绑定[binding]. "在 princ 函数中时, 变量 \*print-escape* 是被绑定的(The variable \*print-escape* is bound while in the princ function)". 3. v.t. 绑定[bind]的过去时态.

**bound declaration** n. 一种声明[declaration], 它引用一个变量[variable]或函数[function]或者与它们关联, 并且出现在建立这个变量[variable]或函数[function]的特殊表达式形式[special form]中, 但是在这个特殊表达式形式[special form]的主体之前 (具体来说, 就是在那个表达式形式[form]主体的头部). (如果一个绑定声明[bound declaration]引用一个函数[function]绑定[binding]或者一个词法变量[lexical variable]绑定[binding], 这个声明[declaration]的作用域[scope]就是那个绑定[binding]的作用域[scope]. 如果这个声明[declaration]引用了动态变量[dynamic variable]绑定[binding], 那么这个声明[declaration]的作用域[scope]和这个绑定[binding]是词法而非动态时的作用域[scope]相同.)

**bounded** adj. (指序列[sequence] S, 由一对有序的绑定索引[bounding index] istart 和 iend 表示) 限定为 S 的元素[element]的子范围, 其中包括以 istart 索引的元素[element]开始(并包括), 直到(但不包括) iend 索引的元素[element]为止的每个元素[element].

**bounding index** n. (指一个长度[length]为 n 的序列[sequence]) 一个概念上的整数[integer]对 istart 和 iend, 分别称为 "上边界索引" 和 "下边界索引", 使 0 <=istart <=iend <=n, 因此它划分了一个由 istart 和 iend 限定[bounded]的序列[sequence]的子范围.

**bounding index designator** (指序列[sequence]) 作为有序对放在一起的两个对象[object]中的一个, 表现为序列[sequence]的边界索引[bounding index]的标识符[designator]; 这也就是说, 它们表示这个序列[sequence]的边界索引[bounding index], 并且可以是一个整数[integer] (表示它自身)和 nil (表示这个序列[sequence]的长度[length]), 或者两个整数[integer] (每一个都表示它自身).

**break loop** n. 正常 Lisp read-eval-print 循环[Lisp read-eval-print loop]的一个递归进入的变体, 通常因为调试的目的而暂停了正在进行的其他表达式形式[form]的求值[evaluation]. 通常, 一个中断循环[break loop]提供以某种方式退出的能力来继续中断的计算. 见函数[function] break.

**broadcast stream** n. 一个 broadcast-stream 类型[type]的输出[output]流[stream].

**built-in class** n. 一个类[class], 它是类[class] built-in-class 的一个广义实例[generalized instance].

**built-in type** n. Figure 4-2 中的类型[type]之一.

**byte** n. 1. 一个整数[integer]中的相邻位. (在程序中, 具体的比特数可以随点而变化; 见函数[function] byte.) 2. 在一个特定范围内的整数[integer]. (在程序中, 具体的范围可以随点而变化; 见函数[function] open 和 write-byte.) <!--TODO 待校验-->

**byte specifier** n. 一个有着依赖于具体实现[implementation-dependent]的性质的对象[object], 它由函数[function] byte 返回并且指定了一个整数[integer]中要被诸如 ldb 这样的函数[function]用作字节[byte]的位的范围. 

### C

**cadr** ['ka,duhr], n. (指对象[object]) 那个对象[object]的 cdr 的 car.

**call** v.t., n. 1. v.t. (带实参[argument]的函数[function]) 使该函数[function]所表示的代码[code]在基于这个实参[argument]为其形参[parameter]的值[value]建立绑定[binding]的环境[environment]中执行. "使用参数 5 和 1 来调用函数 + 会产生一个 6 的值 (calling the function + with the arguments 5 and 1 yields a value of 6)." 2. n. 函数[function]被调用的一种情况[situation].

**captured initialization form** n. 一个初始化表达式形式[initialization form]以及定义这个初始化表达式形式[initialization form]的表达式形式[form]被求值时所在的词法环境[lexical environment]. "每个新添加的共享槽都被设置为求值新类的 defclass 表达式形式中指定的槽的捕获初始化表达式形式的结果 (Each newly added shared slot is set to the result of evaluating the captured initialization form for the slot that was specified in the defclass form for the new class)."

**car** n. 1. a. (指 cons) 对应于给 cons 的第一个参数[argument]的 cons 的成员. "函数 rplaca 修改一个 cons 的 car (The function rplaca modifies the car of a cons)." b. (指列表[list]) 这个列表[list]的第一个元素[element], 如果这个列表[list]是空列表[empty list]那么就是 nil. 2. 被保存在 car[1]中的那个对象[object]. "函数 car 返回一个 cons 的 car."

**case** n. (一个字符[character]) 大写或小写的属性. 不是所有字符[character]都有大小写[case]. "The characters #\A and #\a have case, but the character #\$ has no case". 见章节 13.1.4.3 (大小写字符) 以及函数[function] both-case-p.

**case sensitivity mode** n. 符号[symbol] :upcase, :downcase, :preserve, 或 :invert 的其中之一.

**catch** n. 由一个 catch 表达式形式[form]建立在它主体的动态作用域[dynamic scope]中的一个退出点[exit point], 它由一个捕捉标签[catch tag]命名, 并且控制和值[value]可以 throw 给它.

**catch tag** n. 一个命名一个活跃[active]捕捉[catch]的对象[object]. (如果不止一个带有相同捕捉标签[catch tag]的捕捉[catch]是活跃的[active], 那么只可能 throw 到最内部的那个捕捉[catch], 因为外面那个被遮蔽[shadowed[2]]了.)

**cddr** ['kduh,duhr] 或 ['kuh,dduhr], n. (指对象[object]) 那么对象[object]的 cdr 的 cdr.

**cdr** ['k,duhr], n. 1. a. (指 cons) 对应于给 cons 的第二个实参[argument]的 cons 的成员; 另一个成员就是 car. "函数 rplacd 修改一个 cons 的 cdr (The function rplacd modifies the cdr of a cons)." b. (指一个列表[list] L1) 要么是包含  L1 的第一个之后的元素的列表[list] L2, 如果 L1 是空列表[empty list]那么就是 nil. 2. 保存在 cdr[1] 中的那个对象[object]. "函数 cdr 返回一个 cons 中的 cdr (The function cdr returns the cdr of a cons)."

**cell** n. Trad. (指对象[object]) 那个对象[object]的一个概念槽[slot]. 一个符号[symbol]的动态变量[dynamic variable]和全局函数[function]绑定[binding]有时分别被引用为它的值存储格[value cell]和函数存储格[function cell].

**character** n., adj. 1. n. 一个 character 类型[type]的对象[object]; 这也就是说, 一个表示一个文本的聚合总量中的单一标记; 见章节 13.1 (字符概念). 2. adj. a. (一个流[stream]的) 有着一个是 character 类型[type]的子类型[subtype]的元素类型[element type]. 在一个字符[character]输入[input]流[stream]上最基本的操作是 read-char 而在一个字符[character]输出[output]流[stream]上是 write-char. 见二进制[binary]. b. (一个文件[file]的) 已经通过打开一个字符[character]流[stream]来创建了. (这个是否是这个文件[file]的可检查方面, 或者任何给定的二进制[binary]文件[file]是否可以被当作一个字符[character]文件[file]是依赖于具体实现的[implementation-dependent].)

**character code** n. 1. 一个字符[character]的多个可能的属性[attribute]之一. 2. 一个小于 char-code-limit 的值的非负整数[integer], 它适用于字符码[character code[1]].

**character designator** n. 一个字符[character]的标识符[designator]; 这也就是说, 一个对象[object], 表示一个字符[character]并且为以下之一: 长度 1 的字符串[string]的一个标识符[designator] (表示它仅有的那个字符[character]元素[element]), 或者一个字符[character] (表示它自身).

**circular** adj. 1. (指列表[list]) 一个环状列表[circular list]. 2. (指一个任意对象[object]) 有着一个成员, 元素[element], 标记成分[constituent[2]], 或子表达式[subexpression] (视情况而定) 为这个对象[object]自身.

**circular list** n. 一个没有终止的 cons 链, 因为这个链中的某个 cons 是后面的一个 cons 的 cdr.

**class** n. 1. 一个对象[object],  它决定了那些被称为它的直接实例[direct instance]的其他对象[object]集合的结构和行为, 给那些被称为非直接实例[indirect instance]的其他对象[object]集合提供结构和行为, 并且充当一组被称为它的广义实例[generalized instance]的对象[object]的类型指定符[type specifier]. "类 integer 是类 number 的子类 (The class integer is a subclass of the class number)." (注意, 措辞 "类 foo" 经常指代更精确的术语 "名为 foo 的类[class]" --- 在这两种情况中, 表示的都是一个类[class]对象[object] (不是一个符号[symbol]).) 2. (指一个对象[object]) 对象[object]是其直接实例[direct instance]的唯一确定类[class]. 见函数[function] class-of. "由 gensym 返回的对象的类是 symbol (The class of the object returned by gensym is symbol)." (注意, 在这种用法中, "它的类[class]是 foo"之类的短语经常被替换为更精确的短语"它的类[class]是名为 foo 的类[class]"---在这两种情况中, 表示的都是一个类[class]对象[object] (不是一个符号[symbol]).)

**class designator** n. 一个类[class]的标识符[designator]; 这也就是说, 一个对象, 它表示一个类[class]并且它是以下之一: 一个符号[symbol] (表示由这个符号[symbol]命名的这个类[class]; 见函数[function] find-class) 或一个类 (表示它自身).

**class precedence list** n. 类[class]及其超类[superclass]上的唯一总排序, 与类[class]及其超类[superclass]的局部优先级[local precedence order]顺序一致. 关于详细信息, 见章节 4.3.5 (确定类的优先级列表).

**close** v.t. (一个流[stream]) 终止流[stream]作为数据的源或接收器的使用, 允许具体实现[implementation]去收回它的内部数据结构, 并且去释放任何在这个流[stream]被打开时锁定的外部资源.

**closed** adj. (指一个流[stream]) 已经被关闭 (见 close). 一些 (但不是全部) 在打开的[open]流[stream]上是合法的操作在关闭的[closed]流[stream]上是不合法的. 见章节 21.1.1.1.2 (打开和关闭的流).

**closure** n. 一个词法闭包[lexical closure].

**coalesce** v.t. (类似的[similar]字面化[literal]对象[object]) 来巩固这些对象[object]的标识, 使它们成为相同的[same]对象[object]. 见章节 3.2.1 (编译器术语).

**code** n. 1. Trad. 要执行的操作的任何表示形式, 无论是概念上的还是作为实际对象[object], 例如表达式形式[form], lambda 表达式[lambda expression], 函数[function]类型[type]的对象[object], 源码文件[source file]中的文本, 或者一个编译后文件[compiled file]中的指令序列. 这是一个通用术语; 表示的具体性质取决于它的上下文. 2. (指字符[character]) 一个字符码[character code].

**coerce** v.t. (一个对象[object]为一个类型[type]) 通过遵循一组强制转换规则从给定对象[object]生成一个对象[object], 而不修改该对象[object], 这些强制转换规则必须针对使用该术语的任何上下文进行特定说明. 得到的对象[object]必须是指定的类型[type], 除非该类型是类型[type] complex 的子类型[subtype]; 在这个情况中, 如果产生一个虚部为零的复有理数[complex rational], 则结果是一个有理数[rational]而不是一个复数[complex]---见章节 12.1.5.3 (复数的正规表示规则).

**colon** n. 标准字符[standard character], 它被称为 "冒号" (:). 见 Figure 2-5.

**comma** n. 标准字符[standard character], 它被称为 "逗号" (,). 见 Figure 2-5.

**compilation** n. 编译器[compiler]编译代码[code]的过程.

**compilation environment** n. 1. 一个环境[environment], 表示编译器[compiler]所知的关于一个要被编译的表达式形式[form]的信息. 见章节 3.2.1 (编译器术语). 2. 一个对象[object], 表示编译环境[compilation environment[1]]并且被用作给一个宏函数[macro function]的第二个参数 (它为这个宏函数[macro function]定义中的任何 &environment 形参[parameter]提供一个值[value]).

**compilation unit** n. 发生单个编译单元的时间间隔. 见宏[macro] with-compilation-unit.

**compile** v.t. 1. (代码[code]) 执行代码[code]的语义预处理, 通常优化代码的一个或多个质量, 如运行时执行速度或运行时存储使用情况. 编译的最小语义要求是它必须移除所有宏调用并且并安排在运行时之前解析所有加载时的值[ load time value]. 2. (一个函数[function]) 来产生一个 compiled-function 类型[type]的新对象[object], 它表示编译这个函数[function]表示的代码[code]的结果. 见函数[function] compile. 3. (一个源码文件[source file]) 来产生一个来自于一个源码文件[source file]的编译后文件[compiled file]. 见函数[function] compile-file.

**compile time** n. 编译器[compiler]处理源代码[source code]的持续时间.

**compile-time definition** n. 编译环境[compilation environment]中的一个定义.

**compiled code** n. 1. 编译后的函数[compiled function]. 2. 表示编译后的函数[compiled function]的代码[code], 例如一个编译后文件[compiled file]的内容.

**compiled file** n. 一个文件[file], 表示编译那些出现在对应源文件[source file]中的表达式形式[form]的结果, 并且可以被加载. 见函数[function] compile-file.

**compiled function** n. 一个 compiled-function 类型[type]的对象[object], 它是一个已经被编译的函数[function], 不包含必须在运行时被展开的宏[macro]的引用, 并且不包含对加载期值[load time value]的无法解决的引用.

**compiler** n. 一个工具, 它是 Lisp 的一部分, 将代码[code]转换为一个依赖于具体实现的[implementation-dependent]可以被高效地表示和执行的形式. 函数 compile 和 compile-file 允许程序去调用这个编译器[compiler].

**compiler macro** n. 全局定义的函数[function]或宏[macro]的辅助宏定义, 它可能被任何给定的符合规范的实现[conforming implementation]调用, 也可能不被调用, 它必须保留全局定义的函数[function]或宏[macro]的语义, 但可能执行一些额外的优化. (不像一个宏[macro], 一个编译器宏[compiler macro]不会扩展 Common Lisp 的语法; 相反, 它为一些现有的语法或功能提供了一种替代的实现策略.)

**compiler macro expansion** n. 1. 通过一个编译器宏[compiler macro]将一个表达式形式[form]转换为另一个表达式形式[form]的过程. 2. 这个过程产生的表达式形式[form].

**compiler macro form** n. 一个操作符[operator]被定义为编译器宏[compiler macro]的函数表达式形式[function form]或宏表达式形式[macro form], 或者一个 funcall 表达式形式[form], 它的第一个实参[argument]是一个 function 表达式形式[form], 这个表达式形式的实参[function]是一个被定义为编译器宏[compiler macro]的函数[function]的名字[name].

**compiler macro function** n. 一个两个参数的函数[function], 两个参数是一个表达式形式[form]和一个环境[environment], 它通过生成一个表达式形式[form]来实现编译器宏展开[compiler macro expansion], 该表达式形式[form]可以用来替代原始参数表达式形式[form], 也可以是 nil, 表示不应该替换原始表达式形式[form]. 见章节 3.2.2.1 (编译器宏).

**complex** n. 一个 complex 类型[type]的对象[object].

**complex float** n. 一个 complex 类型[type]的对象[object], 它的复数部分类型[complex part type]是 float 的一个子类型[subtype]. 一个复浮点数[complex float]是一个复数[complex], 但不是一个浮点数[float].

**complex part type** n. (指复数[complex]) 1. 被用于表示复数[complex]的实部和虚部的类型[type]. 2. 复数[complex]的实际复数部分类型[actual complex part type]. 3. 复数[complex]的表达复数部分类型[expressed complex part type].

**complex rational** n. 一个 complex 类型[type]的对象[object], 它的复数部分类型[complex part type]是 rational 的子类型[subtype]. 一个复有理数[complex rational]是一个复数[complex], 但不是一个有理数[rational]. 没有虚部为零的复有理数[complex rational], 因为这样一个数字总是被 Common Lisp 表示为一个 rational 类型[type]的对象[object]; 见章节 12.1.5.3 (复数的正规表示规则).

**complex single float** n. 一个 complex 类型[type]的对象[object], 它的复数部分类型[complex part type]是 single-float 的子类型[subtype]. 一个复单精度浮点数[complex single float]是一个复数[complex], 但不是一个单精度浮点数[single float].

**composite stream** n. 一个流[stream], 它由一个或多个流[stream]组成. "make-synonym-stream 创建一个复合流 (make-synonym-stream creates a composite stream)."

**compound form** n. 一个非空[non-empty]列表[list], 它是一个表达式形式[form]: 一个特殊表达式形式[special form], 一个 lambda 表达式形式[lambda form], 一个宏表达式形式[macro form], 或者一个函数表达式形式[function form].

**compound type specifier** n. 一个类型指定符[type specifier], 它是一个 cons; 也就是说, 一个不是原子类型指定符[atomic type specifier]的类型指定符[type specifier]. "(vector single-float) 是一个符合类型指定符 ((vector single-float) is a compound type specifier)."

**concatenated stream** n. 一个 concatenated-stream 类型[type]的输入[input]流[stream].

**condition** n. 1. 表示一种情况[situation]的对象[object]---通常, 但不一定是在发送期间. 2. 一个 condition 类型[type]的对象[object].

**condition designator** n. 一个或多个对象[object], 它们组合在一起表示现有的状况[condition]对象[object]或要隐式创建的状况[condition]对象[object]. 关于详细信息, 见章节 9.1.2.1 (状况标识符).

**condition handler** n. 一个函数[function], 它可能被发送的动作所调用, 它接收要被发送的状况[condition]作为它仅有的参数, 并且允许它去处理[handle]这个状况[condition]或拒绝[decline]. 见章节 9.1.4.1 (发送).

**condition reporter** n. 一个函数[function], 它描述了当 Lisp 打印器[Lisp printer]被调用而 \*print-escape* 是 false 时一个状况[condition]如何被打印. 见章节 9.1.3 (打印状况).

**conditional newline** n. 输出中的一个点, 可以由美观打印器[pretty printer]任意插入新行[newline]. 这里有四种条件换行[conditional newline], 称为 "线性风格(linear-style)", "填充风格(fill-style)", "吝啬风格(miser-style)", 以及 "强制风格(mandatory-style)". 见函数[function] pprint-newline 和章节 22.2.1.1 (输出排列的动态控制).

**conformance** n. 通过适当和完全遵守本规范的要求而达到的状态. 见章节 1.5 (规范性).

**conforming code** n. 符合规范的程序[conforming program]中的所有部分的代码[code].

**conforming implementation** n. 一个具体实现[implementation], 用来强调对所有规范性标准的完全和正确的遵守. 一个符合规范的实现[conforming implementation]能够接受符合规范的程序[conforming program]作为输入, 准备执行该程序[program], 并按照本规范执行所准备的程序[program]. 如果没有扩展干扰任何符合规范的程序[conforming program]的正确功能, 已扩展的具体实现[implementation]仍然可以是符合规范的实现[conforming implementation].

**conforming processor** n. ANSI 一个符合规范的实现[conforming implementation].

**conforming program** n. 一个程序[program], 用于强调程序的正确性仅依赖于 Common Lisp 的文档化方面, 因此可以期望在任何符合规范的实现[conforming implementation]中正确运行.

**congruent** n. 符合 lambda 列表[lambda list]一致性的规则, 就像章节 7.6.4 (广义函数的所有方法的一致 Lambda-list) 中详述的那样.

**cons** n.v. 1. n. 一个有着两个成员的复合数据对象[object], 这两个成员称为 car 和 cdr. 2. v. 去创建这样一个对象[object]. 3. v. Idiom. 去创建任何对象[object], 或者去分配存储.

**constant** n. 1. 一个常量表达式形式[constant form]. 2. 一个常变量[constant variable]. 3. 一个常量对象[constant object]. 4. 一个自求值[self-evaluating object].

**constant form** n. 求值[evaluation]总是产生[yield]相同值[value]的任何表达式形式[form], 既不影响它被求值时所在的环境, 也不受该环境影响 (除非允许引用环境[environment]中定义的常变量[constant variable]的名称), 并且不影响任何对象[object]的状态, 也不受任何对象[object]的状态的影响, 除非这些对象是由表达式形式[form]本身创建的对象[object]的其他不可访问部分[otherwise inaccessible part]. "参数为一个 quote 表达式形式的一个 car 表达式形式是一个常量表达式形式(A car form in which the argument is a quote form is a constant form)."

**constant object** n. 一个对象[object], 它被约束为不可变的[immutable] (例如, 根据它在程序[program]中的上下文或它的来源). "一个被 compile-file 处理的字面化对象是一个常量对象(A literal object that has been processed by compile-file is a constant object)."

**constant variable** n. 一个变量[variable], 它的值[value]从不改变; 也就是说, 一个关键字[keyword[1]] 或者一个已命名常量[named constant]. "符号 t, nil, :direction, 和 most-positive-fixnum 都是常变量(The symbols t, nil, :direction, and most-positive-fixnum are constant variables)."

**constituent** n., adj. 1. a. n. 作为标记[token]的一部分的字符[character]的语法类型[syntax type]. 关于详情, 见章节 2.1.4.1 (标记成分字符). b. adj. (一个字符[character]) 有着标记成分[constituent[1a]] 语法类型[syntax type[2]]. c. n. 一个标记成分[constituent[1b]]字符[character]. 2. n. (一个复合流[composite stream]) 组成该流[stream]的源或汇聚的几个对象[object]之一.

**constituent trait** n. (一个字符[character]) 一个读取表[readtable]中的一个标记成分[constituent[1b]]字符[character]的几个分类中的一个. 见章节 2.1.4.1 (标记成分字符).

**constructed stream** n. 一个源或接收器是一个 Lisp 对象[object]的流[stream]. 注意, 由于一个流[stream]也是一个 Lisp 对象[object], 因此复合流[composite stream]也被认为是构造流[constructed stream]. "一个字符串流是一个构造流 (A string stream is a constructed stream)."

**contagion** n. 一个过程, 其中不同类型[type]的对象[object]上的操作 (例如, 对混合类型[type]的数字[number]进行算术操作) 产生一个类型[type]由一个实参[argument]类型[type]对其他实参[argument]类型[type]的支配性控制的结果. 见章节 12.1.1.2 (数值运算的传递性).

**continuable** n. (指一个错误[error]) 一个通过 continue 重启动是可校正的[correctable]的错误[error].

**control form** n. 1. 一个表达式形式[form], 它建立一个或多个控制可以转移到的位置. 2. 一个转移控制的表达式形式[form].

**copy** n. 1. (指一个 cons C) 一个带有和 C 相同[same]的 car 和 cdr 的新的[fresh] cons. 2. (指一个列表[list] L) 一个带有和 L 相同[same]元素[element]的新[fresh]列表[list]. (只有列表结构[list structure]是新的[fresh]; 其中的元素[element]都相同[same].) 见函数[function] copy-list. 3. (指一个带有多个元素[element] Ai 的关联列表[association list] A) 一个带有多个元素[element] Bi 的新[fresh]列表[list], 如果 Ai 是 nil 那么对应的每一个都是 nil, 否则就是 cons Ai 的一个拷贝[copy]. 见函数[function] copy-alist. 4. (指一个树[tree] T) 一个带有和 T 相同[same]叶节点[leave]的新[fresh]树[tree]. 见函数[function] copy-tree. 5. (指一个随机状态[random state] R) 一个新[fresh]随机状态[random state], 如果被用作函数[function] random 的参数会产生和 R 产生的相同的 "随机" 值序列. 6. (指一个结构体[structure] S) 一个和 S 相同类型[type]的新[fresh]结构体[structure], 并且每一个槽的值都合 S 的对应槽的值相同[same]. (注意, 由于一个 cons, 一个列表[list], 和一个树之间的区别在于 "视图" 或 "意图", 没有一种通用函数[function]仅根据对象[object]的类型[type]就可以确定这些不同含义中的哪些含义. 区别完全取决于本文档内的文本说明. 比如, 像 "给定列表[list]的一个拷贝[copy] (a copy of the given list)" 或 "列表[list] x 的拷贝" 这样的短语意味着第二个定义.)

**correctable** adj. (指一个错误[error]) 1. (通过一个和该错误[error]关联的重启动[restart]而不是 abort) 能够通过调用该重启动[restart]进行纠正. "函数 cerror 发出一个错误, 它是可以通过 continue 重启动[restart]来校正的 (The function cerror signals an error that is correctable by the continue restart)." (注意, 这个可校正性不是一个错误[error]对象[object]的属性, 而是这个错误[error]发出时生效的动态环境[dynamic environment]的属性. 具体来说, 重启动[restart]与错误[error]状况[condition]对象[object]"关联". 见章节 9.1.4.2.4 (关联重启动和状况).) 2. (当没有特定重启动[restart]被提及时) 至少通过一个重启动[restart]即可纠正[correctable[1]]. "如果导入的任何符号具有与包中已经可访问的某些不同符号相同的名称, 则 import 发出 package-error 类型[type]的可纠正错误 (import signals a correctable error of type package-error if any of the imported symbols has the same name as some distinct symbol already accessible in the package)."

**current input base** n. (在一个动态环境[dynamic environment]中) 这个基数[radix]是这个环境[environment]中的 \*read-base* 的值[value], 并且它是 Lisp 读取器[Lisp reader]和它的相关函数[function]采用的默认基数[radix].

**current logical block** n. 最内部词法闭合的 pprint-logical-block 的上下文.

**current output base** n. (在一个动态环境[dynamic environment]中) 这个基数[radix]是这个环境[environment]中的 \*read-base* 的值[value], 并且它是 Lisp 打印器[Lisp printer]和它的相关函数[function]采用的默认基数[radix].

**current package** n. (在一个动态环境[dynamic environment]中) 这个包[package]是这个环境[environment]中 \*package* 的值[value], 并且它是 Lisp 读取器[Lisp reader]和 Lisp 打印器[Lisp printer]采用的默认包[package].

**current pprint dispatch table** n. (在一个动态环境[dynamic environment]中) 这个美观打印分派表[pprint dispatch table]是这个环境[environment]中 \*print-pprint-dispatch* 的值[value], 并且它是美观打印器[pretty printer]采用的默认美观打印分派表[pprint dispatch table].

**current random state** n. (在一个动态环境[dynamic environment]中) 这个随机状况[random state]是这个环境[environment]中 \*random-state* 的值[value], 并且它是 random 采用的默认随机状态[random state].

**current readtable** n. (在一个动态环境[dynamic environment]中) 那个环境中作为 \*readtable* 的值的读取表, 并且影响着表达式[expressions[2]]被 Lisp 读取器[Lisp reader]解析为对象[object]的方式. 


### D

**data type** n. Trad. 一个类型[type].

**debug I/O** n. 一个双向[bidirectional]流[stream], 它是变量[variable] \*debug-io* 的值[value].

**debugger** n. 一个工具, 它允许用户[user]去交互式地处理一个状况[condition]. 例如, 这个调试器[debugger]可以允许从活跃的[active]的重启动[restart]中交互式地选择一个重启动[restart], 并且它可能执行额外的具体实现定义的[implementation-defined]用于调试的服务.

**declaration** n. 一个全局声明[global declaration]或局部声明[local declaration].

**declaration identifier** n. 符号[symbol] declaration, dynamic-extent, ftype, function, ignore, inline, notinline, optimize, special, 或 type 之一; 或者是一个类型[type]名字[name]的符号[symbol]; 或者是一个已经通过 declaration 声明[declaration]被声明为一个声明标识符[declaration identifier]的符号[symbol].

**declaration specifier** n. 一个表达式[expression], 它可以出现在 declare 表达式或 declaim 表达式形式的顶层, 或作为给 proclaim 的参数, 并且它的 car 为一个声明标识符[declaration identifier], 而它的 cdr 是根据这个声明标识符[declaration identifier]特化的规则来解释的数据.

**declare** v. 去建立[establish]一个声明[declaration]. 见 declare, declaim, 或 proclaim.

**decline** v. (指一个处理者[handler]) 在没有处理这个被发出的状况[condition]的情况下正常返回, 允许发送过程继续, 就好像处理者[handler]不存在一样.

**decoded time** n. 绝对[absolute]时间[time], 表示为九个对象[object]的一个有序集, 合起来, 组成日期时间中一个点的描述, 精确到最近的秒 (除了闰秒[leap second]会被忽略). 见章节 25.1.4.1 (解码时间).

**default method** n. 一个方法[method], 它没有除了类[class] t 以外的参数特化符[parameter specializer]. 这样一个方法[method]总是为一个可应用方法[applicable method], 但是可能被一个更具体的方法[method]所遮蔽[shadow[2]].

**defaulted initialization argument list** n. 初始化参数名称[name]和值[value]的交替列表[list], 其中未提供的初始化参数被缺省了, 用于初始化和重新初始化类[class]的实例[instance].

**define-method-combination arguments lambda list** n. 一个被用于 define-method-combination 的 :argument 选项的 lambda 列表[lambda list]. 见章节 3.4.10 (Define-method-combination 参数 Lambda 列表).

**define-modify-macro lambda list** n. 一个被 define-modify-macro 使用的 lambda 列表[lambda list]. 见章节 3.4.9 (Define-modify-macro Lambda 列表).

**defined name** n. 一个意义已经由 Common Lisp 定义了的符号.

**defining form** n. 一个表达式形式[form], 它有着建立一个定义的副作用. "defun 和 defparameter 是定义表达式形式."

**defsetf lambda list** n. 一个 lambda 列表[lambda list], 它就像是一个普通 lambda 列表[ordinary lambda list], 除了它不允许 &aux 而允许 &environment 的使用. 见章节 3.4.7 (Defsetf Lambda 列表).

**deftype lambda list** n. 一个 lambda 列表[lambda list], 它就像一个宏 lambda 列表[macro lambda list], 除了未提供的可选参数[optional parameter]和关键字参数[keyword parameter]的默认值是符号[symbol] * (而不是 nil). 见章节 3.4.8 (Deftype Lambda 列表).

**denormalized** adj., ANSI, IEEE (指一个浮点数[float]) 符合 IEEE Standard for Binary Floating-Point Arithmetic 所描述的 "非规格化". 例如, 在一个最小可能的指数是 -7 但 0.001 是一个有效尾数的具体实现[implementation]中, 数字 1.0e-10 可能被内部表示为 0.001e-7, 即便标准化[normalized]表示需要它被表示为 1.0e-10 或 0.1e-9. 从本质上讲, 非规范化[denormalized]浮点数[float]的精度通常低于规范化[normalized]浮点数[float].

**derived type** n. 一种类型指定符[type specifier], 它是根据展开为另一个类型指定符[type specifier]来定义的. deftype 定义衍生类型[derived type], 可能还有其他具体实现定义的[implementation-defined]操作符[operator]也这样做.

**derived type specifier** n. 一个衍生类型[derived type]的类型指定符[type specifier].

**designator** n. 一个对象[object], 它表示另一个对象[object]. 在一个操作符[operator]的字典条目中, 如果一个形参被描述为一个类型[type]的标识符[designator], 那么所编写的该操作符[operator]的描述假设已经发生了对该类型[type]的适当强制转换; 也就是说, 那个形参[parameter]已经是表示的类型[type]了. 关于详细信息, 见章节 1.4.1.5 (标识符).

**destructive** adj. (指一个操作符[operator]) 能够修改一个或多个对象[object]的某些程序可见的方面, 这些对象[object]要么是操作符[operator]的显式参数[argument], 要么可以由操作符[operator]直接或间接地从全局环境[global environment]中获得.

**destructuring lambda list** n. 一个扩展 lambda 列表[extended lambda list], 它被用于 destructuring-bind 以及内嵌在宏 lambda 列表[macro lambda list]中. 见章节 3.4.5 (解构 lambda 列表).

**different** adj. 不相同[same] "字符串 'FOO' 和 'foo' 在 equal 下是不同的但是在 equalp 下是相同的 (The strings 'FOO' and 'foo' are different under equal but not under equalp)."

**digit** n. (在一个基数[radix]下) 在可能的数字(0 到 9、a 到 Z 和 a 到 Z)之间的一种字符[character], 它被定义为具有一个相关的数值权重, 作为基数[radix]中的一个数字. 见章节 13.1.4.6 (一个给定基数的数字).

**dimension** n. 1. 一个表示一个数组[array]可以在一个坐标轴中持有的对象[object]数量的非负整数[integer]. 如果这个数组[array]是一个带有填充指针[fill pointer]的向量[vector], 这个填充指针[fill pointer]会被忽略. "那个数组的第二维度大小是 7 (The second dimension of that array is 7)." 2. 一个数组[array]的一个坐标轴. "这个数组有六个维度 (This array has six dimensions)."

**direct instance** n. (指一个类[class] C) 一个类[class]是 C 自身的对象[object], 而不是 C 的某个子类[subclass]. "函数 make-instance 总是返回它的第一个参数表示 (或者由它命名) 的类的直接实例 (The function make-instance always returns a direct instance of the class which is (or is named by) its first argument)."

**direct subclass** n. (指一个类[class] C1) 一个类[class] C2, 使得 C1 是 C2 的一个直接超类[direct superclass].

**direct superclass** n. (指一个类[class] C1) 一个类[class] C2, 它在 C1 的定义中被显式的标识为 C1 的一个超类[superclass].

**disestablish** v.t. 去撤销一个对象[object], 一个绑定[binding], 一个退出点[exit point], 一个标签[tag], 一个处理者[handler], 一个重启动[restart], 或者一个环境[environment]的建立.

**disjoint** n. (指类型[type]) 没有公共的元素[element].

**dispatching macro character** n. 一个宏字符[macro character], 它有一个关联的表指定了跟在这个分派宏字符[dispatching macro character]后的每个字符调用的函数[function]. 见函数[function] make-dispatch-macro-character.

**displaced array** n. 一个数组[array], 它自身没有存储, 而是以指定的偏移位定向到另一个数组[array]的存储, 称为它的目标[target], 以这种方式, 任何访问存储转移数组[displaced array]的尝试都会隐式引用目标数组[target array].

**distinct** adj. 不相同[identical].

**documentation string** n. (在一个定义表达式形式[form]) 一个字面化[literal]字符串[string]由于它出现的上下文 (而不是由于该字符串[string]的某些本质上可观察的方面) 而被视为文档. 在某些情况下, 文档字符串[documentation string]以这样一种方式保存, 以便以后可以通过向函数[function] documentation 提供对象[object]或名称[name]和"种类"来获得它. "在一个 defmacro 表达式形式的代码主体前可以有一个 function 种类的文档字符串 (The body of code in a defmacro form can be preceded by a documentation string of kind function)."

**dot** n. 标准字符[standard character], 可以被称为 "句点(full stop)", "句号(period)", 或 "点(dot)" (.). 见 Figure 2-5.

**dotted list** n. 一个终止原子[atom]不是 nil 的列表[list]. (然而, 一个原子[atom]自身不是一个点列表[dotted list].)

**dotted pair** n. 1. 一个 cdr 为非列表[non-list]的 cons. 2. 任何 cons, 用于强调一个 cons 作为对称数据对的使用.

**double float** n. 一个 double-float 类型[type]的对象[object].

**double-quote** n. 标准字符[standard character], 可称为 "引号(quotation mark)" 或 "双引号(double quote)" ("). 见 Figure 2-5.

**dynamic binding** n. 在一个动态环境[dynamic environment]中的绑定[binding].

**dynamic environment** n. 一个环境[environment]的这个部分包含了带有动态范围[dynamic extent]的绑定[binding]. 一个动态环境[dynamic environment]包括: 由 unwind-protect 建立的退出点[exit point], 以及动态变量[dynamic variable]的绑定[binding], 由 catch 建立的退出点[exit point], 状况处理者[condition handler], 以及重启动[restart].

**dynamic extent** n. 一种范围[extent], 其持续时间受某一特定表达式形式[form]执行过程中的建立点和废除点的限制. 见不确定范围[indefinite extent]. "动态变量绑定有着动态范围 (Dynamic variable bindings have dynamic extent)".

**dynamic scope** n. 带有动态范围[dynamic extent]的不确定作用域[indefinite scope].

**dynamic variable** n. 一个变量[variable], 它的绑定[binding]是在动态环境[dynamic environment]中的. 见 special. 


### E

**echo stream** n. 一个 echo-stream 类型[type]的流[stream].

**effective method** n. 可应用方法[applicable method]的组合, 它在使用一个特定参数[argument]序列调用一个广义函数[generic function]时被执行.

**element** n. 1. (指列表[list]) 一个对象[object], 它是组成这个列表[list]的其中一个 cons 的 car. 2. (指数组[array]) 一个存储在数组[array]中的一个对象[object]. 3. (指序列[sequence]) 一个对象[object], 它是这个序列[sequence]所表示的列表[list]或数组[array]的一个元素[element]. 4. (指类型[type]) 一个对象[object], 它是这个类型[type]所表示的对象集中的一个成员[member]. 5. (指一个输入[input]流[stream]) 一个字符[character]或数字[number] (适用于流[stream]的元素类型[element type]) 它是可从流[stream]中读取的有序对象[object]序列中的一个 (使用 read-char 或 read-byte, 适用于该流[stream]). 6. (指一个输出[output]流[stream]) 一个字符[character]或数字[number] (适用于流[stream]的元素类型[element type]) 它是已经被写入到该流[stream]或者会被写入到该流[stream]的有序对象[object]序列中的一个 (使用 write-char 或 write-byte, 适用于该流[stream]). 7. (指类[class]) 该类[class]的一个广义实例[generalized instance].

**element type** n. 1. (指数组[array]) 数组[array]的数组元素类型[array element type]. 2. (指一个流[stream]) 流[steam]的流元素类型[stream element type].

**em** n. Trad. 一种与上下文相关的度量单位, 通常用于排版, 等于当前字体中字母"M"的显示宽度. (传统上选择字母"M"是因为它通常由字体中最宽的字形[glyph]表示, 而其他字符的宽度通常是 em 的一部分. 在提供比"M"字符更宽的非罗马字符的实现中, 允许另一个字符作为该度量的具体实现定义的[implementation-defined]引用字符, 而"M"只是 em 宽度的一小部分.) 在一个固定宽度字体中, 一个带有 n 个字符的行是 n 个 em 的宽度; 在一个可变宽度字体中, n 个 em 是这样一行的宽度的期望上限.

**empty list** n. 不包含元素[element]的列表[list]. 见 ().

**empty type** n. 这个类型[type]不包含元素[element], 并且它是所有类型[type]的子类型[subtype] (包括它自身). 见 nil.

**end of file** n. 1. 一个输入[input]流[stream]中一个一旦越过就没有进一步数据的点. 在一个交互式流[interactive stream]中是否有这样的点是由具体实现定义的[implementation-defined]. 2. 试图从位于文件末尾[end of file[1]]的输入[input]流[stream]中获取数据时发生的一种情况[situation].

**environment** n. 1. 一个绑定[binding]集合. 见章节 3.1.1 (环境的介绍). 2. 一个环境对象[environment object]. "macroexpand 接受一个可选的环境参数 (macroexpand takes an optional environment argument)".

**environment object** n. 表示词法绑定[lexical binding]集合的一个对象[object], 用于表达式形式[form]的处理中为该表达式形式[form]中的名称[name]提供意义. "macroexpand 接受一个可选环境参数 (macroexpand takes an optional environment argument)". (对象[object] nil 在用作一个环境对象[environment object]时表示空词法环境[null lexical environment]; 传递给宏函数[macro function]的环境参数[environment parameter]的值[value]是带有依赖于具体实现的[implementation-dependent]性质的对象[object], 它表示对应宏表达式形式[macro form]被展开时的环境[environment[1]].) 见章节 3.1.1.4 (环境对象).

**environment parameter** n. 定义表达式形式[defining form] f 中的一个形参[parameter], 它没有对应的实参[argument]; 而是, 该形参[parameter]接受一个环境[environment]对象[object]作为其值, 对应定义表达式形式[defining form] f 出现所在的词法环境[lexical environment].

**error** n. 1. (尽在措辞 "是一个错误 (is an error)" 中) 未指定程序语义, 且结果未定义的一种情况[situation]. 2. 表示一个错误[error]情况[situation]的一个状况[condition]. 见章节 1.4.2 (错误术语). 3. 一个 error 类型[type]的对象[object].

**error output** n. 动态变量[dynamic variable] \*error-output* 的值[value]所指代的输出[output]流[stream].

**escape** n., adj. 1. n. 一个单转义字符[single escape]或多转义字符[multiple escape]. 2. adj. 单转义[single escape]或多转义[multiple escape].

**establish** v.t. 去建立或形成一个绑定[binding], 一个声明[declaration], 一个退出点[exit point], 一个标签[tag], 一个处理者[handler], 一个重启动[restart], 或者一个环境[environment]. "let 建立词法绑定 (let establishes lexical bindings)".

**evaluate** v.t. (一个表达式形式[form]或一个隐式 progn [implicit progn]) 通过应用求值[evaluation]规则来执行这个表达式形式[form] (或者由多个表达式形式[form]组成的隐式 progn [implicit progn]) 所表示的代码[code], 返回零个或多个值.

**evaluation** n. 执行表达式形式[form]的模型, 返回零个或多个值. 这样的执行过程可能被解释器直接实现为一步或者通过先编译这个表达式形式[form]然后执行编译后的代码[code]来实现为两步; 这个选择依赖于上下文和具体实现[implementation]的性质, 但在任何情况下都不会被任何程序检测到. 求值模型的设计方式是, 符合规范的实现[conforming implementation]可能合法地只有一个编译器而没有解释器, 反之亦然. 见章节 3.1.2 (求值模型).

**evaluation environment** n. 一个运行时环境[run-time environment], 宏展开器和 eval-when 指定要被求值的代码在这里被求值. 编译器[compiler]发起的求值都发生在求值环境[evaluation environment]中.

**execute** v.t. Trad. (代码[code]) 去执行由这个代码[code]表示的命令操作.

**execution time** n. 已编译代码[compiled code]正在被执行的时期.

**exhaustive partition** n. (指一个类型[type]) 一组成对[pairwise]不相交[disjoint]的类型[type], 构成一个详尽的并集[exhaustive union].

**exhaustive union** n. (指一个类型[type]) 这个类型[type]的子类型[subtype]的集合, 它们的并集包含了这个类型[type]的所有元素[element].

**exit point** n. 控制表达式形式[control form]中的一个点, 从该点 (例如, block), 通过该点(例如, unwind-protect), 或到该点(例如, tagbody), 可以通过使用另一种控制表达式形式[control form]主动地转移控制和可能的值[value], 也可以通过求值[evaluation]的正常控制和数据流被动地传递值. "catch 和 block 为退出点建立绑定, throw 和 return-from 分别可以转移控制和值到该退出点; tagbody 建立为一个退出点建立一个带有词法范围的绑定, go 可以转移控制到这个绑定; 以及 unwind-protect 建立一个退出点, 控制可能被诸如 throw, return-from, 和 go 这样的操作符转移过它 (catch and block establish bindings for exit points to which throw and return-from, respectively, can transfer control and values; tagbody establishes a binding for an exit point with lexical extent to which go can transfer control; and unwind-protect establishes an exit point through which control might be transferred by operators such as throw, return-from, and go)".

**explicit return** n. 通过使用 return-from (或 return) 将控制 (以及可能的值[value]) 转移到一个语句块[block]的操作.

**explicit use** n. (指表达式形式[form] F 中的一个变量[variable] V) 一个对 V 的引用直接出现在 F 的正常语义中; 换句话说, 这不会暴露表达式形式[form]本身的宏展开[macro expansion]的任何未记录的细节. 然而, 由 F 的展开子表达式形式[subform]暴露的对 V 的引用被认为是对 V 的显式使用[explicit use].

**exponent marker** n. 一个字符, 被用于一个浮点数[float]的文本表示, 来分隔尾数和指数. 下一段中展示了标准读取表[standard readtable]中被定义为指数标记符[exponent marker]的那些字符. 关于更多信息, 见章节 2.1 (字符语法). "在 '3.0d7' 中的指数标记符 'd' 表示这个数字被表示为一个双精度浮点数 (The exponent marker 'd' in '3.0d7' indicates that this number is to be represented as a double float)".

    标记     意义                                  
    D 或 d  double-float                             
    E 或 e  float (见 *read-default-float-format*)  
    F 或 f  single-float                             
    L 或 l  long-float                               
    S 或 s  short-float                              

    Figure 26-1. Exponent Markers

**export** v.t. (一个包[package]中的一个符号[symbol]) 去把这个符号[symbol]添加到这个包[package]的外部符号[external symbol]列表中.

**exported** adj. (指一个包[package]中的一个符号[symbol]) 是这个包[package]的外部符号[external symbol].

**expressed adjustability** n. (指数组[array]) 概念上 (但实际上不一定) 与这个数组[array]相关联的一个广义 boolean [generalized boolean], 表示这个数组[array]是否为明确指定可调整的[expressly adjustable][expressly adjustable]. 参见实际可调整性[actual adjustability].

**expressed array element type** n. (指数组[array]) 这个类型[type]是这个数组[array]的类型声明[type declaration]所指示的数组元素类型[array element type], 或是在其创建时所请求的数组元素类型[array element type], 先于提升后的数组元素类型[upgraded array element type]的选择. (Common Lisp 没有提供一种在运行时直接检测这个类型的方式, 但是允许一个具体实现[implementation]在代码分析期间注意到该类型[type]时去对这个数组[array]的内容和可能在这个数组[array]上执行的操作做出假设, 即使这些假设通常不适用于明确指定数组元素类型[expressed array element type]的提升后的数组元素类型[upgraded array element type].)

**expressed complex part type** n. (指复数[complex]) 这个类型[type]是这个复数[complex]的类型声明[type declaration]所指示的复数部分类型[complex part type], 或是在其创建时所请求的复数部分类型[complex part type], 先于提升后的复数部分类型[upgraded complex part type]的选择. (Common Lisp 没有提供一种在运行时直接检测这个类型的方式, 但是允许一个具体实现[implementation]在代码分析期间注意到该类型[type]时去对这个数组[array]的内容和可能在这个数组[array]上执行的操作做出假设, 即使这些假设通常不适用于明确指定复数部分类型[expressed complex part type]的提升后的复数部分类型[upgraded complex part type].)

**expression** n. 1. 一个对象[object], 经常用于强调这个对象[object]的使用以一种专门的格式来编码或表示信息, 例如程序文本. "在一个 let 表达式形式中的第二个表达式是一个绑定列表(The second expression in a let form is a list of bindings)". 2. 用于表示一个源文件中的一个对象[object]的文本记号. "表达式 'sample 等价于 (quote sample)".

**expressly adjustable** adj. (指数组[array]) 由于在其创建时对该特性的显式请求而实际可调整的[actually adjustable]. 所有明确指定可调整的[expressly adjustable]数组[array]都是实际可调整的[actually adjustable], 但反过来未必如此.

**extended character** n. 一个 extended-char 类型[type]的字符[character]: 一个非基本字符[base character]的字符.

**extended function designator** n. 一个函数[function]的标识符[designator]; 也就是说, 一个表示一个函数[function]的对象[object], 它是以下之一: 一个函数名[function name] (表示在全局环境[global environment]中它命名的函数[function]), 或者一个函数[function] (表示它自身). 如果一个函数名[function name]被用作一个扩展函数标识符[extended function designator]但是它没有作为函数[function]的全局定义, 或者它是一个有着作为宏[macro]或特殊表达式形式[special form]作为全局定义的符号[symbol], 那么后果是未定义的.

**extended lambda list** n. 一个列表, 在形式和目的上类似一个普通 lambda 列表[ordinary lambda list], 但是提供额外的在普通 lambda 列表[ordinary lambda list]中不可用的语法或功能. "defmacro 使用扩展 lambda 列表 (defmacro uses extended lambda lists)".

**extension** n. 在一个 Common Lisp 的具体实现[implementatioin]的一个没有被这个标准所指定的工具.

**extent** n. 定义一个对一个对象, 一个绑定[binding], 一个退出点[exit point], 一个标签[tag], 一个处理者[handler], 一个重启动[restart], 或者一个环境[environment]的引用的时间间隔.

**external file format** n. 一个具有依赖于具体实现[implementation-dependent]的性质的对象[object], 它确定字符[character]在字符[character]文件[file]中外部编码的可能的几种依赖于具体实现的[implementation-dependent]方式中的一个.

**external file format designator** n. 一个外部文件格式[external file format]的标识符[designator]; 也就是说, 一个表示外部文件格式[external file format]的对象[object], 它是以下之一: 符号[symbol] :default (表示一个依赖于具体实现[implementation-dependent]的默认外部文件格式[external file format], 它至少可以容纳基本字符[base character]), 某个被具体实现[implementation]定义为一个外部文件格式标识符[external file format designator]的其他对象[object] (表示一个具体实现定义的[implementation-defined]外部文件格式[external file format]), 或者某个由具体实现定义的外部文件格式[external file format] (表示它自身).

**external symbol** n. (指包[package]) 一个符号[symbol], 它是这个包[package]的 '外部接口(external interface)' 的一部分, 并且被任何其他使用[use]这个包[package]的包[package]所继承[inherited[3]]. 在使用 Lisp 读取器[Lisp reader]时, 如果使用了一个包前缀[package prefix], 则外部符号[external symbol]的名称[name]与包[package]名称[name]之间用单个包标记[package marker]分隔, 而内部符号[internal symbol]的名[name]称与包[package]名称[name]之间用双包标记[package marker]分隔; 见章节 2.3.4 (符号标记).

**externalizable object** n. 一个对象[object], 它在要被文件编译器[file compiler]处理的代码[code]中用作一个字面化[literal]对象[object]. 


### F

**false** n. 符号[symbol] nil, 被用于表示一个断言[predicate]检测的失败.

**fbound** ['ef,band] adj. (指一个函数名[function name]) 被绑定[bound]在函数[function]命名空间[namespace]. (宏[macro]和特殊操作符[special operator]的名称是 fbound 的, 但是它们的值[value]对象[object]的类型[type]和性质是依赖于具体实现的[implementation-dependent]. 更进一步, 定义一个 setf 展开器[setf expander] F 不会导致 setf 函数[setf function] (setf F) 变为已定义的; 同样的, 如果这里这样一个 setf 展开器[setf expander]的定义, 那么当且仅当一个 (setf F) 的函数绑定被独立建立时, 不管是故意的或是巧合, 函数[function] (setf F) 可以是 fbound 的.) 见函数[function] fboundp 和 symbol-function.

**feature** n. 1. Common Lisp, 具体实现[implementation], 或环境[environment]的一个方面或属性. 2.命名一个特性[feature[1]]的一个符号[symbol]. 见章节 24.1.2 (特性). ":ansi-cl 特性出现在所有符合规范的实现中 (The :ansi-cl feature is present in all conforming implementations)".

**feature expression** n. #+ 和 #- 读取器宏[reader macro]使用的特性的一种 boolean 组合, 用于直到 Lisp 读取器[Lisp reader]条件读取表达式[expression]. 见章节 24.1.2.1 (特性表达式).

**features list** n. \*features* 的值[value]所表示的列表[list].

**file** n. 在一个文件系统[file system]中的一个已命名的条目, 有着具体实现定义的[implementation-defined]性质.

**file compiler** n. 编译[compile]文件[file]中包含的源代码[source code], 生成已编译文件[compiled file]作为输出的任何编译器[compiler]. 这个 compile-file 函数是 Common Lisp 提供的这样一个编译器[compiler]的仅有的接口, 但是这里可能有其他具体实现定义的[implementation-defined]机制来调用这个文件编译器[file compiler].

**file position** n. (在一个流[stream]中) 表示这个流[stream]中的位置的非负整数[integer]. 并不是所有的流[stream]都能够表示文件位置[file position]的概念; 在任何操纵文件位置[file position]的操作符的描述中, 没有此概念的流[stream]的行为必须显式声明. 对于二进制[binary]流[stream], 文件位置[file position]表示流[stream]中前面的字节[byte]数. 对于字符[character]流[stream], 约束更加宽松: 文件位置[file position]必须单调递增, 与流[stream]中任意两个连续字符对应的文件位置[file position]之间的增量依赖于具体实现[implementation-dependent].

**file position designator** n. (在一个流[stream]中) 在这个流[stream]中一个文件位置[file position]的标识符[designator]; 也就是说, 符号[symbol] :start (表示 0, 在这个流[stream]中的第一个文件位置[file position]), 符号[symbol] :end (在这个流[stream]中的最后一个文件位置[file position]; 也就是说, 这个流[stream]中最后一个元素[element]后面的位置), 或者一个文件位置[file position] (表示它自身).

**file stream** n. 一个 file-stream 类型[type]的对象[object].

**file system** n. 一种工具, 它允许将数据聚合存储在 Lisp 镜像[Lisp image]外部的某些介质上的命名文件[file]中, 从而在不同的会话[session]之间持久保存.

**filename** n. 一个句柄, 不一定直接表示为对象[object], 它可以被用于引用一个文件系统[file system]中的一个文件[file]. 路径名[pathname]和名称字符串[namestring]是 Common Lisp 中两种可以替代文件名[filename]的对象[object].

**fill pointer** n. (指一个向量[vector]) 和一个向量[vector]关联的一个整数[integer], 它表示上面没有有效[active]元素[element]的索引. (一个填充指针[fill pointer]是一个不大于这个向量[vector]中元素[element]数量的非负整数[integer]. 不是所有向量[vector]都有填充指针[fill pointer].)

**finite** adj. (指一个类型[type]) 有着有限数量的元素[element]. "类型指定符 (integer 0 5) 表示一个有限类型, 但类型指定符 integer 和 (integer 0) 不是 (The type specifier (integer 0 5) denotes a finite type, but the type specifiers integer and (integer 0) do not)".

**fixnum** n. 一个 fixnum 类型[type]的整数[integer].

**float** n. 一个 float 类型[type]的对象[object].

**for-value** adj. (指对一个绑定[binding]的引用[reference]) 作为读取[read[2]]绑定[binding]值[value]的一个引用[reference].

**form** n. 1. 任何要被求值的对象[object]. 2. 一个符号[symbol], 一个复合表达式形式[compound form], 或者一个子求值对象[self-evaluating object]. 3. (对于一个操作符[operator], 例如在 "<<operator>> 表达式形式" 中) 第一个元素[element]为该操作符[operator]的一个复合表达式形式[compound form]. "一个 quote 表达式形式是一个常量表达式形式 (A quote form is a constant form)".

**formal argument** n. Trad. 一个参数[parameter].

**formal parameter** n. Trad. 一个参数[parameter].

**format** v.t. (一个格式化控制[format control]和格式化参数[format argument]) 就像通过 format 一样使用格式化字符串[format string]和格式化参数[format argument]去执行输出.

**format argument** n. 一个对象[object], 它被例如 format 这样解释格式化控制[format control]的函数[function]用作数据.

**format control** n. 一个格式化字符串[format string], 或者一个函数[function], 它遵循由 formatter 宏[macro]返回的函数[function]的参数[argument]规约. 见章节 22.2.1.3 (编译格式化字符串).

**format directive** n. 1. 在一个格式化字符串[format string]中通过波浪线[tilde]引入的一个字符[character]序列, 它由处理格式化字符串[format string]的代码[code]进行特殊解释, 表示应该执行某些特殊操作, 可能涉及格式化字符串[format string]附带的格式化参数[format argument]提供的数据. 见函数[function] format. "在 '~D base 10 = ~8R' 中, 字符序列 '~D' 和 '~8R' 是格式化指令 (In '~D base 10 = ~8R', the character sequences '~D' and '~8R' are format directives)". 2. 使用相同分派字符的所有格式化指令[format directives[1]]的概念类别. "'~3d' 和 '~3,'0D' 都是 '~D' 格式化指令的有效使用 (Both '~3d' and '~3,'0D' are valid uses of the '~D' format directive)".

**format string** n. 一个字符串[string], 它可以包含普通文本和格式化指令[format directive], 并且它和格式化参数[format argument]结合来描述文本输出应该如何被特定函数 (例如, format) 格式化.

**free declaration** n. 一个声明[declaration], 它不是一个绑定声明[bound declaration]. 见 declare.

**fresh** adj. 1. (指一个函数[function]产生的一个对象[object]) 由该函数[function]新分配的. (一个返回一个新[fresh]对象[object]的函数[function]的调用者可以自由地修改那个对象[object], 不需要担心这样的修改会破坏那个函数[function]未来的正确行为.) 2. (指一个名称[name]的绑定[binding]) 新分配的; 不和该名称[name]的其他绑定[binding]共享.

**freshline** n. 流[stream]上的一个概念操作, 由函数[function] fresh-line 和格式化指令[format directive] ~& 实现, 它将显示位置提前到下一行的开头 (就好像输入一个换行[newline]或者调用函数[function] terpri 一样), 除非该流[stream]已经知道位于一行的开头. 不像换行符[newline], 新行[freshline]不是一个字符[character].

**funbound** ['efunband] n. (指一个函数名[function name]) 没有被 fbound.

**function** n. 1. 一个表示代码的对象[object], 它可以使用零个或多个参数[argument]来调用, 并且它产生零个或多个值[value]. 2. 一个 function 类型[type]的对象[object].

**function block name** n. (指一个函数名[function name]) 被用作包围在该函数名[function name]表示的函数[function]主体外的隐式语句块[implicit block]的名字的符号[symbol]. 如果这个函数名[function name]是一个符号[symbol], 它的函数语句块名称[function block name]就是那个函数名[function name]自身. 如果那个函数名[function name]是一个 car 为 setf 且 cadr 为一个符号[symbol]的列表[list], 它的函数语句块名称[function block name]就是那个函数名[function name]的 cadr 的符号[symbol]. 一个支持其他种类的函数名[function name]的具体实现[implementation]必须为每种函数名指定如何计算函数语句块名[function block name].

**function cell** n. Trad. (指一个符号[symbol]) 持有由这个符号[symbol]命名的全局函数[function]绑定[binding] (如果存在的话) 的定义的位置[place], 它可以通过 symbol-function 来访问. 见存储格[cell].

**function designator** n. 一个函数[function]的标识符[designator]; 也就是说, 一个表示函数[function]的对象[object], 并且它是以下之一: 一个符号[symbol] (表示全局环境[global environment]中由这个符号[symbol]命名的函数[function]), 或者一个函数[function] (表示它自身). 如果一个符号[symbol]被用作一个函数标识符[function designator]但是它没有作为一个函数[function]的全局定义, 或者它是一个宏[macro]或特殊表达式形式[special form]的全局定义, 那么后果是未定义的. 参见扩展函数标识符[extended function designator].

**function form** n. 一个表达式形式[form], 它是一个列表[list]并且它的第一个元素[element]是要被调用的函数[function]的名称[name], 而实参[argument]是求值该函数表达式形式[function form]的后续元素的结果.

**function name** n. 1. (在一个环境[environment]中) 一个符号[symbol]或一个列表[list] (setf symbol), 它是那个环境[environment]中一个函数[function]的名字[name]. 2. 一个符号[symbol]或一个列表[list] (setf symbol).

**functional evaluation** n. 从一个函数名[function name]或一个 lambda 表达式[lambda expression]中提取一个函数值[functional value]的过程. 求值器在遇到一个复合表达式形式[compound form]的 car 中的一个函数名[function name]或 lambda 表达式[lambda expression]时隐式执行函数求值[functional evaluation], 在遇上一个 function 特殊表达式形式[special form]时被显式求值. 一个符号[symbol]作为函数标识符[function designator]的使用, 以及函数[function] symbol-function 去提取一个符号[symbol]的函数值[functional value]都不被认为是一个函数求值[functional evaluation].

**functional value** n. 1. (指一个环境[environment] E 中一个函数名[function name] N) 在环境[environment] E 的函数[function]命名空间[namespace]中名为 N 的绑定[binding]的值[value]; 也就是说, 在环境[environment] E 中名为 N 的函数存储格[function cell]的内容. 2. (指一个 fbound 的符号[symbol] S) 这个符号[symbol]的函数存储格[function cell]的内容; 也就是说, 全局环境[global environment]函数[function]命名空间[namespace]中的名为 S 的绑定[binding]的值[value]. (一个在全局环境[global environment]中是一个宏名称[macro name]或者是一个特殊操作符[special operator]的名称[name]可能是也可能不是 fbound 的. 但是如果 S 是这样一个名称[name]并且是 fbound 的, 它的函数值[functional value]的具体性质是依赖于具体实现的[implementation-dependent]; 它可能是一个函数[function], 也可能不是.)

**further compilation** n. 在最小编译[minimal compilation]之外的依赖于具体实现[implementation-dependent]的编译. 进一步编译允许发生在运行时[run time'. "语句块编译和特定于机器的指令的生成是进一步编译的示例 (Block compilation and generation of machine-specific instructions are examples of further compilation)".


### G

**general** adj. (指数组[array]) 有着元素类型[element type] t, 因此能够将任何对象[object]作为元素[element].

**generalized boolean** n. 被用作一个真值的对象[object], 其中符号[symbol] nil 表示 false 并且所有其他对象[object]表示 true. 见 boolean.

**generalized instance** n. (指一个类[class]) 一个对象[object], 它的类[class]是该类[class]自身或者该类[class]的某个子类[subclass]. (因为类型[type]和类[class]之间的对应关系, 术语 "X 的广义实例 (generalized instance of X)" 意味着 "类型[type] X 的对象[object] (object of type X)" 并且在 X 为一个类[class] (或类[class]名称[name]) 的情况下反过来说也是对的. 前者强调 X 作为类[class]的观点, 而后者强调 X 作为类型指定符[type specifier]的观点.)

**generalized reference** n. 对存储对象[object]的位置的引用, 就像对变量[variable]的引用一样. (这样的引用可以读取[read]或写入[write]这个位置.) 见章节 5.1 (广义引用). 参见位置 [place].

**generalized synonym stream** n. (使用同义流符号[synonym stream symbol]) 1. (对一个流[stream]) 指向该流[stream]的一个同义流[synonym stream], 或者以指向该流[stream]的同义流[synonym stream]为目标的一个复合流[composite stream]. 2. (对一个符号[symbol]) 指向该符号[symbol]的一个同义流[synonym stream], 或者以指向该符号[symbol]的同义流[synonym stream]为目标的一个复合流[composite stream].

**generic function** n. 一个函数[function], 其行为取决于提供给它的参数的类[class]或标识, 其部分包括一组方法[method]、lambda 列表[lambda list]和方法组合[method combination]类型等.

**generic function lambda list** n. 被用于描述到一个广义函数[generic function]的数据流的 lambda 列表[lambda list]. 见章节 3.4.2 (广义函数 Lambda 列表).

**gensym** n. Trad. 一个未捕获[uninterned]的符号[symbol]. 见函数[function] gensym.

**global declaration** n. 使有关代码的特定种类的信息全局可用的一种表达式形式[form]; 也就是说, 一个 proclaim 表达式形式[form]或 declaim 表达式形式[form].

**global environment** n. 一个环境[environment]中包含带有非限定作用域[indefinite scope]和非限定范围[indefinite extent]的绑定[binding]的部分.

**global variable** n. 一个动态变量[dynamic variable]或者一个常变量[constant variable].

**glyph** n. 一种可见表示. "图形字符具有相关的字形 (Graphic characters have associated glyphs)".

**go** v. 把控制转移到一个 go 点[go point]. 见特殊操作符[special operator] go.

**go point** 由 tagbody (或者其他抽象, 例如 prog, 它由 tagbody 构造而来) 建立的多个可能的退出点[exit point]中的一个.

**go tag** n. 在一个 tagbody 表达式形式[form]的词法作用域[lexical scope]内的这个符号[symbol]或整数[integer]命名了该 tagbody 表达式形式[form]建立的一个退出点[exit point].

**graphic** adj. (指一个字符[character]) 一种 "打印" 或 "可显示" 的字符[character], 具有作为单个字形[glyph]的标准视觉表示, 例如 A 或 * 或 =. 空格[space]被定义为是图形的[graphic]. 标准字符[standard character]中, 除了换行符[newline]以外所有字符都是图形的[graphic]. 见非图形[non-graphic]. 


### H

**handle** v. (指正在被发送的一个状况[condition]) 去执行一个控制的非局部转移, 终止正在进行的状况[condition]发送.

**handler** n. 一个状况处理者[condition handler].

**hash table** n. 一个 hash-table 类型[type]的对象[object], 它提供了一个从键[key]到值[value]的映射.

**home package** n. (指一个符号[symbol]) 这个包[package], 如果存在, 它就是这个符号[symbol]的包存储格[package cell]的内容, 并且它表示当前包[current package]中这个符号[symbol]不是可访问[accessible]时, Lisp 打印器[Lisp printer]如何打印该符号[symbol]. (包存储格[package cell]中的值为 nil 的符号[symbol]被说成是没有 home 包[home package]的, 并且也是明显未捕获的[apparently uninterned].) 


### I

**I/O customization variable** n. 下一段中的那些流变量[stream variable]中的一个, 或者被具体实现[implementation]定义为 I/O 定制变量[I/O customization variable]的某个其他 (具体实现定义的[implementation-defined]) 流变量[stream variable].

    *debug-io*        *error-io*         query-io*       
    *standard-input*  *standard-output*  *trace-output*  

    Figure 26-2. 标准化的 I/O 定制变量

**identical** adj. 在 eq 下相同[same].

**identifier** n. 1. 一个被用于标识或区分名称[name]的符号[symbol]. 2. 被用于相同途径的字符串[string].

**immutable** adj. 不受更改的约束, 这要么是因为没有提供能够执行此类更改的操作符[operator], 要么是因为存在一些约束, 禁止使用本可以执行此类更改的操作符[operator]. 除非显式指出, 否则不要求具体实现[implementation]去检测那些修改不可变[immutable]对象[object]或存储格[cell]的尝试; 尝试去作出这样修改的后果是未定义的. "数字是不可变的 (Numbers are immutable)".

**implementation** n. 一个实现了 Common Lisp 的语义的系统, 机制, 或代码体.

**implementation limit** n. 由具体实现[implementation]强加的限制.

**implementation-defined** adj. 依赖于具体实现的[implementation-dependent], 但是本规范要求每个符合规范的实现[conforming implementation]都要定义的, 并且由对应实现者记录.

**implementation-dependent** adj. 描述 Common Lisp 的一个行为或方面, 这个行为或方面被故意保留为未指定的, 可能在一些符合规范的实现[conforming implementation]中定义, 而在其他实现中没有定义, 其细节可能在不同的实现[implementation]中有所不同. 鼓励 (但不要求) 一个符合规范的实现[conforming implementation]去记录其对本规范中标记为依赖于具体实现[implementation-dependent]的每一项的处理, 虽然在这些情况中这样的文档记录可能简单地标识这个项为 "未定义的".

**implementation-independent** adj. 用于标识或强调 Common Lisp 的一个行为或方面, 该行为或方面在符合规范的实现[conforming implementation]之间没有变化.

**implicit block** n. 一个由宏表达式形式[macro form]而不是显式 block 表达式形式[form]引入的语句块[block].

**implicit compilation** n. 在求值[evaluation]期间执行的编译[compilation].

**implicit progn** n. 在另一个表达式形式[form]中出现的相邻表达式形式[form]的有序集合, 并由该表达式形式[form]中的上下文定义为就像在一个 progn 中执行一样.

**implicit tagbody** n. 在另一个表达式形式[form]中的相邻表达式形式[form] 和/或 标签[tag]的有序集合, 并由该表达式形式[form]中的上下文定义为就像在一个 tagbody 中执行一样.

**import** v.t. (一个包[package]中的一个符号[symbol]) 使这个符号[symbol]出现[present]在该包[package]中.

**improper list** n. 一个列表[list], 它不是一个正规列表[proper list]: 一个循环列表[circular list]或者一个点对列表[dotted list].

**inaccessible** adj. 不是可访问的[accessible].

**indefinite extent** n. 时长是无限的一个范围[extent]. "大部分 Common Lisp 对象有着无限范围 (Most Common Lisp objects have indefinite extent)".

**indefinite scope** n. 没有限制的作用域[scope].

**indicator** n. 一个属性指示器[property indicator].

**indirect instance** n. (指一个类[class] C1) 类[class] C2 的一个对象, 其中 C2 是 C1 的一个子类[subclass]. "一个整数是类 number 的一个简洁实例 (An integer is an indirect instance of the class number)".

**inherit** v.t. 1. 接受或获得一种品质、特质或特征; 访问在其他地方定义的特性. 2. (一个类[class]) 获取超类[superclass]定义的结构和行为. 3. (一个包[package]) 通过使用 use-package 来使被另一个包[package]导出[export]是可访问的[accessible].

**initial pprint dispatch table** n. Lisp 镜像[Lisp image]开始时 \*print-pprint-dispatch* 的值[value].

**initial readtable** n. Lisp 镜像[Lisp image]开始时 \*readtable* 的值[value].

**initialization argument list** n. 用于初始化和重新初始化类[class]实例[instance]的协议中初始化参数名称[name]和值[value]的属性列表[property list]. 见章节 7.1 (对象创建和初始化).

**initialization form** n. 被用于给一个槽[slot]或变量[variable]提供初始值[value]的表达式形式[form]. "一个 defclass 表达式形式中的一个槽的初始化表达式形式由关键字 :initform 引入 (The initialization form for a slot in a defclass form is introduced by the keyword :initform)".

**input** adj. (指一个流[stream]) 支持输入操作 (换句话说, 是一个 "数据源"). 一个输入[input]流[stream]也可能是一个输出[output]流[stream], 在这种情况下它有时被称为双向[bidirectional]流[stream]. 见函数[function] input-stream-p.

**instance** n. 1. 一个直接实例[direct instance]. 2. 一个广义实例[generalized instance]. 3. 一个间接实例[indirect instance].

**integer** n. 一个 integer 类型[type]的对象[object], 表示一个数学上的整数.

**interactive stream** n. 一个流[stream], 可以在其上执行交互式查询. 见章节 21.1.1.1.3 (交互式流).

**intern** v.t. 1. (一个包[package]的字符串[string]) 在这个包[package]中查找这个字符串[string], 返回这个包[package]中已经可访问[accessible]的带有该名称[name]的符号[symbol], 或者返回这个包[package]中新创建的带有这个名称[name]的内部符号[internal symbol]. 2. Idiom. 通常, 观察一种协议, 在该协议定义的某个谓词下具有等价或具有等价名称的对象被映射到单个规范对象.

**internal symbol** n. (指一个包[package]) 一个符号[symbol], 它在该包[package]中是可访问[accessible]的, 但是不是这个包[package]的一个外部符号[external symbol].

**internal time** n. 时间[time], 被表示为内部时间单元[internal time unit]的一个整数[integer]数字. 绝对[absolute]内部时间[internal time]是作为从任意选择的、依赖于具体实现[implementation-dependent]的基础上的偏移量来度量的. 见章节 25.1.4.3 (内部时间).

**internal time unit** n. 等价于一秒的 1/n 的时间单元, 其中 n 是某个具体实现定义的[implementation-defined]整数[integer]值. 见变量[variable] internal-time-units-per-second.

**interned** adj. Trad. 1. (指一个符号[symbol]) 在任何包[package]中可访问的[accessible[3]]. 2. (指一个特定包[package]中的一个符号[symbol]) 出现[present]在该包[package]中.

**interpreted function** n. 一个函数[function], 它不是一个编译后的函数[compiled function]. (这里可能存在一个符合规范的实现[conforming implementation]没有解释型函数[interpreted function], 但是一个符合规范的程序[conforming program]一定不能假设所有的函数[function]都是编译后的函数[compiled function].)

**interpreted implementation** n. 一个具体实现[implementation], 它对解释型函数[interpreted function]使用的执行策略不涉及一次性的语义分析预传递, 而是在执行过程中遇到表达式形式[form]时使用的"惰性"(有时是重复的)语义分析.

**interval designator** n. (指类型[type] T) 一种有序的对象[object]对, 通过在实数行上分隔一个区间来描述 T 的子类型[subtype]. 见章节 12.1.6 (区间标识符).

**invalid** n., adj. 1. n. 字符[character]的一个可能的标记成分特质[constituent trait], 如果它存在就表示这个字符[character]不能出现在一个标记[token]中, 除了在单转义[single escape]字符[character]的控制下. 关于详情, 见章节 2.1.4.1 (标记成分字符). 2. adj. (指一个字符[character]) 是一个字符[character], 它在当前读取表[current readtable]中有着语法类型[syntax type]的标记成分[constituent], 并且它有着非法[invalid[1]]标记成分特质[constituent trait]. 见 Figure 2-8.

**iteration form** n. 操作符[operator]在下一段中命名的一个复合表达式形式[compound form], 或者是一个有着具体实现定义的[implementation-defined]操作符[operator]并且被该实现定义为循环表达式形式[iteration form]的复合表达式形式[compound form].

    do              do-external-symbols  dotimes  
    do*             do-symbols           loop     
    do-all-symbols  dolist                        

    Figure 26-3. 标准循环表达式形式

**iteration variable** n. 一个变量[variable] V, 它的绑定[binding]由一个循环表达式形式[iteration form]中 V 的显式使用[explicit use]所创建. 


### K

**key** n. 在检索过程中用于选择的对象[object]. 见关联列表[association list], 属性列表[property list], 还有散列表[hash table]. 另外, 见章节 17.1 (序列的概念).

**keyword** n. 1. 一个 home 包[home package]是 KEYWORD 包的符号[symbol]. 2. 任何在传递的关键字风格参数中被用作一个标识记号的符号[symbol], 通常在 KEYWORD 包中, 但不一定在 KEYWORD 包中. 见 lambda. 3. Idiom. 一个 lambda 列表关键字[lambda list keyword].

**keyword parameter** n. 一个形参[parameter], 对应的关键字实参[argument]是可选的. (There is no such thing as a required keyword argument.) 如果没有提供这样一个实参[argument], 那么就使用一个默认值. 参见 supplied-p 参数[supplied-p parameter].

**keyword/value pair** n. 一个属性列表[property list]的两个连续元素[element] (分别是一个关键字[keyword]和一个值[value]). 


### L

**lambda combination** n. Trad. 一个 lambda 表达式形式[lambda form].

**lambda expression** n. 一个列表[list], 通过直接描述其行为而非间接引用一个已建立函数[function]的名字, 可以在特定上下文中被用于取代一个函数名[function]来表示一个函数[function]; 它的名称源于它的第一个元素是符号[symbol] lambda. 见 lambda.

**lambda form** n. 一个表达式形式[form], 它是一个列表[list], 并且它的第一个元素[element]是一个要被调用的函数[function]的 lambda 表达式[lambda expression], 这个函数使用求值这个 lambda 表达式形式[lambda form]的后续元素的结果作为实参[argument]来调用.

**lambda list** n. 一个列表[list], 它指定了形参[parameter]集合 (有时被称为 lambda 变量[lambda variables]) 以及一个协议来接收这些形参[parameter]的值[value]; 也就是说, 一个普通 lambda 列表[ordinary lambda list], 一个扩展 lambda 列表[extended lambda list], 或者一个修改后的 lambda 列表 [modified lambda list].

**lambda list keyword** n. 一种符号[symbol], 其名称[name]以与号[ampersand]开头, 在 lambda 列表[lambda list]中被特别识别. 注意, 在 KEYWORD 包中没有标准[standardized] lambda 列表关键字[lambda list keyword].

**lambda variable** n. 一个正规形参[formal parameter], 用于强调该变量[variable]与建立它的 lambda 列表[lambda list]的关系.

**leaf** n. 1. 一个树[tree[1]]中的一个原子. 2. 一个树[tree[2]]的终端节点.

**leap seconds** n. 额外的一秒间隔, 偶尔被官方计时员插入到真实日历中, 作为类似"闰年"的修正. 所有 Common Lisp 时间[time]表示都忽略闰秒[leap second]; 假设每天正好是86400秒长.

**left-parenthesis** n. 标准字符[standard character] "(", 也就是所谓的 "左圆括号(left parenthesis)" 或 "开圆括号(open parenthesis)". 见 Figure 2-5.

**length** n. (指一个序列[sequence]) 这个序列[sequence]中元素[element]的数量. (注意, 如果这个序列[sequence]是一个带有填充指针[fill pointer]的向量[vector], 那么它的长度[length]和填充指针[fill pointer]相同, 即便这个向量[vector]总分配的大小可能更大.)

**lexical binding** n. 一个词法环境[lexical environment]中的绑定[binding].

**lexical closure** n. 一个函数[function], 当在实参[argument]上被调用时, 在这个词法闭包[lexical closure]被创建时所捕获的词法环境[lexical environment]中执行一个 lambda 表达式[lambda expression]的主体, 通过这个函数[function]的形参[parameter]到对应实参[argument]的绑定[binding]来扩增.

**lexical environment** n. 环境[environment]的这个部分包含了名称具有词法作用域[lexical scope]的绑定[binding]. 一个词法环境[lexical environment]还包括其他内容: 变量[variable]名称[name]到值[value]的普通绑定[binding], 词法上建立的函数名[function name]到函数[function]的绑定[binding], 宏[macro], 符号宏[symbol macro], 语句块[block], 标签[tag], 以及局部声明[local declaration] (见 declare).

**lexical scope** n. 限定于建立表达式形式[form]内的空间或文本区域的作用域[scope]. "函数的参数名通常在词法上限定作用域 (The names of parameters to a function normally are lexically scoped)".

**lexical variable** n. 一个变量[variable], 它的绑定[binding]是在词法环境[lexical environment]中.

**Lisp image** n. 一个 Common Lisp 实现[implementation]的运行实例. 一个 Lisp 映像[Lisp image]的特征是一个单独的地址空间, 其中任何对象[object]可以直接引用符合此规范的任何其他对象, 以及一个单一的、公共的全局环境[global environment]. (外部操作系统有时将其称为 "核心映像(core image)", "fork", "实体(incarnation)", "作业(job)", 或者 "进程(process)". 但是请注意, 在这样的操作系统中, "进程"的问题在技术上与这里定义的 Lisp 映像[Lisp image]的问题是正交的. 根据操作系统的不同, 一个"进程"可能有多个 Lisp 映像[Lisp image], 多个"进程"可能驻留在一个 Lisp 映像[Lisp image]中. 因此, 在所有对象[object]之间直接引用一个完全共享的地址空间的概念是定义特征. 还要注意, 如果两个"进程"有一个通信区域, 允许共享一些但不是所有对象[object], 那么这两个"进程"被认为是不同的 Lisp 映像[Lisp image].)

**Lisp printer** n. Trad. 打印一个对象[object]的字符表示到一个流[stream]的程序. (这个程序由函数[function] write 实现.)

**Lisp read-eval-print loop** n. Trad. 一个无尽循环, 它读取[read[2]]一个表达式形式[form], 求值[evaluate]该表达式形式, 然后打印 (也就是, 写入[writes[2]]) 结果. 在许多实现[implementation]中, 在程序开发期间与 Common Lisp 交互的默认模式就是通过这样一个循环.

**Lisp reader** n. Trad. 从一个流[stream]中解析对象[object]的字符表示并产生对象[object]的程序. (这个程序由函数[function] read 实现.)

**list** n. 1. 一个 cons 链, 其中每一个 cons 的 car 是这个列表[list]的元素[element], 而每一个 cons 的 cdr 是这个链中的下一个链接或一个终止的原子[atom]. 参见正规列表[proper list], 点对列表[dotted list], 或循环列表[circular list]. 2. null 和 cons 的并集所表示的类型[type].

**list designator** n. 一个对象[object]列表[list]的标识符[designator]; 也就是说, 一个表示一个列表[list]的对象[object]并且它是以下之一: 一个非 nil [non-nil]原子[atom] (表示一个单元素[singleton]列表[list], 它的元素[element]是这个非 nil [non-nil]原子[atom]) 或一个正规列表[proper list] (表示它自身[itself]).

**list structure** n. (指一个列表[list]) 构成这个列表[list]的 cons 集合. 注意, 当每一个这样的 cons 的 car 组件是这个列表结构[list structure]的一部分时, 作为列表[list]元素[element]的对象[object]本身 (也就是说, 这个列表[list]中每一个 cons 的 car 所表示的这些对象[object]) 不是列表结构的一部分, 即便它们是 cons, 除了这个列表[list]实际上包含了它的一个尾部[tail]作为元素[element] (循环[circular[2]]) 的情况下. (一个列表[list]的列表结构[list structure]有时被冗余地称为"顶级列表结构", 以强调不涉及列表[list]元素[element]的任何 cons.)

**literal** adj. (指一个对象[object]) 在一个程序中直接引用而不是被这个程序计算; 这也就是说, 作为一个 quote 表达式形式[form]中的数据出现, 或者, 如果这个对象[object]是一个子求值对象[self-evaluating object], 则作为非 quote 数据出现. "在表达式形式 (cons "one" '("two")) 中, 表达式 "one", ("two"), 和 "two" 是字面化对象 (In the form (cons "one" '("two")), the expressions "one", ("two"), and "two" are literal objects)".

**load** v.t. (一个文件[file]) 使这个文件[file]中包含的代码[code]被执行. 见函数[function] load.

**load time** n. 加载器加载编译后代码[compiled code]的时期.

**load time value** n. 由 load-time-value 表达式形式[form]在代码[code]中引用的对象[object]. 这样一个表达式形式[form]的值[value]是某个只能在运行时环境[environment]中被计算的特殊对象[object]. 在文件[file]编译[compilation]的情况中, 该值[value]作为加载已编译文件[compiled file]过程的一部分计算一次, 不会再一次计算. 见特殊操作符[special operator] load-time-value.

**loader** n. 一个工具, 它是 Lisp 的一部分, 并且它加载[load]一个文件[file]. 见函数[function] load.

**local declaration** n. 一个表达式[expression], 它只能出现在特定表达式形式[form]的特定位置, 并且它提供有关包含表达式形式[form]中包含的代码的信息; 也就是说, 一个 declare 表达式[expression].

**local precedence order** n. (指一个类[class]) 由类[class]及其直接超类[direct superclass]按照类[class]定义表达式形式[form]中提到的顺序组成的列表[list].

**local slot** n. (指一个类[class]) 只有在一个实例[instance]可访问[accessible]的槽[slot], 即分配这个槽[slot]的实例[instance].

**logical block** n. 美观打印器[pretty printer]使用的相关输出的概念分组. 见宏[macro] pprint-logical-block 以及章节 22.2.1.1 (输出排列的动态控制).

**logical host** n. 一个依赖于具体实现[implementation-dependent]的对象[object], 它被用作一个逻辑路径名[logical pathname]中的 "主机(host)" 的表示, 并且它有一个转换规则的关联集合, 用于将属于该主机的逻辑路径名[logical pathname]转换为物理路径名[physical pathname]. 见章节 19.3 (逻辑路径名).

**logical host designator** n. 一个逻辑主机[logical host]的标识符[designator]; 也就是说, 一个表示一个逻辑主机[logical host]的对象[object]并且它是以下之一: 一个字符串[string] (表示它命名的逻辑主机[logical host]), 或者一个逻辑主机[logical host] (表示它自身). (注意, 由于一个逻辑主机[logical host]的表示是依赖于具体实现的[implementation-dependent], 一个具体实现[implementation]把一个逻辑主机[logical host]表示为一个命名它的字符串[string]是可能的.)

**logical pathname** n. 一个 logical-pathname 类型[type]的对象[object].

**long float** n. 一个 long-float 类型[type]的对象[object].

**loop keyword** n. Trad. 一个符号[symbol], 它是一个扩展 loop 表达式形式[form]的语法中特殊可识别的部分. 这样的符号[symbol]通过它们的名称[name]来识别 (使用 string=), 而不是通过它们的标识; 因此, 它们可能在任何包[package]中. 一个 loop 关键字 [loop keyword]不是一个关键字[keyword].

**lowercase** adj. (指一个字符[character]) 位于与小写字母 a 到 z 对应的标准字符[standard character]之中, 或由具体实现[implementation]定义为小写[lowercase]的其他具体实现定义的[implementation-defined]字符[character]. 见章节 13.1.4.3 (大小写字符). 


### M

**macro** n. 1. 一个宏表达式形式[macro form] 2. 一个宏函数[macro function]. 3. 一个宏名称[macro name].

**macro character** n. 一个字符[character], 当被 Lisp 读取器[Lisp reader]在它的主要分派循环中遇到时, 引入一个读取器宏[reader macro[1]]. (宏字符[macro character]与宏[macro]无关.)

**macro expansion** n. 1. 把一个宏表达式形式[macro form]转换为另一个表达式形式[form]打过程. 2. 这个过程产生的表达式形式[form].

**macro form** n. 代表另一个表达式形式[form]的表达式形式[form] (例如, 出于抽象、信息隐藏或语法方便的目的); 也就是说, 要么是第一个元素是宏名称[macro name]的复合表达式形式[compound form], 要么是为符号宏[symbol macro]命名的符号[symbol]表达式形式[form].

**macro function** n. 一个两参数的函数[function], 两个参数是一个表达式形式[form]和一个环境[environment], 它通过产生一个要被求值的表达式形式[form]去替换原始的参数表达式形式[form]来实现宏展开[macro expansion].

**macro lambda list** n. 被用于建立[establish]宏[macro]定义的表达式形式[form] (例如 defmacro 和 macrolet) 中的扩展 lambda 列表[extended lambda list]. 见章节 3.4.4 (宏 Lambda 列表).

**macro name** n. 一个名称[name], 对于它 macro-function 返回 true, 并且当被用作一个复合表达式形式[compound form]的第一个元素时标识这个表达式形式[form]为一个宏表达式形式[macro form].

**macroexpand hook** n. \*macroexpand-hook* 的值[value]所指的函数[function].

**mapping** n. 1. 一种迭代类型, 其中一个函数[function]被依次应用到取自集合 (例如序列[sequence]或散列表[hash table]) 中对应条目的对象[object]上. 2. Math. 两个集合之间的一种关系, 其中第一个集合的每个元素("域")都分配给第二个集合的一个元素("范围").

**metaclass** n. 1. 一个类[class], 它的实例[instance]也是类[class]. 2. (指一个对象[object]) 该对象[object]的类[class]的类[class].

**Metaobject Protocol** n. 关于一个符合规范的实现[conforming implementation]可能如何实现对象系统的多个方面的可能的描述之一. 这个描述超出了文档的范围, 并且没有要求符合规范的实现[conforming implementation]去遵守它, 除了它在这个规范中显式标注的例外. 然而, 它的存在有助于建立规范的做法, 并鼓励没有理由背离它的实现者考虑在可能的情况下使他们的实现[implementation]遵守它. 这个在 The Art of the Metaobject Protocol 中详细描述.

**method** n. 一个对象[object], 它是一个广义函数[generic function]的一部分, 并且它提供了关于实参[argument]是特定类[class]的对象[object]或特定标识时该广义函数[generic function]应该如何表现的信息.

**method combination** n. 1. 通常, 一组方法[method]的组合, 来产生一个广义函数[generic function]的生效方法[effective method]. 2. 一个 method-combination 类型[type]的对象[object], 它表示一个或多个特定广义函数[generic function]的方法组合如果被执行的详细情况.

**method-defining form** n. 一个表达式形式[form], 它定义了一个广义函数[generic function]的一个方法[method], 不管是显式的还是隐式的. 见章节 7.6.1 (广义函数的介绍).

**method-defining operator** n. 对应于一个方法定义表达式形式[method-defining form]的操作符[operator]. 见 Figure 7-1.

**minimal compilation** n. 编译器[compiler]必须要在编译期采取的动作. 见章节 3.2.2 (编译语义).

**modified lambda list** n. 一个列表, 它在形式和目的上类似于普通 lambda 列表[ordinary lambda list], 但在语法或功能上偏离了普通 lambda 列表[ordinary lambda list]的定义. 见普通 lambda 列表[ordinary lambda list]. "deftype 使用一个改进 lambda 列表 (deftype uses a modified lambda list)".

**most recent** adj. 最里面的; 也就是说, 比其他同类的建立得更晚 (而且尚未解除建立).

**multiple escape** n., adj. 1. n. 一个被成对使用的字符[character]的语法类型[syntax type], 来表示括起来的那些字符要被当作字母[alphabetic[2]]字符[character], 保留它们的大小写[case]. 关于详情, 见章节 2.1.4.5 (多转义字符). 2. adj. (一个字符[character]的) 有着多转义[multiple escape]语法类型[syntax type]. 3. n. 一个多转义[multiple escape[2]]字符[character]. (在标准读取表[standard readtable]中, 竖线[vertical-bar]是一个多转义[multiple escape]字符[character].)

**multiple values** n. 1. 不止一个值[value]. "函数 truncate 返回多个值 (The function truncate returns multiple values)". 2. 一个可变数量的值[value], 可能包含零个或一个. "函数 values 返回多值 (The function values returns multiple values)". 3. 除 1 以外的固定数量的值[value]. "宏 multiple-value-bind 是 Common Lisp 中为数不多的可以检测和操纵多值的操作符 (The macro multiple-value-bind is among the few operators in Common Lisp which can detect and manipulate multiple values)".


### N

**name** n., v.t. 1. n. 一个标识符[identifier],  一个绑定[binding]关联通过它来引用一个对象[object]、一个绑定[binding]或一个退出点[exit point]. 2. v.t. 去给定一个名称[name]. 3. n. (指具有一个名称组件的对象[object]) 就是该组件的对象[object]. "一个符号的名称字符串由 symbol-name 返回 (The string which is a symbol's name is returned by symbol-name)". 4. n. (指一个路径名[pathname]) a. 由 pathname-name 返回的名称组件. b. 由 namestring 返回的完整路径名字符串. 5. n. (指一个字符[character]) 一个命名该字符[character]的字符串[string], 并且它有着超过一的长度[length]. (所有非图形[non-graphic]字符[character]都需要有名称[name], 除非它们具有某个具体实现定义的[implementation-defined]不为空[null]的属性[attribute]. 其他字符[character]是否具有名称[name]是依赖于具体实现的[implementation-dependent].)

**named constant** n. 一个变量[variable], 它由 Common Lisp、具体实现[implementation]或用户代码 (见宏[macro] defconstant) 定义, 在求值时总是产生[yield]相同的值[value]. "一个已命名常量的值不能通过赋值或绑定更改".

**namespace** n. 1. 表示受限于一个特定种类的绑定[binding]. "名称到标签的绑定是标签命名空间 (The bindings of names to tags is the tag namespace)". 2.域是一组名称[name]的任何映射[mapping]. "一个包定义一个命名空间 (A package defines a namespace)".

**namestring** n. 一个字符串[string], 它使用章节 19.3.1 (逻辑路径名名称字符串的语法)所述的命名逻辑路径名[logical pathname]的标准[standardized]表示法或者某个具体实现定义的[implementation-defined]命名一个物理路径名[physical pathname]的表示法来表示了一个文件名[filename].

**newline** n. 标准字符[standard character] <Newline>, 为 Lisp 读取器[Lisp reader]表示为 #\Newline.

**next method** n. 针对特定参数或参数类[class]的集合的给定方法[method]调用的下一个方法[method]. 见章节 7.6.6.1.3 (对排序后的可应用方法应用方法组合).

**nickname** n. (指一个包[package]) 可以被用于引用该包[package]的几个可能的名字[name]中的一个, 但不是这个包[package]的主要名称[name].

**nil** n. 这个对象[object], 即 COMMON-LISP 包中名为 "NIL" 的符号[symbol]、空列表[empty list]、表示 false 的 boolean (或广义 boolean [generalized boolean])以及空类型[empty type]的名称[name].

**non-atomic** adj. 不是一个原子[atom]; 换句话说, 就是一个 cons.

**non-constant variable** n. 一个变量[variable], 它不是一个常变量[constant variable].

**non-correctable** adj. (指一个错误[error]) 不能故意校正的[correctable]. (由于重启动[restart]的动态特性, 完全禁止错误[error]的可校正性[correctable]既不可能, 通常也没有用处. 使用这个术语是为了表达一种意图, 即不应该通过发出错误[error]信号的代码[code]来做出特殊的努力来使这个错误[error]成为可校正的[correctable]; 然而, 这个术语对符合标准的程序[conforming program]或符合标准的实现[conforming implementation]并没有实际的要求.)

**non-empty** adj. 至少有一个元素[element].

**non-generic function** n. 一个函数[function], 它不是一个广义函数[generic function].

**non-graphic** adj. (指一个字符[character]) 不是图形的[graphic]. 见章节 13.1.4.1 (图形字符).

**non-list** n., adj. 除了列表[list]以外; 换句话说, 一个非空[non-nil]原子[atom].

**non-local exit** n. 将控制(有时时值[value])转移到一个退出点[exit point], 而不是出于正常返回的原因. "操作符 go、throw 以及 return-from 导致一个非局部退出 (The operators go, throw, and return-from cause a non-local exit)".

**non-nil** n., adj. 不是 nil. 学术上, 任何不是 nil 的对象[object]都可以被引用为 true, 但是这将倾向于将对象[object]作为一个广义 boolean [generalized boolean]的独特视图. 引用这样的一个对象[object]为非 nil [non-nil]避免了这种暗示.

**non-null lexical environment** n. 一个词法环境[lexical environment], 它具有没有出现在全局环境[global environment]中的额外信息, 例如一个或多个绑定[binding].

**non-simple** adj. 不简单[simple].

**non-terminating** adj. (一个宏字符[macro character]的) 是这样的, 当它出现在一个扩展标记中时, 它会被当作一个标记成分字符[character]. 见章节 2.2 (读取器算法).

**non-top-level form** n. 一个表达式形式[form], 它是另一个表达式形式[form]的子表达式形式[subform], 一个顶层表达式形式[top level form]. 见章节 3.2.3.1 (顶层表达式形式的处理).

**normal return** n. 控制和值[value]的自然转移, 发生在表达式形式[form]的完整执行之后.

**normalized** adj., ANSI, IEEE (指一个浮点数[float]) 符合 IEEE Standard for Binary Floating-Point Arithmetic 所述的 "标准化 (normalized)" 的描述. 见非标准化[denormalized].

**null** adj., n. 1. adj. a. (指一个列表[list]) 没有元素[element]: 空的. 见空列表[empty list]. b. (指一个字符串[string]) 具有一个为 0 的长度[length]. (无论是在本文档中, 还是在观察到的口语行为中, 通过明显的明确引用来引用空字符串都是常见的, 就像在 "空字符串" 中一样, 即使没有尝试去捕获[intern[2]]空字符串. 措辞 "一个空字符串 (a null string)" 在技术上更正确, 但是大多数 Lisp 程序员通常认为它很笨拙. 因此, 除了回指引用外, 术语 "空字符串 (the null string)" 在所有情况下都应视为不确定引用.) c. (指一个字符[character]的一个具体实现定义的[implementation-defined]属性[attribute]) 如果没有请求特定值, 则该属性[attribute]的值默认为该对象[object]的值. 2. n. 一个 null 类型[type]的对象[object] (仅有的这样的对象[object]是 nil).

**null lexical environment** n. 没有绑定[binding]的词法环境[lexical environment].

**number** n. 一个 number 类型[type]的对象[object].

**numeric** adj. (指一个字符[character]) 是标准字符[standard character] 0 到 9 中的一个, 或者被具体实现[implementation]定义为数值[numeric]的某个其他的图形[graphic]字符[character]. 


### O

**object** n. 1. 任何 Lisp 数据. "函数 cons 创建一个引用其他两个对象的对象(The function cons creates an object which refers to two other objects)". 2. (直接跟在一个类型[type]的名字后面) 一个那个类型[type]的对象[object], 被用于强调那个对象[object]不止是那个类型[type]的一个对象的名字[name], 并且在那个类型[type](例如 function 或 class)的对象[object]普遍通过名字[name]来引用的情况下是那个类型[type]的一个元素[element]. "函数 symbol-function 接收一个函数名并返回一个函数对象(The function symbol-function takes a function name and returns a function object)".

**object-traversing** adj. 连续地对对象[object]的组件进行操作. "操作符 mapcar、maphash、with-package-iterator 和 count 执行对象穿越操作 (The operators mapcar, maphash, with-package-iterator and count perform object-traversing operations)".

**open** adj., v.t. (一个文件[file]) 1. v.t. 去创建并返回一个到该文件[file]的流[stream]. 2. adj. (指一个流[stream]) 已经被打开[open[1]], 但还没有被关闭[closed].

**operator** n. 1. 一个函数[function], 宏[macro], 或[special operator]. 2. 命名这样一个函数[function], 宏[macro], 或特殊操作符[special operator]的符号[symbol]. 3. (在一个 function 特殊表达式形式[special form]中) 这个 function 特殊表达式形式[special form] 的 cadr, 它可能是一个操作符[operator[2]] 或者一个 lambda 表达式[lambda expression]. 4. (一个复合表达式形式[compound form]的) 这个复合表达式形式[compound form]的 car, 它可能是一个操作符[operator[2]] 或者一个 lambda 表达式[lambda expression], 并且它从来不是 (setf symbol).

**optimize quality** n. 一个程序中可以被特定编译器优化的多个方面中的一个. 由于优化一个这样的质量可能与优化另一个冲突, 相关质量的优先级可以再一个 optimize 声明[declaration]中建立. 标准[standardized]优化质量[optimize quality]是 compilation-speed (编译过程的速度)、 debug (调试的容易程度)、 safety (运行时错误检测), space (包括代码大小和运行时空间)、 以及 speed (指对象代码). 具体实现[implementation]可以定义额外的优化质量[optimize quality].

**optional parameter** n. 一个形参[parameter], 其对应位置的实参[argument]是可选的. 如果这个实参[argument]没有被提供, 就使用一个默认值. 参见 supplied-p 参数[supplied-p parameter].

**ordinary function** n. 一个函数[function], 它不是一个广义函数[generic function].

**ordinary lambda list** n. 被 lambda 所使用的 lambda 列表[lambda list]的种类. 见改进 lambda 列表[modified lambda list]和扩展 lambda 列表[extended lambda list]. "defun 使用一个普通 lambda 列表 (defun uses an ordinary lambda list)".

**otherwise inaccessible part** n. (指一个对象[object], O1) 一个对象[object] O2, 如果 O1 不可访问[inaccessible], 则该对象 O2 将不可访问[inaccessible]. (每个对象[object]都是它自身的其他不可访问部分[otherwise inaccessible part].)

**output** adj. (指一个流[stream]) 支持输出操作 (换句话说, 就是一个 "数据接收器 (data sink)"). 一个输出[output]流[stream]可能也是一个输入[input]流[stream], 在这个情况下它有时被称为双向[bidirectional]流[stream]. 见函数[function] output-stream-p. 


### P

**package** n. 一个 package 类型[type]的对象[object].

**package cell** n. Trad. (指一个符号[symbol]) 一个符号[symbol]中的一个位置[place], 它持有了该符号[symbol]被捕获[interned]的多个包[package]中的一个, 称为 home 包[home package], 或者如果不存在这样的包[package]或不可知则持有 nil. 见函数[function] symbol-package.

**package designator** n. 一个包[package]的标识符[designator]; 也就是说, 表示一个包[package]的对象[object]并且是以下之一: 一个字符串标识符[string designator] (表示名称[name]或别名[nickname]之一为该字符串[string]的包[package]), 或者一个包[package] (表示它自身).

**package marker** n. 一个字符, 它被用于一个符号中去分割包名和符号名, 它是标准读取表[standard readtable]中的冒号[colon]. 见章节 2.1 (字符语法).

**package prefix** n. 在 Lisp 读取器[Lisp reader]处理的文本中的一个符号[symbol]名字[name]前的标记, 它使用一个包[package]名称[name]后面跟着一个或多个包标记[package marker], 并且它表示这个符号[symbol]在表示的包[package]中查找.

**package registry** n. 一个名称[name]到包[package]对象[object]的映射. 有可能有一个包[package]对象[object]不在这个映射中; 这样一个包[package]被称为未注册的包[unregistered package]. 例如 find-package 这样的操作符[operator]查阅这个映射, 来从它的名称[name]中找到一个包[package]. 例如 do-all-symbols、find-all-symbols 和 list-all-packages 这样的操作符[operator]只在出现在包注册表[package registry]中的包[package]上操作.

**pairwise** adv. (指集合上的形容词)单独地应用于集合中所有可能的元素对. "如果 A 和 B 互斥, B 和 C 互斥并且 A 和 C 也互斥, 那么类型 A、B 和 C 时成对互斥的 (The types A, B, and C are pairwise disjoint if A and B are disjoint, B and C are disjoint, and A and C are disjoint)".

**parallel** adj. Trad. (指绑定[binding]或赋值[assignment]) 以 psetq、let 或 do 的风格完成; 也就是说, 首先求值所有产生值[value]的表达式形式[form], 然后才赋值或绑定[binding]这些变量[variable] (或者位置[place]). 注意, 这并不意味着传统的计算"并行性", 因为生成值[value]的表达式形式[form]是顺序[sequential]计算的. 见顺序的[sequential].

**parameter** n. 1. (指一个函数[function]) 在一个函数[function]的定义中的一个变量[variable], 当这个函数被调用时取自对应实参[argument]的指[value] (或者对应实参的一个列表[list]), 或者在某些情况下由于没有对应的实参[argument]就给定一个默认值. 2. (指一个格式化指令[format directive]) 由格式化指令[format directive]接收的作为数据流的对象[object], 由于格式化字符串[format string]中的前缀表示法位于格式化指令[format directive]的使用点. 见章节 22.3 (格式化输出). "在 "~3,'0D" 中, 数字 3 和字符 #\0 是给 ~D 格式化指令的参数 (In "~3,'0D", the number 3 and the character #\0 are parameters to the ~D format directive)".

**parameter specializer** n. 1. (指一个方法[method]) 一种表达式[expression], 它限制该方法[method]仅适用于对应实参[argument]匹配参数特化符[parameter specializer]的实参[argument]序列. 2. 一个类[class], 或一个列表[list] (eql object).

**parameter specializer name** n. 1. (指一个方法[method]定义) 一个表达式[expression], 它被用于代码中来命名一个参数特化符[parameter specializer]. 见章节 7.6.2 (方法的介绍). 2. 一个类[class], 命名一个类[class]的符号[symbol], 或一个列表[list] (eql form).

**pathname** n. 一个 pathname 类型[type]的对象[object], 它是一个文件[file]名字的结构化表示. 一个路径名[pathname]有六个成员: 一个 "主机(host)", 一个"设备(device)", 一个 "目录(directory)", 一个 "名称(name)",一个 "类型(type)" 以及一个版本 "版本(version)".

**pathname designator** n. 一个路径名[pathname]的标识符[designator]; 也就是说, 一个表示路径名[pathname]的对象[object]并且它是以下之一: 一个路径名[pathname]名称字符串[namestring] (表示对应路径名[pathname]), 和一个文件[file]关联的流[stream] (表示被用于打开该文件[file]的路径名[pathname]; 这可能但不一定是该文件[file]的实际名称), 或者一个路径名[pathname] (表示它自身). 见章节 21.1.1.1.2 (打开和关闭流).

**physical pathname** n. 一个路径名[pathname], 它不是一个逻辑路径名[pathname].

**place** n. 1. 一个表达式形式[form], 它适用于一个广义引用[generalized reference]. 2. 被这样一个位置[place[1]]引用的概念位置.

**plist** ['pee,list] n. 一个属性列表[property list].

**portable** adj. (指代码[code]) 需要在所有符合规范的实现[conforming implementation]中产生等价的结果和可观测的副作用.

**potential copy** n. (指一个受限于约束的对象[object] O1) 一个对象[object] O2, 如果指定的约束由 O1 满足而没有进行修改, 那么它可能与 O1 相同[identical], 也可能与 O1 不同, 或者它必须是一个新的[fresh]对象[object], 类似于 O1 的副本[copy], 除非它已经根据需要进行了修改以满足约束. <!--TODO 待校对-->

**potential number** n. 一个文本标记, 可能在某个符合规范的实现[conforming implementation]中被 Lisp 读取器[Lisp reader]解析为一个数字[number], 但不是必须解析为一个数字[number]. 没有对象[object]是一个潜在数字[potential number]---一个对象[object]要么是一个数字[number]要么不是. 见章节 2.3.1.1 (潜在数字作为标记).

**pprint dispatch table** n. 一个对象[object], 它可以是 \*print-pprint-dispatch* 的值[value]并且因此可以控制当 \*print-pretty* 为 true 时对象[object]如何被打印. 见章节 22.2.1.4 (美观打印分派表).

**predicate** n. 一个函数[function], 它返回一个广义 boolean [generalized boolean]作为它的第一个值.

**present** n. 1. (指一个 Lisp 映像[Lisp image]中的一个特性[feature]) 当且仅当命名特性[feature]的符号[symbol]是特性列表[feature list]的一个元素[element]时才有效的存在状态. 2. (指一个包[package]中的一个符号[symbol]) 在那个包[package]中是直接可访问的, 而不是从另一个包[package]中继承而来.

**pretty print** v.t. (一个对象[object]) 在这个对象[object]上去调用美观打印器[pretty printer].

**pretty printer** n. 当 \*print-pretty* 的值[value]是 true 时打印一个对象[object]的字符表示到一个流[stream]上的程序, 它使用了布局技术(例如缩进), 这种技术往往突出对象[object]的结构, 使人类读者更容易直观地解析. 见变量[variable] \*print-pprint-dispatch* 和章节 22.2 (Lisp 美观打印器).

**pretty printing stream** n. 执行美观打印的一个流[stream]. 这样的流由函数[function] pprint-logical-block 创建, 作为该输出流和逻辑语句块之间的链接.

**primary method** n. 两个方法[method]集合中的一个的成员 (另一个是辅助方法[auxiliary method]), 这两个集合组成了该方法[method]的广义函数[generic function]上的方法[method]集合的详尽分区. 这些集合如果决定取决于方法组合[method combination]类型; 见章节 7.6.2 (方法的介绍).

**primary value** n. (指一个表达式形式[form]的求值[evaluation]所产生的那些值[value]) 如果存在就是第一个值[value], 如果这里没有值[value]那么就是 nil. "由 truncate 返回的主值是一个整数商, 朝着零截断 (The primary value returned by truncate is an integer quotient, truncated toward zero)".

**principal** adj. (一个由 Common Lisp 函数[function]返回的值, 该函数实现在复域中定义的数学上的无理数或超越函数) 可能有许多 (有时是无穷多个) 数学函数的正确值, 即定义相应的 Common Lisp 函数[function]返回的特定值[value].<!--TODO 待校对-->

**print name** n. Trad. (通常指一个符号[symbol]) 一个名称[name[3]].

**printer control variable** n. 一个变量[variable], 它的具体目的是去控制 Lisp 打印器[Lisp printer]的一些行为; 也就是说, Figure 22-1 中的变量[variable]之一, 或者某个被具体实现[implementation]定义为一个打印器控制变量[variable]的具体实现定义的[implementation-defined]变量[variable].

**printer escaping** n. 打印器控制变量[printer control variable] \*print-escape* 和 \*print-readably* 的组合状态. 如果 \*print-readably* 或 \*print-escape* 的值[value]是 true, 那么打印器转义[printer escaping]是 "启用的"; 否则 (如果 \*print-readably* 和 \*print-escape* 的值[value]都是 false), 那么打印器转义[printer escaping]是 "禁用的".

**printing** adj. (指一个字符[character]) 是一个图形[graphic]字符[character]而不是空格[space].

**process** v.t. (一个表达式形式[form]被编译器[compiler]) 去执行最小编译[minimal compilation], 决定一个表达式形式[form]求值的时间, 并且可能求值那个表达式形式[form] (如果必要的话).

**processor** n., ANSI 一个具体实现[implementation].

**proclaim** v.t. (一个公告[proclamation]) 去建立[establish]该公告[proclamation].

**proclamation** n. 一个全局声明[global declaration].

**prog tag** n. Trad. 一个 go 标签[go tag].

**program** n. Trad. Common Lisp 代码[code].

**programmer** n. 编写一个程序[program]的一个活跃的实体, 通常是一个人, 他可能是也可能不是该程序[program]的用户[user].

**programmer code** n. 程序员提供的代码[code]; 也就是说, 不是系统代码[system code]的代码[code].

**proper list** n. 由空列表[empty list]终止的一个列表[list]. (空列表[empty list]是一个正规列表[proper list].) 见非正规列表[improper list].

**proper name** n. (指一个类[class]) 一个符号[symbol], 它命名[name]了名称[name]为该符号[symbol]的类[class]. 见函数[function] class-name 和 find-class.

**proper sequence** n. 一个不是非正规列表[imporper list]的序列[sequence]; 也就是说, 一个向量[vector]或一个正规列表[proper list].

**proper subtype** n. (指一个类型[type]) 与该类型[type]不同的该类型[type]的子类型[subtype] (换句话说, 它的元素[element]时该类型[type]的一个"正规子集[proper subset]").

**property** n. (指一个属性列表[property list]) 1. 属性指示符[property indicator]及其在属性列表[property list]上的关联属性值[property value]的概念配对. 2. 一个属性值[property value].

**property indicator** n. (指一个属性列表[property list]) 一个属性[property]的名称[name]部分, 在一个属性列表[property list]上查找一个属性值[property value]时用作一个键[key].

**property list** n. 1. 一个包含偶数个元素[element]的列表[list], 它们是交替的[name] (有时称为指示器[indicator]或键[key]) 和值[value] (有时称为属性[property]). 当属性列表[property list]中有多个具有相同[identical]名称[name]的名称[name]和值[value]对时, 第一个这样的对确定属性[property]. 2. (指一个符号[symbol]) 包含一个属性列表[property list]的该符号[symbol]的成员.

**property value** n. (指一个属性列表[property list]上的属性指示器[property indicator]) 在该属性列表[property list]上与该属性指示器[property indicator]关联的对象[object].

**purports to conform** v. 对一致性做出善意的声明, 这个术语表达了一致性的意图, 不管这个意图的目标是否在实践中实现. 例如, 众所周知, 语言实现存在 bug, 尽管带有 bug 的此规范的实现[implementation]可能不是符合规范的实现[conforming implementation], 但它仍然可以声称符合规范. 在某些特定的情况下, 这是一个重要的区别; 例如, 见变量[variable] \*features*. 


### Q

**qualified method** n. 一个方法[method], 它有一个或多个限定符[qualifier].

**qualifier** n. (指一个广义函数[generic function]的一个方法[method]) 以一种确定其在方法组合[method combination]中的角色的方式对方法[method]进行注释的几个对象[object]之一. 方法组合[method combination]类型[type]决定了每一个方法[method]允许多少修饰符[qualifier], 允许哪些修饰符[qualifier], 以及这些修饰符[qualifier]的语义.

**query I/O** n. 这个双向[bidirectional]流[stream]它时变量[variable] \*query-io* 的值[value].

**quoted object** n. 一个对象[object], 它是一个 quote 表达式形式[form]的第二个元素. 


### R

**radix** n. 一个在 2 和 36 之间的整数[integer] (包括 2 和 36), 它可以用来指定执行哪一种特定类型的数字输入或输出的基数. (对于任何给定的基数[radix] n 这里有 n 个有效数字字符, 这些数字分别是序列 0, 1, ..., 9, A, B, ..., Z 中的前 n 个数字, 分别有着权值 0, 1, ..., 9, 10, 11, ..., 35. 在解析基数大于 10 的数字时大小写是无效的, 因此 "9b8a" 和 "9B8A" 都表示相同的基数[radix] 16.)

**random state** n. 一个 random-state 类型[type]的对象[object].

**rank** n. 一个表示数组[array]的维度[dimension]数量的非负整数[integer].

**ratio** n. 一个 ratio 类型[type]的对象[object].

**ratio marker** n. 在一个比率[ratio]的文本标记中被用于分隔分子和分母的字符, 它在标准读取表[standard readtable]中是一个斜杠[slash]. 见章节 2.1 (字符语法).

**rational** n. 一个 rational 类型[type]的对象[object].

**read** v.t. 1. (一个绑定[binding]或槽[slot]或成员) 去获取该绑定[binding]或槽[slot]的值[value]. 2. (来自一个流[stream]的对象[object]) 从这个流[stream]上的该对象的表示去解析一个对象[object].

**readably** adv. (指打印一个对象[object] O1 的方式) 在这种方式下允许 Lisp 读取器[Lisp reader]稍后把这个打印输出解析为一个对象[object] O2, 它与 O1 相似[similar].

**reader** n. 1. 一个函数[function], 它读取[read[1]]一个变量[variable]或槽[slot]. 2. Lisp 读取器[Lisp reader].

**reader macro** n. 1. 一种文本符号, 由一个或两个字符[character]上的分派引入, 它定义了供 Lisp 读取器[Lisp reader]使用的特殊语法, 并由读取器宏函数实现[reader macro function]. 见章节 2.2 (读取器算法). 2. 引入一个读取器宏[reader macro[1]]的字符[character]或多个字符[character]; 也就是说, 一个宏字符[macro character]或一个分派宏字符[dispatching macro character]和跟在它后面的字符[character]的概念对. (一个读取器宏[reader macro]不是一个宏[macro]的种类.)

**reader macro function** n. 一个函数标识符[function designator], 它表示实现了一个读取器宏[reader macro[2]]的函数[function]. 见函数[function] set-macro-character 和 set-dispatch-macro-character.

**readtable** n. 一个 readtable 类型[type]的对象[object].

**readtable case** n. 一个读取表[readtable]的一个属性, 它的值是一个大小写敏感模式[case sensitivity mode], 并且它选择了一个符号[symbol]的名字[name]中的字符[character]会被 Lisp 读取器[Lisp reader]和 Lisp 打印器[Lisp printer]对待的方式. 见章节 23.1.2 (Lisp 读取器上的读取表大小写的影响) 和章节 22.1.3.3.2 (Lisp 打印器上读取表大小写的影响).

**readtable designator** n. 一个读取表[readtable]的标识符[designator]; 也就是说, 一个表示一个读取表的对象[object]并且它是以下之一: nil (表示标准读取表[standard readtable]), 或者一个读取表[readtable] (表示它自身).

**recognizable subtype** n. (指一个类型[type]) 可以被具体实现[implementation]可靠检测到的该类型[type]的一个子类型[subtype]. 见函数[function] subtypep.

**reference** n., v.t. 1. n. 引用一个对象[object], 一个绑定[binding], 一个退出点[exit point], 一个标签[tag], 或者一个环境[environment]的行为或出现. 2. v.t. 去引用一个对象[object], 一个绑定[binding], 一个退出点[exit point], 一个标签[tag], 或者一个环境[environment], 通常是通过名称[name].

**registered package** n. 一个包[package]对象[object], 它被安装到包注册表[package registry]中. (每个已注册包[registered package]有着一个字符串[string]名称[string], 以及零个或多个字符串[string]别名. All packages that are initially specified 由 Common Lisp 最初指定的或由 make-package 或 defpackage 创建的所有包[package]都是已注册包[registered package]. 已注册包[registered package]可以通过 delete-package 变成未注册包[unregistered package].)

**relative** adj. 1. (指时间[time]) 表示相对于一个绝对[absolute]时间[time]的偏移量, 使用与该时间相适应的单位表示. 例如, 一个相对[relative]内部时间[internal time] 是两个绝对[absolute]内部时间[internal time]只差, 用内部时间单位[internal time unit]来衡量. 2. (指一个路径名[pathname]) 通过从根目录以外的位置移动来表示目录层次结构中的位置, 因此根目录的位置可能不同. "如果主机文件系统是 Unix, 那么标记 #P"../foo.text" 表示一个相对路径名 (The notation #P"../foo.text" denotes a relative pathname if the host file system is Unix)". 见绝对[absolute].

**repertoire** n., ISO 一个 character 的子类型[subtype]. 见章节 13.1.2.2 (字符字元库).

**report** n. (指一个状况[condition]) 在一个 \*print-escape* 的值[value]是 false 的环境[environment]中在该状况[condition]上去调用函数[function] print-object.

**report message** n. 由状况汇报器[condition reporter]输出的文本.

**required parameter** n. 调用函数[function]时必须为其提供相应位置实参[argument]的形参[parameter].

**rest list** n. (指一个具有剩余参数[rest parameter]的函数[function]) 在对函数[function]的某个特定调用[call]上剩余参数[rest parameter]被绑定[bound]到的那个列表[list].

**rest parameter** n. 由 &rest 引入的一个形参[parameter].

**restart** n. 一个 restart 类型[type]的对象[object].

**restart designator** n. 一个重启动[restart]的标识符[designator]; 也就是说, 一个表示重启动[restart]的对象[object], 并且是以下之一: 一个非 nil [non-nil]符号[symbol] (表示名字[name]为该符号[symbol]的最近建立的活跃[active]重启动[restart]), 或者一个重启动[restart] (表示它自身).

**restart function** n. 一个调用一个重启动[restart]的函数[function], 就像是通过 invoke-restart 一样. 一个重启动函数[restart function]的主要目的是去提供一个替代的接口. 按照惯例, 重启动函数[restart function]通常与它调用的重启动[restart]具有相同的名称[name]. 下一段展示了标准化[standardized]重启动函数[restart function]的列表.

abort     muffle-warning  use-value  
continue  store-value                

Figure 26-4. 标准化重启动函数

**return** v.t. (指值[value]) 1. (从一个语句块[block]) 从这个语句块[block]转移控制和值[value]; 也就说说, 去使这个语句块[block]在没有对主体中的表达式形式[form]做任何进一步求值的情况下立即产生[yield]这些值[value]. 2. (从一个表达式形式[form]) 来产生[yield]这些值[value].

**return value** n. Trad. 一个值[value[1]]

**right-parenthesis** n. 标准字符[standard character] ")", 这被称为 "右圆括号" 或 "闭圆括号". 见 Figure 2-5.

**run time** n. 1. 加载时间[load time] 2. 执行时间[execution time]

**run-time compiler** n. 引用 compile 函数或隐式编译[implicit compilation], 编译和运行时环境[environment]在相同的 Lisp 映像[Lisp image]中维护.

**run-time definition** n. 在运行时环境[run-time environment]中的一个定义.

**run-time environment** n. 一个程序被执行时所在的环境[environment]. 


S

**safe** adj. 1. (指代码[code]) 在最高安全(safety)等级 (3) 生效的词法环境[lexical environment]中处理的. 见 optimize. 2. (指一个调用[call]) 一个安全调用[safe call].

**safe call** n. 一种调用[call], 其中该调用[call], 被调用的函数[function], 以及函数求值[functional evaluation]的点都是安全[safe[1]]代码[code]. 关于更多详细信息, 见章节 3.5.1.1 (安全和非安全調用).

**same** adj. 1. (指多个对象[object]在指定断言[predicate]) 通过该断言[predicate]是不可区分的. "符号 car, 字符串 "car", 以及字符串 "CAR" 在 string-equal 下时相同的(The symbol car, the string "car", and the string "CAR" are the same under string-equal)". 2. (指多个对象[object], 如果上下文没有暗示断言) 通过 eql 是不可区分的. 注意, eq 可能可以区分 eql 不能区分的一些数字[number]和字符[character], 但是这样的性质如果存在的话是依赖于具体实现的[implementation-dependent]. 由于 eq 在这个规范中很少使用, 当没有显式提及时, eql 就是默认的断言. "两个对 cons 的连续调用返回的 cons 从不相同 (The conses returned by two successive calls to cons are never the same)". 3. (指类型[type]) 具有相同的元素[element]集合; 也就是说, 每个类型[type]是另一个的子类型[subtype]. "由 (integer 0 1), (unsigned-byte 1), 和 bit 指定的类型是相同的 (The types specified by (integer 0 1), (unsigned-byte 1), and bit are the same)".

**satisfy the test** v. (指一个正在被序列函数[sequence function]考虑的对象[object]) 1. (对于一个单实参[argument]测试) 当给定一个实参[argument] (该实参是在被考虑对象[object]上调用序列函数[sequence function]的 key 参数[argument]的结果)时, 作为序列函数[sequence function] predicate 参数[argument]的函数[function]返回 true. 见章节 17.2.2 (满足一个单参数的测试). 2. (对于一个两实参[argument]测试) 处于这样一种状态: 当被考虑的对象[object]作为第一个参数[argument]并且这个序列函数[sequence function]的 sequence 参数[argument]的元素[element]上调用该序列函数[sequence function]的 key 参数[argument]的结果作为第二个参数[argument]时, 该序列函数[sequence function]的 test 参数[argument]的二元的断言[predicate]检测为等价的; 或者处于 test-not 函数[function]在给定相同参数[argument]的情况下返回 false 的状态. 见章节 17.2.1 (满足一个两个参数的测试).

**scope** n. 可以引用一个对象[object], 一个绑定[binding], 一个退出点[exit point], 一个标签[tag], 或一个环境[environment] (通常是通过名称[name]) 的代码中的结构或文本区域.

**script** n. ISO 组成 character 类型的详尽分区[exhaustive partition]的多个可能的集合中的一个. 见章节 13.1.2.1 (字符文字).

**secondary value** n. (指一个表达式形式[form]的求值[evaluation]所产生的多个值[value]) 如果存在就是第二个值[value], 如果这里少于两个值[value]那么就是 nil. "由 truncate 返回的第二个值是个余数 (The secondary value returned by truncate is a remainder)".

**section** n. 在美观打印流[pretty printing stream]上用条件换行[conditional newline]对输出进行的分区. 见章节 22.2.1.1 (输出排列的动态控制).

**self-evaluating object** n. 一个对象[object], 它既不是一个符号[symbol]也不是一个 cons. 如果一个自求值对象[self-evaluating object]被求值, 它产生[yield]它自身作为仅有的值[value]. "字符串是自求值对象 (Strings are self-evaluating objects)".

**semi-standard** adj. (指一个语言特性) 没有要求被任何符合规范的实现[conforming implementation]所实现, 但是在一个实现[implementation]确实计划支持此类特性的情况下, 推荐使用规范方法. 该语言中存在半标准[semi-standard]方面的目的是减少可移植性问题, 并降低实现[implementation]之间不必要的差异的风险, 这些差异可能会阻碍未来的标准化.

**semicolon** n. 标准字符[standard character], 它被称为 "分号(semicolon)" (;). 见 Figure 2-5.

**sequence** n. 1. 元素的一个有序集合 2. 一个向量[vector]或一个列表[list].

**sequence function** n. 在 Figure 17-1 中的那些函数[function]之一, 或者一个具体实现定义的[implementation-defined]操作一个或多个序列[sequence]的函数[function], 它也被具体实现[implementation]定义为序列函数[sequence function].

**sequential** adj. Trad. (指绑定[binding]或赋值) 以 setq、let* 或 do* 的风格完成; 也就是说, 将生成值[value]的表达式形式[form]的计算与变量[variable] (或位置[place])的赋值或绑定[binding]交错起来. 见并行[parallel].

**sequentially** adv. 以一种顺序的[sequential]方式.

**serious condition** n. 一个 serious-condition 类型[type]的状况[condition], 它表示一种情况[situation], 这种情况通常非常严重, 如果该状况[condition]被发出但没有被处理, 则应该预期会进入调试器[debugger].

**session** n. 在一个 Lisp 映像[List image]中从开始到结束的事件的概念聚合.

**set** v.t. Trad. (任何变量[variable]或一个符号[symbol], 它是一个动态变量[dynamic variable]的名称[name]) 去对这个变量[variable]赋值[dynamic variable].

**setf expander** n. 被 setf 用来计算一个位置[place]的 setf 展开式[setf expansion]的函数[function].

**setf expansion** n. 一个五表达式[expressions[1]]的集合, 一起描述了如何存储到一个位置[place]以及求值与该位置关联的宏调用的哪些子表达式形式[subform]. 见章节 5.1.1.2 (Setf 展开式).

**setf function** n. 一个名字[name]为 (setf symbol) 的函数[function].

**setf function name** n. (指一个符号[symbol] S) 列表[list] (setf S).

**shadow** v.t. 1. 去重写...的意义. "X 的绑定遮蔽了较外面的那个 (That binding of X shadows an outer one)". 2. 去隐藏...的存在. "这个 F 的 macrolet 遮蔽了较外面的 F 的 flet". 3. 去替换. "这个包用它自己的符号 car 遮蔽了符号 cl:car (That package shadows the symbol cl:car with its own symbol car)".

**shadowing symbol** n. (在一个包[package]中) 该包[package]的遮蔽符号列表[shadowing symbols list]的一个元素[element].

**shadowing symbols list** n. (指一个包[package]) 和该包[package]关联的一个符号[symbol]列表[list], 这些符号在包被使用时将免于"符号冲突错误"检测. 见函数[function] package-shadowing-symbols.

**shared slot** n. (指一个类[class]) 一个槽[slot]在一个类[class]的不止一个实例[instance]中是可访问的[accessible]; 具体来说, 这样一个槽[slot]在该类[class]的所有直接实例[direct instance]中都是可访问的[accessible], 并且在类[class]没有遮蔽[shadow[1]]该槽[slot]的间接实例[indirect instance]中也是可访问的.

**sharpsign** n. 标准字符[standard character], 被称为 "数字符号"、 "sharp" 或 "井号" (#). 见 Figure 2-5.

**short float** n. 一个 short-float 类型[type]的对象[object].

**sign** n. 标准字符[standard character] "+" 或 "-".

**signal** v. 使用标准协议宣布已经检测到由状况[condition]表示的特定情况. 见章节 9.1 (状况系统的概念).

**signature** n. (指一个方法[method]) 该方法的形参[parameter]和参数特化符[parameter specializer]的描述, 决定了该方法[method]对于一个给定的必要实参[argument]集合的可应用性, 并且也描述了它的其他非必要实参[argument]的参数[argument]规约.

**similar** adj. (指两个对象[object]) 在相似性[similarity]关系下被定义为等价的.

**similarity** n. 一个二元概念等价性断言, 它独立于 Lisp 映像[Lisp image], 这样一来在不同 Lisp 映像[Lisp image]中的两个对象[object]可以在这个断言下被理解为等价的. 见章节 3.2.4 (编译后文件中的字面化对象).

**simple** adj. 1. (指数组[array]) 是 simple-array 类型[type]. 2. (指一个字符[character]) 没有具体实现定义的[implementation-defined]属性[attribute], 或者是有着具体实现定义的[implementation-defined]属性[attribute]但是每一个属性[attribute]都有着空[null]值.

**simple array** n. 一个 simple-array 类型[type]的数组[array].

**simple bit array** n. 一个位数组[bit array], 它是一个简单数组[simple array]; 也就是说, 一个 (simple-array bit) 类型[type]的对象[object].

**simple bit vector** n. 一个 simple-bit-vector 类型[type]的位向量[bit vector].

**simple condition** n. 一个 simple-condition 类型[type]的状况[condition].

**simple general vector** n. 一个简单向量[simple vector].

**simple string** n. 一个 simple-string 类型[type]的字符串[string].

**simple vector** n. 一个 simple-vector 类型[type]的向量[vector], 有时被称为一个 "简单普通向量[simple general vector]". 不是所有的简单的[simple]向量[vector]都是简单向量[simple array]---只有那些元素类型[element type]为 t 的.

**single escape** n., adj. 1. n. 一个字符[character]的语法类型[syntax type], 表示下一个字符[character]被当作是字母[alphabetic[2]]字符[character], 保留它的大小写[case]. 关于详情, 见章节 2.1.4.6 (单转义字符). 2. adj. (一个字符[character]的) 有着单转义[single escape]语法类型[syntax type]. 3. n. 一个单转义[single escape[2]]字符[character]. (在标准读取表[standard readtable]中, 斜线[slash]是仅有的单转义[single escape].)

**single float** n. 一个 single-float 类型[type]的对象[object].

**single-quote** n. 标准字符[standard character], 它也被称为 "撇号(apostrophe)","重音号(acute accent)","引号(quote)",或 "单引号(single quote)" ('). 见 Figure 2-5.

**singleton** adj. (指一个序列[sequence]) 只有一个元素[element]. "(list 'hello) 返回一个单元素列表 ((list 'hello) returns a singleton list)".

**situation** n. 一个表达式形式[form]在一个特定环境[environment]中的求值[evaluation].

**slash** n. 标准字符[standard character], 它也被称为 "斜线(solidus)" 或 "斜杠(slash)" (/). 见 Figure 2-5.

**slot** n. 可以存储一个值[value]的一个对象[object]的组件.

**slot specifier** n. 一个槽[slot]的表示, 它包括槽[slot]的名称[name]以及零个或多个槽[slot]选项. 一个槽[slot]选项只能从属于一个单独的槽[slot].

**source code** n. 表示适合求值[evaluation]的对象[object]的代码[code] (例如, objects created 由 read, 宏展开式[macro expansion], 或者编译期宏展开式[compiler macro expansion]创建的对象[object]).

**source file** n. 一个包含源代码[source code]的文本表示的文件[file], 它可以被编辑、加载或编译.

**space** n. 标准字符[standard character] <Space>, 为 Lisp 读取器[Lisp reader]标记为 #\Space.

**special form** n. 一个列表[list], 而不是一个宏表达式形式[macro form], 它是一个具有特殊语法或特殊求值[evaluation]规则或者两者兼有的表达式形式[form], 它可能操纵求值[evaluation]环境[environment]或控制流或两者都操纵. 一个特殊表达式形式[special form]的第一个元素是一个特殊操作符[special operator].

**special operator** n. 枚举在 Figure 3-2 中的一组固定符号[symbol]中的一个, 它可能出现在一个表达式形式[form]的 car 中来标识这个表达式形式[form]为一个特殊表达式形式[special form].

**special variable** n. Trad. 一个动态变量[dynamic variable].

**specialize** v.t. (一个广义函数[generic function]) 去为这个广义函数[generic function]定义一个方法[method], 或者换句话说, 通过给它一组类[class]或实参[argument]的特定意义来精炼这个广义函数[generic function]的行为.

**specialized** adj. 1. (指一个广义函数[generic function]) 有着特化[specialize]这个广义函数[generic function]的方法[method]. 2. (指数组[array]) 实际数组元素类型[actual array element type]是类型[type] t 的合适子类型[proper subtype]; 见章节 15.1.1 (数组元素). "(make-array 5 :element-type 'bit) 创建一个长度 5 的数组, 并且它特化为 bit ((make-array 5 :element-type 'bit) makes an array of length five that is specialized for bits)".

**specialized lambda list** n. 一个扩展 lambda 列表[extended lambda list], 被用于建立[establish]方法[method]定义的表达式形式[form]中, 例如 defmethod. 见章节 3.4.3 (特化的 lambda 列表).

**spreadable argument list designator** n. 一个对象[object]列表[list]的标识符[designator]; 也就是说, 一个对象[object], 它表示一个列表[list]并且它是一个长度为 n 的非空列表[list] L1, 其中最后一个元素是长度为 m 的列表[list] L2 (表示一个长度为 m+n-1 的列表 L3, 其中元素是 L1i (i < n-1) 后面跟着 L2i (j < m)). "列表 (1 2 (3 4 5)) 是列表 (1 2 3 4 5) 的一个可扩展参数列表标识符 (The list (1 2 (3 4 5)) is a spreadable argument list designator for the list (1 2 3 4 5))".

**stack allocate** v.t. Trad. 用一种非持久方式, 例如在一个栈上. 栈上分配是一种优化技术在某些实现[implementation]中用于分配具有动态范围[dynamic extent]的某些类型的对象[object]. 这样的对象[object]会被分配在栈上而不是在堆上, 这样一来它们的存储就可以作为栈解除的一部分被释放而不是在下一次垃圾回收之前都占用着堆中的空间. 什么类型 (如果有的话) 可以有动态范围[dynamic extent]在实现[implementation]和实现[implementation]之间有所不同. 没有要求实现[implementation]去执行栈上分配.

**stack-allocated** adj. Trad. 已经被栈上分配.

**standard character** n. 一个 standard-char 类型[type]的字符[character], 它是所有符合规范的实现[conforming implementation]中需要的 96 个固定字符[character]中的一个. 见章节 2.1.3 (标准字符).

**standard class** n. 一个类[class], 它是类[class] standard-class 的一个广义实例[generalized instance].

**standard generic function** 一个 standard-generic-function 类型[type]的函数[function].

**standard input** n. 这个输入[input]流[stream], 它是动态变量[dynamic variable] \*standard-input* 的值[value].

**standard method combination** n. 名为 standard 的方法组合[method combination].

**standard object** n. 一个对象[object], 它是类[class] standard-object 的一个广义实例[generalized instance].

**standard output** n. 这个输出[output]流[stream], 它是动态变量[dynamic variable] \*standard-output* 的值[value].

**standard pprint dispatch table** n. 一个美观打印分派表[pprint dispatch table], 它和初始美观打印分派表[initial pprint dispatch table]不同, 它按照这个规范中所描述的实现了美观打印, 并且它不像其他美观打印分派表[pprint dispatch table], 一定不能被任何程序修改. (虽然在本文档中通常使用了明确的引用 "标准美观打印分派表", 但是到底是一个单独的对象[object]还是多个这样的对象来充当标准美观打印分派表[standard pprint dispatch table]的角色, 实际上是依赖于具体实现的[implementation-dependent], 任何一种都可以被用于需要"标准美观打印分派表"的特定场合. 因此, 除照应前项引用外, 这句话在所有情况下都应视为不确定的引用.)

**standard readtable** n. 一个区别[different]于初始读取表[initial readtable]的读取表[readtable], 它实现了这个规范中定义的表达式[expression]语法, 并且它不像其他读取表[readtable], 一定不能被任何程序所修改. (虽然明确的引用 "标准读取表[standard readtable]" 被普遍用于这个文档中, 事实上, 是否是一个单独的对象[object]充当这个标准读取表[standard readtable]的角色, 还是这里存在多个这样的对象, 它们中的任意一个都可以被用于需要 "标准读取表[standard readtable]" 的场合, 这个是依赖于具体实现的[implementation-dependent]. 因此, 这个短语在所有情况下都应该被看作是不确定的引用, 除了照应前项引用(anaphoric reference).)

**standard syntax** n. 由标准读取表[standard readtable]表示的语法, 并且被用作贯穿这个文档的参考语法. 见章节 2.1 (字符语法).

**standardized** adj. (一个名字[name], 对象[object], 或定义) 已经被 Common Lisp 定义. "所有需要持有双向流的标准化变量的名字中都具有 '-io*' (All standardized variables that are required to hold bidirectional streams have \"-io*\" in their name)".

**startup environment** n. 调用编译器的运行的 Lisp 映像[Lisp image]的全局环境[global environment].

**step** v.t., n. 1. v.t. (一个循环变量[variable]) 在一个循环的结束去给这个变量[variable]赋予[assign]一个新值[value], 为新的循环做准备. 2. n. 标识一个循环中的下一个值如何被计算的代码[code]. 3. v.t. (代码[code]) 去特殊地执行这个代码[code], 每隔一段时间停下来让用户确认或干预, 通常用于调试.

**stream** n. 可以被一个输入或输出函数用来标识这个操作的一个字符[character]或字节[byte]源或目标的对象[object].

**stream associated with a file** n. 一个文件流[file stream], 或者一个同义流[synonym stream], 它的目标是一个和文件关联的流[stream associated with a file]. 这样一个流[stream]不能用 make-two-way-stream, make-echo-stream, make-broadcast-stream, make-concatenated-stream, make-string-input-stream, 或 make-string-output-stream 创建.

**stream designator** n. 一个流[stream]的标识符[designator]; 也就是说, 一个对象[object], 它是一个流[stream]并且它是以下之一: t (表示 \*terminal-io* 的值[value]), nil (对于输入[input]流标识符[stream designator]表示 \*standard-input* 的值[value]或者对于输出[output]流标识符[stream designator]表示 \*standard-output* 的值[value]), 或者一个流[stream] (表示它自身).

**stream element type** n. (指一个流[stream]) 这个流[stream]被特化的数据类型[type].

**stream variable** n. 一个值[value]必须为一个流[stream]的变量[variable].

**stream variable designator** n. 一个流变量[stream variable]的标识符[designator]; 这也就是说, 一个表示流变量[stream variable]的符号[symbol]并且它是以下之一: t (表示 \*terminal-io*), nil (对于输入[input]流变量标识符[stream variable designator]表示 \*standard-input* 或者对于输出[output]流变量标识符[stream variable designator]表示 \*standard-output*), 或者某个其他符号[symbol] (表示它自身).

**string** n. 一个 string 类型[type]的特化向量[vector], 并且它的元素是 character 类型[type]或者 character 类型[type]的子类型[subtype].

**string designator** n. 一个字符串[string]的标识符[designator]; 这也就是说, 一个表示字符串[string]的对象[object]并且它是其中之一: 一个字符[character] (表示一个单独的字符串[string], 持有该字符[character]作为它仅有的元素[element]), 一个符号[symbol] (表示它的名称字符串[string]), 或者一个字符串[string] (表示它自身). 其目的是使这个术语与 string 的行为保持一致; 扩展 string 的具体实现[implementation]必须以一种兼容的方式扩展这个术语的意义.

**string equal** adj. 在 string-equal 下是相同的[same].

**string stream** n. 一个 string-stream 类型[type]的流[stream].

**structure** n. 一个 structure-object 类型[type]的对象[object].

**structure class** n. 一个类[class], 它是类[class] structure-class 的广义实例[generalized instance].

**structure name** n. 使用 defstruct 定义的名称[name]. 通常, 这样一个类型[type]也是一个结构体类[structure class], 但是如果使用了给 defstruct 的 :type 选项, 可能会出现依赖于具体实现[implementation-dependent]的情况, 而不是这样.

**style warning** n. 一个 style-warning 类型[type]的状况[condition].

**subclass** n. 一个类[class], 它继承[inherit]自另一个类[class], 称为超类[superclass]. (没有类[class]是它自身的子类[subclass].)

**subexpression** n. (指一个表达式[expression]) 一个表达式[expression], 它被包含在该表达式[expression]中. (事实上, 成为一个子表达式[subexpression]的状态不是该子表达式[subexpression]的一个属性, 但实际上是包含表达式[expression]的属性, 因为相同[same]对象[object]可以同时是一个上下文中的子表达式[subexpression], 而不是另一个上下文中的子表达式.)

**subform** n. (指一个表达式形式[form]) 一个表达式[expression], 它是这个表达式形式[form]的子表达式[subexpression], 由于它在这个表达式形式[form]中的位置, 它也是一个表达式形式[form]. "(f x) 和 x, 除了 exit, 都是 (return-from exit (f x)) 的子表达式形式[subform] ((f x) and x, but not exit, are subforms of (return-from exit (f x)))".

**subrepertoire** n. 一个字元库[repertoire]的子集.

**subtype** n. 一个类型[type], 它的成员关系和另一个称为超类型[supertype]的类型[type]的成员关系相同或者是一个适当子集. (每个类型[type]都是它自身的一个子类型[subtype].)

**superclass** n. 一个类[class], 另一个类[class] (称为一个子类[subclass])继承[inherit]自它. (没有类[class]是它自身的一个超类[superclass].) 见子类[subclass].

**supertype** n. 一个类型[type], 它的成员关系与另一个称为子类型[subtype]的类型[type]的成员关系相同或是一个适当超集. (每个类型[type]都是它自身的超类型[supertype].) 见子类型[subtype].

**supplied-p parameter** n. 一个形参[parameter], 由于与另一个形参[parameter] (例如一个可选参数[optional parameter]或一个剩余参数[rest parameter])对应的实参[argument]的存在与否, 它隐式地接收它的广义 boolean [generalized boolean]值. 见章节 3.4.1 (普通 Lambda 列表).

**symbol** n. 一个 symbol 类型[type]的对象[object].

**symbol macro** n. 一个符号[symbol], 它代表另一个表达式形式[form]. 见宏[macro] symbol-macrolet.

**synonym stream** n. 1. 一个 synonym-stream 类型[type]的流[stream], 因此它是一个流[stream], 这个流是另一个流[stream]的别名, 它是一个动态变量[dynamic variable]的值[value], 该变量的名称[name]是同义流[synonym stream]的同义流符号[synonym stream symbol]. 见函数[function] make-synonym-stream. 2. (对一个流[stream]) 一个同义流[synonym stream], 它的同义流符号[synonym stream symbol]的值[value]就是该流[stream]. 3. (对一个符号[symbol]) 一个同义流[synonym stream], 它的同义流符号[synonym stream symbol]即为该符号[symbol].

**synonym stream symbol** n. (指一个同义流[synonym stream]) 这个符号[symbol]命名一个动态变量[dynamic variable], 它的值为另一个流, 这个同义流[synonym stream]是该流的一个别名.

**syntax type** n. (一个字符[character]的) 几个在解析期间被 Lisp 读取器[Lisp reader]用来分派的类型中的一个, 枚举在 Figure 2-6 中. 见章节 2.1.4 (字符语法类型).

**system class** n. 一个类[class], 在一个符合规范的实现[conforming implementation]中它可能是 built-in-class 类型[type] 并且因此不能被符合规范的程序[conforming program]定义的类[class]所继承.

**system code** n. 由具体实现[implementation]提供来实现这个规范 (例如, mapcar 的定义) 或自动生成支持此规范的代码[code] (例如, 在方法组合期间); 也就是说, 不是编程者代码[programmer code]的代码[code]. 


### T

**t** n. 1. a. 表示 true 的 boolean 值. b. 表示 true 的标准广义 boolean [generalized boolean]. (虽然除了 nil 以外的任何对象[object]都被认为是 true, 作为一个广义 boolean [generalized boolean], t 通常用于没有特殊原因更偏向其中一个对象[object]时.) 2. 所有对象[object]所属类型[type]的名字[name]---所有类型[type]的超类型[supertype] (包括它自身). 3. 除了它自身以外的所有类[class]的超类[superclass]的名字[name].

**tag** n. 1. 一个捕获标签[catch tag]. 2. 一个 go 标签[go tag].

**tail** n. (指一个列表[list]) 一个对象[object], 它和构成这个列表[list]的某个 cons 相同[same]或者和终止这个列表[list]的原子[atom]相同[same] (如果存在的话). "空列表是每个正规列表的末尾 (The empty list is a tail of every proper list)".

**target** n. 1. (指一个构造流[constructed stream]) 这个构造流[constructed stream]的一个标记成分[constituent]. "一个同义流的目标是它的同义流符号的值 (The target of a synonym stream is the value of its synonym stream symbol)". 2. (指一个存储被转移的数组[displaced array]) 这个存储被转移的数组[displaced array]被转移到的数组[array]. (对于一个构造流[constructed stream]或存储被转移的数组[displaced array]的链, 非限定术语 "目标[target]" 总是指链中第一项的直接目标[target], 而不是最后一项的直接目标.)

**terminal I/O** n. 这个双向流[bidirectional stream]是变量[variable] \*terminal-io* 的值[value].

**terminating** n. (一个宏字符[macro character]的) 是这样的, 如果它在解析一个标记时出现, 那么它终止那个标记. 见章节 2.2 (读取器算法).

**tertiary value** n. (指从一个表达式形式[form]的求值[evaluation]所产生的哪些值[value]) 第三个值[value] (如果存在的话), 或者如果这里少于三个值[value]那么就是 nil.

**throw** v. 去转移控制和值[value]到一个捕获点[catch]. 见特殊操作符[special operator] throw.

**tilde** n. 标准字符[standard character], 它被称为 "波浪符(tilde)" (~). 见 Figure 2-5.

**time** 一个时间线上的时间点 (绝对[absolute]时间[time]) 或者时间间隔 (相对[relative]时间[time]) 的表示. 见解码时间[decoded time], 内部时间[internal time], 和通用时间[universal time].

**time zone** n. 一个 1/3600 的有理[rational]倍数, 在-24(包含)和24(包含)之间, 表示一个时区与格林尼治平均时间偏移的小时数. 时区值随着向西移动而增加, 美国马萨诸塞州位于时区 5, 美国加利福尼亚州位于时区 8, 俄罗斯莫斯科位于时区 3. (当 "夏令时" 单独表示为一个实参[argument]或返回值[return value]时, 它所对应的时区并不取决于夏令时是否有效.)

**token** n. 一个数字[number]或符号[symbol]的文本表示. 见章节 2.3 (Interpretation of Tokens).

**top level form** n. 一个表达式形式[form], 出于启用该表达式形式[form]的编译期[compile time]求值[evaluation]的目的, 它被 compile-file 特殊处理. 顶层表达式形式[Top level form]包括那些不是任何其他表达式形式[form]的子表达式形式[subform]的表达式形式[form], 以及某些其他情况. 见章节 3.2.3.1 (顶层表达式形式的处理).

**trace output** n. 这个输出[output]流[stream], 它是动态变量[dynamic variable] \*trace-output* 的值[value].

**tree** n. 1. 一个由 cons 和原子[atom]组成的二元递归数据结构: 这些 cons 自身也是树[tree] (有时称为 "子树(subtree)" 或 "分支(branch)"), 而原子[atom]是终端节点 (有时也称为叶[leaf]). 通常, 这些叶[leaf]表示数据而这些分支建立数据之间的某个联系. 2. 多数情况下, 任何具有某种"分支"和"叶[leaf]"概念的递归数据结构.

**tree structure** n. (指一个树[tree[1]]) 组成这个树[true]的 cons 的集合. 注意, 当每一个这样的 cons 的 car[1b] 组件是这个树结构[tree structure]的一部分时, 这个树[tree]中每一个 cons 的 car[2] 中的这些对象[object]本身不是树结构[tree structure]的一部分, 除非它们也是 cons.

**true** n. 任何不是 false 的对象[object], 被用于表示一个断言[predicate]测试的成功. 见 t[1].

**truename** n. 1. 在文件系统[file system]中的一个文件[file]的正规文件名[filename]. 见章节 20.1.3 (真实名字). 2. 表示一个真实名字[truename[1]]的路径名[pathname].

**two-way stream** n. 一个 two-way-stream 类型[type]的流[stream], 它是一个双向[bidirectional]复合流[composite stream], 它从一个关联的输入[input]流[stream]接收它的输入并把它的输出发送到一个关联的输出[output]流[stream].

**type** n. 1. 一个对象(object)的集合, 通常带有共同的结构, 行为, 和目的. (注意, 如果 Sa 是 Sb 的一个子类型, 语句 "X 是 Sa 类型" 自然意味着 "X 是 Sb 类型".) 2. (紧跟在类型[type]名称之后) 那个类型[type]的一个子类型[subtype]. "类型 vector 是一个数组类型 (The type vector is an array type)."

**type declaration** n. 一个声明[declaration], 断言声明[declaration]的范围内对指定绑定[binding]的每次引用结果都是指定类型[type]的某个对象[object].

**type equivalent** adj. (指两个类型[type] X 和 Y) 相同的元素[element]; 也就是说, X 是 Y 的子类型[subtype] 并且 Y 是 X 的子类型[subtype].

**type expand** n. 去完全展开为一个类型指定符[type specifier], 移除对衍生类型[derived type]的任何引用. (Common Lisp 没有提供编程接口来使这个发生, 但是 Common Lisp 的语义是这样的, 每个实现[implementation]都必须能够在内部完成这一操作, 而且一些涉及类型指定符[type specifier]的情况最容易用完全展开的类型指定符[type specifier]来描述.)

**type specifier** n. 表示一个类型[type]的表达式[expression]. "符号 random-state, 列表 (integer 3 5), 列表 (and list (not null)), 以及名为 standard-class 的类都是类型指定符 (The symbol random-state, the list (integer 3 5), the list (and list (not null)), and the class named standard-class are type specifiers)". 


### U

**unbound** adj. 在一个绑定[binding]中没有一个关联的表示. 见绑定[bound].

**unbound variable** n. 一个名称[name], 它在语法结构上似乎是一个变量[variable]的名字, 但是它在变量[variable]命名空间[namespace]中没有被绑定[bound].

**undefined function** n. 一个名称[name], 它在语法结构上似乎是一个函数[function]的名字, 但是它在函数[function]命名空间[namespace]中没有被绑定[bound].
符号符号符号
**unintern** v.t. (一个包[package]中的一个符号[symbol]) 去使这个符号[symbol]没有出现[present]在包[package]中. (这个符号[symbol]可能通过继承可继续访问.)

**uninterned** adj. (指一个符号[symbol]) 在任何包[package]中都是不可访问的[accessible]; 换句话说, 不是捕获的[interned[1]].

**universal time** n. 时间[time], 表示为秒的一个非负整数[integer]数量. 绝对[absolute]通用时间[universal time]使用一个从 1900 年开始的偏移来测量 (忽略闰秒[leap second]). 见章节 25.1.4.2 (通用时间).

**unqualified method** n. 一个没有限定符[qualifier]的方法[method].

**unregistered package** n. 一个没有出现在包注册表[package registry]中的包[package]对象[object]. 一个未注册的包[unregistered package]没有名字[name]; 换句话说, 它的名称[name]是 nil. 见函数[function] delete-package.

**unsafe** adj. (指代码[code]) 不是安全的[safe]. (注意, 除非显式地另外指定, 否则如果只保证在安全[safe]上下文中进行特定类型的错误检查, 那么如果是不安全的[unsafe], 则相同的检查可能会也可能不会在该上下文中发生; 把一个上下文描述为不安全的[unsafe]意味着特定种类的错误检查不能确定启用, 但不能保证绝对禁用错误检查.)

**unsafe call** n. 一个不是安全调用[safe call]的调用[call]. 关于更多详细的信息, 见章节 3.5.1.1 (安全和非安全调用).

**upgrade** v.t. (一个声明的类型[type]到一个实际的类型[type]) 1. (在创建一个数组时[array]) 当选择一个适当特化[specialized]数组[array]表示时将实际数组元素类型[actual array element type]替换为表达数组元素类型[expressed array element type]. 见函数[function] upgraded-array-element-type. 2. (当创建一个复数时[complex]) 当选择一个适当特化[specialized]复数[complex]表示时将实际复数部分类型[actual complex part type]替换为一个表达复数部分类型[expressed complex part type]. 见函数[function] upgraded-complex-part-type.

**upgraded array element type** n. (指一个类型[type]) 一个类型[type], 它是该类型[type]的一个超类型[supertype], 当该类型[type]用作数组元素类型[array element type]的对象创建或类型区分时, 它被用于替换该类型[type]. 见章节 15.1.2.1 (数组提升).

**upgraded complex part type** n. (指一个类型[type]) 一个类型[type], 它是该类型[type]的一个超类型[supertype], 当该类型[type]用作复数部分类型[complex part type]的对象创建或类型区分时, 它被用于替换该类型[type]. 见函数[function] upgraded-complex-part-type.

**uppercase** adj. (指一个字符[character]) 在标准字符[standard character]中对应大写字母 A 到 Z, 或者是某个被具体实现[implementation]定义为大写[uppercase]的具体实现定义的[implementation-defined]字符[character]. 见章节 13.1.4.3 (大小写字符).

**use** v.t. (一个包[package] P1) 去继承[inherit] P1 的外部符号[external symbol]. (如果包[package] P2 使用 P1, 那么 P1 的外部符号[external symbol]成为 P2 的内部符号[internal symbol], 除非它们被显式导出[export].) "包 CL-USER 使用包 CL (The package CL-USER uses the package CL)".

**use list** n. (指一个包[package]) 一个和每个包[package]关联的 (可能为空的) 列表[list], 它决定了其他哪些包[package]当前正在被该包[package]所使用.

**user** n. 在运行时调用程序[package]或与程序[package]交互的活动实体(通常是人), 但不一定是程序员[programmer]. 


### V

**valid array dimension** n. 适合用于一个数组[array]维度[dimension]的一个 fixnum. 这样一个 fixnum 一定大于等于零, 并且小于 array-dimension-limit 的值[value]. 当多个数组[array]维度[dimension]一起使用来指定一个多维数组[array]时, 还有一个隐含的约束, 即所有维度的乘积都小于 array-total-size-limit 的值[value].

**valid array index** n. (指数组[array]) 一种适合用作根据多维笛卡尔坐标系命名数组[array]元素[element]所需的几个索引之一的 fixnum. 这样一个 fixnum 一定大于等于零, 并且小于该数组[array]的对应维度[dimension[1]]. (除非另有明确规定, 术语 "一个有效数组索引列表" 进一步暗示了这个列表[list]的长度[length]和这个数组[array]的秩[rank]相同.) "对于一个2×3的数组, 第一个维度的有效数组索引是0和1, 第二个维度的有效数组索引是0、1和2 (For a 2 by 3 array, valid array indices for the first dimension are 0 and 1, and valid array indices for the second dimension are 0, 1 and 2)".

**valid array row-major index** n. (指一个数组[array], 它可能有任意数量的维度[dimensions[2]]) 适用于命名该数组[array]的任何元素[element]的一个单独的 fixnum, 通过将该数组的存储视为以行优先的顺序排列的一系列线性元素. 这样一个 fixnum 一定大于等于零, 并且小于该数组[array]的数组总大小[array total size].

**valid fill pointer** n. (指数组[array]) 一个适用于该数组[array]的填充指针[fill pointer]的 fixnum. 这样一个 fixnum 必须大于等于零, 并且小于等于该数组[array]的数组总大小[array total size].

**valid logical pathname host** n. 一个字符串[string], 它已经被定义为一个逻辑主机[logical host]的名称. 见函数[function] load-logical-pathname-translations.

**valid pathname device** n. 一个字符串[string], nil, :unspecific, 或某个被具体实现[implementation]定义为有效路径名设备[valid pathname device]的其他对象[object].

**valid pathname directory** n. 一个字符串[string], 一个字符串[string]列表[list], nil, :wild, :unspecific, 或某个被具体实现[implementation]定义为有效路径名成员的其他对象[object].

**valid pathname host** n. 一个有效物理路径名主机[valid physical pathname host]或一个有效逻辑路径名主机[valid logical pathname host].

**valid pathname name** n. 一个字符串[string], nil, :wild, :unspecific, 或某个被具体实现[implementation]定义为有效路径名名称[valid pathname name]的其他对象[object].

**valid pathname type** n. 一个字符串[string], nil, :wild, :unspecific.

**valid pathname version** n. 一个非负整数[integer], 或 :wild、 :newest、:unspecific 或 nil 其中之一. 符号 :oldest, :previous, 和 :installed 是不完全标准[semi-standard]特殊版本符号.

**valid physical pathname host** n. 一个字符串[string]、一个字符串[string]列表[list]或符号 :unspecific 中的任意一个, 它被具体实现识别为一个主机的名称.

**valid sequence index** n. (指一个序列[sequence]) 适用于命名该序列[sequence]的一个元素[element]的整数[integer]. 这样一个整数[integer]一定大于等于零, 并且已经小于这个序列[sequence]的长度[length]. (如果这个序列[sequence]是一个数组[array], 那么这个有效序列索引[valid sequence index]被进一步认为是一个 fixnum.)

**value** n. 1. a. 可能是求值[evaluation]结果的几个对象[object]之一. b. (在一个表达式形式[form]的求值[evaluation]只需要一个值[value]的情况下) 由这个表达式形式[form]返回的主值[primary value]. c. (指一个隐式 progn [implicit progn]中的表达式形式[form]) 最后一个表达式形式[form]的求值[evaluation]可能产生的几个对象[object]之一, 或者如果没有表达式形式[form]那么就是 nil. 2. 和一个绑定[binding]中的名字[name]关联的对象[object]. 3. (指一个符号[symbol]) 由这个符号命名的动态变量[dynamic variable]的值[value]. 4. 和一个关联列表[association list]、一个属性列表[property list]或一个哈希表[hash table]中的一个键[key]关联的一个对象[object].

**value cell** n. Trad. (指一个符号[symbol]) 持有这个符号[symbol]命名的动态变量[dynamic variable]的值[value] (如果有的话)的位置, 并且它可以通过 symbol-value 来访问. 见存储格[cell].

**variable** n. 在 "变量(variable)" 命名空间[namespace]的一个绑定[binding]. 见章节 3.1.2.1.1 (符号表达式形式).

**vector** n. 一个一维数组[array].

**vertical-bar** n. 标准字符[standard character], 它被称为 "竖杠(vertical bar)" (|). 见 Figure 2-5. 


### W

**whitespace** n. 1. 一个或多个是图形[graphic]字符[character] #\Space 或是例如 #\Newline 这样只移动打印位置的非图形[non-graphic]字符的字符[character]. 2. a. n. 一个是标记[token]分隔符的字符[character]的语法类型[syntax type]. 关于详情, 见章节 2.1.4.7 (空白字符). b. adj. (一个字符[character]的) 有着空白[whitespace[2a]]语法类型[syntax type[2]]. c. n. 一个空白[whitespace[2b]]字符[character].

**wild** adj. 1. (指一个名称字符串[namestring]) 使用一个具体实现定义的[implementation-defined]用于命名文件的语法, 它可能 "匹配" 几个可能的文件名[filename]中的任意一个, 因此它可以用来引用由这些文件名[filename]命名的文件[file]的聚合体. 2. (指一个路径名[pathname]) 一个名称的结构化表示, 它可能 "匹配" 几个可能的路径名[pathname]中的任何一个, 因此它可以用来引用由这些路径名[pathname]命名的文件[file]的聚合体. 这个通配符[wild]路径名[pathname]的集合包括单不限于: 具有成员为 :wild 的路径名[pathname], 或者具有包含 :wild or :wild-inferors 的目录成员的路径名[pathname]. 见函数[function] wild-pathname-p.

**write** v.t. 1. (一个绑定[binding]或槽[slot]或成员) 去修改这个绑定[binding]或槽[slot]的值[value]. 2. (到一个流[stream]的一个对象[object]) 把这个对象[object]的表示输出到这个流[stream].

**writer** n. 一个函数[function], 它写入[writes[1]]一个变量[variable]或槽[slot]. 


### Y

**yield** v.t. (值[value]) 产生值[value]作为求值[evaluation]的结果. "表达式形式 (+ 2 3) 产生 5 (The form (+ 2 3) yields 5)".